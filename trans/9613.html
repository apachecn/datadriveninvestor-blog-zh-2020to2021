<html>
<head>
<title>Pricing Option Credit Spreads with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python定价期权信用利差</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/pricing-option-credit-spreads-with-python-6d6acb6b1609?source=collection_archive---------2-----------------------#2021-02-16">https://medium.datadriveninvestor.com/pricing-option-credit-spreads-with-python-6d6acb6b1609?source=collection_archive---------2-----------------------#2021-02-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/235e00620899ef24caa3303daec5e7a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oY5AOwj2U-gDQEqR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@chrisliverani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Chris Liverani</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="19b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在之前的一篇文章中，我提到我在玩期权交易策略。现在我又有了一些进步。第一，快速TL；以前工作的博士。计划是卖出看涨期权，然后以更高的价格买入，将差价作为利润。为了对冲这一头寸，我将买入相关股票。</p><p id="cf78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我想展示一下我是如何在市场数据中寻找机会的。有许多相互竞争的因素，所以我必须权衡它们。我想要:</p><ul class=""><li id="273f" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">最高预付保费</li><li id="cf08" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">净接近零的买入/卖出比率δ和γ具有大的正θ</li><li id="9e99" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">股票购买和期权保证金的最低现金要求</li><li id="5440" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">中低股票波动</li><li id="1624" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">充足的股票和期权流动性</li></ul><p id="ecb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了简化搜索并最小化风险，我将把重点放在两次直接执行之间的期权差价上。这也将保持我们的利润成本下降，虽然也有更少的溢价差异。为了限制时间范围，我打算在期权到期前一周集中买入价差，希望它们到期时一文不值。接下来的计划是寻找下一组期权，在接下来的一周进行交易。</p><p id="5390" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lp">免责声明:</em> </strong> <em class="lp">再次声明，我不是理财顾问，这不是理财建议。期权和股票交易有风险，其中一些我会在这里讨论。在投资股票或期权市场之前，你应该做自己的研究。我一直把这个策略写在纸上作为学术练习，因为我觉得这很有趣。您可以出于自己的目的和研究目的自由使用下面的代码，但它的提供没有任何明示或暗示的保证。你想要你的钱，但是你已经被警告了。</em></p><h1 id="4231" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">收集必要的数据</h1><p id="2db0" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">我之前提到过我没有很好的市场数据来源，但是我找到了一些可行的方法。雅虎财经有免费的市场数据，并且有许多Python库支持访问这些数据。我选定的是<a class="ae kc" href="http://theautomatic.net/yahoo_fin-documentation/" rel="noopener ugc nofollow" target="_blank"> yahoo_fin </a>。虽然雅虎确实提供了期权的隐含波动率，但我并不觉得它们特别好。也就是说，当我用隐含波动率为期权定价来计算δ，γ和θ时，我的价格与市场价格相差甚远。所以我选择的方法是取最后一个期权价格，自己计算隐含波动率。然后取隐含波动率，我会再次给期权定价(这应该会给我最后的价格)来得到希腊价值。对于期权定价，我使用Python绑定<a class="ae kc" href="https://quantlib-python-docs.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> QuantLib </a>。虽然他们的文档不是很好，但对我来说足够做我需要做的事情了。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="fca8" class="nc lr iq my b gy nd ne l nf ng"># Standard library imports<br/>import datetime<br/>import re</span><span id="cd54" class="nc lr iq my b gy nh ne l nf ng"># Third-party library requirements<br/>import pandas as pd<br/>import QuantLib as ql<br/>from yahoo_fin.options import get_calls<br/>from yahoo_fin.stock_info import get_quote_table</span><span id="abab" class="nc lr iq my b gy nh ne l nf ng"># Hard-coded ticker and expiration for example purposes<br/>ticker = "AAPL"<br/>expiration = datetime.date(2021, 2, 12)</span><span id="1f49" class="nc lr iq my b gy nh ne l nf ng"># Get the current stock price and dividend rate<br/>info = get_quote_table(ticker)<br/>current_price = info["Quote Price"]<br/>yield_re = re.compile(r"\((?P&lt;value&gt;(\d+\.\d+))%\)")<br/>try:<br/>    dividend_yield = float(<br/>        yield_re.search(info["Forward Dividend &amp; Yield"])["value"]<br/>    )<br/>except (KeyError, ValueError, TypeError):<br/>    dividend_yield = 0.0</span><span id="dab0" class="nc lr iq my b gy nh ne l nf ng"># Fetch call option chain prices<br/>calls = get_calls(ticker, expiration.strftime("%B %d, %Y"))</span><span id="ab28" class="nc lr iq my b gy nh ne l nf ng"># Setup instruments for Black-Scholes pricing<br/>today = ql.Date.todaysDate()<br/>underlying = ql.SimpleQuote(current_price)<br/>exercise = ql.AmericanExercise(<br/>    today,<br/>    ql.Date(expiration.day, expiration.month, expiration.year)<br/>)<br/>dividendYield = ql.FlatForward(<br/>    today, dividend_yield, ql.Actual360()<br/>)<br/>riskFreeRate = ql.FlatForward(today, 0.0008913, ql.Actual360())</span><span id="5abc" class="nc lr iq my b gy nh ne l nf ng">def create_option(row):<br/>    volatility = ql.BlackConstantVol(<br/>        today,<br/>        ql.UnitedStates(),<br/>        row["volatility"],<br/>        ql.Business252()<br/>    )<br/>    option = ql.VanillaOption(<br/>        ql.PlainVanillaPayoff(ql.Option.Call, row["Strike"]),<br/>        exercise<br/>    )<br/>    process = ql.BlackScholesMertonProcess(<br/>        ql.QuoteHandle(underlying),<br/>        ql.YieldTermStructureHandle(dividendYield),<br/>        ql.YieldTermStructureHandle(riskFreeRate),<br/>        ql.BlackVolTermStructureHandle(volatility),<br/>    )<br/>    # Don't use the quoted implied vol<br/>    # Calculate it out from the last price<br/>    imp_vol = option.impliedVolatility(row["Last Price"], process)<br/>    implied_volatility = ql.BlackConstantVol(<br/>        today,<br/>        ql.UnitedStates(),<br/>        imp_vol,<br/>        ql.Business252()<br/>    )<br/>    process = ql.BlackScholesMertonProcess(<br/>        ql.QuoteHandle(underlying),<br/>        ql.YieldTermStructureHandle(dividendYield),<br/>        ql.YieldTermStructureHandle(riskFreeRate),<br/>        ql.BlackVolTermStructureHandle(implied_volatility),<br/>    )<br/>    option.setPricingEngine(<br/>        ql.FdBlackScholesVanillaEngine(process, 1000, 1000)<br/>    )<br/>    return {<br/>        "Name": row["Contract Name"],<br/>        "Strike": row["Strike"],<br/>        "Last": row["Last Price"],<br/>        "Bid": row["Bid"],<br/>        "Ask": row["Ask"],<br/>        "NPV": option.NPV(),<br/>        "Delta": option.delta(),<br/>        "Gamma": option.gamma(),<br/>        "Theta": option.theta() / 365,<br/>        "Volatility": imp_vol * 100,<br/>    }</span><span id="9d69" class="nc lr iq my b gy nh ne l nf ng"># Filter down to only OTM strikes<br/>calls = calls[calls["Strike"] &gt;= current_price * 1.025]<br/>calls = calls[calls["Strike"] &lt;= current_price * 1.10]<br/># Parse out implied volatility<br/>calls = calls.assign(<br/>    volatility=lambda x: x["Implied Volatility"].str.rstrip("%").astype("float") / 100,<br/>)<br/># Price options and calculate greeks<br/>options = calls.apply(create_option, axis=1, result_type="expand")</span></pre><p id="e3e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与yahoo_fin和QuantLib一起，它利用<a class="ae kc" href="https://pandas.pydata.org/pandas-docs/stable/index.html" rel="noopener ugc nofollow" target="_blank">熊猫</a>进行一些数据操作和过滤。这将获取给定股票代码和到期日的股票和期权的当前市场价格。它只过滤出2.5%到10%的价格(OTM)，并计算布莱克-斯科尔斯价格。</p><p id="a045" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我需要的一个市场数据是无风险利率。因为我关注的是一周后的期权，所以我决定使用上面代码中显示的<a class="ae kc" href="https://www.global-rates.com/en/interest-rates/libor/american-dollar/usd-libor-interest-rate-1-week.aspx" rel="noopener ugc nofollow" target="_blank"> 1周LIBOR利率</a>。这不是自动抓取的，必须每周更新。</p><h1 id="e8e6" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">最小化风险和最大化利润</h1><p id="b564" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">有了市场数据，现在又有了每个期权的希腊价值，我开始为每个期权对定价，试图找到一个最有价值的。同样，我将此限制为仅在链中彼此相邻的罢工，但这可以扩展到搜索更广泛的传播。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="4237" class="nc lr iq my b gy nd ne l nf ng"># This code is a continuation of the same file from above<br/># Pair up options with the next available option<br/>pairs = pd.concat(<br/>    [<br/>        options.add_suffix("_1"),<br/>        options.shift(-1).add_suffix("_2")<br/>    ],<br/>    axis=1<br/>)<br/>pairs = pairs[pairs["Name_2"].notna()]</span><span id="4833" class="nc lr iq my b gy nh ne l nf ng">def maximize_theta(row):<br/>    bid, ask = row["Bid_1"], row["Ask_2"]</span><span id="dede" class="nc lr iq my b gy nh ne l nf ng">    strike_1, strike_2 = row["Strike_1"], row["Strike_2"]<br/>    delta_1, delta_2 = row["Delta_1"], row["Delta_2"]<br/>    gamma_1, gamma_2 = row["Gamma_1"], row["Gamma_2"]<br/>    theta_1, theta_2 = row["Theta_1"], row["Theta_2"]</span><span id="4e45" class="nc lr iq my b gy nh ne l nf ng">    def calculate_values(sell):</span><span id="0f0f" class="nc lr iq my b gy nh ne l nf ng">        buy = round(gamma_1 * sell / gamma_2)<br/>        credit = (bid * sell * 100) - (ask * buy * 100) - ((sell + buy) * 0.65)<br/>        shares = -1 * round(delta_2 * buy * 100 - delta_1 * sell * 100)<br/>        delta = delta_2 * buy * 100 - delta_1 * sell * 100 + shares<br/>        gamma = gamma_2 * buy * 100 - gamma_1 * sell * 100<br/>        theta = theta_2 * buy * 100 - theta_1 * sell * 100<br/>        share_cost = shares * current_price<br/>        margin = strike_2 * buy * 100 - strike_1 * sell * 100<br/>        return {<br/>            "Sell Contract": f"{row['Strike_1']} @ {bid}",<br/>            "Sell Amount": sell,<br/>            "Buy Contract": f"{row['Strike_2']} @ {ask}",<br/>            "Buy Amount": buy,<br/>            "Shares": shares,<br/>            "Share Cost": share_cost,<br/>            "Margin": margin,<br/>            "Credit": credit,<br/>            "Cost Ratio": credit / (share_cost + margin),<br/>            "Net Delta": delta,<br/>            "Net Gamma": gamma,<br/>            "Net Theta": theta,<br/>            "Risk Ratio": theta / (delta ** 2 + gamma ** 2) ** 0.5,<br/>        }</span><span id="4f70" class="nc lr iq my b gy nh ne l nf ng">    trades = []<br/>    sell = 1<br/>    values = calculate_values(sell)<br/>    while (abs(values["Share Cost"]) + abs(values["Margin"])) &lt; 2500:<br/>        if values["Shares"] &gt; 0 and values["Credit"] &gt; 0:<br/>            trades.append(values)<br/>        sell += 1<br/>        values = calculate_values(sell)<br/>    <br/>    if trades:<br/>        results = pd.DataFrame.from_records(trades)<br/>        results.sort_values(<br/>            by=["Risk Ratio", "Cost Ratio"],<br/>            ascending=False,<br/>            inplace=True<br/>        )<br/>        return results.iloc[0]<br/>    return None</span><span id="ade3" class="nc lr iq my b gy nh ne l nf ng">results = pairs.apply(maximize_theta, axis=1, result_type="expand")<br/>results = results[results["Shares"].notna()]<br/>print(results)</span></pre><p id="2686" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是暴力搜索。它不断增加我要卖出的合约数量，直到我们的总股票成本和利润超出上限。在这里，我将其设置为2500美元。这可能比实际情况更聪明，所以我可能会错过一些机会，但它现在是有效的，并且很容易理解它是如何工作的。</p><p id="18e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于每一对，我会根据我得出的两个比率选择最高的交易。首先，我按风险比率排序。我把它定义为:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="7519" class="nc lr iq my b gy nd ne l nf ng">Risk Ratio = (Net Θ) / √(Net Δ^2 + Net Γ^2)</span></pre><p id="6612" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这在期权定价中没有任何意义，但它做了我想做的事。特别是，它奖励与接近零的δ和γ配对的高正θ交易，不管它们是正还是负。这是另一个值得尝试的领域，但是我喜欢在早期迭代中使用。</p><p id="9d7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我关心的下一个比率是成本比率，它被定义为:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="1bae" class="nc lr iq my b gy nd ne l nf ng">Cost Ratio = (Net Credit) / (Share Cost + Margin Required)</span></pre><p id="1869" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与持有交易所需的资金总额相比，这种奖励交易为我们提供了较高的预付溢价。把我们的钱投入到一个交易中意味着它不能投入到其他可能出现的机会中。如果我能在一个利差上获得2%的净信贷，在另一个利差上获得1.5%的净信贷，风险大致相等，那么我会选择2%。我没有运行这个来扫描每一个可用的股票，但一些抽查和运行对一打左右，1-2%似乎是一个坚实的百分比。这是一个查看2/12 AAPL呼叫的输出示例。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/4dfc652fc8e48c1c86ca92919a258994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ECIgoNxNod1k4YxRUAkjHw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Best AAPL option spreads for the 2/12/2021 expiration</figcaption></figure><p id="d21e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，最好的差价是以53美元的价格卖出一个141看涨期权，以40美元的价格买入一个142看涨期权，11.70美元的价格为13美元减去1.30美元的手续费。为了对冲头寸，需要购买4股。这个例子是在2月7日周日定价的，现在我们可以看到这个交易是如何进行的。如果你在2月8日周一以136.03美元买入，你将花费544.12美元，以0.13美元的差价卖出141/142的差价，扣除费用后你将净得11.70美元，但要求你保留100美元的保证金。2月12日，AAPL股票收于135.37美元，这使得这两种期权都到期了。如果你在收盘时卖出，那么你在股票头寸上总共损失了2.64美元，这一周的净利润为9.06美元，所需的644.12美元资本回报率为1.4%。</p><h1 id="09fc" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">一个集合在一起的策略</h1><p id="7dc7" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">虽然没有完全自动化，但这对于继续测试这一策略非常有帮助。我们的想法是在每周五或周末使用这个脚本来寻找下周五到期的期权的价差机会。也就是说，每周一开始新的交易，周五平仓。如果某周没有好的机会，那么资本就会闲置。我不确定这将如何扩展。至少目前我搜索的是相当小的职位。虽然每周从1000-2000美元中获得1-3%的回报似乎是可行的，但如果你希望投资$10K或更高，是否能找到足够多的好机会来真正扩大这一回报就不太清楚了。这并不限制它作为一项实验的乐趣，但目前来看，赚钱的潜力似乎是有限的，因为如果你不能再投资，你就不能真正复合你的收益。</p><p id="cd97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从最初的一系列要点来看，还没有解决的是股票的波动性和流动性。在测试这一策略时，这应该是下一个关注和研究的领域。在短期内，它可能会表现为一组用于每周扫描的股票。</p><p id="f55d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还没有放弃我的日常工作，我会继续在纸上测试这个，记下这个规定的交易和最终的结果。如果我能找到一个好的(免费的)历史期权定价来源，那么我可以做一些更大规模的回溯测试。我希望你觉得这是有帮助的和有趣的，如果你有关于如何改进这项工作的想法，请留下回应。交易愉快！</p></div></div>    
</body>
</html>