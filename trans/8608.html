<html>
<head>
<title>What Makes You a Modern C++ Programmer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是什么让你成为现代C++程序员</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/what-makes-you-a-modern-c-programmer-608fe80c61eb?source=collection_archive---------18-----------------------#2021-01-15">https://medium.datadriveninvestor.com/what-makes-you-a-modern-c-programmer-608fe80c61eb?source=collection_archive---------18-----------------------#2021-01-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1c93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">通过使用“现代”C++ </em>，让您的C++技能更上一层楼</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/8ff41401afe21c9832c566dbd6de0492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4a5a6_xX89GMthoN"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Photo by <a class="ae lc" href="https://unsplash.com/@heftiba?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Toa Heftiba</a> on <a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fdc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi ld translated"><span class="l le lf lg bm lh li lj lk ll di"> Y </span>你知道C++语言的语法和编码。但你知道是什么让你成为现代C++程序员吗？您的代码是否使用了C++ 11、14或17中引入的特性？你在应用程序中使用了标准的库类吗？你知道C++ <em class="kl"> lambda </em>函数、<em class="kl">智能指针</em>和用于循环的表达式<em class="kl">吗？</em></p><p id="1250" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你的答案是否定的，这里有一些技巧可以提升你的C++技能，让你成为一名现代的C++程序员。</p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="957f" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">1.标准库容器</h1><p id="c97b" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated"><em class="kl"> Vector </em>、<em class="kl"> Array </em>和<em class="kl"> List </em>是C++中使用的基本库容器。</p><p id="5977" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> Vector </em>在堆中分配内存，所以可以动态添加和删除元素。当容器的大小未知并且在运行时可以改变时，这是有用的。</p><p id="c4fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果容器的大小是固定的，例如。一年中的几个月(12)，继续使用一个<em class="kl"> std:array </em>来代替。与<em class="kl">向量</em>不同，<em class="kl">数组</em>在堆栈中分配内存，对元素访问更快。</p><p id="f52f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">列表</em>有助于顺序元素访问ex。存储按日期排序的订单列表。在最坏的情况下，它需要遍历列表的末尾来访问元素。</p><p id="9ffd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了这些，C++还提供了其他标准库容器如<em class="kl">栈</em>、<em class="kl">队列</em>、<em class="kl">出列</em>、<em class="kl">优先级_队列</em>、<em class="kl">映射</em>、<em class="kl">无序_映射。</em></p><p id="4efa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> Stack </em>对于容器中元素的push、pop、top操作很有用。</p><p id="377a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">队列</em>仅用于对队列前面的元素进行推、弹出等操作。</p><p id="7e2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">出列</em>类似于<em class="kl">一个队列</em>但是<em class="kl"> </em>对队列前面和后面的元素执行操作。</p><p id="a41a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">优先级队列</em>类似于<em class="kl">队列</em>，但是基于与它们相关的优先级在容器中插入一个元素。根据排名插入学生</p><p id="d975" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">映射</em>用于存储按键值排序的键和值对。</p><p id="0903" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">无序映射</em>用于没有排序的键和值对。</p><p id="7550" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你是C++的初学者，从使用<em class="kl"> vector </em>开始。如果你觉得你需要一个<em class="kl">栈</em>或者<em class="kl">地图</em>，那么就开始使用这些容器吧。同样以这样一种方式编写你的代码，使得容器之间的切换更容易，例如使用关键字<em class="kl"> auto </em>。将来，如果你想从<em class="kl">出列</em>切换到<em class="kl">队列</em>，那就简单多了。</p><h1 id="3e8b" class="lt lu iq bd lv lw mw ly lz ma mx mc md me my mg mh mi mz mk ml mm na mo mp mq bi translated">2.兰姆达斯</h1><p id="8ba9" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">在C++的早期版本中，<em class="kl">函数指针</em>被用来在变量中存储函数行为。后来使用指针访问了该函数。函数指针的缺点是难以理解，可读性差。所以他们想出了<em class="kl"> lambdas </em>来代替传统的函数指针。所有现代编程语言都像Java，Kotlin使用<em class="kl"> Lambdas </em>。</p><p id="6964" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是C++中lambda的例子</p><pre class="kn ko kp kq gt nb nc nd ne aw nf bi"><span id="c2c1" class="ng lu iq nc b gy nh ni l nj nk">[](){} // Empty Lambda function</span></pre><p id="67ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中[]表示用于捕获值的capture子句，()表示传递给函数的参数，{}包含lambda函数体。</p><pre class="kn ko kp kq gt nb nc nd ne aw nf bi"><span id="3657" class="ng lu iq nc b gy nh ni l nj nk"><em class="kl">//Example Lambda function isOdd</em><br/>auto isOdd = [](int candidate){ return candidate % 2 != 0 }; </span><span id="5e80" class="ng lu iq nc b gy nl ni l nj nk">bool is3Odd = isOdd(3); //Returns true as 3 is Odd<br/>bool is4Odd = isOdd(4); //Returns false as 4 is Even</span><span id="eb42" class="ng lu iq nc b gy nl ni l nj nk">vector nums{2, 3, 4, -1, 1};<br/>//Find the number of Odd Items in the Vector. Returns 3<br/>int odds = std::count_if(begin(nums), end(nums), isOdd);</span></pre><p id="02ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，<em class="kl"> isOdd </em>是一个lambda函数，用于检查输入的数字是否为奇数。<em class="kl"> Lambdas </em>可以和<em class="kl">一起使用，用于每个</em>、<em class="kl"> count_if </em>和其他标准库函数，突然间这些库就变得有用了。</p><p id="c991" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用lambdas的优势在于——它们可以用于形成某些通用工作，有助于实现并发性并增加代码的可读性。</p><h1 id="5274" class="lt lu iq bd lv lw mw ly lz ma mx mc md me my mg mh mi mz mk ml mm na mo mp mq bi translated">3.标准库算法</h1><p id="8088" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">C++中的<em class="kl">算法</em>库定义了可以执行多种操作的函数，例如排序、计数、操作、在容器中查找元素等。开发人员不需要为它们编写任何代码，节省了关注代码其他部分的时间。</p><p id="43b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">标准库算法<em class="kl">交换、排序和计数_if </em>示例如下</p><pre class="kn ko kp kq gt nb nc nd ne aw nf bi"><span id="6202" class="ng lu iq nc b gy nh ni l nj nk"><em class="kl">//Example of Swap function for a and b<br/>int a = 5;<br/>int b = 8;<br/>swap(&amp;a, &amp;b);</em></span><span id="1f86" class="ng lu iq nc b gy nl ni l nj nk">//<em class="kl">Example of sort function. Sort elements in ascending order<br/>vector&lt;int&gt; v{5, 3, 4, 2, 1};<br/>sort(v.begin(), v.end());</em></span><span id="186e" class="ng lu iq nc b gy nl ni l nj nk">//Count the number of 3’s in the vector v<br/>int num_items3 = std::count_if(v.begin(), v.end(), [](int i){return i == 3;});</span></pre><p id="fea9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有大量的标准库算法可以使用。使用它们的好处包括——它们使代码更具可读性和表达性，就像每个人都明白<em class="kl"> sort </em>函数是做什么的。此外，不必从头开始编写它们可以节省您的时间、精力和处理边缘情况时的所有麻烦。这也使得开发者很容易切换容器，因为大多数算法使用<em class="kl">迭代器</em>来访问元素。由于迭代器可以用于任何容器，当开发者从<em class="kl">栈</em>改变到<em class="kl">队列时，</em>代码的改变将是最小的。</p><p id="4554" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对开发者来说，最大的挑战是<em class="kl">为代码找到</em>正确的算法，并<em class="kl">学习</em>实现它们。</p><h1 id="127e" class="lt lu iq bd lv lw mw ly lz ma mx mc md me my mg mh mi mz mk ml mm na mo mp mq bi translated">4.例外</h1><p id="2f02" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">程序在运行时抛出错误或导致失败是很自然的。虽然有些可能是可预测的，但有些可能不是。此外，不同类型的错误需要以不同的方式处理。在某些情况下，开发人员可能会忘记处理错误情况。为了处理异常和异常错误，使用<em class="kl">异常</em>。</p><p id="fb1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">c++中的异常</em>包含3个主要部分</p><ul class=""><li id="d89e" class="nm nn iq jp b jq jr ju jv jy no kc np kg nq kk nr ns nt nu bi translated"><em class="kl"> Try — </em>这个块需要尽可能的小，以检查抛出<em class="kl">异常</em>的代码</li><li id="9554" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk nr ns nt nu bi translated"><em class="kl">抛出— </em>可以抛出<em class="kl"> std::exception </em>类的异常</li><li id="ea89" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk nr ns nt nu bi translated"><em class="kl"> Catch — </em>用于捕获异常的代码块。需要对异常进行排序，从最具体的异常在顶部，到一般的异常在底部。</li></ul><p id="3ff8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<em class="kl">异常</em>的例子如下所示</p><pre class="kn ko kp kq gt nb nc nd ne aw nf bi"><span id="c99e" class="ng lu iq nc b gy nh ni l nj nk">//Example of Divide by Zero exception thrown<br/>void func(int a, int b)<br/>{<br/>  try {<br/>    if( b == 0 ) throw std::invalid_argument("b is zero");<br/>    else a/b;<br/>  }<br/>  catch(std::exception&amp; e){<br/>    //Handle Exception here<br/>  }<br/>}</span></pre><p id="21ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用异常的优点是在try和catch块之间，通过调用它们的析构函数类，本地范围的对象被自动清除。所以与其他编程语言不同，C++中不需要<em class="kl"> finally </em>块。另外<em class="kl"> std::exception </em>类非常有用。大多数标准库代码抛出从这个类派生的对象。同样，当有一系列函数调用时，如<em class="kl"> a </em>调用<em class="kl"> b </em> , <em class="kl"> b </em>调用<em class="kl"> c </em> …。<em class="kl"> y </em>调用<em class="kl"> z </em>，从<em class="kl"> z </em>返回错误给<em class="kl"> a </em>是相当令人沮丧的。这会花费大量时间并影响性能。在这种情况下，可以在<em class="kl"> z </em>中使用异常来处理错误。</p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><p id="ffc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">综上所述，<em class="kl">现代C++ </em>表现力强，可读性强。它帮助开发人员使用语言的力量来表达意图，并最小化编码所需的工作。</p></div></div>    
</body>
</html>