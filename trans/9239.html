<html>
<head>
<title>Running Flask and FastAPI on Google Colab</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Google Colab上运行Flask和FastAPI</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/flask-on-colab-825d2099d9d8?source=collection_archive---------1-----------------------#2021-02-04">https://medium.datadriveninvestor.com/flask-on-colab-825d2099d9d8?source=collection_archive---------1-----------------------#2021-02-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="570d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程中，我们将快速演示如何在google colab上运行一个基本的flask服务器和一个基于FastAPI的服务器。</p><h2 id="8c9d" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">烧瓶是什么？</h2><p id="d7d7" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">Flask是一个用Python编写的微型web框架。它被归类为微框架，因为它不需要特殊的工具或库。它没有数据库抽象层、表单验证或任何其他组件，而现有的第三方库提供了通用功能。如果您是Python web开发的新手。Flask是一个很好的起点。</p><h2 id="46af" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">什么是FastAPI？</h2><p id="3162" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">FastAPI是一个现代、快速(高性能)的web框架，用于基于标准Python类型提示用Python 3.6+构建API。</p><p id="ba3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主要特点是:</p><ul class=""><li id="ea28" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><strong class="jp ir">快</strong>:非常高的性能，与<strong class="jp ir"> NodeJS </strong>和<strong class="jp ir"> Go </strong>不相上下(感谢Starlette和Pydantic)。<a class="ae ls" href="https://fastapi.tiangolo.com/#performance" rel="noopener ugc nofollow" target="_blank">目前最快的Python框架之一</a>。</li><li id="9ee8" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk lo lp lq lr bi translated"><strong class="jp ir">快速编码</strong>:将开发特性的速度提高200%到300%左右。</li><li id="7334" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk lo lp lq lr bi translated"><strong class="jp ir">更少的bug</strong>:减少约40%的人为(开发人员)导致的错误。</li><li id="e1dd" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk lo lp lq lr bi translated"><strong class="jp ir">直观</strong>:强大的编辑器支持。无处不在的完成。调试时间更少。</li><li id="6b74" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk lo lp lq lr bi translated"><strong class="jp ir">简单</strong>:设计为简单易学。减少阅读文件的时间。</li><li id="4406" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk lo lp lq lr bi translated"><strong class="jp ir">简短</strong>:尽量减少代码重复。每个参数声明中的多个特性。更少的错误。</li><li id="efeb" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk lo lp lq lr bi translated"><strong class="jp ir">健壮</strong>:获得生产就绪代码。自动交互式文档。</li><li id="4130" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk lo lp lq lr bi translated">基于标准的:基于(并完全兼容)API开放标准</li></ul><h2 id="4e7c" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">Google Colab是什么？</h2><p id="9020" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">Google colaboratory，简称“Colab ”,允许您在浏览器中编写和执行Python，使用</p><ul class=""><li id="f71e" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">不需要配置</li><li id="f3f5" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk lo lp lq lr bi translated">免费访问GPU</li><li id="9541" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk lo lp lq lr bi translated">轻松分享</li></ul><p id="9cc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论你是学生、数据科学家还是人工智能研究人员，Colab都可以让你的工作变得更简单。Google Colab的结构几乎和Jupyter笔记本类似。</p><p id="f465" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将从安装所需的包开始本教程。要在google colab上安装软件包，请使用！如果您在本地机器上运行演示程序，您可以在命令提示符下编写以下pip命令并删除感叹号。此外，确保<em class="ly"> pip </em>是CLI(命令提示符)上的环境变量。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="8cbf" class="kl km iq me b gy mi mj l mk ml">!pip install flask<br/>!pip install flask-ngrok</span></pre><h2 id="d052" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">为什么我们安装了flask-ngrok？</h2><p id="6645" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">原因是flask server创建了一个服务器，它作为localhost在google colab上分配的运行时上本地运行。为了向外部流量公开服务器，或者使服务器可以在运行时之外通过HTTP全局访问，使用了ngrok。因为我们正在使用flask，所以最好使用python的<em class="ly"> flask-ngrok </em>模块。下图给出了一个基本的想法。</p><figure class="lz ma mb mc gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mm"><img src="../Images/b99494abd4c84bcf53bf0cd32c0daba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ekk8bqEMWLfWHplQfFOh8A.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Basic idea of Ngrok : End user is actually a ngrok client who wants to access our app</figcaption></figure><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="5ad6" class="kl km iq me b gy mi mj l mk ml">from flask import *<br/>from flask_ngrok import run_with_ngrok</span><span id="ee40" class="kl km iq me b gy my mj l mk ml">app = Flask(__name__)</span><span id="4696" class="kl km iq me b gy my mj l mk ml">@app.route('/index')<br/>def home():<br/>  return 'Hello World'</span></pre><p id="9d28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们创建的一条简单路线。<em class="ly">@ app . route('/index ')</em>decorator用于增强<em class="ly"> home() </em>函数的功能性。每当我们调用位于<a class="ae ls" href="http://hostname:portnumber/index" rel="noopener ugc nofollow" target="_blank">http://hostname:port number/index</a>的服务器时，也会调用<em class="ly"> home() </em>函数。主机名是“localhost ”,如果您想要访问本地运行的服务器，它会映射到127.0.0.1作为相应的IP地址。这只是作为参考。在这个演示中，我们不会太在意它。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="3484" class="kl km iq me b gy mi mj l mk ml">run_with_ngrok(app)<br/>app.run()</span></pre><p id="dc91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ly"> run_with_ngrok() </em>函数接受<em class="ly"> Flask </em>类的对象，在这里它存储在一个名为<em class="ly"> app </em>的变量中。它将ngrok附加到flask应用程序，这样当我们运行该应用程序时，可以生成一个在运行时之外可以访问的URL。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="5e78" class="kl km iq me b gy mi mj l mk ml"> * Serving Flask app "__main__" (lazy loading)<br/> * Environment: production [31m   WARNING: This is a development      server. Do not use it in a production deployment.[0m [2m   Use a production WSGI server instead.[0m <br/> * Debug mode: off<br/> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)<br/> * Running on <!-- -->http://57b01f4a6baf.ngrok.io<br/> * Traffic stats available on http://127.0.0.1:4040</span></pre><p id="3aac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在执行<em class="ly"> app.run() </em>函数时，我们的服务器就设置好了。可以使用生成的URL从外部访问它，即<em class="ly">http://57 b 01 F4 a6 BAF . ngrok . io</em>，但是我们只为<em class="ly"> /index </em>创建了路由，因此我们应该使用<em class="ly">http://57b01f4a6baf.ngrok.io/index</em>检查它，如下所示。</p><figure class="lz ma mb mc gt mn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/82baf749d39ab1b87741919dc7d6a597.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*O9QaVWg9MHkZv_d3xYaSSw.jpeg"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Accessing the endpoint</figcaption></figure><p id="857f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用flask很容易创建具有充分灵活性的简单API，我们现在也可以挖掘Google Colab的能力，并尝试使用它创建ML服务。</p><p id="cd28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们快速跳转到FastAPI，这是一个非常有前途的Python库，因为它基于ASGI并异步处理请求，与使用不支持异步调用的WSGI的Flask相比，它提高了吞吐量和性能。FastAPI也有很好的文档。为了在Google Colab上运行FastAPI，我们需要首先安装它以及以下软件包:</p><ul class=""><li id="cbf8" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">这提出了一个实际问题:当在一个环境中，事件循环已经在运行时，不可能运行任务并等待结果。试图这样做将给出错误“RuntimeError:这个事件循环已经在运行”。这个问题会在各种环境中出现，比如web服务器、GUI应用程序和Jupyter笔记本。此模块修补了asyncio，以允许嵌套使用asyncio.run和loop.run_until_complete。</li><li id="4a67" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk lo lp lq lr bi translated">这是一个ngrok的Python包装器，它管理自己的二进制文件，并把它放在您的路径上，使得ngrok可以从命令行上的任何地方通过一个方便的Python API获得。通过pyngrok与原生Python集成，ngrok变得更加强大。</li><li id="e7bb" class="lj lk iq jp b jq lt ju lu jy lv kc lw kg lx kk lo lp lq lr bi translated"><em class="ly">uvicon</em>:这包括一个Gunicorn工人类，允许你运行ASGI应用程序，拥有uvicon所有的性能优势，同时也给你Gunicorn全功能的进程管理。</li></ul><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d1fc" class="kl km iq me b gy mi mj l mk ml">!pip install fastapi nest-asyncio pyngrok uvicorn</span></pre><p id="4111" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们从<em class="ly"> fastapi </em>模块导入<em class="ly"> FastAPI </em>类，并创建它的对象，我们称之为<em class="ly"> app </em>。我们还使用<em class="ly">@ app . route('/index ')</em>decorator创建了一个路由，它与<em class="ly"> home() </em>方法相链接。<em class="ly"> async </em>作为一个修饰符，使函数异步执行。本地FastAPI服务器在端口号<em class="ly"> 8000 </em>上运行，并且<em class="ly"> ngrok </em>创建一个隧道，这样外部网络也可以访问它，如前面flask服务器实现中所述。由于FastAPI支持异步调用，我们需要一个ASGI服务器，即<em class="ly">uvicon</em>在本地端口号<em class="ly"> 8000 </em>运行应用程序。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="73a1" class="kl km iq me b gy mi mj l mk ml">from fastapi import FastAPI<br/>import nest_asyncio<br/>from pyngrok import ngrok<br/>import uvicorn<br/><br/>app = FastAPI()<br/><br/>@app.get('/index')<br/>async def home():<br/>  return "Hello World"<br/><br/>ngrok_tunnel = ngrok.connect(8000)<br/>print('Public URL:', ngrok_tunnel.public_url)<br/>nest_asyncio.apply()<br/>uvicorn.run(app, port=8000)</span></pre><p id="eba5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在执行这个代码片段时，我们在控制台上得到以下消息。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="433a" class="kl km iq me b gy mi mj l mk ml">Public URL: http://af9a6a5b8bdb.ngrok.io<br/><br/><br/>INFO:     Started server process [63]<br/>INFO:     Waiting for application startup.<br/>INFO:     Application startup complete.<br/>INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)</span></pre><p id="d29a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的FastAPI服务器已经启动并正在运行，让我们在浏览器上键入<em class="ly"> {Public_URL}/index </em>来访问我们的端点，因为我们只创建了一条路由，即<em class="ly"> /index </em>。</p><figure class="lz ma mb mc gt mn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/8abc49a7a49577b14d5cdcf58160d110.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*iyICCb94V8qrYcHFc6QJmg.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Calling FastAPI endpoint hosted on Google Colab</figcaption></figure><p id="d056" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至此，本教程到此结束。你可以在这里找到这个演示<a class="ae ls" href="https://github.com/SAH-UJA/Flask_on_colab" rel="noopener ugc nofollow" target="_blank">的代码。我希望这篇博客简洁而全面。如果你想获得更多我这边的更新，别忘了喜欢并关注我。编码快乐！！！</a></p></div></div>    
</body>
</html>