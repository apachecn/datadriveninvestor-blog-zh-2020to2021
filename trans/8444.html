<html>
<head>
<title>Bread First that Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面包先放在树上</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/bread-first-that-tree-988bf71f9279?source=collection_archive---------26-----------------------#2021-01-11">https://medium.datadriveninvestor.com/bread-first-that-tree-988bf71f9279?source=collection_archive---------26-----------------------#2021-01-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="72eb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在树中搜索兄弟姐妹</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f879c86ff363aaade35f78225d637ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LPHS35bxRROKsrbccK2ibw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Breadth First Search is an important part of a programmer’s arsenal.</figcaption></figure><h2 id="479a" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">这是怎么回事？</h2><p id="c7f4" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">计算机科学的好学生可能已经知道这一点；但是树是一种组织信息的方式。在计算机科学中，这是一种非常有效的存储数据以便以后快速检索的方法。</p><h2 id="d9ba" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是树？</h2><p id="6357" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">在这种情况下，我们指的是由从其他节点继承的节点组成的数据结构，称为“父节点”因此，高于另一个节点的每个节点都是“父节点”，低于另一个节点的每个节点都是“子节点”</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/dac2e28e8e3af5e837008d89827d995e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pV1CWbJV2xkPaLDG15hDig.png"/></div></div></figure><h2 id="5a27" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">二叉树</h2><p id="221a" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">名字说明了它是什么。二叉树是一种每两棵树最多有两个子树的树。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/aa98ceb282a7456e8cfd9fe80ff91a7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*32xVO3KVt-mdYdvF-oBbIg.png"/></div></div></figure><h2 id="00f9" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">二叉查找树</h2><p id="c747" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">这就是我们具体的地方。我们现在给出了一个条件，根据节点的值来确定节点是成为“左”子节点还是“右”子节点，而不仅仅是限制每个节点的子节点数量。</p><p id="b3fc" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le mo mb mc li mp me mf lm mq mh mi mj ij bi translated">如果该值小于父节点的值，则它成为该父节点的左节点。</p><p id="5570" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le mo mb mc li mp me mf lm mq mh mi mj ij bi translated">如果该值大于父节点的值，则它成为该父节点的右节点。</p><p id="7b6e" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le mo mb mc li mp me mf lm mq mh mi mj ij bi translated">结果使查找特定值变得容易，只需遍历树即可。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/b81bbdffef8ab6869757186b2947da9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lj5ARJktJS4ahI1nQvqxsw.png"/></div></div></figure><h1 id="3145" class="mr kw iq bd kx ms mt mu la mv mw mx ld jw my jx lh jz mz ka ll kc na kd lp nb bi translated">搜索树</h1><p id="d1be" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">搜索树只是简单地遍历每个节点，将每个值与指定的值(精确搜索)或条件(模糊搜索)进行比较。</p><h2 id="d062" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">为什么我们需要树的？</h2><p id="812d" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">树代表有组织的信息。它们存在于日常生活的方方面面，从你电脑上的文件系统到你现在正在阅读的网页(文档对象模型，又名DOM)。</p><h2 id="2d95" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">但是什么是广度优先搜索呢？</h2><p id="54aa" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">有不同的方法来搜索二分搜索法树。您可以上下搜索(宽度优先)、上下搜索(深度优先)，然后以不同的顺序反复搜索(从不同的一侧开始，等等)。</p><p id="a7e7" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le mo mb mc li mp me mf lm mq mh mi mj ij bi translated">不同的方法产生不同的顺序，遍历每个节点的顺序不同，这取决于您的目标是什么(如果您知道您正在搜索的文件是新的，并且所有较新的文件都在较新的节点(也称为目录)中，深度优先是有用的)。</p><p id="547f" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le mo mb mc li mp me mf lm mq mh mi mj ij bi translated">无论您选择哪种方法，它们都需要使用队列。</p><h2 id="a4c9" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是队列？</h2><p id="176b" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">这基本上是在你最喜欢的主题公园、电影院、签售会、车管所、超市或其他服务中为你最喜欢的乘车排队，要求你站在比你先到的每个人后面，一个接一个地等到每个人都到了队伍的前面。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/7eca131fdf5be6b7cde8fb3e8e571205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a1eUE2KusZPbUw239hXKPA.png"/></div></div></figure><h2 id="2477" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">队列如何帮助遍历</h2><ol class=""><li id="756b" class="nd ne iq lt b lu lv lx ly le nf li ng lm nh mj ni nj nk nl bi translated">您可以从定义一个新队列开始</li><li id="c129" class="nd ne iq lt b lu nm lx nn le no li np lm nq mj ni nj nk nl bi translated">将根节点(第一个顶部节点)添加到队列中。</li><li id="8245" class="nd ne iq lt b lu nm lx nn le no li np lm nq mj ni nj nk nl bi translated">定义一个数组来跟踪每个节点，这样您就可以返回它来查看您遍历的顺序。或许称之为“拜访”或“穿越”</li><li id="740f" class="nd ne iq lt b lu nm lx nn le no li np lm nq mj ni nj nk nl bi translated">将根从队列中“出列”,并将其保存到一个变量中，这个变量可能叫做currentNode。</li><li id="b3b0" class="nd ne iq lt b lu nm lx nn le no li np lm nq mj ni nj nk nl bi translated">将currentNode的值添加到数组。</li><li id="bac6" class="nd ne iq lt b lu nm lx nn le no li np lm nq mj ni nj nk nl bi translated">添加当前节点的子节点。因为这是二进制的，只有两个，所以只有两个条件:“左”和“右”如果存在，将它们添加到队列中。</li><li id="4102" class="nd ne iq lt b lu nm lx nn le no li np lm nq mj ni nj nk nl bi translated">现在让我们在队列中有项目时进行循环。接下来，随着我们的继续，我们将向队列中添加节点(如果它们存在的话),同时不断地将最旧的项出队，将其保存到currentNode，将其添加到‘visited’数组，并将任何子节点添加到队列中。一旦我们到达树的末端，循环就会结束。</li><li id="1a50" class="nd ne iq lt b lu nm lx nn le no li np lm nq mj ni nj nk nl bi translated">现在，返回“已访问”数组，以获得按顺序访问过的节点的完整列表。</li></ol><h1 id="5f25" class="mr kw iq bd kx ms mt mu la mv mw mx ld jw my jx lh jz mz ka ll kc na kd lp nb bi translated">这是广度优先搜索</h1><p id="1378" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">上面的伪代码是如何进行广度优先搜索的。当然，总有更好的方法去做一件事。不同的语言可能会提供内置的方法，使得上述内容变得不必要和琐碎。了解“如何做”和“为什么做”很重要，因为当数据变大时，这些内置方法可能会变成障碍。</p><p id="9408" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le mo mb mc li mp me mf lm mq mh mi mj ij bi translated">如果你能创建自己的方法，那么你就能微调你的代码，使之更快更精简。</p></div></div>    
</body>
</html>