<html>
<head>
<title>I Used to Pay $180/yr for a Profitable Betting Tool. This Year I Built One in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我曾经每年花180美元购买一个有利可图的赌博工具。今年我用Python做了一个</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/i-used-to-pay-180-yr-for-a-profitable-betting-tool-this-year-i-built-one-in-python-dda1a9b9581f?source=collection_archive---------1-----------------------#2021-02-11">https://medium.datadriveninvestor.com/i-used-to-pay-180-yr-for-a-profitable-betting-tool-this-year-i-built-one-in-python-dda1a9b9581f?source=collection_archive---------1-----------------------#2021-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7bfb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">完整的代码创建一个足球博彩工具与熊猫和硒。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/99e692d2967de13861c1e62f6be90b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YgGV42kUfJzzGdqX"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@jefflssantos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jefferson Santos</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4830" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我曾经为一个博彩工具支付年费，该工具根据实际赔率、统计数据和博彩公司的赔率向我推荐潜在的足球比赛。我对这个工具的准确性很满意，但是现在我可以编码了，我决定通过使用可用的免费数据用Python来构建这个工具。一开始，我认为我可能需要几个月的时间来建造它；然而，这比预期的要容易。在这个循序渐进的教程中，我将向你展示我是如何做到的。</p><p id="99cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个项目的最终结果看起来像是帮助我创建盈利系统的<em class="lv"> "B </em> etpractice" <em class="lv"> </em>工具。你可以在本文末尾和我的Github上验证我们将创建的熊猫数据帧看起来和下图一模一样(当然，没有花哨的界面)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/28e24adbf503a926d47299496e8b5d59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pi1mqcsqVHYRLlMM_vONaw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Screenshot of Betting tool (Betpractice)</figcaption></figure><p id="0e39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个系统的一部分是基于一种叫做<a class="ae ky" href="https://medium.com/swlh/how-to-make-money-when-the-bookies-get-it-wrong-and-lose-f494017ca697" rel="noopener">价值下注</a>的策略，我在之前的一篇文章中提到过。请确保您完全熟悉价值下注的概念，以便我们将要编写的代码对您有意义。如果你从未听说过它，检查下面的文章。</p><div class="lx ly gp gr lz ma"><a href="https://medium.com/swlh/how-to-make-money-when-the-bookies-get-it-wrong-and-lose-f494017ca697" rel="noopener follow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd iu gy z fp mf fr fs mg fu fw is bi translated">当庄家搞错了，输了，如何赚钱</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">利用Python从博彩公司的错误中获利的另一种方法。</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">medium.com</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo ks ma"/></div></div></a></div><p id="c135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建我们的投注工具，我们需要两个输入— <strong class="lb iu">博彩公司赔率</strong>和<strong class="lb iu">历史足球数据</strong>。在收集了这些数据之后，你可以为任何博彩市场创建一个系统。<strong class="lb iu">在本教程中，我将制作一个系统，显示潜在比赛的日历，为市场“超/低于目标”和“双方得分”(BTTS)下注。</strong>正如你在上面的图片中看到的，潜在的比赛有一个最低要求，即平均进球数(9)、射门数(9)和角球数。他们也有2.0的最大真实赔率(50%概率)。在构建系统时将考虑这些参数。</p><p id="8532" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，通过这些过滤器的比赛代表了经常失球或进球的球队。由于这一点，我们将能够确定潜在的匹配，以投注“超过2.5个目标”和“BTTS”。最后，我们计算赌注的值，并按最高值对潜在匹配进行排序。价值下注在上图中以绿色显示，它们代表“公平的赔率”</p><p id="87de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程将分为两个部分:</p><p id="1f1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第一节:刮庄家赔率(硒+熊猫)</strong></p><ol class=""><li id="eca1" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu mu mv mw mx bi translated"><strong class="lb iu">刮赛前赔率</strong>:在Selenium中，我们会用<code class="fe my mz na nb b">WebdriverWait</code>、<code class="fe my mz na nb b">Expected Conditions(EC) </code>和<code class="fe my mz na nb b">Select</code>刮赔率。此外，我们将使用Python列表、字典、<code class="fe my mz na nb b">for</code>循环、<code class="fe my mz na nb b">try-except</code>块等。</li><li id="2a2a" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu mu mv mw mx bi translated"><strong class="lb iu">清理和转换赛前赔率数据</strong>:来自博彩公司的赔率数据有不同的形式，因此我们需要对它们进行适当的格式化，以使它们与历史数据相匹配。熊猫图书馆在这方面派上了用场。</li></ol><p id="347a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">输出部分1:庄家赔率</em></p><p id="a252" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第2部分:构建赌博工具(熊猫)</strong></p><p id="f245" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">输入部分1:博彩公司赔率+历史足球数据</em></p><ol class=""><li id="2af3" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu mu mv mw mx bi translated"><strong class="lb iu">数据清理:</strong>首先，我们将使用<code class="fe my mz na nb b">pd.read_csv()</code>获取历史足球数据。然后我们会清理庄家的赔率和历史数据。稍后，我们将使用Fuzzywuzzy来匹配博彩公司写的球队名称和在历史足球数据. csv中找到的球队名称。</li><li id="ea58" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu mu mv mw mx bi translated"><strong class="lb iu">创建投注档案:</strong>投注档案包含特定的赛季，可以帮助我们计算统计数据和实际赔率。虽然我们的历史数据包含5年的记录，但我们将只使用最近2个赛季的投注概况。</li><li id="ab05" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu mu mv mw mx bi translated"><strong class="lb iu">计算数据:</strong>因为我们的系统是“进球过多”和“BTTS”，我们将计算每支球队的平均进球数、总命中率和总角球数。</li><li id="8f92" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu mu mv mw mx bi translated"><strong class="lb iu">创建市场过滤器:</strong>首先，我们将编写一个公式来计算一场比赛的真实赔率。然后，我们使用这些真实的赔率作为一个过滤器，以及找到价值赌注。我们还将根据日期和统计数据过滤匹配。</li><li id="205a" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu mu mv mw mx bi translated"><strong class="lb iu">寻找价值匹配:</strong>我们将按照最高价值对潜在匹配进行排序。</li></ol><p id="00f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">输出:按下注值排序的“超过2.5个目标”的潜在匹配下注列表。</em></p><p id="b850" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我会尽力解释系统背后的概念和我在Python中使用的代码，但是如果有什么不清楚的地方，请随时问我。</p><p id="50af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用2个脚本。我们将使用第一个脚本通过Selenium抓取数据(第1节)，第二个脚本处理数据并构建工具(第2节)。</p><h1 id="1e0d" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">编码时间到了</h1><p id="ec8a" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">我们将从博彩网站Betfair(代码中的链接)收集赛前赔率，因为它是全球最受欢迎的博彩网站之一；然而，请随意从任何博彩网站刮赔率。你可以遵循我创建的其他教程，在那里我解释了如何从3个投注网站刮赔率。然而，请记住<strong class="lb iu">我们将在本周的许多欧洲联赛中为所有即将到来的比赛收集赔率，所以代码将与我以前写的文章明显不同。</strong></p><p id="432e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第1部分结束时，刮擦工具将能够完成以下任务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/1d1c158d300524a2704467b6c3f5f503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PMqKnudVjRfBjgZbvTG0Ag.gif"/></div></div></figure><p id="e3fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们接受cookie弹出窗口，然后我们将网站语言设置为英语，这样我们就可以在多个比赛中导航，并获得接下来7天的博彩赔率。</p><p id="7d81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你觉得你可以自己完成，跳过第一部分，但是要确保你得到的数据和我们在第一部分得到的数据相似。开始编码吧！刮刀的完整代码可在第1节的末尾找到。</p><h1 id="1897" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">第一部分:排除万难</h1><h1 id="fb78" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">1.<strong class="ak">用硒刮赛前赔率</strong></h1><h2 id="98dd" class="of ni it bd nj og oh dn nn oi oj dp nr li ok ol nt lm om on nv lq oo op nx oq bi translated">导入库并更改Chromedriver默认选项</h2><p id="e6e6" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">我们需要导入<code class="fe my mz na nb b">Options</code>来改变chromedriver的默认选项；<code class="fe my mz na nb b">By</code>、<code class="fe my mz na nb b">WebDriverWait</code>、<code class="fe my mz na nb b">EC</code>、<code class="fe my mz na nb b">time</code>等待特定条件发生(显式等待)，以及<code class="fe my mz na nb b">time</code>等待特定时间量(隐式等待)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="1892" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要编辑的默认选项是“无头模式”和“窗口大小”您可以通过编写<code class="fe my mz na nb b">option.headless=False </code>来禁用无头模式，并使用<code class="fe my mz na nb b">driver.maximize_window()</code>而不是<code class="fe my mz na nb b">options.add_argument(‘window-size=1920x1080’) </code>，如完整代码所示。</p><p id="5223" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解代码:</p><ul class=""><li id="d7d4" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu ot mv mw mx bi translated"><code class="fe my mz na nb b">options = Options()</code>创建选项类的实例</li><li id="29cc" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">options.headless = True </code>开启无头模式</li><li id="edc9" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">options.add_argument(‘window-size=1920x1080’) </code>以自定义尺寸打开窗口</li></ul><h2 id="3d9f" class="of ni it bd nj og oh dn nn oi oj dp nr li ok ol nt lm om on nv lq oo op nx oq bi translated">初始化存储并循环每个联赛</h2><p id="9c6a" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">在接下来的步骤中，我们将为一个足球联赛创建一个数据框架。这就是为什么我们需要将每个数据帧存储在我称为<code class="fe my mz na nb b">dict_frames</code>的字典中。我们还需要创建另一个字典来帮助我们的scraper识别我们想要从中获取数据的联赛。</p><p id="9a3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字典的关键字是国家的名称(如网站上所写的)，而值是列表的形式。每个列表包含每个国家的联赛。你可以删除或添加任何其他国家/联盟，但记住要按照网站英文版所示来写(我将在下面的“点击特定联盟”小节中展示如何选择名称)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="1231" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们创建了字典，我们需要遍历每个国家和联盟。这样，我们将为每个联盟打开一个chrome窗口，收集赔率和其他重要数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="8d0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解代码:</p><ul class=""><li id="4323" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu ot mv mw mx bi translated"><code class="fe my mz na nb b">webdriver.Chrome(path, options = options) </code>应用我们之前在chromedriver中所做的更改</li><li id="7562" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">driver.get </code>打开浏览器</li><li id="a4c7" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">web </code>代表博彩网站的网址，而<code class="fe my mz na nb b">path </code>代表chrome驱动程序在你电脑中的路径</li><li id="38f4" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">driver.maximize_window() </code>最大化chrome窗口。当我不在无头模式下工作时，我通常需要它</li><li id="d4e5" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">time.sleep(2)</code>是隐式等待。您也可以使用显式等待，如我在“选项1”注释中所示</li><li id="b3f3" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">accept </code>是我们每次访问这个网站都会弹出的“接受所有cookies”按钮吗</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/6f4af372958ac6fe48e29a506aec844a.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*xM0swv3cKUWdS6UvM1sWTw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Screenshot of the accept button</figcaption></figure><p id="b21e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要获得accept按钮的XPath，右键单击并“检查”元素。完成此操作后，您将看到一行高亮显示。右键单击，然后复制并粘贴XPath。</p><h2 id="a652" class="of ni it bd nj og oh dn nn oi oj dp nr li ok ol nt lm om on nv lq oo op nx oq bi translated">从下拉菜单中切换语言</h2><p id="f9cc" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">在我们抓取数据之前，我们需要将网站语言切换为英语。为此，我们编写以下代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="747e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解代码:</p><ul class=""><li id="7c3d" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu ot mv mw mx bi translated"><code class="fe my mz na nb b">language_box </code>是包含网站所有可用语言的框。我们用类名<code class="fe my mz na nb b">ssc-hlsw</code>定位它，你可以通过检查右上角的语言框来验证这个类名。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/cba1d8ba7932a8152ae59d1b48e07f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*jnMMwk5p7ERiSJOH05bhXQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Screenshot of language_box</figcaption></figure><ul class=""><li id="4daf" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu ot mv mw mx bi translated"><code class="fe my mz na nb b">WebDriverWait(language_box,5).until(EC.element_to_be_clickable((By.CLASS_NAME, ‘ssc-en_GB’))).click() </code>点击英语图标。</li></ul><p id="e55b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要让selenium等待网站加载所有英文内容。为此，我们需要选择一个引用来进行显式等待。在这种情况下，我将使用“高于/低于2.5目标”作为参考，所以我们将等待下拉列表在<code class="fe my mz na nb b">span</code>标记中包含英文的<code class="fe my mz na nb b">text</code>元素<code class="fe my mz na nb b">Over/Under 2.5 Goals</code>。这显示在下面的代码中。</p><ul class=""><li id="c39a" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu ot mv mw mx bi translated"><code class="fe my mz na nb b">WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, '//span[contains(text(), "Over/Under 2.5 Goals")]')))</code></li></ul><h2 id="5560" class="of ni it bd nj og oh dn nn oi oj dp nr li ok ol nt lm om on nv lq oo op nx oq bi translated">点击特定的联赛(在循环内)</h2><p id="7247" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">一旦所有的内容都是英文的，我们就必须按照这个顺序来得到每个联盟的赔率。</p><p id="0bd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击比赛→点击国名→点击联赛名。为此，我们编写了以下代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="41e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解代码:</p><ul class=""><li id="e593" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu ot mv mw mx bi translated"><code class="fe my mz na nb b">header </code>是包含“竞赛”按钮的框。检查下面的框，你会得到它的类名。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/441587d2cd105c9d619a1a37385c7bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DYWj_v71joqOf-onxuBTUQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Screenshot of the header</figcaption></figure><ul class=""><li id="fed0" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu ot mv mw mx bi translated"><code class="fe my mz na nb b">competition </code>是我们需要点击的“竞赛”按钮，因此会显示国家列表。我们定位带有<code class="fe my mz na nb b">contains</code>选项的按钮，以匹配在<code class="fe my mz na nb b">a</code>标签内的<code class="fe my mz na nb b">title</code>内包含<code class="fe my mz na nb b">COMPETITIONS</code>的元素。</li><li id="4239" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated">在我们点击<code class="fe my mz na nb b">country_button </code>和<code class="fe my mz na nb b"> league_button </code>之前，最好先定位下图所示的<code class="fe my mz na nb b">competition_table </code>。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/4316ddcd9b18c0579e5514a3d4a32036.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*f4KgLh64--ogf_Ovez-r7A.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Screenshot — Competition table</figcaption></figure><p id="c547" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要找到<code class="fe my mz na nb b">competition_table</code>，右键单击比赛表并寻找<code class="fe my mz na nb b">id. </code>，它应该看起来像这样<code class="fe my mz na nb b">mod-multipickazmenu-1061-container</code></p><ul class=""><li id="1463" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu ot mv mw mx bi translated"><code class="fe my mz na nb b">country_button </code>和<code class="fe my mz na nb b"> league_button </code>显示网站上所有可用的联赛。国家/地区的XPath具有以下形式。</li></ul><pre class="kj kk kl km gt oy nb oz pa aw pb bi"><span id="f810" class="of ni it nb b gy pc pd l pe pf">'.//div[contains(@data-category, "australian football")]'</span></pre><p id="3491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将定位一个在<code class="fe my mz na nb b">div</code>标签内的<code class="fe my mz na nb b">data-category</code>中包含<code class="fe my mz na nb b">“australian football”</code>的元素。为了找到<code class="fe my mz na nb b">data-category,</code>，检查如下图所示的元件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/9595dcf1c27867acbbb9116976ab1ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nUa6guCjNOqhMwaWCpFhQA.png"/></div></div></figure><p id="1ccb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，在我们的代码中，我们替换了特定数据联盟的名称(例如，<code class="fe my mz na nb b">“australian football”) </code>替换了<code class="fe my mz na nb b">country</code>变量，这样我们就可以遍历<code class="fe my mz na nb b">dict_countries</code>字典中的每个国家。最终的XPath如下所示。</p><pre class="kj kk kl km gt oy nb oz pa aw pb bi"><span id="6d3b" class="of ni it nb b gy pc pd l pe pf">WebDriverWait(competitions_table, 5).until(EC.element_to_be_clickable((By.XPATH, './/div[contains(@data-category,' +'"' + country + '"' + ')]')))</span></pre><p id="be3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe my mz na nb b">league_button.</code>，我们遵循相同的步骤</p><h2 id="0d39" class="of ni it bd nj og oh dn nn oi oj dp nr li ok ol nt lm om on nv lq oo op nx oq bi translated">收集团队名称、赔率和日期</h2><p id="0004" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">最后，我们准备收集我们想要的数据。首先，我们在下拉列表中选择任何可用的博彩市场。在本例中，我将选择从“超过/低于2.5个进球”和“两个队都得分？”。我们还需要一个字典<code class="fe my mz na nb b">dict_odds</code>来存储<code class="fe my mz na nb b">list_odds</code>、<code class="fe my mz na nb b">teams</code>和<code class="fe my mz na nb b">list_dates</code>列表，这些列表将包含我们将要抓取的数据。</p><p id="7417" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是刮各个联赛数据的方案。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/1577213942a245c2f5ac315bdfc8d646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lak_2uV4Ygd62h2jg_BD_g.png"/></div></div></figure><p id="6fe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，它有一个类似于我们在以前的文章中用来获得赛前赔率或现场赔率的序列。首先，我们遍历每个博彩市场，然后用<code class="fe my mz na nb b">chooser</code>变量从<code class="fe my mz na nb b">dropdown</code>菜单中选择它们。然后我们遍历每个<code class="fe my mz na nb b">section </code>来拆分每个日期的数据。最后，我们循环遍历每一个<code class="fe my mz na nb b">row </code>，它代表一场足球比赛。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="7624" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我将只解释那些在以前的文章中没有包括的细节。如果你对剩下的代码有任何问题，尽管问我。</p><p id="cafe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解代码:</p><ul class=""><li id="cabe" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu ot mv mw mx bi translated"><code class="fe my mz na nb b">section_date = section_date * len(rows) </code>帮助我们创建一个日期列表，每个<code class="fe my mz na nb b">section. </code>中的<code class="fe my mz na nb b">rows</code>的长度存储在<code class="fe my mz na nb b">list_dates</code>中</li><li id="13df" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">list_dates = [element for section in list_dates for element in section] </code>解包<code class="fe my mz na nb b">list_dates</code>中存储的嵌套列表</li><li id="53dc" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">dict_odds </code>存储抓取的数据。<code class="fe my mz na nb b">%s % i</code>帮助我们根据<code class="fe my mz na nb b">enumerate(markets)</code>改变按键的名称</li><li id="8b59" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">driver.quit() </code>关闭浏览器</li></ul><h1 id="935a" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">2.<strong class="ak">清理和转换赛前赔率数据</strong></h1><p id="d337" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">一旦我们完成了抓取部分，我们需要正确地格式化数据。<strong class="lb iu">请记住，我们将在第1小节开始的</strong> <code class="fe my mz na nb b"><strong class="lb iu">for</strong></code> <strong class="lb iu">循环中执行此操作。</strong></p><h2 id="bf19" class="of ni it bd nj og oh dn nn oi oj dp nr li ok ol nt lm om on nv lq oo op nx oq bi translated">为每个联盟创建数据框架</h2><p id="2b65" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">我们必须为我们刮到的每个博彩市场赔率创建一个数据框架。在这个例子中，我划掉了“超过/低于2.5个目标”和“两个队都得分”，所以我创建了<code class="fe my mz na nb b">df_over_under</code>和<code class="fe my mz na nb b">df_btts </code>帧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="aa01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解代码:</p><ul class=""><li id="0d85" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu ot mv mw mx bi translated"><code class="fe my mz na nb b">pd.DataFrame </code>根据我们之前创建的列表创建一个数据框架</li><li id="7238" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">pd.concat </code>将两个数据帧连接成一个数据帧，我称之为<code class="fe my mz na nb b">df_betfair</code></li><li id="4401" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">.fillna('')</code>用空值填充任何<code class="fe my mz na nb b">NaN</code>值，而。replace()用一个空值替换任何包含单词“SUSPENDED”的数据。</li><li id="2b70" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">.applymap()</code>将公式<code class="fe my mz na nb b">.strip()</code>应用于<code class="fe my mz na nb b">df_betfair </code>数据帧的每个字符串元素</li></ul><h2 id="9a5b" class="of ni it bd nj og oh dn nn oi oj dp nr li ok ol nt lm om on nv lq oo op nx oq bi translated">在熊猫数据框架中管理时间</h2><p id="91ea" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">我们需要将网站中使用的时间格式转换为标准格式YYYY–MM–DD。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="e7ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解代码:</p><ul class=""><li id="d50c" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu ot mv mw mx bi translated"><code class="fe my mz na nb b">datetime.date.today() </code>创建了一个<code class="fe my mz na nb b">today</code>变量，我们将使用它来标识我们正在抓取的日期。</li><li id="782d" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">datetime.timedelta(days=1) </code>加1天得到<code class="fe my mz na nb b">tomorrow</code>变量</li></ul><p id="48e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了当天(“今天”)或第二天(“明天”)进行的比赛之外，网站使用的格式看起来像这样“2月13日星期六<strong class="lb iu">”</strong><code class="fe my mz na nb b">(%A, %d %B)</code>。我们需要将所有内容格式化为YYYY–MM–DD<code class="fe my mz na nb b">(%Y %d %B)</code></p><ul class=""><li id="911f" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu ot mv mw mx bi translated"><code class="fe my mz na nb b">re.sub() </code>用网站(%A，%d %B)中使用的标准时间格式替换网站上显示的词语，如“进行中”、“今天”和“明天”</li><li id="c2ec" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">x.split(‘,’)[1] </code>获取“2月13日星期六<strong class="lb iu">”</strong>中逗号后的所有内容</li><li id="6999" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">datetime.datetime.strptime() </code>将日期格式转换为YYYY–MM–DD<code class="fe my mz na nb b">(%Y %d %B)</code></li></ul><p id="dba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们用<code class="fe my mz na nb b">dict_frames[dict_countries[country][league]] = df_betfair </code>将包含每个联赛的<code class="fe my mz na nb b">df_betfair</code>数据帧存储在<code class="fe my mz na nb b">dict_frames</code>字典中，用<code class="fe my mz na nb b">pickle.dump()</code> <strong class="lb iu">保存文件，我们将</strong> <code class="fe my mz na nb b"><strong class="lb iu">dict_frames</strong></code> <strong class="lb iu">保存为名称</strong> <code class="fe my mz na nb b"><strong class="lb iu">dict_betfair </strong></code> <strong class="lb iu">，以备后用。</strong></p><p id="dd7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">祝贺你！我们完成了脚本1 (Selenium)的工作。你可以在我的</em><a class="ae ky" href="https://github.com/ifrankandrade/betting-tool.git" rel="noopener ugc nofollow" target="_blank"><em class="lv">Github</em></a><em class="lv">上找到我们第一个脚本的代码。现在是时候开始脚本2(熊猫)的工作了</em></p><p id="29ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，收集的数据只包含未来4天左右比赛的赔率。因此，我强烈建议您将第一个脚本自动化，这样它就可以在每周三、周日运行，永远不会出现数据不足的情况。在下面的文章中，我用三个简单的步骤展示了如何做到这一点。</p><div class="lx ly gp gr lz ma"><a href="https://medium.com/datadriveninvestor/automate-your-python-scripts-in-3-steps-mac-and-windows-3c6fb0fb5bc2" rel="noopener follow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd iu gy z fp mf fr fs mg fu fw is bi translated">通过3个步骤自动化您的Python脚本——Mac和Windows</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">厌倦了重复的任务？自动化您的脚本并节省大量宝贵的时间。</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">medium.com</p></div></div><div class="mj l"><div class="pi l ml mm mn mj mo ks ma"/></div></div></a></div></div><div class="ab cl pj pk hx pl" role="separator"><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po"/></div><div class="im in io ip iq"><h1 id="3af7" class="nh ni it bd nj nk pq nm nn no pr nq nr jz ps ka nt kc pt kd nv kf pu kg nx ny bi translated"><strong class="ak">第2部分:构建下注工具</strong></h1><h2 id="94ee" class="of ni it bd nj og oh dn nn oi oj dp nr li ok ol nt lm om on nv lq oo op nx oq bi translated">导入库</h2><p id="ae29" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">这些是我们将在第2节中使用的库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><h1 id="8f7e" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">1.<strong class="ak">数据</strong>清洗</h1><h2 id="ac53" class="of ni it bd nj og oh dn nn oi oj dp nr li ok ol nt lm om on nv lq oo op nx oq bi translated">清洗必发赔率</h2><p id="97d9" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">首先，我们酸洗我们在第1节刮的框架(<code class="fe my mz na nb b">dict_betfair<strong class="lb iu">)</strong></code>)。然后我们创建2个字典，我们将使用它们来匹配Betfair名称和历史数据名称。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="e190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解代码:</p><ul class=""><li id="3dd4" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu ot mv mw mx bi translated"><code class="fe my mz na nb b">.str.extract(r’(.+)\n(.+)’) </code>按照正则表达式模式提取字符串。使用的正则表达式表示“在' \n '之间选择两个元素”</li><li id="c067" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">dict_home_name_matching[league] </code>是包含主队名称的数据帧</li></ul><h2 id="ffb8" class="of ni it bd nj og oh dn nn oi oj dp nr li ok ol nt lm om on nv lq oo op nx oq bi translated">获取和清除历史数据</h2><p id="1ac0" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">我们需要下载我们之前刮过赔率的联赛的历史足球数据。为此，我们使用<code class="fe my mz na nb b">dict_countries </code>来指定包含在下载CSV文件的链接中的名称(例如，“SP1”=“西班牙联赛”)。所有数据都存储在<code class="fe my mz na nb b">dict_historical_data</code>中。稍后我们将使用它来管理两个数据帧:<code class="fe my mz na nb b">df_historical_data</code>和<code class="fe my mz na nb b">df_profile</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="c6dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解代码:</p><ul class=""><li id="d2ba" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu ot mv mw mx bi translated"><code class="fe my mz na nb b">pd.read_csv() </code>读取CSV文件。“意大利乙级联赛”CSV文件的编码有冲突，所以我使用<code class="fe my mz na nb b">‘unicode_escape’</code>作为该特定文件的编码。</li><li id="5149" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">df.assign() </code>为现有列或新列赋值</li><li id="5098" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">.rename() </code>重命名列的名称</li></ul><p id="0a4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，您可以使用<code class="fe my mz na nb b">pickle.dump()</code>保存<code class="fe my mz na nb b">dict_historical_data </code>，以便在本周使用。你需要运行这个来更新最近几周的比赛。</p><h2 id="a576" class="of ni it bd nj og oh dn nn oi oj dp nr li ok ol nt lm om on nv lq oo op nx oq bi translated">匹配球队名称并替换Betfair数据框架中的历史数据球队名称</h2><p id="381f" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">我们需要一个标准的团队名称。这就是为什么我们使用<code class="fe my mz na nb b">fuzzywuzzy </code>库来匹配名称并替换Betfair数据框架中的历史数据团队名称。</p><p id="87ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将使用我们在“清理Betfair赔率”步骤中创建的<code class="fe my mz na nb b">dict_home_name_matching </code>和<code class="fe my mz na nb b">dict_away_name_matching </code>。然后我们更新<code class="fe my mz na nb b">dict_betfair, </code>的值，这样我们就得到标准的团队名称。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="d8bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解代码:</p><ul class=""><li id="cfa4" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu ot mv mw mx bi translated"><code class="fe my mz na nb b">.unique() </code>给出dataframe列的唯一元素。<code class="fe my mz na nb b">fuzzywuzz </code>需要列表形式的名称，所以我们使用<code class="fe my mz na nb b">.tolist() </code>来转换列表中的数组。</li><li id="5fc8" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">.apply(lambda x: ...) </code>将公式应用于特定dataframe列的所有元素。</li><li id="3761" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">process.extractOne(x, all_teams, scorer=fuzz.token_set_ratio))</code>给出Betfair队名(x)与historical_data队名(all_teams)之间最高<code class="fe my mz na nb b">score</code>的匹配。在这种情况下,<code class="fe my mz na nb b">fuzz.token_set_ratio </code>计分器做得很好，但是你可以改变标准。</li><li id="e3af" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">.apply(pd.Series) </code>将结果转换成dataframe的两列。在这种情况下，匹配给出了两个输出，所以我创建了列<code class="fe my mz na nb b">teams_matched</code>和<code class="fe my mz na nb b">score</code></li><li id="d1c8" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">.update({}) </code>更新了字典中的值</li></ul><h1 id="aeca" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">2.创建个人资料以计算实际赔率和统计数据</h1><p id="6ccf" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">虽然我们获得了5年的历史数据，但我们必须小心，因为只有最近几年才有所有可用的统计数据。为此，我将数据分为两个数据帧<code class="fe my mz na nb b">df_historical_data </code>和<code class="fe my mz na nb b">df_profile</code>。然而，大多数时候，我们使用<code class="fe my mz na nb b">df_profile</code>。这将用于计算真实的赔率和统计数据，因此我们可以过滤球队，并保留潜在的游戏下注。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="b175" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解代码:</p><ul class=""><li id="263f" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu ot mv mw mx bi translated"><code class="fe my mz na nb b">pd.concat() </code>连接<code class="fe my mz na nb b">dict_historical_data</code>内的所有帧</li><li id="a3f3" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">.isin() </code>仅考虑我们包含在<code class="fe my mz na nb b">seasons</code>列表中的元素</li><li id="11dc" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">.rename() </code>重命名列的名称</li><li id="d639" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">df_profiles </code>代表两个季节的历史数据</li></ul><h1 id="8fce" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">3.计算统计数据</h1><p id="2000" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">我们将计算平均进球数、总命中率和总角球数。最后2个是主队在有主场优势时的射门次数/角球次数，以及客队在没有主场优势时的射门次数/角球次数(换句话说，只有主队产生的射门次数/角球次数，而不是收到的射门次数/角球次数)</p><p id="ad06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这些进球代表了主队在有主场优势时进球和失球的总和，以及客队在没有主场优势时进球和失球的总和。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="a5d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解代码:</p><ul class=""><li id="b8d2" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu ot mv mw mx bi translated"><code class="fe my mz na nb b">.groupby(‘home_team’).mean() </code>将有主场优势的球队参加的所有比赛分组，然后计算进球、射门和角球的平均值</li><li id="e46a" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">df_stats </code>代表我们将用来过滤匹配的统计数据</li></ul><h1 id="70f1" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">4.创建市场过滤器</h1><h2 id="8c65" class="of ni it bd nj og oh dn nn oi oj dp nr li ok ol nt lm om on nv lq oo op nx oq bi translated">过滤器1(日期)和过滤器2(统计数据)</h2><p id="b105" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">现在我们已经计算了统计数据，我们可以根据自己的需要过滤游戏了。首先，我们只选择特定日期的游戏，这样我们就可以像本文开头演示的那样创建一个日历。这个日历将有助于过滤比赛，并获得潜在的游戏下注。</p><p id="955d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">统计过滤器如下:平均进球数&gt; 2.5，总命中率&gt; 9，总角球数&gt; 9。满足这些要求的球队统计表明比赛可能有很多进球。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="da32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要代表没有统计数据的团队的<code class="fe my mz na nb b">promoted_teams </code>。他们很可能是晋级的队伍，所以比赛中没有关于他们的数据。我们将为他们的属性赋予<code class="fe my mz na nb b">0 </code>值。</p><p id="46d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解代码:</p><ul class=""><li id="9714" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu ot mv mw mx bi translated"><code class="fe my mz na nb b">home </code>和<code class="fe my mz na nb b">away</code>是在特定数据下比赛的主客场球队列表</li><li id="dbfb" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated">返回一个迭代器。迭代器生成一系列元组，包含来自每个可迭代的<code class="fe my mz na nb b">home</code>和<code class="fe my mz na nb b">away</code>的元素</li><li id="8650" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">df_filters </code>代表特定日期的所有比赛，其平均进球数&gt; 2.5，总射门数&gt; 9，总角球数&gt; 9</li></ul><h2 id="18de" class="of ni it bd nj og oh dn nn oi oj dp nr li ok ol nt lm om on nv lq oo op nx oq bi translated">过滤器3(实际赔率)</h2><p id="05bd" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">我们需要过滤“两个队都得分”和“超过2.5个进球”的真实赔率大于2的比赛(我们希望比赛至少有50%的概率)</p><p id="9446" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了计算实际赔率，我们使用上面的公式，如果你看过我以前发表的文章“<a class="ae ky" href="https://medium.com/swlh/how-to-make-money-when-the-bookies-get-it-wrong-and-lose-f494017ca697" rel="noopener">价值赌注</a>”，你可能会很熟悉。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="b513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们有了公式，我们就用下面的代码把它应用到<code class="fe my mz na nb b">df_filters </code>数据帧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="774c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解代码:</p><ul class=""><li id="f650" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu ot mv mw mx bi translated"><code class="fe my mz na nb b">lambda x,y: calculate_real_odds() </code>简化了<code class="fe my mz na nb b">calculate_real_odds</code>，所以我们可以用它来计算通过前面过滤器的匹配的真实几率</li><li id="6135" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">df_filters </code>代表特定日期的所有比赛，其平均进球数&gt; 2.5，目标总射门数&gt; 9，总角球数&gt; 9，实际赔率btts &lt; 2，实际赔率超过2.5 &lt; 2</li></ul><h1 id="5f77" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">5.寻找价值赌注</h1><p id="5ffb" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">最后，我们创建一个数据框架<code class="fe my mz na nb b">df_system </code>，它将包含每个潜在游戏的值。我们将根据“超过2.5倍”赔率的最高赌注值对数据帧进行排序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="191d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解代码:</p><ul class=""><li id="fd54" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu ot mv mw mx bi translated"><code class="fe my mz na nb b">.str.extract()</code>通过遵循正则表达式模式<code class="fe my mz na nb b">r’(.+)\n.+’</code>获取赔率的第一个元素(大于2.5或btts=True)</li><li id="9d43" class="mp mq it lb b lc nc lf nd li ne lm nf lq ng lu ot mv mw mx bi translated"><code class="fe my mz na nb b">df_system['V_OVER']</code>代表必发中超过2.5倍赔率的数值</li></ul></div><div class="ab cl pj pk hx pl" role="separator"><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po"/></div><div class="im in io ip iq"><p id="548d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">祝贺您，现在您有了一个按赌注价值排序的“超过2.5个目标”的潜在匹配赌注列表！您可以在我的Github上查看Jupyter笔记本，以验证最终的数据帧是否与本文开头显示的图片相同。</em></p><p id="7db6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些都是有潜力的游戏，但你不必全部下注。现在你可以分析一下，赌那些有潜力的游戏好不好。该工具还提供了比赛中的徒手分析，这很容易编码。我在我的<a class="ae ky" href="https://github.com/ifrankandrade/betting-tool.git" rel="noopener ugc nofollow" target="_blank"> Github </a>上包含了最后一小部分以及第1和第2部分的脚本。</p><p id="ea92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">希望本教程对你有用！</em></p></div></div>    
</body>
</html>