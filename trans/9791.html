<html>
<head>
<title>Visualise Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可视化算法</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/visualise-algorithm-bd5c6d1634d9?source=collection_archive---------24-----------------------#2021-02-20">https://medium.datadriveninvestor.com/visualise-algorithm-bd5c6d1634d9?source=collection_archive---------24-----------------------#2021-02-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/d17abc1e5af287be96cc22ce78c266fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cRP9RNcKE-kgdbzG0nT50A.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@maxchen2k" rel="noopener ugc nofollow" target="_blank">Max Chen</a> taken from <a class="ae jd" href="https://unsplash.com/photos/lud4OaUCP4Q" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="651f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇短文是可视化算法的一步一步的演练。第一步是在Microsoft Excel中打开一个空白笔记本，然后在第一行键入“syntax ”,接着在下一行键入“comments ”(见下图)。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lb"><img src="../Images/3da355dcb425764c6f3432268d32bf1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ltq77It7ls5Za9gewuQh7g.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Image by Author</figcaption></figure><p id="e4fd" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在“语法”列下面，复制并粘贴代码的语法。同样，在注释栏下，复制、粘贴或写一个描述相应语法的句子。完成写入后，将文件另存为”。csv”。. csv文件只是一种存储形式，它代表“逗号分隔值”文件(见下图)。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lg"><img src="../Images/9b281fdd83ce974ab41c3ccd20062dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8xxJvrFp0EsplhXid2IE7Q.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Image by Author</figcaption></figure><p id="9937" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦完成。只需点击这个<a class="ae jd" href="https://github.com/seanjudelyons/AlgorithmVisualise/blob/main/Algorithm_Visualiser.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh"> GitHub链接</strong> </a>，然后点击<a class="ae jd" href="https://colab.research.google.com/github/seanjudelyons/AlgorithmVisualise/blob/main/Algorithm_Visualiser.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh">在Colab </strong> </a>中打开，然后运行每个代码片段，提示上传. csv文件。这将下载一个meta和vecs数据文件。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lh"><img src="../Images/471e047f0072297271233bc5661b9a4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*GAzXquLEFHwjJF1Gp47EhA.gif"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Image by Author</figcaption></figure><p id="0714" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后上传两个文件，即meta和vecs文件到TensorFlow嵌入式投影仪。链接可以在 这里找到<a class="ae jd" href="https://projector.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh">。然后看着算法在高维空间里盘旋。相似的句法会在这个维度空间里并列在一起。该算法也是由Nikolaj Kuntner提出的(点击这里查看他的git要点<a class="ae jd" href="https://gist.github.com/Nikolaj-K/388e643d1f5e6989072a21e469d10a48" rel="noopener ugc nofollow" target="_blank"/>)。</strong></a></p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lh"><img src="../Images/111d9e4451c7c625fad8df9190bd13da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7NEVHM02gsVga3TNEt9tHg.gif"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Image by Author</figcaption></figure><h1 id="58c9" class="li lj jg bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">信用</h1><p id="d552" class="pw-post-body-paragraph kd ke jg kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">感谢嵌入式投影仪的设计者(在这里 找到他们的论文<a class="ae jd" href="https://arxiv.org/pdf/1611.05469.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh">)。评论的主要矢量化是Devlin等人最初的transformer(在这里找到他们的论文<a class="ae jd" href="https://arxiv.org/pdf/1810.04805.pdf" rel="noopener ugc nofollow" target="_blank"><strong class="kf jh"/></a><strong class="kf jh">)。</strong>在这篇文章中我们实际上是用句子-Bert进行矢量化，一个连体的Bert网络(在这里</strong> </a> <strong class="kf jh">找到他们的论文<a class="ae jd" href="https://arxiv.org/pdf/1908.10084.pdf" rel="noopener ugc nofollow" target="_blank">)。该算法也是由尼古拉·考特纳提出的(点击这里查看他的G </a><a class="ae jd" href="https://gist.github.com/Nikolaj-K/388e643d1f5e6989072a21e469d10a48" rel="noopener ugc nofollow" target="_blank"> it要点</a>)。</strong></p></div></div>    
</body>
</html>