<html>
<head>
<title>Opening a Kebab Restaurant in Milan, With Data Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在米兰开一家烤肉串餐厅，用数据分析</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/opening-a-kebab-restaurant-in-milan-with-data-analysis-2dcca8f45ad1?source=collection_archive---------6-----------------------#2021-02-18">https://medium.datadriveninvestor.com/opening-a-kebab-restaurant-in-milan-with-data-analysis-2dcca8f45ad1?source=collection_archive---------6-----------------------#2021-02-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c7acfc90c2f0c7c07e99a2018b40ca4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jVMXLK-dbBbcyTnTJpUE4g.jpeg"/></div></div></figure><p id="3fdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个项目中，我将尝试以不同的方式处理数据分析，如果我要在我居住的米兰开一家餐厅吃一顿美味的土耳其餐，我会考虑应该在哪里开。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="c9d3" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated"><em class="lw"> 1。将维基百科页面上的数据剪切成一个数据帧</em></h2><p id="4d65" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">首先，因为我没有数据，我研究了哪里可以了解米兰地区，我可以在<a class="ae mc" href="https://en.wikipedia.org/wiki/Category:Districts_of_Milan" rel="noopener ugc nofollow" target="_blank">维基百科</a>上访问米兰的信息。首先，我制作了这些信息，以便我可以通过BeautifulSoup检索这些信息。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="6316" class="ld le iq mi b gy mm mn l mo mp"># Getting information about Milan<br/>data = requests.get("https://en.wikipedia.org/wiki/Category:Districts_of_Milan").text<br/><br/># creating beautifulsoup object from html<br/>soup = BeautifulSoup(data, 'html.parser')</span></pre><p id="96c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">属于BeautifulSoup的html.parser完全按照我的要求完成了它的任务，为了从这里获得区域，我添加了一个过程，即选择并添加列表中的所有文章到我的空列表NeighborhoodList中，这个空列表名为NeighborhoodList，带有for循环。然后我把它变成了一个DataFrame，让它更容易在这个列表上操作。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/a3577472d5a86e3deaaa58ce1a8655b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zkyrsx-Dg5507e45ffDvzw.png"/></div></div></figure><h2 id="d331" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated"><em class="lw"> 2。获取地理坐标</em></h2><p id="5c9f" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">由于我需要可视化一个覆盖所有米兰地区的数据帧，我需要获得这些地区的地理坐标，在地理编码器库的帮助下，我们可以很容易地找到坐标。所以我创建了一个函数，我称之为“get_latlng”。有了这个功能，我们将能够访问我们输入的每个neighborhoodList成员的位置数据。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="ea3f" class="ld le iq mi b gy mm mn l mo mp"># Function to obtain the locations of the neighborhood in Milan.<br/>def get_latlng(neighborhood):<br/>    lat_lng_coords = None<br/>    while(lat_lng_coords is None):<br/>        g = geocoder.arcgis('{}, Milan, Italy'.format(neighborhood))<br/>        lat_lng_coords = g.latlng<br/>    return lat_lng_coords</span></pre><p id="859f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用我命名为“坐标”的新列表，我在邻居列表中记录了所有区域的位置。我把在这里获得的经纬度信息保存到之前准备好的mi_df数据帧中。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="7de0" class="ld le iq mi b gy mm mn l mo mp"># call the previous function to get the coordinates, store in a coords list<br/>coords = [ get_latlng(neighborhood) for neighborhood in mi_df["Neighborhood"].tolist()]</span></pre><h2 id="1f7e" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">3.创建一张米兰附近的地图</h2><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="4936" class="ld le iq mi b gy mm mn l mo mp"># get the coordinates of Milano<br/>address = 'Milan, Italy'<br/><br/>geolocator = Nominatim(user_agent="my-application")<br/>location = geolocator.geocode(address)<br/>latitude = location.latitude<br/>longitude = location.longitude<br/>print('The geograpical coordinate of Milan,Italy {}, {}.'.format(latitude, longitude))</span></pre><p id="d81b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了区域名称和坐标信息，我们可以进行可视化了。使用地理定位器，我们首先将地图与米兰的经纬度数据对齐。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="2d58" class="ld le iq mi b gy mm mn l mo mp"># create a map<br/>map_mi = folium.Map(location=[latitude, longitude], zoom_start=11)<br/><br/># add markers <br/>for lat, lng, neighborhood in zip(mi_df['Latitude'], mi_df['Longitude'], mi_df['Neighborhood']):<br/>    label = '{}'.format(neighborhood)<br/>    label = folium.Popup(label, parse_html=True)<br/>    folium.CircleMarker(<br/>        [lat, lng],<br/>        radius=5,<br/>        popup=label,<br/>        color='blue',<br/>        fill=True,<br/>        fill_color='#3186cc',<br/>        fill_opacity=0.7).add_to(map_mi)  <br/>    <br/>map_mi</span></pre><p id="d85a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们通过leav创建名为map_mi的地图。在这里，我们通过使用mi_df中的邻域、纬度和经度变量为每个区域添加一个标记。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/e048f53f7919739b40e3655e7919691f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CDmbqPv_aC2gX8u87kxh5A.png"/></div></div></figure><p id="81e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了一张漂亮的米兰地图和代表各个地区的标记。</p><h2 id="d25c" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated"><em class="lw"> 4。使用Foursquare API探索邻居</em></h2><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="95c0" class="ld le iq mi b gy mm mn l mo mp">CLIENT_ID = 'xXx'<br/>CLIENT_SECRET = 'xXx'<br/>VERSION = 'xXx'<br/><br/>print('Your credentails:')<br/>print('CLIENT_ID: ' + CLIENT_ID)<br/>print('CLIENT_SECRET:' + CLIENT_SECRET)</span></pre><p id="26dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要使用Foursquare API探索区域的内容并了解餐馆的类型。在输入API信息(如client_id、client_secret和版本)后，我们访问API，让我们看看半径为2000米的前200个场馆。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="bd3f" class="ld le iq mi b gy mm mn l mo mp">radius = 2000<br/>LIMIT = 200<br/><br/>venues = []<br/><br/>for lat, long, neighborhood in zip(mi_df['Latitude'], mi_df['Longitude'], mi_df['Neighborhood']):<br/>    <br/>    # create API request <br/>    url = "https://api.foursquare.com/v2/venues/explore?client_id={}&amp;client_secret={}&amp;v={}&amp;ll={},{}&amp;radius={}&amp;limit={}".format(<br/>        CLIENT_ID,<br/>        CLIENT_SECRET,<br/>        VERSION,<br/>        lat,<br/>        long,<br/>        radius, <br/>        LIMIT)<br/>    <br/>    # make the GET request<br/>    results = requests.get(url).json()["response"]['groups'][0]['items']<br/>    <br/>    # return only relevant information<br/>    for venue in results:<br/>        venues.append((<br/>            neighborhood,<br/>            lat, <br/>            long, <br/>            venue['venue']['name'], <br/>            venue['venue']['location']['lat'], <br/>            venue['venue']['location']['lng'],  <br/>            venue['venue']['categories'][0]['name']))</span></pre><p id="a42c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们检查一下每个街区返回了多少个场馆</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/4a0334989f1b203492fff37c495e7a68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RYn-lZIAKUzRQTaZtJ3KZA.png"/></div></div></figure><p id="91b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们来考虑如何覆盖所有地区，有多少独特的地方。再来看看每个地区有多少独特的地方。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="02d5" class="ld le iq mi b gy mm mn l mo mp">print('There are {} uniques categories.'.format(len(venues_df['VenueCategory'].unique())))</span></pre><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/1254fa61bf3fb7166fea4cedf742e7f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M7NBYDo0I22XyejL0kqSsg.png"/></div></div></figure><h2 id="5e19" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated"><em class="lw"> 5。分析每个邻域</em></h2><p id="fb16" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">让我们走到一步，在这一步，我们会感到我们正在接近终点。现在让我们用one-hot-encoder来区分各个地区的餐馆类型。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="386c" class="ld le iq mi b gy mm mn l mo mp"># one hot encoding<br/>mi_onehot = pd.get_dummies(venues_df[['VenueCategory']], prefix="", prefix_sep="")<br/><br/># add neighborhood column back to dataframe<br/>mi_onehot['Neighborhoods'] = venues_df['Neighborhood'] <br/><br/># move neighborhood column to the first column<br/>fixed_columns = [mi_onehot.columns[-1]] + list(mi_onehot.columns[:-1])<br/>mi_onehot = mi_onehot[fixed_columns]<br/><br/>print(mi_onehot.shape)<br/>mi_onehot.head()</span></pre><p id="e46b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们将此数据保存为mi_grouped，并使用groupby操作根据邻域排列保存的数据帧，并通过为这些数字的平均值(频率)赋值，以mi_grouped的名称再次保存它。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/91e353f9e1ecee64b995e040b418f8f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*Bw5hNCHP9a24OGJTX8a4Cw.png"/></div></figure><p id="d776" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们检查在mi_grouped数据集中拥有超过0个“Kebap餐馆”的地区的数量。然后，让我们创建一个名为mi _ kebap的新数据框架，其中只包含地区和烤肉店频率。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/a90eac8d5134c1cbf1e017603bc0450b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*KIKabjvM2GG-U68xR0WAWQ.png"/></div></figure><h2 id="807b" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated"><em class="lw"> 6。聚类邻域</em></h2><p id="e2a5" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">感谢k-means，我用mi _ kebap数据帧创建了3个聚类。我将这里创建的集群添加到我的数据框架中，命名为集群标签。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="ddc3" class="ld le iq mi b gy mm mn l mo mp">kclusters = 3<br/><br/>mi_clustering = mi_kebap.drop(["Neighborhoods"], 1)<br/><br/># run k-means clustering<br/>kmeans = KMeans(n_clusters=kclusters, random_state=0).fit(mi_clustering)<br/>kmeans.labels_[0:10]</span><span id="e56f" class="ld le iq mi b gy mw mn l mo mp">mi_merged = mi_kebap.copy()<br/><br/>mi_merged["Cluster Labels"] = kmeans.labels_</span></pre><p id="9236" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我创建的最后一个数据框中，我有Neighborhood、Kebap Restaurant、聚类标签、纬度和经度变量，因此我将为每个聚类分配一个聚类标签，并且我可以在地图上显示不同的颜色及其坐标。通过leav，我创建了一个带有标记的地图，每个聚类都有不同的颜色。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/bdcd3c0fec9e2a4bce2c5954954cd17f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*sKCLCQp1ZrZymujDFzLMaA.png"/></div></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="8867" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated"><em class="lw"> 7。观察结果</em></h2><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><blockquote class="na nb nc"><p id="4700" class="jy jz nd ka b kb kc kd ke kf kg kh ki ne kk kl km nf ko kp kq ng ks kt ku kv ij bi translated">大多数烤肉串餐厅都集中在稍微远离米兰市中心的区域，第1组(紫色的)的比率最高，第2组的比率中等。<br/> <br/>这代表着开设新烤肉串餐厅的巨大机会和巨大潜力，因为现有烤肉串餐厅几乎没有竞争。与此同时，由于供应过剩和烤肉串餐馆密度高，集群1附近的烤肉串餐馆面临激烈的竞争。从另一个角度来看，这表明过度供应的烤肉店大多发生在城市的中心地区，仍然很少有烤肉店在郊区和市中心。因此，该项目建议房地产开发商利用这些发现，在0区附近新开一家烤肉串餐馆。拥有独特销售方案以在竞争中脱颖而出的房地产开发商，也可以在竞争适度的第二组团的社区中开设新的烤肉店。最后，建议房地产开发商避开集群1中的社区，这里已经是一个高度集中的烤肉串餐厅，竞争激烈。</p></blockquote></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="4bd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想继续阅读，与本文相关的笔记本在<a class="ae mc" href="https://github.com/ogulcanertunc/Data-Science-Projects/tree/main/Python/Finding%20the%20restaurant%20location%20to%20be%20opened%20with%20data%20analysis" rel="noopener ugc nofollow" target="_blank"> Github </a>上。</p></div></div>    
</body>
</html>