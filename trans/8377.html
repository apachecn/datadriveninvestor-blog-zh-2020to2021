<html>
<head>
<title>Loan Defaulter Risk Prediction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">贷款违约风险预测</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/loan-defaulter-risk-prediction-4b44dc8c3c35?source=collection_archive---------8-----------------------#2021-01-09">https://medium.datadriveninvestor.com/loan-defaulter-risk-prediction-4b44dc8c3c35?source=collection_archive---------8-----------------------#2021-01-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4920" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">建立了一个逻辑回归模型，预测某个候选人是否有拖欠贷款的倾向</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/3c015e2365a1501e4405e13f75a1f8a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_5ot4cnEH5WH1qNCKg9NA.jpeg"/></div></div></figure><p id="0324" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">贷款已经成为我们日常生活的重要组成部分。尽管这对借贷双方都有利可图。有一个巨大的困境，贷款人在制裁时，特别是如果借款人没有足够的或不存在的信用记录。如果借款人拖欠贷款，会导致贷方的损失。因此，了解借款人是否有能力偿还债务或违约，对所有贷款机构来说都是一个非常关键的问题。在本文中，我们将建立一个逻辑回归模型，预测某个候选人是否会拖欠贷款:</p><p id="e0e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个模型是根据Murilã在kaggle上提供的<a class="ae la" href="https://www.kaggle.com/upadorprofzs/credit-risk" rel="noopener ugc nofollow" target="_blank">信用风险数据集</a>训练出来的。</p><p id="fc6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">准备数据:</strong></p><p id="2377" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1.首先，我使用pandas库读取CSV文件:</p><pre class="kp kq kr ks gt lb lc ld le aw lf bi"><span id="a939" class="lg lh it lc b gy li lj l lk ll"># Loading CSV File<br/>data = pd.read_csv('original.csv')<br/># Dropping rows with NaN values<br/>input = data.dropna()</span></pre><p id="270f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.然后我删除了包含NaN值的列</p><p id="32da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.然后，我使用sklearn的“train_test_split”将数据集分别拆分为测试值和训练值。</p><pre class="kp kq kr ks gt lb lc ld le aw lf bi"><span id="ebb5" class="lg lh it lc b gy li lj l lk ll"># Splitting Dataset into train and test<br/>y = input['default']<br/>X = input.drop(columns=['default'])<br/><br/>X_train<strong class="lc iu">, </strong>X_test<strong class="lc iu">, </strong>y_train<strong class="lc iu">, </strong>y_test = train_test_split(X<strong class="lc iu">, </strong>y<strong class="lc iu">, </strong>test_size=<strong class="lc iu">0.2</strong>)</span></pre><p id="80e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">创建模型:</strong></p><p id="7979" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Model.py中，我创建了两个函数:</p><ol class=""><li id="59d0" class="lm ln it js b jt ju jx jy kb lo kf lp kj lq kn lr ls lt lu bi translated">train():调用这个函数在给定的数据集上训练模型</li></ol><pre class="kp kq kr ks gt lb lc ld le aw lf bi"><span id="5ee8" class="lg lh it lc b gy li lj l lk ll">#Function to train model<br/>def train(X_train<strong class="lc iu">, </strong>y_train):<br/>    model = LogisticRegression()<br/>    model.fit(X_train<strong class="lc iu">, </strong>y_train)<br/>    return model</span></pre><p id="9960" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在这个例子中使用了逻辑回归。逻辑回归是分类问题中非常著名的算法。我们可以很容易地用几行代码实现逻辑回归，并得到满意的结果。逻辑回归类似于线性回归，只是函数不同。</p><p id="6b8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.predict():这个函数用于对给定的数据进行预测</p><pre class="kp kq kr ks gt lb lc ld le aw lf bi"><span id="cd9e" class="lg lh it lc b gy li lj l lk ll">#Fuction for prediction<br/>def predict(model<strong class="lc iu">, </strong>X_test):<br/>    return model.predict(X_test)</span></pre><p id="6730" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">训练模型:</strong></p><p id="073e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦数据被分别分成训练和测试组件，我们就从model.py文件中调用train函数来训练/拟合X_train和y_train数据上的模型。</p><pre class="kp kq kr ks gt lb lc ld le aw lf bi"><span id="8831" class="lg lh it lc b gy li lj l lk ll"># Training the model<br/>model = train(X_train<strong class="lc iu">, </strong>y_train)</span></pre><p id="0ae5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">预测:</strong></p><p id="c837" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完成训练后，我们将测试值传递给model.py文件的predict函数，以测试预测</p><pre class="kp kq kr ks gt lb lc ld le aw lf bi"><span id="98b7" class="lg lh it lc b gy li lj l lk ll"># making Prediction<br/>pred = predict(model<strong class="lc iu">, </strong>X_test)<br/>print(pred)</span></pre><p id="c620" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">绩效指标:</strong></p><p id="d62e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了衡量性能，我们查看分类报告和混淆矩阵:</p><pre class="kp kq kr ks gt lb lc ld le aw lf bi"><span id="b4fe" class="lg lh it lc b gy li lj l lk ll"># Printing perfomance Metrics<br/>print(classification_report(y_test<strong class="lc iu">, </strong>pred))<br/>print('===================================')<br/>print(confusion_matrix(y_test<strong class="lc iu">, </strong>pred))</span><span id="d2c9" class="lg lh it lc b gy lv lj l lk ll">            precision    recall  f1-score   support</span><span id="0906" class="lg lh it lc b gy lv lj l lk ll">      0       0.94      0.99      0.96       350<br/>      1       0.87      0.52      0.65        50</span><span id="eca8" class="lg lh it lc b gy lv lj l lk ll">accuracy                           0.93       400<br/>   macro avg       0.90      0.75      0.81       400<br/>weighted avg       0.93      0.93      0.92       400</span><span id="e686" class="lg lh it lc b gy lv lj l lk ll">===================================<br/>[[346   4]<br/> [ 24  26]]</span><span id="2008" class="lg lh it lc b gy lv lj l lk ll">Process finished with exit code 0</span></pre><p id="fabd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如你所见，通过这个数据集，我们预测某个人是否会拖欠贷款的准确率达到了93%。你可以在<a class="ae la" href="https://github.com/nischalmadiraju/Loan-Risk-Prediction" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到代码。</p></div></div>    
</body>
</html>