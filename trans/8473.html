<html>
<head>
<title>Pandas Data Frame 101: Filtering Data, loc &amp; iloc</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pandas数据框101:过滤数据，loc和iloc</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/pandas-data-frame-101-filtering-data-loc-iloc-939301489088?source=collection_archive---------8-----------------------#2021-01-12">https://medium.datadriveninvestor.com/pandas-data-frame-101-filtering-data-loc-iloc-939301489088?source=collection_archive---------8-----------------------#2021-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/52363d4ba43ca8051ceee1d6350f07cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*_X0vE_7HmaQ2hOEoC_fOvA.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk"><a class="ae kb" href="https://mysimple.name/filtering-data-in-symfony/" rel="noopener ugc nofollow" target="_blank">(Image Source)</a></figcaption></figure><p id="b866" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">本文是第一篇文章的延续，在第一篇文章中，我们学习了<a class="ae kb" href="https://medium.com/datadriveninvestor/pandas-data-frame-101-part-1-627b9405d14f" rel="noopener">如何从CSV和Excel文件</a>创建数据框并将数据加载到数据框中。</p><p id="7e0f" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在今天的教程中，我们将学习如何从数据框中选择数据。让我们<a class="ae kb" href="https://finance.yahoo.com/quote/%5EGSPC/history?p=%5EGSPC" rel="noopener ugc nofollow" target="_blank">通过点击页面上的下载链接从雅虎财经下载</a>股票数据，这可以让你以CSV文件的形式下载数据。这是标准普尔500指数的历史数据。我将该文件重命名为stocks.csv。让我们从导入pandas开始，并从csv文件加载数据。你可以在这里下载包含这个代码<a class="ae kb" href="https://github.com/doctorsmonsters/pandas_loc_iloc" rel="noopener ugc nofollow" target="_blank">的CVS文件和笔记本。</a></p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="c66e" class="lj lk it lf b gy ll lm l ln lo"><strong class="lf iu">import</strong> pandas <strong class="lf iu">as</strong> pd</span><span id="f37a" class="lj lk it lf b gy lp lm l ln lo">data<strong class="lf iu">=</strong>pd.read_csv('stocks.csv')</span></pre><p id="a628" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">让我们看看数据框架中的列。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="de04" class="lj lk it lf b gy ll lm l ln lo">data.columns</span></pre><p id="84dd" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们得到以下输出:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="579d" class="lj lk it lf b gy ll lm l ln lo">Index(['Date', 'Open', 'High', 'Low', 'Close', 'Adj Close', 'Volume'], dtype='object')</span></pre><p id="fe06" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu">使用‘loc’属性:</strong></p><p id="096a" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">loc可用于基于标签检索数据。默认情况下，数据框的索引列被视为一个标注。因此，在我们的数据中，如果我们想要检索第3行所有列中的数据，我们将使用:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="f65b" class="lj lk it lf b gy ll lm l ln lo">data.loc[3]</span></pre><p id="3a49" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">输出:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="51a7" class="lj lk it lf b gy ll lm l ln lo">Date         2020-01-15<br/>Open            3282.27<br/>High            3298.66<br/>Low             3280.69<br/>Close           3289.29<br/>Adj Close       3289.29<br/>Volume       3716840000<br/>Name: 3, dtype: object</span></pre><p id="0999" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">然而，为了便于阅读，最好分配更合理的标签。所以在我们的数据中，因为它可以被认为是时间序列数据，所以我们可以将日期列指定为索引。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="499a" class="lj lk it lf b gy ll lm l ln lo">data.index<strong class="lf iu">=</strong>data['Date']</span></pre><p id="0f61" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">现在我们使用日期作为标签，检索数据将变得非常容易。假设我们想查看1月4日的数据。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="6f7c" class="lj lk it lf b gy ll lm l ln lo">data.loc['2021-01-04']</span></pre><p id="0e59" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">输出:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="7f5b" class="lj lk it lf b gy ll lm l ln lo">Date         2021-01-04<br/>Open            3764.61<br/>High            3769.99<br/>Low             3662.71<br/>Close           3700.65<br/>Adj Close       3700.65<br/>Volume       5006680000<br/>Name: 2021-01-04, dtype: object</span></pre><p id="5352" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">现在假设我们对一个特定的列感兴趣，比如收盘价。我们可以通过传递列名来做到这一点。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="aa6a" class="lj lk it lf b gy ll lm l ln lo">data.loc['2021-01-04', 'Close']</span></pre><p id="b7cc" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">输出:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="863e" class="lj lk it lf b gy ll lm l ln lo">3700.649902</span></pre><p id="a5fb" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">要从多个列中检索数据，可以将列名作为列表传递。类似地，如果需要来自多行的数据，也可以将标签作为列表传递。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="30b1" class="lj lk it lf b gy ll lm l ln lo">print(data.loc['2021-01-04', ['Open', 'Close']])</span><span id="0931" class="lj lk it lf b gy lp lm l ln lo"><em class="lq"># Open and close for Janurary 4 and 5.</em></span><span id="50d4" class="lj lk it lf b gy lp lm l ln lo">print(data.loc[['2021-01-04','2021-01-05'], ['Open','Close']])</span><span id="4364" class="lj lk it lf b gy lp lm l ln lo">Open     3764.61<br/>Close    3700.65<br/>Name: 2021-01-04, dtype: object<br/>                   Open        Close<br/>Date                                <br/>2021-01-04  3764.610107  3700.649902<br/>2021-01-05  3698.020020  3726.860107</span></pre><p id="ef27" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">现在，如果您想查看整个数据帧的某些列，可以按如下方式进行:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="286d" class="lj lk it lf b gy ll lm l ln lo">​print(data.loc[:, ['Open','Close']])</span><span id="bc1c" class="lj lk it lf b gy lp lm l ln lo">Open        Close<br/>0    3281.810059  3265.350098<br/>1    3271.129883  3288.129883<br/>2    3285.350098  3283.149902<br/>3    3282.270020  3289.290039<br/>4    3302.969971  3316.810059<br/>..           ...          ...<br/>247  3764.610107  3700.649902<br/>248  3698.020020  3726.860107<br/>249  3712.199951  3748.139893<br/>250  3764.709961  3803.790039<br/>251  3815.050049  3824.679932</span><span id="2ad2" class="lj lk it lf b gy lp lm l ln lo">[252 rows x 2 columns]</span></pre><p id="63db" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu">使用“iloc”:</strong></p><p id="e8bb" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">iloc使您能够基于虚拟数字索引检索数据。请注意，数字索引是虚构的，这意味着它是实际的索引列。例如，在我们的数据中，日期列被指定为索引。但是使用iloc，您可以基于从0开始的索引号检索数据。例如，如果您想检索索引为0的行，可以按如下方式进行:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="55b4" class="lj lk it lf b gy ll lm l ln lo">data.iloc[0]</span></pre><p id="1e74" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">输出:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="64a9" class="lj lk it lf b gy ll lm l ln lo">Date         2020-01-10<br/>Open            3281.81<br/>High            3282.99<br/>Low             3260.86<br/>Close           3265.35<br/>Adj Close       3265.35<br/>Volume       3212970000<br/>Name: 0, dtype: object</span></pre><p id="e46f" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">以类似的方式，您可以使用iloc从特定的行和列中检索数据，方法是为这两者提供索引。假设我们想从第2行第3列检索数据。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="7a65" class="lj lk it lf b gy ll lm l ln lo">data.iloc[2,3]</span></pre><p id="fa41" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">输出:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="2166" class="lj lk it lf b gy ll lm l ln lo">3277.189941</span></pre><p id="d01a" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">人们可能想知道这有什么用。在我们的数据中，想象您想要检索最后3行。您可以使用iloc实现这一点。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="73cb" class="lj lk it lf b gy ll lm l ln lo">print(data.iloc[<strong class="lf iu">-</strong>1])</span><span id="3c00" class="lj lk it lf b gy lp lm l ln lo">Date         2021-01-08<br/>Open            3815.05<br/>High            3826.69<br/>Low              3783.6<br/>Close           3824.68<br/>Adj Close       3824.68<br/>Volume       4764180000<br/>Name: 251, dtype: object</span></pre><p id="657a" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">因此，就像列表一样，您可以使用索引从开头或结尾检索数据的日期或范围，也可以使用步骤。例如，你想选择每第三行，你可以这样做。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="e784" class="lj lk it lf b gy ll lm l ln lo">data.iloc[::3]</span></pre><p id="a211" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">使用iloc，我们实际上可以设置单元格的值。例如，在我们的数据中，假设我们希望将每隔一行的音量设置为0。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="77e3" class="lj lk it lf b gy ll lm l ln lo">data.iloc[::2,6]<strong class="lf iu">=</strong>0</span></pre><p id="5d36" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu">有条件选择数据:</strong></p><p id="1841" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">熊猫也给我们提供了有条件的挑排。例如，我们希望只显示收盘价高于平均收盘价的日期的数据。为此，首先我们定义条件，将其分配给一个对象，然后将该对象传递给loc属性。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="7298" class="lj lk it lf b gy ll lm l ln lo">high_close<strong class="lf iu">=</strong>data.Close<strong class="lf iu">&gt;</strong>data.Close.mean()</span><span id="42e0" class="lj lk it lf b gy lp lm l ln lo">data.loc[high_close]</span></pre><p id="5202" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">另一个例子是选择一个有特定价格的日期。所以我们想知道收盘价为3700.649902这一天的数据。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="8abb" class="lj lk it lf b gy ll lm l ln lo">condition <strong class="lf iu">=</strong> data.Close <strong class="lf iu">==</strong> 3700.649902</span><span id="2420" class="lj lk it lf b gy lp lm l ln lo">data.loc[condition]</span></pre><p id="fc21" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">就这样了，伙计们。熊猫确实有一些超能力，高效的数据过滤绝对是其中之一。</p></div></div>    
</body>
</html>