<html>
<head>
<title>Stock Price Simulations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">股票价格模拟</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/stock-price-simulations-fa2ce492dd93?source=collection_archive---------3-----------------------#2021-01-28">https://medium.datadriveninvestor.com/stock-price-simulations-fa2ce492dd93?source=collection_archive---------3-----------------------#2021-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="feea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">免责声明:不根据本文内容做任何交易决定。这是对股票价格预测的纯理论尝试</em></p><p id="af1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">众所周知，预测股票价格是不可能的，即使试图预测也是徒劳的。股票的走势总是不确定的。也就是说，尽可能减少这种不确定性并制定应急计划是可能的。</p><p id="38d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当考虑投资股票时，让投资者害怕的是投资的风险和不确定性。不知道股票会如何表现的感觉让他们感到害怕，然而，有一种方法可以缓解这些保留意见。这种改变游戏规则的方法就是蒙特卡洛法。</p><p id="c5f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">蒙特卡罗方法本质上是基于不同事件的概率对数据集进行多次模拟，并考虑随机特征。通过这种方式，它产生了一系列不同的情景，利用这些情景，人们可以为各种不同的未来做好准备，不确定性可以有所减少。在这篇文章中，我将带您了解我的项目，在这个项目中，我使用Python实现了对GOOGLE股票价格的蒙特卡罗方法。所以，让我们开始吧！</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="a1a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我导入了所有需要的包。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="89e5" class="lc ld iq ky b gy le lf l lg lh">import numpy as np<br/>import pandas as pd<br/>import seaborn as sns<br/>import matplotlib.pyplot as plt<br/>from scipy.stats import norm<br/>from pandas_datareader import data as dr</span></pre><p id="3c24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步，获取数据。对于任何类型的预测或模拟，都需要相关目标的历史数据。在这个项目中，我使用了谷歌从2016年1月1日到2020年12月31日五年间调整后的收盘价。我从雅虎导入了数据！使用pandas_datareader库融资。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="548e" class="lc ld iq ky b gy le lf l lg lh">ticker = 'GOOGL'  #GOOGLE stock ticker<br/>data = pd.DataFrame(columns = [ticker])<br/>data[ticker] = dr.DataReader(ticker, data_source = 'yahoo', start = '2016-1-1', end = '2020-12-31')['Adj Close']<br/>print(data.head())</span></pre><figure class="kt ku kv kw gt lj gh gi paragraph-image"><div class="gh gi li"><img src="../Images/8e7dbf4060d568563527aa04b82cb47e.png" data-original-src="https://miro.medium.com/v2/resize:fit:320/format:webp/1*Okla_FUGAEkfvoGjgGuLbA.png"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">First 5 stock prices</figcaption></figure><figure class="kt ku kv kw gt lj gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/3e0fa437c92b3a9c83a4c78def437fab.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*7L8j7tEYksdSWekEvXmE4Q.png"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">GOOGLE 5 year Adjusted Close prices</figcaption></figure><p id="5bda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">起初，我打算直接随机排列股票价格并预测它们，但后来我发现这样做，股票价格会在整个价格范围内波动。因此，我决定随机化每日回报，而不是随机化股票价格。通过这种方式，我能够得到更可靠的模拟。这样做的第一步是计算每日回报，这很容易实现。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="78d0" class="lc ld iq ky b gy le lf l lg lh">returns = data.pct_change()<br/>returns.dropna(inplace = True)<br/>print(returns.head())</span></pre><figure class="kt ku kv kw gt lj gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/f76e616b99d918925b3518922bb46eb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:294/format:webp/1*vCjRREfTRmfYJbYHpWxl8g.png"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">First 5 daily return rates</figcaption></figure><p id="5beb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，蒙特卡罗方法已被发现是金融奇才武库中如此可靠的工具，因为它不是直接随机取值，而是利用各种事件的概率来预测目标变量。为了正确地做到这一点，需要数据的概率分布，这是我做的下一件事。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="180d" class="lc ld iq ky b gy le lf l lg lh">sns.distplot(returns, hist = True)<br/>plt.show()</span></pre><figure class="kt ku kv kw gt lj gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/a817a4220bc1475cec4241ca40cff861.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*IvTb5_2QBCB3wxHK9YeBug.png"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">Density plot of returns, closely resembling normal distribution</figcaption></figure><p id="f2fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你从密度图中看到的，日收益率服从正态分布，左边的尾部更粗。这种异常的细节可以很容易地处理，它将在模拟部分提前处理。</p><p id="aaf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的目标是建立一个概率模拟模型。传统上，在正态分布中，平均值的68%的概率范围，即任一侧的34%，足以覆盖任一侧的1个标准差的范围。为了安全起见，我决定使用75%的概率范围，左边和右边的分配分别为40-35。由于更加强调左侧，模拟将能够更好地使用历史性能进行投影。极限可以这样设置</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="afd0" class="lc ld iq ky b gy le lf l lg lh">l = norm.ppf(0.10)<br/>u = norm.ppf(0.85)</span></pre><p id="e766" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面这段代码中，我使用了scipy.stats中的norm模块来设置限制。在正态分布中，0.5的累积分布给出平均值。因此，要向左移动平均值的40%，我将下限设置为(0.5–0.4)= 0.1，向右移动35%，我将上限设置为(0.5+0.35) = 0.85。</p><p id="965d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，为了生成一组30×10的随机日回报率(30天，10次模拟)，我使用标准正态分布(均值= 1，标准差= 1)生成了一个随机的30×10矩阵，同时牢记我们的限制。然而，我们的日收益率并不遵循正态分布，因为它们的均值不是0，标准差也不是1。通过一点统计操作，我改变了这些标准费率，以符合我们的要求。下面给出了公式。</p><figure class="kt ku kv kw gt lj gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/23fee349a77c452c7d815c1b1b948807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*D_k2WhaXkb2vTCPYn-Obcw.png"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">Formula for conversion of S.N.V to N.V</figcaption></figure><p id="bbe9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用此公式，可以将标准正态变量改变为与任何正态变量的标度相匹配。有了这个，我攻克了算法最难的部分。我现在所需要的就是用这些比率来得到模拟价格。</p><p id="513b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我创建了一个充满1的30x10矩阵。我将矩阵的第一行乘以最近已知的收盘价，以此作为所有模拟的起点。然后我简单地用这个逻辑一行接一行地乘以价格</p><figure class="kt ku kv kw gt lj gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/2f34f3d002fb6194041163aacd57993f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*WdvZE6aAbf-d_IuP1_KYBw.png"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">Formula for simulation</figcaption></figure><p id="2e32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">瞧，我成功地生成了10个谷歌股票的模拟。然后，我继续绘制模拟图以及最高和最低模拟价格，如下所示</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="4a0b" class="lc ld iq ky b gy le lf l lg lh">mean = returns.mean()<br/>stdev = returns.std()<br/>np.random.seed(42)<br/>n = np.random.normal(size = (30,10))<br/>rows = n.shape[0]<br/>cols = n.shape[1]<br/>for i in range(0,rows) :<br/>    for j in range(0,cols) :<br/>        if n[i][j] &gt; u :<br/>           n[i][j] = u       #sets upper limit<br/>        elif n[i][j] &lt; l :<br/>             n[i][j] = l     #sets lower limit<br/>        else :<br/>             n[i][j] = n[i][j]<br/>        n[i][j] = (stdev * n[i][j]) + mean<br/>s = data.iloc[-1]<br/>pred = np.zeros_like(n) + 1<br/>pred[0] = s         #sets beginning point of simulations<br/>for i in range(1,30) :<br/>    pred[i] = pred[(i-1)] * (1 + n[(i-1)])</span><span id="9c38" class="lc ld iq ky b gy lv lf l lg lh">plt.figure(figsize = (7,4))<br/>plt.title('{} SIMULATIONS'.format(ticker))    <br/>for i in range(0,10) :<br/>    plt.plot(pred[:, i])<br/>plt.show()</span></pre><figure class="kt ku kv kw gt lj gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/7be96df92d298ab43b3d0f745a1dda91.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*gbMGX1CgOD-_xefooswTug.png"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">GOOGLE stock price simulations</figcaption></figure><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="74fe" class="lc ld iq ky b gy le lf l lg lh">print('\n')<br/>print('Maximum Simulated Price : {}'.format(np.max(pred)))<br/>print('Minimum Simulated Price : {}'.format(np.min(pred)))<br/>for j in range(0,cols) :<br/>    print('Simulated Close Prices after 30 days : {}'.format(pred[-1][j]))</span></pre><figure class="kt ku kv kw gt lj gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/d915fc98a35267df2890bf4a42b6c8b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*3M3QmoxhvIQzSvFVR5hUuw.png"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">The important simulated values</figcaption></figure><p id="5cda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这个输出中，您可以看到，模拟的最高价格为2038.79美元，最低价格为1615.5美元，给出了400美元的范围。所以，我至少成功地将30天的股票价格控制在400美元的范围内。厉害！</p><p id="5135" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你喜欢这篇文章，并保持关注，因为下一个项目会更好。</p></div></div>    
</body>
</html>