# 朴素贝叶斯 Noob 指南

> 原文：<https://medium.datadriveninvestor.com/a-noobs-guide-to-naive-bayes-2ef0d8c131a6?source=collection_archive---------2----------------------->

今天，我们将学习一种非常“幼稚”的算法，即朴素贝叶斯算法。我们还将讨论它在包含分类值和连续值的数据集上的实现(从头开始)。

![](img/afd0abb74904faa4eeb83f981f13f7aa.png)

Source:analyticsprofile.com

# 介绍

朴素贝叶斯是一种用于分类问题的监督学习算法。它来自“概率分类器”家族，并在假设所有特征相互独立的情况下应用贝叶斯定理对对象进行分类。这是使其“幼稚”的假设，因为在现实生活中，很难找到预测值之间没有多重共线性或零相关性的数据集。

尽管有这样的假设，它在分类物体方面做得相当好。

所以在实现我们的朴素贝叶斯算法之前，我们应该先了解一下贝叶斯定理是怎么回事。

# 贝叶斯定理

在学习贝叶斯定理之前，我们需要了解条件概率的概念。

## 条件概率:

> 条件概率是指在某种条件为真的情况下，某一事件发生的概率。它被表示为 P(事件|条件)。

让我们用一个“非常复杂”的例子来理解它。

假设一个人想打一面墙(我不知道为什么，但继续前进)。如果他击打墙壁，受伤的可能性有多大？这里，我们找到概率的事件是“伤手”，条件是“打墙”。

我们的例子可以表示为 P(“受伤的手”|“打一堵墙”)。

> 应该注意的是，
> 
> P("伤手" | "打墙")≠P("打墙" | "伤手")
> 
> 一个人在打完一面墙之后伤到手的概率和他在手受伤的时候打一面墙的概率是不一样的。(只要读几遍，你就会明白了)

## 回到贝叶斯定理…

这个定理是下面这位先生介绍的:

![](img/5b1b60f05d87d88d864c075cd8f35610.png)

Thomas Bayes

它给了我们一种计算条件概率的方法。

数学上这可以描述为，

![](img/2ca37415cc818e212cbecf530f26e560.png)

Source: iq.opengenus.org

很多时候，我们并没有得到分母 P(B) *(这个术语也被称为证据)*的值。我们可以通过下面的等式来计算:

P(B)= P(B | A)*P(A)+P(B |非 A)* P(非 A)

**注意:**

*   P(非 A) = 1-P(A)
*   P(B |非 A) = 1-P(非 B |非 A)

使用上面的等式，我们得到了贝叶斯定理的新公式，

P(A | B)= P(B | A)*P(A)/(P(B | A)* P(A)+P(B |非 A)* P(非 A))

# 使用示例实现朴素贝叶斯:

![](img/734af12e41b10f2b0b891df11c4df7d7.png)

Train set

*   在我们的响应变量中找到不同的类/组。在我们的例子中，响应变量是“流感？”它分为两类:“是”和“否”。
*   对于每个预测变量，我们确定其不同类型的值。例如，对于“发冷”、“发烧”和“流鼻涕”列，它们具有类型值:“是”和“否”；对于“头痛”一栏，它有“轻微”、“没有”和“强烈”。
*   对于特定预测中的每种类型的值，我们找出它们被分类到某一类响应变量中的“可能性”。举个例子，

> 如果某人患了流感，那么他出现轻微头痛或 P(headerships = " mineral " | flu = " yes ")的可能性有多大？
> 
> 具有(头痛=“轻微”)的行的总数是 3。在这三行中，我们看到其中的 2 行被归类为“流感？”中的“是”类专栏。
> 
> 因此，P(头痛=“轻微”)|流感=“是”)= 2/3

类似地，我们计算其他的如下:

## **假设流感=“是”(可能性):**

*   *P(头痛= "轻微" |流感= "是")= 2/3，*
*   *P(头痛= "否" |流感= "是")= 1/2*
*   P(头痛= "强烈" |流感= "是")=2/3
*   *P(chills = " yes " | flu = " yes ")= 3/4，P(chills = " no " | flu = " yes ")= 2/4*
*   *P(流鼻涕=“是”|flu =“是”)= 4/5，P(流鼻涕=“否”|flu =“是”)= 1/3*
*   *P(fever = " yes " | flu = " yes ")= 4/5，P(fever = " no " | flu = " yes ")= 1/3*

## **鉴于流感= "否"**(可能性) **:**

*   *P(头痛= "轻微" |流感= "否")* *= 1/3*
*   *P(头痛= "否" |流感= "否")* *= 1/2*
*   P(头痛= "强烈" |流感= "否")=1/3
*   *P(chills = " yes " | flu = " no ")= 1/4*和*P(chills = " no " | flu = " no ")**= 2/4*
*   *P(流鼻涕= "是" |流感= "否")= 1/5* 和 *P(流鼻涕= "否" |流感= "否")= 2/3*
*   *P(fever = " yes " | flu = " no ")= 1/5*和*P(fever = " no " | flu = " no ")= 2/3*

## 其他概率:

*   *P(flu = "yes") = 5/8* 和 *P(flu = "no") = 3/8*
*   *P(冷激=“是”)= 4/8* 和 *P(冷激=“否”)= 4/8*
*   *P(头痛=“轻度”)= 3/8*； *P(头痛= "强")= 3/8* 和 *P(头痛= "否")= 2/8*
*   *P(流鼻涕=“是”)= 5/8* 和 *P(流鼻涕=“否”)= 3/8*
*   *P(发烧=“是”)= 5/8* 和 *P(发烧=“否”)= 3/8*

## 示例:使用贝叶斯定理找出流鼻涕时患流感的可能性(后)

*   P(flu = " yes " | runny nose = " yes ")=

P(流鼻涕:“是”)|flu= "是)*P(流感:“是”)/P(流鼻涕:“是”)

= ((4/5)*(5/8))/(5/8)=4/5

## 现在，我们将预测在给定的条件下我们是否会患流感

![](img/8d82355fbcd347eaa209bb137a59eff5.png)

Test case

设上述条件为 x，我们需要计算:

*   P(flu = " yes " | X)= P(X | flu = " yes ")* P(flu = " yes ")/P(X)
*   P(flu = " no " | X)= P(X | flu = " no ")* P(flu = " no ")/P(X)

因为 P(X)很常见，所以忽略它。

**通过乘以下面给出的值计算 P(flu = " yes " | X)= 5/8 *(3/4 * 1/3 * 2/3 * 1/3)= 0.0347:**

*   P(flu = "yes") = 5/8
*   P(chills = " yes " | flu = " yes ")= 3/4
*   *P(流鼻涕= "no"|flu = "yes") = 1/3*
*   *P(头痛= "轻微" |流感= "是")= 2/3*
*   *P(发烧= "否" |流感= "是")= 1/3*

> 上述值是使用下面的公式计算的:
> 
> P(X₁、X₂、X₃,…Xₙ|“是”)= p(x₁|"yes")*p(x₂|"yes")*p(x₃|"yes")….*P(Xₙ|"yes”)

类似地，我们计算流感=“否”，

计算 P(flu = " no " | X)=(3/8)*(1/4)*(2/3)*(1/3)*(2/3)= 0.0138

*   P(flu = "no") = 3/8
*   *P(chills = " yes " | flu = " no ")= 1/4*
*   *P(流鼻涕= "no"|flu = "no") = 2/3*
*   *P(头痛= "轻微" |flu = "否")* *= 1/3*
*   *P(fever = " no " | flu = " no ")= 2/3*

> 由于 P(X|flu= "no") < P(X|flu= "yes ")，在给定的一组条件下，一个人极有可能会患流感。

哦，那有很多计算。

# 高斯朴素贝叶斯

我们为寻找条件概率所做的所有计算都是针对分类数据的。由于显而易见的原因，上述内容不适用于连续值。这就是我们引入高斯朴素贝叶斯的地方。

如果我们想计算给定条件 y =c 的点的可能性:

*   首先找出满足 y=c 的行
*   对于给定的一组行，计算每个特征或列的平均值和标准差。
*   对于这组行中的每个数据点，将 x 值(即该数据点的特征值)、该列的平均值和标准偏差代入下面给出的表达式中。

![](img/5fcac7e0cf49014b5af50f4737fcd282.png)

Source: [www.machinelearningplus.com](http://www.machinelearningplus.com)

*   然后将每一列的这些值相乘，通过应用 P(X|Y=c) = P(X₁，X₂，x₃,…xₙ| y = c)= p(x₁|y = c)*p(x₂|y = c)*p(x₃|y = c)找出该数据点的可能性。*P(Xₙ|Y = c)

其中，X={X₁、X₂、X₃,…Xₙ}是特征/自变量。

# 在企鹅数据集上的实现

*   导入 numpy、math 和 seaborn 库。
*   我已经使用 seaborn.load_dataset(“企鹅”)加载了数据集“企鹅”。
*   对于这个数据集，我们的响应变量是“物种”,其余的列是特征值。

在数据集上实现朴素贝叶斯之前，我检查了空值:

![](img/dd9c4424ed48e6d5f52ebec5d2fd41cd.png)

一些行有 5 个值为空，一些行只有“性别”列下的值为空。

*   首先，我找出了“性别”列中的模式值，并用该值替换该列中的空值。在我的例子中，mode 是“男性”。
*   如果一些行仍然有空值，那么我就删除它。

![](img/8a8d886a9fb648c0c7f43174713ee969.png)

cnt stores the mode of a column and fillna(cnt) fills the null values.

在将数据集转换为 numpy 数组后，我将数据集以 80:20 的比例划分为训练和测试数据集(我只是觉得这样更容易处理) :

![](img/c7e6f576dfaef6ec84a4487e4c9c6d75.png)

# 这些功能

我们发现连续数据的均值、标准差和分类数据的似然性。然后将这些值用于测试数据，以找到预测值。

## stats_by_class(x，y):

将数据集除以响应变量的类类型，然后返回连续数据的平均值、标准差，并计算分类数据的对数似然。

自变量:x_train 集合和 y_train 集合。

*   它首先为我们的响应变量找出所有唯一的类类型。
*   用 y = <class_name>的所有行初始化每个类类型的字典“组”。</class_name>
*   “stats”存储每个类的平均值和标准偏差(每列都有)、列索引(标识具有连续值的列)和行数。
*   “category_prob”存储包含分类数据的列的对数可能性。

![](img/e7d5f2b771761d30938a736fea1bfadf.png)

## find_stats(x):

参数:x 是数据集，其对应的响应变量属于特定的类类型。

它检查每一列是否包含字符串类的数据。如果它不是字符串类型，那么我们找到均值和标准差。

![](img/d48d74a0502f454041273a77b6027b43.png)

## gaussian_prob(x_i，均值，标准差):

使用高斯分布表达式计算 x_i 的概率，其中，x_i 等于 x[row][column]，平均值和标准偏差是针对该特定列传递的。

![](img/95500e6932ced06b06a12ab3ac601242.png)

## find_category_prob(x，y，cls):

辩君:这里 cls 是类类型。

给定响应变量的分类类型，找出所有预测值的对数似然。

同样，我们检查列的数据类型，如果它包含 string 类的数据，我们会发现:

*   该列中的唯一类型。
*   在 y_train[row] = cls 的那一列中查找每种类型的行
*   将上述计数除以该列中该类型的总计数。
*   然后找到它的日志并将其存储在概率字典中，其中键值是列索引。

![](img/8d38eae91a325ad77628651efe61c5f8.png)

## find_prob_for_class(stats，test_row，category_prob=None):

此函数查找 P(Y=cls|X)的后验值，其中 X 是我们的测试行呈现的条件集。

我们调用 gaussian_prob()来查找连续列的似然性，并找到它的对数值。我们将所有这些对数值与由 category_prob 字典提供的对数似然值和我们的类概率的对数值相加。

![](img/8ea19f712b71a3896d590a1488c08465.png)

stats[class][0] contains mean for each column, stats[class][1] contains standard deviation for each column, stats[class][2] has column indices, stats[class][3] has number of rows for that class.

我们通过将数据集中的 stats[cls][3]除以 total_rows 来找到该类的概率。

![](img/080216952e6e552f0ae7dc19feee0335.png)

## predict(stats，test_row，category_prob=None):

它从 find_prob_for_class()函数中获取后验概率的对数值，并返回具有最大后验概率值的类。

![](img/7ebea766b4dc337761ef220ca735625a.png)

无论如何，这结束了我们的博客。我希望它能让你对这个话题有一点了解。感谢您花时间阅读这篇文章！！！

祝你愉快😄！！！

附注:我洗耳恭听所有的更正和建议。如果我做错了什么，请随时指出，并告诉我如何做得更好。