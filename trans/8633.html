<html>
<head>
<title>Load in Image Classification Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">载入影像分类数据</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/load-in-image-classification-data-e2dfec6dfcb6?source=collection_archive---------1-----------------------#2021-01-17">https://medium.datadriveninvestor.com/load-in-image-classification-data-e2dfec6dfcb6?source=collection_archive---------1-----------------------#2021-01-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="bf2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">一个技术博客</em></p><p id="1841" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在谷歌上搜索了图像分类数据。我看到一个文件，里面有建筑、森林、冰川、山脉、海洋和街道的图片。如果您点击下面的链接，您会看到我使用了第6号，英特尔图像分类。</p><div class="km kn gp gr ko kp"><a href="https://lionbridge.ai/datasets/top-10-image-classification-datasets-for-machine-learning/" rel="noopener  ugc nofollow" target="_blank"><div class="kq ab fo"><div class="kr ab ks cl cj kt"><h2 class="bd ir gy z fp ku fr fs kv fu fw ip bi translated">机器学习的10大图像分类数据集| Lionbridge AI</h2><div class="kw l"><h3 class="bd b gy z fp ku fr fs kv fu fw dk translated">为了帮助您构建对象识别模型、场景识别模型等，我们编制了一份最佳…</h3></div><div class="kx l"><p class="bd b dl z fp ku fr fs kv fu fw dk translated">lionbridge.ai</p></div></div><div class="ky l"><div class="kz l la lb lc ky ld le kp"/></div></div></a></div><p id="7f07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我下载了之前的文件并解压。然后我愣住了，我意识到我不知道如何在Python中加载图像数据集。我已经习惯了将csv文件导入熊猫数据框架，但是加载图像是不同的！所以我在YouTube上快速搜索了一下，想知道我应该怎么做。我在下面附上了我跟随的YouTube教程。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="4b32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">流程</strong></p><p id="5693" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先导入必要的包。导入NumPy是因为我们将使用多维数组对象。导入Matplotlib用于绘图。操作系统模块已导入，因此您计算机上的文件可以轻松读取和加载。最后，cv2是一个用于解决计算机视觉问题的python库。要安装cv2，进入<em class="kl"> pip安装opencv-python </em>到你的终端。同时输入<em class="kl"> pip install keras。</em> Keras是一个用于神经网络的API。</p><pre class="lf lg lh li gt lm ln lo lp aw lq bi"><span id="43db" class="lr ls iq ln b gy lt lu l lv lw">import numpy as np<br/>import matplotlib.pyplot as plt<br/>import os<br/>import cv2</span></pre><p id="af5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，DATADIR是分配给包含训练数据的文件路径的字符串。我决定只处理两个数据集，冰川和山脉图片。基于上述类别，类别被分成一个列表。</p><pre class="lf lg lh li gt lm ln lo lp aw lq bi"><span id="a9c0" class="lr ls iq ln b gy lt lu l lv lw">DATADIR = "insert_file_path_here/archive/seg_train/seg_train"<br/>CATEGORIES = ['glacier', 'mountain']</span></pre><p id="284f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来创建一个循环来访问这两个类别的图像。os.path.join方法连接路径，因此训练数据(DATADIR)的文件路径与glacier and mountains文件夹(category)连接。</p><pre class="lf lg lh li gt lm ln lo lp aw lq bi"><span id="d614" class="lr ls iq ln b gy lt lu l lv lw">for category in CATEGORIES:<br/>    path = os.path.join(DATADIR, category) </span></pre><p id="43d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个for循环遍历文件路径中的所有图像。listdir()将返回一个文件名列表。cv2.imread()从联合文件路径(训练路径和类别)加载图像。中断被插入，所以只打印一个图像。</p><pre class="lf lg lh li gt lm ln lo lp aw lq bi"><span id="fe6a" class="lr ls iq ln b gy lt lu l lv lw">for category in CATEGORIES:<br/>    path = os.path.join(DATADIR, category)<br/>    for img in os.listdir(path):<br/>        img_array = cv2.imread(os.path.join(path,img))<br/>        plt.imshow(img_array)<br/>        plt.show()<br/>        break<br/>     break</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/e84ac6a13ebed448f29a05e491f79cab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*FM7JUZoF0YGn6bHglOsEFQ.png"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">The break is used to stop the loop after the first image is outputted. Here is the first image.</figcaption></figure><p id="2081" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要显示一张照片的数据，需要打印图像数组。这三列代表蓝色、绿色和红色。</p><pre class="lf lg lh li gt lm ln lo lp aw lq bi"><span id="1d4d" class="lr ls iq ln b gy lt lu l lv lw">print(img_array)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi md"><img src="../Images/b44e977dac4a6fc0d84a37d26a977efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X5b_3aIbH5I-JStBDNkCFQ.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Blue Green Red</figcaption></figure><pre class="lf lg lh li gt lm ln lo lp aw lq bi"><span id="3734" class="lr ls iq ln b gy lt lu l lv lw">print(img_array.shape)</span></pre><p id="3ab2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图像的形状是(150，150，3)。这个特殊的图像是相同的形状，但在图像形状改变的情况下，我已经加入了程序，以确保图像大小保持不变。</p><p id="f46b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">IMG大小控制图像的质量。数字越低，质量越差。例如，10将使图像看起来像一堆像素。</p><pre class="lf lg lh li gt lm ln lo lp aw lq bi"><span id="1908" class="lr ls iq ln b gy lt lu l lv lw">IMG_SIZE = 100</span></pre><p id="5214" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">cv.resize()将调整图像数组的大小，plt.imshow(new_array)将显示新数组</p><pre class="lf lg lh li gt lm ln lo lp aw lq bi"><span id="871c" class="lr ls iq ln b gy lt lu l lv lw">new_array = cv2.resize(img_array, (IMG_SIZE, IMG_SIZE))<br/>plt.imshow(new_array)<br/>plt.show()</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/5bef792e62fcf937f37875a62e1627ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*uJZw4mwqo-MK6WUsM9LqUg.png"/></div></figure><p id="4a7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来创建一个训练数据集。索引循环将用于将照片与类别冰川或山脉进行匹配。如前所述，下一个for循环遍历文件路径中的图像。listdir()将返回一个图像列表。cv2.imread()从联合文件路径加载图像。创建一个新数组来调整新图像的大小。所有这些都被追加到训练数据的列表中，因为append方法只接受一个参数，而列表允许我们保存两个参数。</p><pre class="lf lg lh li gt lm ln lo lp aw lq bi"><span id="eb69" class="lr ls iq ln b gy lt lu l lv lw">training_data = []</span><span id="2cf1" class="lr ls iq ln b gy mj lu l lv lw">def create_training_data():<br/>    for i in range(len(CATEGORIES)):<br/>        category = CATEGORIES[i]<br/>        path = os.path.join(DATADIR, category)<br/>        for img in os.listdir(path):<br/>            img_array = cv2.imread(os.path.join(path,img))<br/>            new_array = cv2.resize(img_array, (IMG_SIZE, IMG_SIZE))<br/>            training_data.append([new_array, i])</span></pre><p id="c4f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要查找训练数据的长度，请打印该长度。</p><pre class="lf lg lh li gt lm ln lo lp aw lq bi"><span id="2f72" class="lr ls iq ln b gy lt lu l lv lw">print(len(training_data))</span></pre><p id="e457" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">长度为4916。有4916张冰川和山脉的图片。</p><p id="57e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们数一数有多少照片是冰川，有多少是山脉，以确保山脉和冰川之间有一个平均的分界线。</p><pre class="lf lg lh li gt lm ln lo lp aw lq bi"><span id="cd45" class="lr ls iq ln b gy lt lu l lv lw">count_glaciers = 0<br/>count_mountains = 0 <br/>for image in training_data:<br/>    if image[1] == 0:<br/>        count_glacier += 1<br/>    else:<br/>         count_mountains +=1<br/>print('Glaciers:', count_glaciers, 'Mountains:', count_mountains)</span></pre><p id="0931" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">冰川图片2404张，山地图片2512张；相当平均的分配。将来，可以给模型赋予权重以更精确地平衡数据集。</p><p id="f972" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，数据被随机打乱以进行预测。</p><pre class="lf lg lh li gt lm ln lo lp aw lq bi"><span id="3dbf" class="lr ls iq ln b gy lt lu l lv lw">import random</span><span id="778b" class="lr ls iq ln b gy mj lu l lv lw">random.shuffle(training_data)</span></pre><p id="ca3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打印出随机洗牌的前10个。样本[0]是实际的图像数组，样本[1]是类别。</p><pre class="lf lg lh li gt lm ln lo lp aw lq bi"><span id="f491" class="lr ls iq ln b gy lt lu l lv lw">for sample in training_data[:10]:<br/>    print(sample[1])</span></pre><p id="e2fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">混洗后的数据将被分类到X(特征)和y(标签)中。列表不能传递给神经网络，因此X必须转换为numpy数组。np.array(X)需要整形。整形括号中的-1表示任意数量/种类的要素。IMG尺寸代表图像尺寸，数字3代表彩色图像，数字1代表灰度图像。将X写成一个numpy数组并对其进行整形只是keras让我们做的事情。</p><pre class="lf lg lh li gt lm ln lo lp aw lq bi"><span id="ed37" class="lr ls iq ln b gy lt lu l lv lw">X = []<br/>y = []</span><span id="4862" class="lr ls iq ln b gy mj lu l lv lw">for features, label in training_data:<br/>    X.append(features)<br/>    y.append(label)</span><span id="d274" class="lr ls iq ln b gy mj lu l lv lw">X = np.array(X).reshape(-1, IMG_SIZE, IMG_SIZE, 3)</span></pre><p id="6e4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一次导入pickle，这样您就不必每次都重新生成数据。加载和构建训练数据需要花费大量时间。腌制会让你更有效地利用你的时间。Pickle会保存我们的数据。为X和y创建Pickle out。</p><pre class="lf lg lh li gt lm ln lo lp aw lq bi"><span id="c251" class="lr ls iq ln b gy lt lu l lv lw">import pickle</span><span id="2e4b" class="lr ls iq ln b gy mj lu l lv lw">pickle_out = open('X.pickle', 'wb')<br/>pickle.dump(X, pickle.out)<br/>pickle_out.close()</span><span id="0d8d" class="lr ls iq ln b gy mj lu l lv lw">pickle_out = open('y.pickle', 'wb')<br/>pickle.dump(y, pickle_out)<br/>pickle_out.close()</span></pre><p id="98e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用pickle_in重新插入我们的pickle文件。</p><pre class="lf lg lh li gt lm ln lo lp aw lq bi"><span id="74f5" class="lr ls iq ln b gy lt lu l lv lw">pickle_in = open('X.pickle', 'rb')<br/>X = pickle.load(pickle_in)</span></pre><h1 id="e500" class="mk ls iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated"><strong class="ak">建模</strong></h1><p id="b993" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated">在终端中写下<em class="kl"> pip安装张量流-集线器</em>和<em class="kl"> pip安装张量流</em>。</p><pre class="lf lg lh li gt lm ln lo lp aw lq bi"><span id="724b" class="lr ls iq ln b gy lt lu l lv lw">import tensorflow as tf<br/>from keras.models import Sequential<br/>from keras.layers import Dense, Dropout, Activation, Flatten, Conv2D, MaxPooling2D<br/>import pickle</span></pre><p id="d096" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在加载之前的数据之后。</p><pre class="lf lg lh li gt lm ln lo lp aw lq bi"><span id="391b" class="lr ls iq ln b gy lt lu l lv lw">X = pickle.load(open('X.pickle', 'rb'))<br/>y = pickle.load(open('y.pickle', 'rb'))</span></pre><p id="3179" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后</p><pre class="lf lg lh li gt lm ln lo lp aw lq bi"><span id="4970" class="lr ls iq ln b gy lt lu l lv lw">y = np.array(y)<br/>X = X/225.0</span><span id="dc54" class="lr ls iq ln b gy mj lu l lv lw">model = Sequential()<br/>model.add(Conv2D(64, (3,3), input_shape = X.shape[1:]))<br/>model.add(Activation("relu")) <br/>model.add(MaxPooling2D(pool_size=(2,2)))</span><span id="ae43" class="lr ls iq ln b gy mj lu l lv lw">model.add(Conv2D(64, (3,3)))<br/>model.add(Activation("relu")) #rectified linear<br/>model.add(MaxPooling2D(pool_size=(2,2)))</span><span id="2392" class="lr ls iq ln b gy mj lu l lv lw">model.add(Flatten())<br/>model.add(Dense(64))</span><span id="9ebf" class="lr ls iq ln b gy mj lu l lv lw">model.add(Dense(1))<br/>model.add(Activation('sigmoid'))</span><span id="c789" class="lr ls iq ln b gy mj lu l lv lw">model.compile(loss='binary_crossentropy',<br/>                optimizer="adam",<br/>                metrics=['accuracy'])</span><span id="8407" class="lr ls iq ln b gy mj lu l lv lw">model.fit(X, y, batch_size=32, epochs=3, validation_split=0.2)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nm"><img src="../Images/eb0abcba236b16f1017e647986bbca02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0kVOeRjpO2m5nkg0gcLYTQ.png"/></div></div></figure></div></div>    
</body>
</html>