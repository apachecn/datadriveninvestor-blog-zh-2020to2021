<html>
<head>
<title>Edge Detection in Computer Vision</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机视觉中的边缘检测</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/edge-detection-in-computer-vision-6c2c25100bca?source=collection_archive---------4-----------------------#2021-02-03">https://medium.datadriveninvestor.com/edge-detection-in-computer-vision-6c2c25100bca?source=collection_archive---------4-----------------------#2021-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/251c1e66aa50cfa483c870f32e161437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZrmN-WHSJloWr8Hm6RQoQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">credits <a class="ae kc" href="https://unsplash.com/photos/fVzz6Fy4SbU" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6570" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">边缘检测是计算机视觉中一项基本但重要的任务。这样做通常是为了减少数据量，同时保留图像中对象的结构属性。使用边缘检测的常见任务是车道检测和将图像转换为草图。</p><p id="5bac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然边缘检测的算法很多，但是今天我们要讨论的是<strong class="kf ir"> Canny边缘检测算法</strong>(John f . Canny于1986年提出)。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="13d7" class="lk ll iq lg b gy lm ln l lo lp">import numpy as np<br/>import cv2<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span></pre><p id="dc81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lq">它是一个多阶段算法:</em></p><h1 id="2c58" class="lr ll iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">步骤1:使用高斯模糊降低噪声:</h1><p id="87ba" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">高斯滤波器在图像上进行卷积，以去除噪声并防止将噪声假设为边缘。像素强度的突然变化不应被视为边缘，因此首先对输入图像进行平滑处理是至关重要的。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c1a5" class="lk ll iq lg b gy lm ln l lo lp">A typical Gaussian filter: <br/>          [[2,  4,   5,  4,  2],<br/>          [ 4,  9,  12,  9,  4],<br/>(1 / 159)*[ 5, 12,  15, 12,  5],<br/>          [ 4,  9,  12,  9,  4],<br/>          [ 2,  4,   5,  4,  2]]</span></pre><h2 id="103c" class="lk ll iq bd ls mt mu dn lw mv mw dp ma ko mx my me ks mz na mi kw nb nc mm nd bi translated">展示如何在图像上使用高斯模糊的示例</h2><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="d942" class="lk ll iq lg b gy lm ln l lo lp"># input image<br/>img = cv2.imread("plant2.jpg", 0)</span><span id="e586" class="lk ll iq lg b gy ne ln l lo lp"># gaussian smoothing<br/>blurred=cv2.GaussianBlur(img,(5, 5),1.4) </span><span id="0e75" class="lk ll iq lg b gy ne ln l lo lp">f,(ax1, ax2) = plt.subplots(1,2)<br/>ax1.imshow(img,cmap='gray')<br/>ax1.title.set_text("Original image")<br/>ax2.imshow(blurred,cmap='gray')<br/>ax2.title.set_text("after Gaussian blur")</span></pre><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/496e3b467cf6049ae2558c42960e2caf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TW0uAtn2CbNw7Sf0RlWijw.png"/></div></div></figure><h1 id="d09d" class="lr ll iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">第二步:寻找渐变:</h1><p id="8640" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">渐变只不过是图像像素强度的变化。图像平滑后，使用Sobel算子计算沿x和y方向的梯度。然后，通过应用毕达哥拉斯定律，可以将梯度幅度(也称为边缘强度)确定为欧几里德距离度量。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="fc1b" class="lk ll iq lg b gy lm ln l lo lp">The Sobel kernels are convolved <br/>over the image to determine <br/>gradient magnitudes.</span><span id="95fe" class="lk ll iq lg b gy ne ln l lo lp">Along X direction Kx:  <br/>            [[-1, 0, 1],<br/>            [-2, 0, 2],<br/>            [-1, 0, 1]]<br/> </span><span id="11a1" class="lk ll iq lg b gy ne ln l lo lp">Along Y direction Ky:  <br/>            [[1, 2, 1],<br/>            [0, 0, 0],<br/>            [-1,-2,-1]]</span><span id="8b8b" class="lk ll iq lg b gy ne ln l lo lp">gradient magnitude = sqrt(Gx^2 + Gy^2)<br/>angle = arctan(|Gy| / |Gx|)</span></pre><h2 id="afb4" class="lk ll iq bd ls mt mu dn lw mv mw dp ma ko mx my me ks mz na mi kw nb nc mm nd bi translated">演示如何使用Sobel算子查找梯度的示例</h2><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="2431" class="lk ll iq lg b gy lm ln l lo lp"># input image<br/>img = cv2.imread("plant2.jpg", 0)</span><span id="31bb" class="lk ll iq lg b gy ne ln l lo lp">sobelx = cv2.Sobel(img,cv2.CV_64F,1,0,ksize=5)<br/>sobely = cv2.Sobel(img,cv2.CV_64F,0,1,ksize=5)</span><span id="b4da" class="lk ll iq lg b gy ne ln l lo lp">f, (ax1,ax2,ax3) = plt.subplots(1,3)<br/>ax1.imshow(img, cmap='gray')<br/>ax1.title.set_text("Original image")<br/>ax2.imshow(sobelx, cmap='gray')<br/>ax2.title.set_text("Sobel along X axis")<br/>ax3.imshow(sobely, cmap='gray')<br/>ax3.title.set_text("Sobel along Y axis")</span></pre><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a771d2e72b737c496485b35e648eedbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GQaz6iEYSwuD6KDvq08eGg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Sobel-operator along X and Y axis</figcaption></figure><h1 id="fa6f" class="lr ll iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">步骤3:非最大抑制:</h1><p id="05b0" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">应用非最大抑制来寻找强度值变化最剧烈的位置。梯度图像中每个像素的算法是:</p><ol class=""><li id="b544" class="ng nh iq kf b kg kh kk kl ko ni ks nj kw nk la nl nm nn no bi translated">将梯度方向θ四舍五入到最近的45度，对应于使用8-连通邻域。</li><li id="5a0b" class="ng nh iq kf b kg np kk nq ko nr ks ns kw nt la nl nm nn no bi translated">将当前像素的边缘强度与该像素在正负梯度方向上的边缘强度进行比较。</li><li id="dce3" class="ng nh iq kf b kg np kk nq ko nr ks ns kw nt la nl nm nn no bi translated">如果当前像素的边缘强度与掩模中具有相同方向的其他像素相比是最大的(例如，指向y方向的像素将与垂直轴上其上方和下方的像素进行比较)，则该值将被保留。否则，该值将被抑制。</li></ol><h1 id="7bc1" class="lr ll iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">第四步:双阈值</h1><p id="fdee" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">在非最大值抑制步骤之后剩余的边缘像素被(仍然)逐个像素地标记其强度。这些边缘中的许多可能是图像中的真实边缘，但一些可能是由噪声或颜色变化引起的，例如由于粗糙的表面。辨别它们的最简单的方法是使用阈值，以便只保留比某个值更强的边缘。Canny边缘检测算法使用双阈值。比高阈值强的边缘像素被标记为强；比低阈值弱的边缘像素被抑制，两个阈值之间的边缘像素被标记为弱</p><h1 id="58db" class="lr ll iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">步骤5:通过滞后进行边缘跟踪</h1><p id="9d50" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">这个阶段决定了哪些是真正的边，哪些不是。为此，我们需要两个阈值，minVal和maxVal。任何强度梯度大于maxVal的边缘肯定是边缘，而小于minVal的边缘肯定是非边缘，因此被丢弃。位于这两个阈值之间的那些根据它们的连通性被分类为边缘或非边缘。如果它们连接到“确定边缘”像素，它们被认为是边缘的一部分。否则，它们也会被丢弃。</p><blockquote class="nu nv nw"><p id="a70a" class="kd ke lq kf b kg kh ki kj kk kl km kn nx kp kq kr ny kt ku kv nz kx ky kz la ij bi translated"><em class="iq"> openCV有一个很好的实现</em> <strong class="kf ir"> <em class="iq"> cv2。Canny() </em> </strong> <em class="iq">将所有这些步骤包装成一个函数。</em></p></blockquote><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="21af" class="lk ll iq lg b gy lm ln l lo lp">img = cv2.imread("noctua.jpg", 0)<br/># detect edges <br/>canny = cv2.Canny(img,30,100)</span><span id="ef4c" class="lk ll iq lg b gy ne ln l lo lp">f, (ax1, ax2) = plt.subplots(1,2)<br/>ax1.imshow(img, cmap='gray')<br/>ax1.title.set_text("Original image")<br/>ax2.imshow(canny, cmap='gray')<br/>ax2.title.set_text("Edges detected")</span></pre><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b36392b3f0a87c0cd84a0a115abd96b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hga1Iov4ZctL7aBo7qcXqA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">noctua NH-D15 from my Deep Learning rig</figcaption></figure><h1 id="1fc5" class="lr ll iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">参考资料:</h1><ul class=""><li id="149e" class="ng nh iq kf b kg mo kk mp ko oa ks ob kw oc la od nm nn no bi translated"><a class="ae kc" href="https://en.wikipedia.org/wiki/Canny_edge_detector" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Canny_edge_detector</a></li><li id="e504" class="ng nh iq kf b kg np kk nq ko nr ks ns kw nt la od nm nn no bi translated"><a class="ae kc" href="https://www.cse.iitd.ac.in/~pkalra/col783-2017/canny.pdf" rel="noopener ugc nofollow" target="_blank">https://www.cse.iitd.ac.in/~pkalra/col783-2017/canny.pdf</a></li><li id="2e5d" class="ng nh iq kf b kg np kk nq ko nr ks ns kw nt la od nm nn no bi translated"><a class="ae kc" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html" rel="noopener ugc nofollow" target="_blank">https://opencv-python-tutro als . readthedocs . io/en/latest/py _ tutorials/py _ imgproc/py _ canny/py _ canny . html</a></li><li id="8454" class="ng nh iq kf b kg np kk nq ko nr ks ns kw nt la od nm nn no bi translated"><a class="ae kc" href="https://www.geeksforgeeks.org/implement-canny-edge-detector-in-python-using-opencv/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/implement-canny-edge-detector-in-python-using-opencv/</a></li><li id="13c6" class="ng nh iq kf b kg np kk nq ko nr ks ns kw nt la od nm nn no bi translated"><a class="ae kc" href="https://www.tutorialspoint.com/opencv/opencv_canny_edge_detection.htm" rel="noopener ugc nofollow" target="_blank">https://www . tutorialspoint . com/opencv/opencv _ canny _ edge _ detection . htm</a></li></ul><p id="32d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在github页面<a class="ae kc" href="https://rahulbakshee.github.io/iWriteHere/" rel="noopener ugc nofollow" target="_blank"> iWriteHere </a>上阅读我的其他故事，或者在<a class="ae kc" href="https://twitter.com/rahulbakshee" rel="noopener ugc nofollow" target="_blank"> twitter </a>和<a class="ae kc" href="https://www.linkedin.com/in/rahulbakshee/" rel="noopener ugc nofollow" target="_blank"> linkedin </a>上与我联系</p></div></div>    
</body>
</html>