<html>
<head>
<title>Algorithms: Validating Parentheses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法:验证括号</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/algorithms-validating-parentheses-e8c8749e6e67?source=collection_archive---------5-----------------------#2020-02-11">https://medium.datadriveninvestor.com/algorithms-validating-parentheses-e8c8749e6e67?source=collection_archive---------5-----------------------#2020-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ff82" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">查看有效括号算法挑战的两个不同版本</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7366665c63f91a649efe403bead587bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Dw5HfFBFCHnhrWK3.jpg"/></div></div></figure><p id="773b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我完全诚实的话，作为一名开发人员最好的部分之一就是有机会解决代码挑战。他们玩起来很有趣，但除非你熟悉挑战的语言，否则你可能会迷失方向。如果你喜欢数独或类似的逻辑游戏，我肯定你会同意。最棒的是没有唯一正确的答案！正确答案可以有多种变化！关键是让你的回答更快更有效率，还有赏心悦目！这使得解决这些代码挑战更加令人兴奋！</p><p id="1180" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更重要的是，作为一名开发人员，你可能会在工作面试中被要求解决代码挑战。既然如此，练习你的算法也同样重要。网络上的挑战数不胜数，你永远不知道哪一个会被你的面试选中，即使你最终遇到了一个你从未见过的挑战，你也会知道如何去解决它。</p><div class="ln lo gp gr lp lq"><a href="https://www.datadriveninvestor.com/2019/03/22/the-seductive-business-logic-of-algorithms/" rel="noopener  ugc nofollow" target="_blank"><div class="lr ab fo"><div class="ls ab lt cl cj lu"><h2 class="bd ir gy z fp lv fr fs lw fu fw ip bi translated">算法诱人的商业逻辑|数据驱动的投资者</h2><div class="lx l"><h3 class="bd b gy z fp lv fr fs lw fu fw dk translated">某些机器行为总是让我感到惊讶。我对他们从自己的成就中学习的能力感到惊讶…</h3></div><div class="ly l"><p class="bd b dl z fp lv fr fs lw fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="lz l"><div class="ma l mb mc md lz me kp lq"/></div></div></a></div><p id="655f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇博客中，我将回顾一下如何解决与圆括号相关的代码挑战的思考过程，对于圆括号，我已经看到了两种不同的变体。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="55d2" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">变体1</h1><p id="b8b3" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated"><em class="nj">写一个函数，接受一串括号，并确定括号的顺序是否有效。</em></p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="5e9f" class="np mn iq nl b gy nq nr l ns nt">//Examples:</span><span id="abed" class="np mn iq nl b gy nu nr l ns nt">"()"              =&gt;  true <br/>")(()))"          =&gt;  false <br/>"("               =&gt;  false <br/>"(())((()())())"  =&gt;  true</span></pre><p id="7440" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种挑战总是伴随着一个例子来帮助我们想象我们的解决方案应该能够做什么，这很好。</p><p id="93e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于上面的挑战，我首先必须考虑是什么使括号有效。</p><p id="c608" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nv nw nx nl b">()</code>有效。左圆括号<code class="fe nv nw nx nl b">(</code>必须用右圆括号<code class="fe nv nw nx nl b">)</code>正确闭合。</p><p id="4328" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">换句话说，只要每一个<code class="fe nv nw nx nl b">(</code>都有一个相应的<code class="fe nv nw nx nl b">)</code>来关闭它，这对就有效。</p><p id="8466" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当括号字符串变得太长时，很难看出这一点。</p><p id="700b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我首先想到的是创建一个从字符串中删除所有有效对的函数。这是一个函数，它基本上会收缩我的输入字符串，直到只剩下无效的字符串对。如果字符串以空结束，我知道原来的字符串是有效的。</p><p id="2ccc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是我该如何着手做这件事呢？</p><p id="c0b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我从我熟悉的东西开始:操纵数组。</p><p id="a756" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将字符串输入转换成一个字符串数组。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="a0a9" class="np mn iq nl b gy nq nr l ns nt">function validParentheses(parens) {<br/>  let parenths = parens.split('')<br/>}</span></pre><p id="89bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我需要编写一个方法来遍历这个数组，只删除有效的数组对，并在这样做的时候折叠原始数组。</p><p id="f7a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了控制这个循环只在有效对存在时运行，我设置了一个条件:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="d747" class="np mn iq nl b gy nq nr l ns nt">function validParentheses(parens) {<br/>  let parenths = parens.split('')<br/>  while (parenths.join('').includes('()')) {</span><span id="fee5" class="np mn iq nl b gy nu nr l ns nt">  }<br/>}</span></pre><p id="8062" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，一旦我的数组不再有有效的对，我的循环就会停止。</p><p id="c143" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我需要编写一个循环来删除有效的线对。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="f03b" class="np mn iq nl b gy nq nr l ns nt">function validParentheses(parens) {<br/>  let parenths = parens.split('')<br/>  while (parenths.join('').includes('()')) {<br/>    for (let i = 0; i &lt; parenths.length - 1; i++) {       <br/>      if (parenths[i].concat(parenths[i + 1]) == '()') { <br/>        parenths.splice(i, 2)         <br/>        i -= 1       <br/>      }     <br/>    }<br/>  }<br/>}</span></pre><p id="766f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望我写的<code class="fe nv nw nx nl b">for loop</code>所代表的数组能够改变。这就是为什么每次我找到一个有效的对并修改我的数组时，我都要后退一次，以免错过任何东西。</p><p id="0a21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的数组由单个圆括号组成。我测试当前的括号加上下一个括号是否等同于<code class="fe nv nw nx nl b">()</code>，如果等同，则删除两个括号。</p><p id="09eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样下去，阵列会崩溃。<code class="fe nv nw nx nl b">'(())’</code>会变成<code class="fe nv nw nx nl b">'()’</code>，然后变成<code class="fe nv nw nx nl b">''</code>。</p><p id="c1e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我需要根据新数组的长度设置返回<code class="fe nv nw nx nl b">true</code>或<code class="fe nv nw nx nl b">false</code>的条件。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="a03d" class="np mn iq nl b gy nq nr l ns nt">function validParentheses(parens) {<br/>  let parenths = parens.split('')<br/>  while (parenths.join('').includes('()')) {<br/>    for (let i = 0; i &lt; parenths.length - 1; i++) {       <br/>      if (parenths[i].concat(parenths[i + 1]) == '()') { <br/>        parenths.splice(i, 2)         <br/>        i -= 1       <br/>      }     <br/>    }<br/>  }<br/>  if (parenths.length === 0) {<br/>    return true<br/>  }<br/>  return false<br/>}</span></pre><p id="69f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果新数组是空的，我知道原来的字符串是有效的，所以我的函数返回<code class="fe nv nw nx nl b">true</code>。否则，我的函数返回<code class="fe nv nw nx nl b">false</code>。</p><h1 id="31c8" class="mm mn iq bd mo mp ny mr ms mt nz mv mw jw oa jx my jz ob ka na kc oc kd nc nd bi translated">变体2</h1><p id="3704" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated"><em class="nj">编写一个函数，它接受一串括号，并确定使括号有效所需的运算次数。</em></p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="3e8b" class="np mn iq nl b gy nq nr l ns nt">//Examples</span><span id="e137" class="np mn iq nl b gy nu nr l ns nt">'()'          =&gt;  0 // No additional brackets necessary<br/>'('.          =&gt;  1 // Missing one bracket<br/>'(()(((())'   =&gt;  3 // Missing three brackets</span></pre><p id="ef28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于这种变异，我一开始有点迷茫。</p><p id="64a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我最初的想法是，有效的一对意味着相同数量的<code class="fe nv nw nx nl b">(</code>和<code class="fe nv nw nx nl b">)</code>。</p><p id="3e42" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我认为我需要做的就是检查每一个的数量并找出不同之处。如果它是零，那么它是一个有效的括号串。否则，我只需要填写缺失的括号。</p><p id="d150" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一开始听起来很巧妙！😅</p><p id="d791" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是后来我运行了我的测试，发现我实际上失败了很多！</p><p id="12e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是为什么呢？</p><p id="9bdf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">经过进一步思考，我意识到括号的顺序很重要。</p><p id="eeb4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nv nw nx nl b">'((()))'</code>有效。</p><p id="d57f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nv nw nx nl b">'()()()'</code>有效。</p><p id="568d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nv nw nx nl b">)))(((</code>无效。</p><p id="8177" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">嗯，我觉得自己很蠢…😅</p><p id="068c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">既然是这样，我不得不改变我的整个思维方式。</p><p id="9057" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我需要写一个函数来跟踪左右括号的数量…不！我需要一个跟踪所需补码数量的函数。</p><p id="b86a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我的函数遍历字符串输入并找到了<code class="fe nv nw nx nl b">(</code>，那么它的补码的计数就会增加，因为它缺少一个<code class="fe nv nw nx nl b">)</code>来变得有效。</p><p id="1e5f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">类似地，一旦我的函数遇到<code class="fe nv nw nx nl b">)</code>，这个补码的计数就会下降。</p><p id="a75b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">反之亦然。</p><p id="d285" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果函数遇到的<code class="fe nv nw nx nl b">)</code>比<code class="fe nv nw nx nl b">(</code>多，那么补码计数将增加。</p><p id="a832" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它的基本功能是中和所需数量的补体。</p><p id="462f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们开始吧:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="26e4" class="np mn iq nl b gy nq nr l ns nt">function numComplements(parens) {<br/>  let parenths = parens.split('')<br/>}</span></pre><p id="6969" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我能说什么呢？对于这类挑战，我更喜欢使用数组。尤其是因为我会循环播放。</p><p id="9835" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我需要将我的补数设置为零。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="606c" class="np mn iq nl b gy nq nr l ns nt">function numComplements(parens) {<br/>  let parenths = parens.split('')<br/>  let rComplement = 0<br/>  let lComplement = 0<br/>}</span></pre><p id="3ec6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的循环将持续到字符串输入的长度。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="ab5b" class="np mn iq nl b gy nq nr l ns nt">function numComplements(parens) {<br/>  let parenths = parens.split('')<br/>  let rComplement = 0<br/>  let lComplement = 0<br/>  for (let i = 0; i &lt; parenths.length; i++) {<br/>  <br/>  }<br/>}</span></pre><p id="4132" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我需要我的条件句。如果我的循环遇到了<code class="fe nv nw nx nl b">(</code>,循环计数就会增加。</p><p id="080e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我的循环遇到了<code class="fe nv nw nx nl b">)</code>，那么它应该会降低<code class="fe nv nw nx nl b">(</code>所需的补码，并且rComplement会降低。然而，这仅在存在要关闭的现有<code class="fe nv nw nx nl b">(</code>的情况下。如果没有要关闭的内容，我们将缺少一个左括号，因此必须增加lComplement计数。</p><blockquote class="od oe of"><p id="7067" class="kr ks nj kt b ku kv jr kw kx ky ju kz og lb lc ld oh lf lg lh oi lj lk ll lm ij bi translated">这很难用语言来解释，但是试着在脑海中描绘出来。</p></blockquote><p id="6b02" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最终的代码看起来像这样:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="3d97" class="np mn iq nl b gy nq nr l ns nt">function numComplements(parens) {<br/>  let parenths = parens.split('')<br/>  let rComplement = 0<br/>  let lComplement = 0<br/>  for (let i = 0; i &lt; parenths.length; i++) {<br/>    if (parenths[i] === '(') {<br/>      rComplement++<br/>    }<br/>    else {<br/>      if (rComplement &gt; 0) {<br/>        rComplement--<br/>      }<br/>      else {<br/>        lComplement++<br/>      }<br/>    }<br/>  return rComplement + lComplement<br/>}</span></pre><p id="b5a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我增加了我需要的右补的数量，当我遇到一个补时就中和它。否则，我的左补的计数反而上升。</p><p id="e090" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我对所有需要的补码求和，并返回结果。</p><p id="a7c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个结果就是使括号中的字符串有效所需的运算次数(补码数，左右都有)!</p><h1 id="d9ac" class="mm mn iq bd mo mp ny mr ms mt nz mv mw jw oa jx my jz ob ka na kc oc kd nc nd bi translated">结论</h1><p id="a696" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated">在我写这篇博客的时候，我意识到我为第一个变体编写的代码可能也能解决第二个变体。</p><p id="f863" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于我的第一个解决方案折叠括号数组，直到只剩下无效的括号，这意味着数组将只包含需要补码的括号。</p><p id="4a21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该数组的长度应该是求解第二个变量所需的长度。</p><p id="3fa8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我应该很快意识到这一点，但自从我看到第一个变化已经有一段时间了，我不想依靠我的旧代码来解决新的挑战。</p><p id="4630" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然我花的时间比我回头看旧的解决方案要长，但这仍然是一次有趣的经历，我尝试了一种不同的编码方式。</p><p id="c870" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不用看旧的解决方案，回去重复你以前可能已经解决的挑战是很有趣的，因为你永远不知道你自己的思维过程可能会发生什么变化。</p><p id="2319" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不管怎样，你都要从两种经历中学习！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure></div></div>    
</body>
</html>