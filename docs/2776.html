<html>
<head>
<title>Predicting Apple Stock Prices with LSTM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用LSTM预测苹果股价</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/predicting-apple-stock-prices-with-lstm-79456ba0b904?source=collection_archive---------1-----------------------#2020-05-15">https://medium.datadriveninvestor.com/predicting-apple-stock-prices-with-lstm-79456ba0b904?source=collection_archive---------1-----------------------#2020-05-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/630fe36e3196e61e6b6d65ea1ba134f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v6dX_xw7KJioJlgC1ASo7w.png"/></div></div></figure><p id="2f39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我一直想效仿像埃隆·马斯克、T2、沃伦·巴菲特和T4这样的连续创业者的生活，这有三个主要原因。</p><ol class=""><li id="5fbc" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">推动创新和颠覆产业</li><li id="2f6b" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">让自己沉浸在聪明人的环境中</li><li id="4f4c" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">赚足够的钱，让我每次离开家都能穿上一双新鞋子</li></ol><p id="1696" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是啊- <em class="lk">尤其是</em>最不理智。不幸的是，钱不会长在树上，所以当我13岁的时候，我开始投资(实际上)股票。我的投资组合在3年内从100，000美元涨到437，303美元，当我16岁时，我开始用真金白银投资。</p><p id="1322" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我失败了</strong>。可怕地。撕了16年的生日钱😥</p><p id="1e96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然我在进步，但我想加快这个过程，并决定编写一个能够进行股票预测的<strong class="ka ir"> LSTM </strong>程序<strong class="ka ir">来拯救我自己免于又一次悲惨的破产！</strong></p><p id="dd01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">传统的神经网络使用<strong class="ka ir">前馈</strong>神经元，输入从该神经元通过函数传播以构建期望的输出。这种架构的局限性在于，它不能捕获输入数据的<em class="lk">顺序信息</em>，并且人工神经网络不考虑先前的预测。</p><div class="ll lm gp gr ln lo"><a href="https://www.datadriveninvestor.com/2020/02/19/cognitive-computing-a-skill-set-widely-considered-to-be-the-most-vital-manifestation-of-artificial-intelligence/" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd ir gy z fp lt fr fs lu fu fw ip bi translated">认知计算——一套被广泛认为是……</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">作为它的用户，我们已经习惯了科技。这些天几乎没有什么是司空见惯的…</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="lx l"><div class="ly l lz ma mb lx mc jw lo"/></div></div></a></div><p id="53ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">递归神经网络</strong>更好地模拟了我们的认知框架，因为它们在不同的<em class="lk">时间步长</em>上共享参数，这意味着需要训练的参数更少，计算成本也降低了。它们的内部存储器允许架构<strong class="ka ir">记忆先前的输入</strong>并将先前的输出反馈到输入中，以做出更好的未来预测。</p><p id="f3bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，现在很少实现递归神经网络。所有的递归神经网络在递归层中都有<strong class="ka ir">反馈回路</strong>，这使得它们能够将信息保存在<em class="lk">‘记忆’</em>中，然而训练它们对于需要学习<strong class="ka ir">长期时间依赖性</strong>的RNN氏症患者来说是很困难的。这是因为声明的损失函数的梯度随时间呈指数衰减，并且<strong class="ka ir">消失梯度问题</strong>随之而来。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi md"><img src="../Images/a958eb6a17d23f9041a887b80c9e6ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*2l6dDYm7v3iu9yLiC9JRTw.png"/></div></figure><p id="1a73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> LSTM </strong>网络除了使用标准单元之外，还使用特殊单元来包括<em class="lk">存储单元</em>，这些存储单元可以将信息长时间保存在内存中。这个模型包括多个<strong class="ka ir">门</strong>，它们控制信息进入记忆的时间、输出的时间以及信息被遗忘的时间，从而增强网络学习长期依赖关系的能力。</p><blockquote class="mi mj mk"><p id="fb94" class="jy jz lk ka b kb kc kd ke kf kg kh ki ml kk kl km mm ko kp kq mn ks kt ku kv ij bi translated"><em class="iq">本质上，普通的RNN网络只有</em>个隐藏状态<em class="iq">用于存储，而LSTM网络有</em>个隐藏状态和单元状态<em class="iq">，可以通过门控删除和添加信息。</em></p></blockquote><p id="448d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从股票预测的角度来看，随着时间的推移，普通RNN会忘记早期的股票价格数据，而LSTM可以使用历史趋势和数据进行更准确的预测。<strong class="ka ir">存储门</strong>收集可能的输出并存储相关的输出；<strong class="ka ir">选择门</strong>从存储门产生的可能输出中选择最终输出；<strong class="ka ir">遗忘和忽略</strong>门决定哪些数据存储器是不相关的，并处理掉它们。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/90f878478d479c75f9e8e2b4bae71682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/0*Ji9Z4pMn9Sngjnom"/></div></figure></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h2 id="ba3d" class="mw mx iq bd my mz na dn nb nc nd dp ne kj nf ng nh kn ni nj nk kr nl nm nn no bi translated">既然我们已经理解了递归神经网络和LSTM体系结构，让我们开始编程吧！</h2><div class="ll lm gp gr ln lo"><a href="https://github.com/Suraj-Bansal/LSTM-for-Apple-Stock-Predictions" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd ir gy z fp lt fr fs lu fu fw ip bi translated">苹果股票的苏拉吉-班萨尔/LSTM预测</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">利用长短期记忆和递归神经网络预测苹果股票价格…</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">github.com</p></div></div><div class="lx l"><div class="np l lz ma mb lx mc jw lo"/></div></div></a></div><h1 id="31d5" class="nq mx iq bd my nr ns nt nb nu nv nw ne nx ny nz nh oa ob oc nk od oe of nn og bi translated">步骤1 →导入库</h1><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/ab2503022572f8afae2308843b418833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XKP2lPSs1tQFiv_R"/></div></div></figure><h1 id="4335" class="nq mx iq bd my nr ns nt nb nu nv nw ne nx ny nz nh oa ob oc nk od oe of nn og bi translated">步骤2 →导入数据集</h1><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/fb1c116c4d8556ba8cc2dbb65d3000a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_Xx6y05v5xKQLb9E"/></div></div></figure><p id="1523" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lk"> Pd.read_csv </em>帮助将<strong class="ka ir">逗号分隔值(csv) </strong>文件读入数据帧——我们数据集的<em class="lk">头</em>和<em class="lk">尾</em>打印在下面，显示行数和列数。</p><h1 id="a124" class="nq mx iq bd my nr ns nt nb nu nv nw ne nx ny nz nh oa ob oc nk od oe of nn og bi translated">步骤3 →检查空值</h1><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/92e7cee9bbb71e901c35829e4aa664cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0AvfRN3G3vWJsMOH"/></div></div></figure><p id="bee4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，检查每一列中的空值<strong class="ka ir">并打印找到的空值总数。空值会改变我们模型的预测——幸运的是没有发现空值。</strong></p><h1 id="7fdf" class="nq mx iq bd my nr ns nt nb nu nv nw ne nx ny nz nh oa ob oc nk od oe of nn og bi translated">步骤4 →可视化数据</h1><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/6914aedc223a824114c880652418a00a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FMutesetAKyzHG1D"/></div></div></figure><p id="3854" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了可视化股票价格，首先<strong class="ka ir">删除</strong>不必要的列——我单独绘制了每一列，然后为了更好的可视化，将它们集合起来，但是这一步对于创建我们的LSTM来说并不是必需的。</p><h1 id="d6ec" class="nq mx iq bd my nr ns nt nb nu nv nw ne nx ny nz nh oa ob oc nk od oe of nn og bi translated">步骤5 →删除额外的列</h1><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/a194be8033aae85277d5e10963ba54ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IbN4Y-1WuQFIlgU1"/></div></div></figure><p id="ae59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们只处理<strong class="ka ir">开盘</strong>股价，所以我们可以删除高低柱。默认情况下，该函数将在y轴上搜索，但设置<strong class="ka ir"> axis = 1 </strong>可确保该函数搜索列而不是行，并且<strong class="ka ir"> inplace=True </strong>可确保实际数据集被更改。我们还删除了最下面的两行，以便以后更清晰地显示数字。</p><h1 id="a173" class="nq mx iq bd my nr ns nt nb nu nv nw ne nx ny nz nh oa ob oc nk od oe of nn og bi translated">步骤6 →分为培训和测试</h1><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/9347d4a3453fec1d006af560de1a098a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3ixld1CP9DWh-Wxt"/></div></div></figure><p id="e71a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在继续之前，将数据集转换成一个<strong class="ka ir"> numpy数组</strong>。然后将数据的<strong class="ka ir"> 1760 </strong>个样本的数据集按照<em class="lk"> 80/20 </em>的百分比分成训练和测试两部分，训练数据集<strong class="ka ir"> 1408 </strong>个样本，测试数据集<strong class="ka ir"> 352 </strong>个样本。</p><h1 id="bf6e" class="nq mx iq bd my nr ns nt nb nu nv nw ne nx ny nz nh oa ob oc nk od oe of nn og bi translated">步骤7 →缩放数据</h1><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/701c570bf05bc93d8029026d2cedee3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_4EQHijLZ03Jod-h"/></div></div></figure><p id="d6a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当每个单独的特征被<strong class="ka ir">缩放</strong>到更小的范围，同时保持<em class="lk">正态分布</em>时，机器学习工作流得到更好的优化。我使用了一个效用函数<strong class="ka ir">将特征向量</strong>缩放成表示形式，以使<em class="lk">在特定范围内标准化</em>数据，并在减少误差的同时加快计算速度。</p><p id="fa64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将数据缩放到默认范围<strong class="ka ir"> [0，1] </strong>，并使用<strong class="ka ir">最小最大缩放器</strong>，它减去每个单独特征中的最小值并除以该范围，该范围计算为原始最小值和最大值之间的差值。</p><blockquote class="mi mj mk"><p id="f527" class="jy jz lk ka b kb kc kd ke kf kg kh ki ml kk kl km mm ko kp kq mn ks kt ku kv ij bi translated">如果您对全面理解数据预处理以及如何使用scikit-learn进行缩放感兴趣，请查看这篇文章！</p></blockquote><div class="ll lm gp gr ln lo"><a href="https://medium.com/datadriveninvestor/data-pre-processing-with-scikit-learn-9896c561ef2f" rel="noopener follow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd ir gy z fp lt fr fs lu fu fw ip bi translated">使用SCIKIT学习进行数据预处理</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">大多数机器学习工作流在要素按相对较小的比例缩放时运行得更好，并且通常…</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">medium.com</p></div></div><div class="lx l"><div class="oi l lz ma mb lx mc jw lo"/></div></div></a></div><h1 id="8b04" class="nq mx iq bd my nr ns nt nb nu nv nw ne nx ny nz nh oa ob oc nk od oe of nn og bi translated">第八步→分成X列车和Y列车</h1><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/0dde91d7d53fce3ec66b17a0d17161aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yvv5BdliZMt3kZWY"/></div></div></figure><p id="3a78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将数据分为x_train和y_train，并将x_train重新整形为LSTM模型可接受的3D输入。</p><h1 id="4664" class="nq mx iq bd my nr ns nt nb nu nv nw ne nx ny nz nh oa ob oc nk od oe of nn og bi translated">步骤9 →建立LSTM模型</h1><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/8fee0e6760743f40bcea3ea5f39802ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sc8IKQ1xa5X6NGwT"/></div></div></figure><p id="36f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，实例化预训练的<strong class="ka ir">顺序</strong>模型，它通过允许我们简单地添加层而使生活变得更容易。</p><p id="afff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> LSTM层</strong>设置声明输出空间维度的<em class="lk">单元</em>的数量。<strong class="ka ir"> Return_sequences = True </strong>确定是返回输出序列中的前一个输出，还是整个序列，而<strong class="ka ir"> input_shape </strong>表示我们训练数据集的形状，基本上反映了<em class="lk">时间步长</em>的数量，而最后一个参数是指示符的数量。</p><p id="39c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">退出层</strong>随机选择神经元并忽略它们，以使我们的网络<em class="lk">对特定神经元值不太敏感</em>，从而使<em class="lk">具有更好的泛化能力</em>。这避免了<strong class="ka ir">过度拟合</strong>，这概括了模型在训练数据上比测试数据表现更好的现象。</p><h1 id="e6ac" class="nq mx iq bd my nr ns nt nb nu nv nw ne nx ny nz nh oa ob oc nk od oe of nn og bi translated">步骤10 →编译模型</h1><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/c1c815df4d2e507da38748335c593fab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mW0O2RkK3GQk0S1R"/></div></div></figure><p id="89a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<strong class="ka ir"> Adam optimizer </strong>编译模型，Adam optimizer 使用<em class="lk">自适应学习速率</em>方法根据训练数据更新神经网络的八次迭代。它将<strong class="ka ir"> RMSprop </strong>和<strong class="ka ir">随机梯度下降</strong>与<strong class="ka ir">动量</strong>结合在一起——本质上是平方梯度以缩放学习速率，类似于RMSprop，但它通过使用梯度的移动平均值而不是梯度本身来利用动量，就像具有动量的SGD一样。</p><p id="c39f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">估计器的均方误差</strong>测量误差平方的平均值<em class="lk">(估计值和估计值之间的平均平方差)</em>。此度量查找部分误差，该误差等于由测量点之间的距离产生的形状面积。</p><h1 id="00d3" class="nq mx iq bd my nr ns nt nb nu nv nw ne nx ny nz nh oa ob oc nk od oe of nn og bi translated">步骤11 →拟合模型</h1><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/091a152e4d1868492eb5669aa2d6d9dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OLbgdKGggHxl4GvU"/></div></div></figure><p id="1075" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用<strong class="ka ir"> 32 </strong>的<strong class="ka ir">批量</strong>训练<strong class="ka ir"> 100个周期</strong>的模型。这意味着32个训练样本将用于100次迭代。</p><h1 id="5383" class="nq mx iq bd my nr ns nt nb nu nv nw ne nx ny nz nh oa ob oc nk od oe of nn og bi translated">步骤12 →预测测试数据</h1><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/6d75d2ec85c13820b87b3b9913497df1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YtTkYC3pnLWkE4jt"/></div></div></figure><p id="01fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将测试数据整形为可接受的<strong class="ka ir"> 3D </strong>格式，并将之前使用的<em class="lk">标量</em>应用于数据集。将<strong class="ka ir">模型预测</strong>应用到数据上，然后<strong class="ka ir">将预测逆</strong>为其原始值。</p><h1 id="0988" class="nq mx iq bd my nr ns nt nb nu nv nw ne nx ny nz nh oa ob oc nk od oe of nn og bi translated">步骤13 →绘制数据</h1><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/055651227fd4efb8ac82a2052be2e36e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qoq22sBpq1zTe_hB"/></div></div></figure><p id="bb99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">绘制预测股票价格与实际股票价格的对比图。创建图表是不言自明的。该图应该类似于下图。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/9fe6c9fa4c754839303a32cade894e7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/0*vy84srLOt_IukPz4"/></div></figure><h1 id="1799" class="nq mx iq bd my nr ns nt nb nu nv nw ne nx ny nz nh oa ob oc nk od oe of nn og bi translated">步骤14 →一些快速数学</h1><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/bfe0a84de4ada4f1ce2783410eb883df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_jvhEzkmYUHf6uGb"/></div></div></figure><p id="5179" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> RMSE值</strong>代表残差方差的<em class="lk">平方根，表示模型对数据的绝对拟合，以及数据点到模型预测值之间的距离。这么低的RMSE值太棒了！</em></p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/f5535e566569b2d24067e94e51210d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*njXPFQLTubeKrNra"/></div></div></figure><p id="e025" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只是为了好玩，我计算了实际数据集和预测值的<strong class="ka ir">最小值</strong>和<strong class="ka ir">最大值</strong>股价。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/63e16c729678fc6ac3bcee580e1ae0ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pbCs4ea4Eq4PFR-I"/></div></div></figure><p id="0c0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我确定了<strong class="ka ir">模型精度</strong>。我是通过计算MAPE的值来实现的，这个值用下面的公式表示。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/c4523b28808a339e1d29e4c6c8020c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8lG7SV7c9JM9uvjq"/></div></div></figure><p id="d095" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个基本上取<em class="lk">(实际—预测)* 100/绝对值(实际)*样本数的绝对值。</em>使用for循环计算实际值上的残差总和，然后通过舍入该总和除以样本数并转换为百分比来计算MAPE。</p><p id="252a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于MAPE代表<strong class="ka ir">误差</strong>，所以<strong class="ka ir">精度</strong>是通过从100中减去误差得到的，以显示<strong class="ka ir"> 98.3% </strong>的精度！这意味着我们的模型非常准确。希望这意味着每次我根据我的LSTM做预测时，我会变得更富有98.3%🤑</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="458b" class="nq mx iq bd my nr oo nt nb nu op nw ne nx oq nz nh oa or oc nk od os of nn og bi translated">最后一件事</h1><blockquote class="mi mj mk"><p id="7efe" class="jy jz lk ka b kb kc kd ke kf kg kh ki ml kk kl km mm ko kp kq mn ks kt ku kv ij bi translated">希望你能够更好地理解LSTM网络，以及我如何利用它们进行股票预测！如果你能通过做以下事情来支持我，那对我来说将意味着一切</p></blockquote><ol class=""><li id="1817" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">注意👏图标？给我的文章发些<strong class="ka ir">掌声</strong></li><li id="899e" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">通过<a class="ae ot" href="https://twitter.com/surajbansal2003" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae ot" href="https://www.linkedin.com/in/suraj-bansal/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae ot" href="https://github.com/Suraj-Bansal" rel="noopener ugc nofollow" target="_blank"> Github </a>与我联系</strong></li><li id="f3c4" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">查看</strong>我的<a class="ae ot" href="https://surajbansal.ca/" rel="noopener ugc nofollow" target="_blank">个人网站</a>了解我的最新作品</li></ol><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="ou ov l"/></div></figure></div></div>    
</body>
</html>