<html>
<head>
<title>Beyond requests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超出要求</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/beyond-requests-1c2237ce45d6?source=collection_archive---------15-----------------------#2020-05-28">https://medium.datadriveninvestor.com/beyond-requests-1c2237ce45d6?source=collection_archive---------15-----------------------#2020-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2186" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在<a class="ae kl" href="https://greendeck.co/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Greendeck </strong> </a>为我们的客户提供定价和零售智能解决方案。我们帮助他们根据数据而不是直觉做出伟大的定价决策。</p><p id="82b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现这一点，主要任务之一是每天从许多电子商务商店中抓取数以亿计的产品。</p><p id="2874" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们是一家数据驱动型公司，数据构成了Greendeck的基础。如果我们不能在正确的时间获得正确的数据，事物就不会从一个地方转移到另一个地方。</p><div class="km kn gp gr ko kp"><a href="https://www.datadriveninvestor.com/2020/01/16/software-development-process-how-to-pick-the-right-process/" rel="noopener  ugc nofollow" target="_blank"><div class="kq ab fo"><div class="kr ab ks cl cj kt"><h2 class="bd ir gy z fp ku fr fs kv fu fw ip bi translated">软件开发过程:如何选择正确的过程？数据驱动的投资者</h2><div class="kw l"><h3 class="bd b gy z fp ku fr fs kv fu fw dk translated">软件是任何企业组织成功的生命线。没有软件的帮助，一个…</h3></div><div class="kx l"><p class="bd b dl z fp ku fr fs kv fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="ky l"><div class="kz l la lb lc ky ld le kp"/></div></div></a></div><p id="01d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要构建一个健壮可靠的架构，能够尽快完成抓取操作，这样其他任务也可以执行。</p><p id="1e82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是这种情况下数据管道的大致情况:</p><ol class=""><li id="b764" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">发送请求并接收HTML作为响应。</li><li id="bc8d" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">解析响应:以正确的格式提取数据。</li><li id="1e9e" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">将数据保存在所需的模式中。</li></ol><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/e89c06dabcb8a6813819504600dfab11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EtqgwunCsvYpt6KjO0ulXg.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">AMS Architecture</figcaption></figure><p id="527b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些任务中的第一个任务是最耗时的，所有其他任务都依赖于它。做好这件事，并让它变得更快，是这个架构的基础。</p><p id="974c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">要求:</strong></p><ol class=""><li id="42c8" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">我们需要向多个门户发送数百万个请求，而不会被阻塞。</li><li id="f2bf" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">它需要很快。</li><li id="fbd4" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">它需要强大和可靠。</li><li id="e634" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">需要具有成本效益。</li></ol><p id="b738" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章就像是我们尝试的每一件事情的旅程，我们从那些实验中得到的结果，什么有效，什么无效。</p><h2 id="550b" class="mi mj iq bd mk ml mm dn mn mo mp dp mq jy mr ms mt kc mu mv mw kg mx my mz na bi translated">基本要求</h2><p id="1c73" class="pw-post-body-paragraph jn jo iq jp b jq nb js jt ju nc jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated">像大多数人一样，我们简单地从<a class="ae kl" href="https://pypi.org/project/requests/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> python的请求</strong> </a>模块开始向服务器发送请求。简单明了的请求只是为了开始。按照我们的期望和要求，它失败了。它悲惨地失败了。</p><ol class=""><li id="4206" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">超级慢。</li><li id="41fb" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">我们被禁止发送这么多请求。</li><li id="8e87" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">我们只是在做<code class="fe ng nh ni nj b">requests.get(url)</code>。稍后将详细介绍。</li></ol><p id="1fb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单的要求在各个方面对我们来说都不够好。</p><p id="f885" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们开始考虑加快这个过程之前，我们必须停止被门户网站禁止。我们开始挖掘问题，我们发现我们需要比自动化整个过程的代码更人性化。门户屏蔽了我们，因为他们知道是幕后的代码在发送请求，而不是真正的人。所以，我们需要用代码模拟现实世界的过程。</p><p id="c352" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们需要利用<strong class="jp ir">用户代理、cookies和头文件的地方。</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nk"><img src="../Images/b642e7103369e9bd299a99f80dda282c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3kCC3yOIJPbw52YVK9TSmg.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Using proxies</figcaption></figure><p id="05ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些就像是模拟人类使用浏览器请求资源的过程的小插件。情况有所改善。我们开始得到一些门户网站的回应，但大多数仍在屏蔽我们。下一个明显的步骤是使用<strong class="jp ir">代理。</strong>我们需要有一个非常大的<strong class="jp ir">池在每一个实例中工作</strong>代理<strong class="jp ir"> </strong>，这样我们就可以利用它们来欺骗服务器，请求是从不同的位置由不同的用户发送的。在Greendeck上有一项24x7全天候运行的服务，可以返回有效的代理。</p><p id="a98d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用代理、用户代理、cookies和头文件为我们解决了大部分问题。我们提出的95%以上的请求都得到了处理，没有任何问题。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="e51b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如何让它</strong> <strong class="jp ir">快？</strong></p><p id="1e18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在加快这个过程之前，我们需要提高我们将为所有实验优化的指标。当你知道你最终想要实现什么时，事情就很容易完成。</p><p id="450f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们得出的指标是每秒<strong class="jp ir">个请求</strong>。它是每秒完成的请求数。非常简单。我们需要使这个数字尽可能高。</p><p id="5fa9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是集中精力让<strong class="jp ir">变得更快。</strong>需要认识到的重要一点是，该进程是一个<strong class="jp ir"> I/O受限的</strong>进程，而不是<strong class="jp ir">基于计算的</strong>进程。因此，我们可以利用多线程和多处理，而不会受到python解释器强加给多线程进程的<a class="ae kl" href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> GIL锁</strong> </a>的限制。</p><p id="a379" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们开始利用多线程和多处理来同时发送许多并发请求。不用说，性能大幅提升。</p><p id="78ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如何不再被封禁？</strong></p><p id="7528" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在使用多线程和多处理后，速度得到了疯狂的提高，但随之而来的是另一个问题。即使使用了代理，我们又开始受阻。现在，我们要在两个选项中做出选择:</p><ol class=""><li id="fa3f" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">对每个URL请求使用不同的代理。</li><li id="b06d" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">对每个<strong class="jp ir"> n个</strong>请求使用相同的代理，其中n =门户允许的同时请求数</li></ol><p id="0cc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继续选择选项2肯定是正确的，也是唯一的选择，因为可用的代理数量有限。你不能指望每时每刻都有数百万个代理供你使用。<strong class="jp ir">刮的时候需要大方，尊重门户网站的政策。在你的头脑中设定这个规则。</strong></p><p id="8417" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们同时发送给门户的请求总数等于可用代理总数乘以数量<strong class="jp ir"> n </strong>。整批请求由来自不同门户的URL组成。这样，我们既尊重政策，又能充分利用我们的资源。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="74aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如何让它更快？</strong></p><p id="c4b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">整个过程仍然没有达到标准。我们知道它可以更优化。这就是使用<strong class="jp ir">会话</strong>和<strong class="jp ir"> DNS缓存</strong>的想法发挥作用的地方。</p><h1 id="7cf7" class="ns mj iq bd mk nt nu nv mn nw nx ny mq nz oa ob mt oc od oe mw of og oh mz oi bi translated">会议</h1><p id="c91f" class="pw-post-body-paragraph jn jo iq jp b jq nb js jt ju nc jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated">当我们执行<code class="fe ng nh ni nj b">requests.get(url,headers=headers,proxies=proxies)</code>时，它为每个请求创建与服务器的会话。这就像是我们所做的努力白费了。我们可以利用我们为第一个请求创建的会话，并且可以为进一步的请求使用相同的会话对象。这意味着第一次使用<code class="fe ng nh ni nj b">requests.session()</code>创建一个会话对象，然后对每个后续请求使用相同的会话对象。这极大地提高了速度。会话对我们的用例非常有用。</p><h1 id="27cb" class="ns mj iq bd mk nt nu nv mn nw nx ny mq nz oa ob mt oc od oe mw of og oh mz oi bi translated">DNS缓存</h1><p id="ab38" class="pw-post-body-paragraph jn jo iq jp b jq nb js jt ju nc jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated">在访问实际的服务器之前，请求首先通过DNS服务器，该服务器将域名解析为服务器的实际IP地址。这个过程需要时间，但是当我们通过浏览器发送请求时，它通常会被忽略。我们认为，与其在每次请求时都解析同一个域名的IP地址，为什么不在开始时只解析一次，并存储解析后的IP地址供以后的请求使用。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi oj"><img src="../Images/9d3695c61ac4b860b2c03871ca6a5f3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OuPJvcngMnqa5qY0hG4jzA.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">DNS caching</figcaption></figure></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="9c51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们能让它更快吗？</p><p id="ff5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从一开始就在想这个问题。我们能让它更快吗？答案是:当然可以。我们开始寻找python请求库的良好替代品。在做了一点研究之后，我们开始了解到<a class="ae kl" href="http://pycurl.io/docs/latest/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> pycurl </strong> </a>和<a class="ae kl" href="https://pypi.org/project/faster-than-requests/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">比请求更快。</strong> </a></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ok"><img src="../Images/d764e8d1376bb25c25960fc6ca3f6f8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t2qx1mfn5PwB5My3apI0rQ.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Libraries comparison, <a class="ae kl" href="https://pypi.org/project/faster-than-requests/" rel="noopener ugc nofollow" target="_blank">Source</a>.</figcaption></figure><p id="5910" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们尝试了比请求更快，但后来意识到它没有我们想要的那种定制。开发人员在发出请求时可以传递的参数非常少。大约95%的请求是使用用户代理、cookies、代理和头来完成的。因此，我们放弃了使用比请求更快的想法。</p><p id="fef9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们尝试了<strong class="jp ir"> pycurl，</strong>这主要是一个在<strong class="jp ir"> libcurl </strong>库之上的python包装器。结果真的很棒。我们注意到速度提高了3倍。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="1fa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些都是我们迄今为止为使我们的架构更快更可靠而做的实验。该过程仍未完成。我们仅仅触及了可能性的表面。有很多事情可以尝试，作为回报，它可以更加优化。</p><p id="9f28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望您会发现这些见解对您的用例有用，如果您还有其他建议，请告诉我们！</p><p id="f0a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你对……感兴趣，或者只是想打个招呼，请给我写信，地址是rishabh@greendeck.co。</p><p id="f129" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">进入专家视角— </strong> <a class="ae kl" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>