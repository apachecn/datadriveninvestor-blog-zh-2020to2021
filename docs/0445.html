<html>
<head>
<title>Sentence Reverse Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">句子逆序算法</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/sentence-reverse-algorithm-9371fbe0948d?source=collection_archive---------5-----------------------#2020-01-30">https://medium.datadriveninvestor.com/sentence-reverse-algorithm-9371fbe0948d?source=collection_archive---------5-----------------------#2020-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/88849e2de2a149b41c1e505fe81d5955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PCBEI-Vxk5CaIFlY.jpg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">“At what point do your dreams for yourself become ‘unreasonable’?”</figcaption></figure><p id="9b9a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这周我在Pramp上做了一个模拟面试。事情进行得不是很顺利——这很令人沮丧，因为回想起来，这并不是一个很难的问题。让我们跳进来。</p><div class="la lb gp gr lc ld"><a href="https://www.datadriveninvestor.com/2019/03/22/the-seductive-business-logic-of-algorithms/" rel="noopener  ugc nofollow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd ir gy z fp li fr fs lj fu fw ip bi translated">算法诱人的商业逻辑|数据驱动的投资者</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">某些机器行为总是让我感到惊讶。我对他们从自己的成就中学习的能力感到惊讶…</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr jw ld"/></div></div></a></div><p id="5917" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有人问我一个问题，叫做“句子颠倒”。您会得到一个字符“s”数组，它“由空格字符分隔的字符序列组成”。每个空格分隔的字符序列定义一个单词。所以，你会得到这样的东西:</p><p id="ad95" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">s[] = "熟能生巧"</p><p id="0321" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要求您“实现一个‘reverse _ words’函数，以最有效的方式反转数组中单词的顺序。”因此，如果给定上面的输入，期望的输出将是:</p><p id="6528" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">s[] =“熟能生巧”</p><p id="b83c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">关于边缘情况，可能存在空数组、仅包含空格的数组、一个单词的数组、单词之间的多个空格等。</p><p id="289e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">解决这个问题的最好方法是首先反转数组中的每个单词:</p><p id="148c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">s[] = "ecitcarp sekam tcefrep "</p><p id="2356" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后颠倒每个单词:</p><p id="d911" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">s[] =“熟能生巧”</p><p id="7fa8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们开始编码。</p><p id="abaa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，让我们考虑一下我们的主要功能。我们需要初始化将要反转的字符串。然后，我们希望将字符串的地址传递给一个函数，该函数将反转字符串中的每个单词。我们的主要功能可能是这样的:</p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ls"><img src="../Images/cf904305f473b89f40eaeac265f8c115.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n-B2suZsQOVjjG4D52RF9Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">I include the print statements I used to debug for reference</figcaption></figure><p id="d079" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我们调用reverse_words(s)时，我们实际上是将字符串中第一个字符的内存地址传递给函数。这很方便，因为这样一来，我们的助手函数就不必向main()返回任何东西，因为main()有一个对助手函数所操作的数据的引用。</p><p id="e218" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来我们来写reverse_words()。由于我们需要完成的第一件事是反转字符串中的每个单词，reverse_words()将负责为它遇到的每个单词获取一个指向单词开头和结尾的指针。一旦设置了这些指针，我们就可以对每个单词调用reverse()，这实际上将反转字符串中的每个字符:</p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lx"><img src="../Images/fac29c9980729f6a9198eb5309dd981a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UIdPsU2L-CLoG-eLfj4Eww.png"/></div></div></figure><p id="fae5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意reverse_words()如何遍历字符串s:</p><ol class=""><li id="6d31" class="ly lz iq ke b kf kg kj kk kn ma kr mb kv mc kz md me mf mg bi translated">首先，我们将while循环设置为运行，直到temp指向的地址值为NULL。</li></ol><p id="9b2c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.其次，我们递增temp指向的地址，然后检查我们现在是否指向一个空字节。请注意，在这种情况下，while循环似乎比for循环更合适，因为我们希望在循环体中遇到逻辑之前增加temp，而不是在for或do-while循环中通常会发生的情况之后。</p><ul class=""><li id="5f22" class="ly lz iq ke b kf kg kj kk kn ma kr mb kv mc kz mh me mf mg bi translated">如果我们指向一个空字节，那么我们已经到达了字符数组的末尾。我们现在要做的就是反转数组中的最后一个字，等待while循环终止，然后调用reverse(第45行)并反转整个字符串。</li></ul><p id="0298" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.接下来，我们检查temp是否指向一个空格字符。</p><ul class=""><li id="f8c2" class="ly lz iq ke b kf kg kj kk kn ma kr mb kv mc kz mh me mf mg bi translated">如果我们指向一个空格字符，那么我们在字符串中找到了另一个单词的结尾。我们需要使用指向字符串开头的指针(word_begin)和表示字符串最后一个字符的temp-1来调用reverse。</li><li id="4159" class="ly lz iq ke b kf mi kj mj kn mk kr ml kv mm kz mh me mf mg bi translated">在我们颠倒这个单词之后，我们需要把我们的新单词begin设置为temp+1，它代表我们的字符串中下一个单词的第一个字符，然后继续循环。</li></ul><p id="bc24" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">4.如果temp没有指向空字节或空格字符，我们在每次循环迭代中所做的就是通过单词中的字母递增temp指针。</p><p id="b21a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在让我们看看reverse()实际上是如何颠倒我们传递给它的单词中的字符的:</p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/5097990227d6b94d15066bb21fee4547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mYV2lyb0O0ncTq_Or0H5Ng.png"/></div></div></figure><p id="4bc4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，当begin的地址小于end的地址时，我们将运行while循环:</p><p id="7596" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">//让我们想象我们正在反转字符串“perfect”</p><ol class=""><li id="415a" class="ly lz iq ke b kf kg kj kk kn ma kr mb kv mc kz md me mf mg bi translated">将“p”的值复制到一个名为temp的char变量中。</li><li id="dc7f" class="ly lz iq ke b kf mi kj mj kn mk kr ml kv mm kz md me mf mg bi translated">将begin指向的地址值(以前是“p”)更改为end指向的地址值(以前是“t”)。我们可以通过使用指向字符串开头的字符指针save打印字符串来测试这一点。该字符串现在应该显示为“terfect”：</li></ol><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/13f10705777257fa348cbeacdacd3b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*ijOt24xHzenALw2nQXkenQ.png"/></div></figure><p id="c496" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后应用后置递增运算符。现在，begin指向字符串中的第二个字符，即“e”:</p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/208ee0e50dda74a4baae5654893cf22d.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/1*7VmZ7ONbNOr2ej74A2n3Pg.png"/></div></figure><p id="1ce2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.保存在temp中的字符被分配给保存在指针末端的地址。该词现在应读作“terfecp”:</p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/3abe1f525077c8d798b1fa07b6d6d09c.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*Ejz1SwyFaa9bXkpCfP7Aeg.png"/></div></figure><p id="e994" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后应用后缀减量运算符，end现在指向单词“c”中的倒数第二个字符:</p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/ef386e42b3e4949e25d527b6f7cc48fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:350/format:webp/1*N-13VWv3WVWK8w3BB-etmA.png"/></div></figure><p id="1bf2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个循环将继续下去，直到begin指向的地址大于end指向的地址:</p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/3fe9bc781ca3809ff26c7c03849aac05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3cqIAU1q1O2ihEy7LHa4wA.png"/></div></div></figure><p id="8f42" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">就时间和空间复杂度而言，该算法对于两者都是O(n ),其中n表示字符串中的字符数。</p><p id="fa65" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是你如何在c语言这样的低级语言中反转一个句子。</p><figure class="lt lu lv lw gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure></div></div>    
</body>
</html>