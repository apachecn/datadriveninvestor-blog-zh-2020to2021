<html>
<head>
<title>Understanding Run-Time Complexities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解运行时的复杂性</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/understanding-run-time-complexities-c4f0bed0053?source=collection_archive---------4-----------------------#2020-01-01">https://medium.datadriveninvestor.com/understanding-run-time-complexities-c4f0bed0053?source=collection_archive---------4-----------------------#2020-01-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9be2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章的目的是用最简单的解释来涵盖常见的运行时复杂性，使初学者更容易理解代码的运行时复杂性。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="6537" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码或算法的运行时复杂性意味着决定算法的性能。最有可能的是，一个算法有多个解，运行时复杂性帮助我们确定哪个解是最好的。我们真正要问的问题是，当我们增加或加倍算法的输入时，我们还需要多少处理能力？让我们考虑以下例子:</p><p id="0d1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如1:字符串反转(“ABC”-&gt;“CBA”)</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi ks"><img src="../Images/58e65dddc842f5ffc47974462031ad8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*zz7rG1GiCedtOH_zujdW1A.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Code for Reversing a string</figcaption></figure><p id="c661" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码是一个字符串反转的迭代解决方案。我们将字符串中的每个字符精确地迭代<strong class="jp ir">一次</strong>。因此，可以肯定地说，当我们添加一个额外的字符时，我们必须在循环中执行一个额外的步骤。因此，我们将该算法称为具有线性运行时(表示为“N”)复杂性，因为在我们拥有的输入元素的数量和我们必须用来处理它的工作量(步骤)之间存在直接的一对一关系。</p><div class="le lf gp gr lg lh"><a href="https://www.datadriveninvestor.com/2019/03/22/the-seductive-business-logic-of-algorithms/" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd ir gy z fp lm fr fs ln fu fw ip bi translated">算法诱人的商业逻辑|数据驱动的投资者</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">某些机器行为总是让我感到惊讶。我对他们从自己的成就中学习的能力感到惊讶…</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv ky lh"/></div></div></a></div><p id="697e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如2:打印楼梯(使用#字符的N级台阶形状。)</p><p id="4d75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">举个例子，</p><p id="a6a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">步骤(2)</p><p id="e8ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">// ‘# ‘</p><p id="f461" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">// ‘##’</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/f9de1d923bf1501aaf03f34694af2d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*ujVs2GEBdOWRweudjfS4vA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Code for printing the stairs</figcaption></figure><p id="1181" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有一个输入‘n’，基于这个输入，我们有两个嵌套的for循环(一个循环在另一个循环里面)。这意味着当我们增加n的输入大小时，我们必须做更多的步骤。如果n是2，我们必须做4步……两步用于外循环，两步用于内循环。同样，如果n是3，我们要做9步。随着N的增加，我们不得不做更多的步骤，或者总共(N*N)件事。这将是N，称为二次运行时间。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="7062" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(常见)复杂类型:</p><ol class=""><li id="d90b" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated">恒定运行时间:表示为(1)。不管输入集是什么，算法总是花费完全相同的时间。常数时间最好的例子是打印一条语句或添加两个输入值。语句的大小与算法无关，它所要做的就是打印出来。类似地，输入的值并不重要，代码只需将它们相加并返回。</li><li id="e1a5" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">对数运行时间:表示为(Log(N))。如果输入集翻倍并不能使您必须做的工作量翻倍，那么您将有一个对数时间。当你使用搜索算法时，它们是最重要的。因此，搜索经过排序的数据数组可能需要对数的运行时间，这也是对数时间的一个例子。</li><li id="a221" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">线性运行时间:表示为(N)。这是最常见的运行时，相对简单和直接。您可以通过遍历数据集合中的所有元素来识别线性运行时。如果你看到一个从' 0 '到某个' array.length '的for循环，你可能有' N '，或者线性运行时间。提到的弦反转的例子，是线性时间的最好例子。</li><li id="e3b2" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">准线性运行时间:表示为(N*Log(N))。当输入集增加1时，工作量增加1+一点点(即log(n))，您可以注意到一个准线性运行时间。准线性运行时领域的好例子很多不同类型的排序算法。</li><li id="2a82" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">二次运行时间:表示为(N*N)或(N)。“打印楼梯”的例子有一个二次运行时间。当集合中的每个元素都必须与其他每个元素进行比较时，或者当您注意到嵌套的for循环时，您可以确定二次运行时。经典的例子是<a class="ae ml" href="http://mathworld.wolfram.com/HandshakeProblem.html" rel="noopener ugc nofollow" target="_blank">‘握手问题’</a>。</li><li id="0f35" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">指数运行时间:表示为(2^N).向输入集添加一个元素会显著提高处理能力，几乎是两倍。任何具有指数时间的算法都应该绝对避免。任何具有指数运行时间的解决方案都可以作为参考点，直到找到替代方案。例如:寻找一个集合的子集。</li></ol></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="4d93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">识别复杂性的技巧。</p><p id="348c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦你对它有了一些经验，识别复杂性就变得容易了，但是没有100%的时间识别算法的时间复杂性的神奇公式。你需要不断的经验和实践，没有一成不变的规则。尽管如此，还是有一些建议:</p><ol class=""><li id="1422" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated">如果你曾经看到一个简单的for循环遍历一个集合，那很可能是线性运行时。请记住，遍历半个集合并不意味着，现在的运行时间是(N/2)，它仍然是(N)。即使循环在迭代中途中断，它仍然是线性运行时。</li><li id="5e13" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">遍历两个不同的集合，进入<strong class="jp ir">两个独立的循环</strong>，意味着在我们的运行时复杂性中引入了一个额外的术语。那可以写成(N+M)。“n”表示遍历第一个集合，“M”表示遍历第二个集合，因为两个集合可能不同。</li><li id="cdb7" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">两个嵌套的for循环？运行时间可能是二次的(N)。示例:阶梯算法或金字塔算法(如下)。此外，这种解决方案是一个巨大的危险信号，应该避免。</li></ol><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mm"><img src="../Images/fabbce94d967e78e988eea5f9d7f9dfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-OU4I2uo2qy3G_xKiraHJQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">print a pyramid</figcaption></figure><p id="55ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">两个嵌套的for循环，但是迭代不同的数据集合，可以表示为(N*M)。它不能再是(N)了。它与(N)没有太大的不同，因为它本质上是(N*N)。我们实际上只是在迭代另一组数据。基本上，对于N中的每条记录，我们都要遍历m中的每条记录。</p><p id="32e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单快捷方式:</p><ol class=""><li id="3906" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated">排序？很有可能它的运行时间是(N*Log(N))。</li><li id="b976" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">在一个排序的数组中搜索？(Log(N))。</li></ol><p id="9fdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回想起来，你只需要做到这一点。学习大量的算法，并练习它们，以真正擅长识别时间复杂性。没有绝对的、可以100%使用的神奇算法、公理或定律。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="4eb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">参考</p><ol class=""><li id="2b8f" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated"><a class="ae ml" href="https://www.udemy.com/course/coding-interview-bootcamp-algorithms-and-data-structure/" rel="noopener ugc nofollow" target="_blank"> <em class="mr">编码面试训练营</em> </a>作者<a class="ms mt ep" href="https://medium.com/u/d058882d8cd2?source=post_page-----c4f0bed0053--------------------------------" rel="noopener" target="_blank">斯蒂芬·格里德</a></li><li id="4da0" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><a class="ae ml" href="https://adrianmejia.com/most-popular-algorithms-time-complexity-every-programmer-should-know-free-online-tutorial-course/" rel="noopener ugc nofollow" target="_blank"> <em class="mr">每个程序员都应该知道的8个时间复杂性</em> </a> <em class="mr"> </em>作者<a class="ms mt ep" href="https://medium.com/u/e86755444968?source=post_page-----c4f0bed0053--------------------------------" rel="noopener" target="_blank">艾德里安·梅希亚</a></li></ol><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div></div>    
</body>
</html>