<html>
<head>
<title>Outstanding Performance predicting Amazon Stock applying Natural Language Processing (Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用自然语言处理(Python)预测亚马逊股票的杰出表现</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/outstanding-performance-predicting-amazon-stock-applying-natural-language-processing-python-2636cdd59bbe?source=collection_archive---------1-----------------------#2020-10-02">https://medium.datadriveninvestor.com/outstanding-performance-predicting-amazon-stock-applying-natural-language-processing-python-2636cdd59bbe?source=collection_archive---------1-----------------------#2020-10-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="bdf0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单是关键。</p><h1 id="0f97" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">目标</h1><p id="f5eb" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在本教程中，我们将制作一个机器学习管道，它输入新闻并应用NLP来生成<a class="ae lr" href="https://www.openblender.io/#/dataset/explore/5d4c39159516290b01c8246b/or/41" rel="noopener ugc nofollow" target="_blank">亚马逊股价</a>T4的<strong class="js iu">预测。</strong></p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/12a075b884a0f4227e2a41a6694f06fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QCDqGFquKcD-aiXc0NSWSg.jpeg"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Image taken from Amazon.com</figcaption></figure><p id="d5a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还将衡量<strong class="js iu">它在现实生活中的盈利能力</strong>。</p><h1 id="5374" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">我们要做什么</h1><ul class=""><li id="4aed" class="mi mj it js b jt lm jx ln kb mk kf ml kj mm kn mn mo mp mq bi translated">步骤1:设置技术<strong class="js iu">先决条件</strong></li><li id="3f6a" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">第二步:<strong class="js iu">获取2017年以来每日亚马逊蜡烛的数据</strong></li><li id="67a2" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">步骤3:定义并理解ML的<strong class="js iu">目标</strong></li><li id="da89" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">第4步:<strong class="js iu">将</strong>商业新闻融入我们的数据并理解令牌</li><li id="a78f" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">第五步:<strong class="js iu">准备</strong>我方数据<strong class="js iu"> </strong>并应用ML</li><li id="f637" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">第六步:测量和分析<strong class="js iu">结果</strong></li><li id="5a60" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">第七步:打破数据和<strong class="js iu">训练/测试</strong>穿越时间</li></ul><h1 id="147f" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">第一步。先决条件</h1><ul class=""><li id="bcf6" class="mi mj it js b jt lm jx ln kb mk kf ml kj mm kn mn mo mp mq bi translated">安装Python 3.1(或更高版本)</li><li id="521a" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">安装熊猫、sklearn和openblender(带pip)</li></ul><pre class="lt lu lv lw gt mw mx my mz aw na bi"><span id="68cf" class="nb kp it mx b gy nc nd l ne nf">$ pip install pandas OpenBlender scikit-learn</span></pre><h1 id="108a" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">第二步。获取数据</h1><p id="5a7b" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我们将使用这个每日<a class="ae lr" href="https://www.openblender.io/#/dataset/explore/5d4c39159516290b01c8246b/or/41" rel="noopener ugc nofollow" target="_blank">亚马逊每日价格</a>数据集，</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ng"><img src="../Images/21fa1f3248800890d5a1159e407bd0c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GUisTiuoiEVmAtIm.png"/></div></div></figure><p id="bab7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它有每天的最高价、最低价、开盘价和收盘价，以及当天的百分比变化。</p><p id="e3e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以让我们<strong class="js iu">通过OpenBlender API <strong class="js iu">拉数据</strong>。</strong>打开一个python脚本，运行以下代码:</p><pre class="lt lu lv lw gt mw mx my mz aw na bi"><span id="7c52" class="nb kp it mx b gy nc nd l ne nf"># Import the libraries<br/>import OpenBlender<br/>import pandas as pd<br/>import numpy as np<br/>import json</span><span id="85fd" class="nb kp it mx b gy nh nd l ne nf">token = '<strong class="mx iu">YOUR_TOKEN_HERE</strong>'</span><span id="092b" class="nb kp it mx b gy nh nd l ne nf"># Specify the action<br/>action = 'API_getObservationsFromDataset'</span><span id="e92c" class="nb kp it mx b gy nh nd l ne nf">interval = 60 * 60 * 24 # One day</span><span id="7732" class="nb kp it mx b gy nh nd l ne nf">parameters = { <br/> 'token' : token,<br/>    'id_dataset':'5d4c39159516290b01c8246b',<br/>    'date_filter':{"start_date":"2017-01-01T06:00:00.000Z",<br/>                   "end_date":"2020-10-01T06:00:00.000Z"},<br/>    'aggregate_in_time_interval' : {<br/>              'time_interval_size' : interval, <br/>              'output' : 'avg', <br/>              'empty_intervals' : 'impute'<br/>      }<br/>}<br/>        <br/># Pull the data into a Pandas Dataframe<br/>df = pd.read_json(json.dumps(OpenBlender.call(action, parameters)['sample']), convert_dates=False, convert_axes=False)<br/>df.reset_index(drop=True, inplace=True)<br/>df['date'] = [OpenBlender.unixToDate(ts, timezone = 'GMT') for ts in df.timestamp]<br/>df = df.drop('timestamp', axis = 1)</span></pre><p id="b331" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意:</strong>要获得您<em class="ni">需要的令牌</em>必须在<a class="ae lr" href="https://www.openblender.io/#/welcome/or/41" rel="noopener ugc nofollow" target="_blank"> openblender.io </a>(免费)上创建一个帐户，您可以在您个人资料图标的“帐户”选项卡中找到它。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/f9fea9c50970a75a9df27518ff51b95b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/0*bOq7fVIpOyeTVStR.png"/></div></figure><p id="f079" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们来看看数据:</p><pre class="lt lu lv lw gt mw mx my mz aw na bi"><span id="9c1f" class="nb kp it mx b gy nc nd l ne nf">df.head()</span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nk"><img src="../Images/8e04958fc8ff69a7acdf6d65586e89b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uLWpxm5pXzStDdxwUTByjQ.png"/></div></div></figure><p id="34a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">检查！</p><h1 id="8328" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">第三步。定义和理解目标</h1><p id="2ec7" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">首先，我们要定义收盘价和开盘价之间的<strong class="js iu">变化百分比</strong>，这样我们就可以得到当天的<strong class="js iu">表现。</strong></p><p id="8dbc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了方便起见，让我们使用<a class="ae lr" href="https://faculty.fuqua.duke.edu/~rnau/Decision411_2007/411log.htm#:~:text=First%20difference%20of%20LOG%20%3D%20percentage%20change%3A%20When%20used%20in%20conjunction,Y%20from%20period%20to%20period." rel="noopener ugc nofollow" target="_blank">对数差</a>(接近百分比变化，对于本教程来说实际上是等效的)。</p><pre class="lt lu lv lw gt mw mx my mz aw na bi"><span id="92c0" class="nb kp it mx b gy nc nd l ne nf">df['change'] = np.log(df['close']) - np.log(df['open'])</span></pre><p id="4256" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们绘制收盘价和变化图。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nl"><img src="../Images/c8ec7550dff3c475c9e0c42d94148f53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QyXrEH1-xWcgQNNZ2eizhQ.png"/></div></div></figure><p id="8e57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“变化”变量是一天的收盘价相对于开盘价的百分比增量或减量。</p><p id="8425" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们将我们的<strong class="js iu">目标变量</strong>定义为大于0.5%的增长(这样就不值得购买了):</p><p id="0d74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">阳性POC: </strong>其中“变化”增加超过0.5%</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nm"><img src="../Images/f74440f1246c6de3959247aed1bb353c.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/0*eVM5W01Ld6SdCu4n.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Distribution of ‘change’ (x100)</figcaption></figure><p id="28f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着绿线右侧的所有观察结果都将是我们的“成功”情景。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nn"><img src="../Images/4ea83fb5378c690ec325d92f551dd4fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1Y4CM9futF10hcFq"/></div></div></figure><h1 id="36e9" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">第四步。向量化和混合商业新闻</h1><p id="ec89" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">这是<strong class="js iu">非常</strong> <strong class="js iu">简单</strong>地执行，但是让我们试着理解在后台发生了什么。</p><p id="a62b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们想要的:</p><ol class=""><li id="2d03" class="mi mj it js b jt ju jx jy kb no kf np kj nq kn nr mo mp mq bi translated">我们需要<strong class="js iu">收集有用的新闻数据</strong>，这些数据与我们的目标相关</li><li id="d31c" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn nr mo mp mq bi translated">我们希望将它融入我们的数据中，使<strong class="js iu">新闻与第二天的价格</strong>“变化”保持一致(这样模型就可以学习预测第二天的价格，我们就可以实际使用它)</li><li id="abb7" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn nr mo mp mq bi translated">我们想把它转换成<strong class="js iu">数字特征</strong>，这样它就可以遍历一个ML模型。</li></ol><p id="f968" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，让我们寻找时间重叠的商业新闻数据集:</p><pre class="lt lu lv lw gt mw mx my mz aw na bi"><span id="5217" class="nb kp it mx b gy nc nd l ne nf"># First we need to add the UNIX timestamp which is the number <br/># of seconds since 1970 on UTC, it is a very convenient <br/># format because it is the same in every time zone in the world!</span><span id="2156" class="nb kp it mx b gy nh nd l ne nf">df['timestamp'] = OpenBlender.dateToUnix(df['date'], <br/>                                           date_format = '%d-%m-%Y %H:%M:%S', <br/>                                           timezone = 'GMT')</span><span id="9575" class="nb kp it mx b gy nh nd l ne nf"># Now, let's search on OpenBlender</span><span id="f904" class="nb kp it mx b gy nh nd l ne nf">search_keyword = '<strong class="mx iu">business</strong>'</span><span id="802c" class="nb kp it mx b gy nh nd l ne nf">df = df.sort_values('timestamp').reset_index(drop = True)</span><span id="80eb" class="nb kp it mx b gy nh nd l ne nf">print('From : ' + OpenBlender.unixToDate(min(df.timestamp)))<br/>print('Until: ' + OpenBlender.unixToDate(max(df.timestamp)))</span><span id="2edc" class="nb kp it mx b gy nh nd l ne nf"># We need to pass our timestamp column and <br/># search keywords as parameters.</span><span id="4199" class="nb kp it mx b gy nh nd l ne nf">OpenBlender.searchTimeBlends(token,<br/>                             df.timestamp,<br/>                             search_keyword)</span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ns"><img src="../Images/88e43dc375a0f01ca8ea5bed78d4909c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DxPEVyAGZ1Nh8BUH.png"/></div></div></figure><p id="9826" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到时间重叠(交叉)数据集及其一些属性，甚至可以看到界面的url。</p><p id="de2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，让我们挑选这个<a class="ae lr" href="https://www.openblender.io/#/dataset/explore/5e2ef74e9516294390e810a9/or/41" rel="noopener ugc nofollow" target="_blank">华尔街日报新闻</a>数据集:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nt"><img src="../Images/d1fafcc5cd53cd305c9f155d6123929f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AQnbkhj43qbmg-Z1.png"/></div></div></figure><p id="cccf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这条<a class="ae lr" href="https://www.openblender.io/#/dataset/explore/5e32fd289516291e346c1726/or/41" rel="noopener ugc nofollow" target="_blank">今日美国</a>推特新闻。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nu"><img src="../Images/f0dfa753fd2152ad985316efd8c46112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xYZO6DP7cR2st8a6.png"/></div></div></figure><ul class=""><li id="ab4b" class="mi mj it js b jt ju jx jy kb no kf np kj nq kn mn mo mp mq bi translated"><em class="ni">注:</em>我选择这些是因为它们有意义，但你可以搜索数百个其他的。</li></ul><p id="e263" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过搜索按时间聚合的新闻术语，将新的栏目融合到我们的数据集中。例如，我们可以创建一个“亚马逊”特性，其中包含来自“华尔街”数据集的新闻数量，这些新闻数量与我们自制的ngrams相匹配:</p><pre class="lt lu lv lw gt mw mx my mz aw na bi"><span id="a410" class="nb kp it mx b gy nc nd l ne nf">text_filter = {'name' : 'amazon', <br/>               'match_ngrams': ['amazon', 'bezos', 'audible', 'aws',<br/>                                'diapers','goodreads','techstreet']}</span><span id="893d" class="nb kp it mx b gy nh nd l ne nf"># We need to pass the 'id_dataset', the name of the<br/># column (which is 'text') and an optional filter.</span><span id="93dd" class="nb kp it mx b gy nh nd l ne nf">blend_source = {<br/>                'id_dataset':'<strong class="mx iu">5e2ef74e9516294390e810a9</strong>',<br/>                'feature' : '<strong class="mx iu">text</strong>',<br/>                'filter_text' : <strong class="mx iu">text_filter</strong><br/>            }</span><span id="5dca" class="nb kp it mx b gy nh nd l ne nf">df_blend = OpenBlender.timeBlend( token = token,<br/>                                  anchor_ts = df.timestamp,<br/>                                  blend_source = blend_source,<br/>                                  blend_type = 'agg_in_intervals',<br/>                                  interval_size = 60 * 60 * 24,<br/>                                  direction = 'time_prior',<br/>                                  interval_output = 'list')</span><span id="5af3" class="nb kp it mx b gy nh nd l ne nf">df_anchor = pd.concat([df, df_blend.loc[:, df_blend.columns != 'timestamp']], axis = 1)<br/>df_anchor</span></pre><p id="06ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">timeBlend功能的参数(您可以在此处找到文档<a class="ae lr" href="https://www.openblender.io/#/api_documentation" rel="noopener ugc nofollow" target="_blank">):</a></p><ul class=""><li id="311b" class="mi mj it js b jt ju jx jy kb no kf np kj nq kn mn mo mp mq bi translated"><strong class="js iu"> anchor_ts </strong>:我们只需要发送我们的时间戳列，这样它就可以作为一个锚来混合外部数据。</li><li id="380c" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu"> blend_source </strong>:关于我们想要的特性的信息。</li><li id="2c4d" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">blend _ type</strong>:‘agg _ in _ intervals’因为我们想要对我们的每个观察值进行24小时间隔聚合。</li><li id="bc98" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu"> inverval_size </strong>:间隔的大小，以秒为单位(本例中为24小时)。</li><li id="f916" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">方向</strong>:‘time _ prior’因为我们希望间隔收集之前24小时的观察值，而不是向前。</li></ul><p id="fa4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出是两个新的列，我们的“亚马逊”功能的“计数”和一个实际新闻的列表，以防有人想遍历每一个。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nv"><img src="../Images/d7b2208bfbed2eaff31dbe06d8ebbbbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A9G4l67UwPb13PmAo3oJLA.png"/></div></div></figure><p id="2391" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看看这一变化，以及过去24小时内我们的“亚马逊”功能被提及的次数。会是有用的关系吗？</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nl"><img src="../Images/080456f2aada6174e33825d5738964ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6_dmUUfIKwn6ZedG06VFKA.png"/></div></div></figure><p id="c39b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在还很难说，我们可以探索几种不同的配置或变量，甚至可以在每次观察中遍历文本列表，并执行任何类型的处理。可能性是无限的。</p><p id="56e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们<strong class="js iu">创建一个文本矢量器</strong>，它是OpenBlender上的一个模型，你可以从中提取数千个计算化的ngrams作为特征:</p><pre class="lt lu lv lw gt mw mx my mz aw na bi"><span id="6c15" class="nb kp it mx b gy nc nd l ne nf">action = 'API_createTextVectorizerPlus'parameters = {<br/>    'token' : token,<br/>    'name' : 'Wall Street and USA Today Vectorizer',<br/>    'sources':[<br/>              {'id_dataset':"<strong class="mx iu">5e2ef74e9516294390e810a9</strong>", <br/>               'features' : ["<strong class="mx iu">text</strong>"]},<br/>              {'id_dataset' : "<strong class="mx iu">5e32fd289516291e346c1726</strong>", <br/>               'features' : ["<strong class="mx iu">text</strong>"]}<br/>    ],<br/>    'ngram_range' : {'min' : 1, 'max' : 2},<br/>    'language' : 'en',<br/>    'remove_stop_words' : 'on',<br/>    'min_count_limit' : 2<br/>}response = OpenBlender.call(action, parameters)<br/>response</span></pre><p id="0aa6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据上述内容，我们指定了以下内容:</p><ul class=""><li id="be5e" class="mi mj it js b jt ju jx jy kb no kf np kj nq kn mn mo mp mq bi translated"><strong class="js iu">名称:</strong>我们将其命名为“华尔街和今日美国矢量器”</li><li id="c4e6" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">源</strong>:作为源包含的数据集的id和源列(在本例中，两者都只有一个名为‘text’)</li><li id="8a53" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu"> ngram_range </strong>:将被标记的单词集的最小和最大长度</li><li id="0671" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">语言:英语</li><li id="f6c9" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu"> remove_stop_words </strong>:这样就从源头上消除了停用词</li><li id="7471" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu"> min_count_limit </strong>:被认为是令牌的最小重复次数(出现一次很少有帮助)</li></ul><p id="69ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，如果我们转到OpenBlender的仪表板，我们可以看到矢量器:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nw"><img src="../Images/1e23dd77eecfa5fd0f3adabd6ee5a015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h_jv5JtMiS5FQYna.png"/></div></div></figure><p id="a88b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它生成了4999个n-gram，这些n-gram是最多2个单词的令牌的<strong class="js iu">二进制特征</strong>，如果提到了<strong class="js iu"> n-gram则为“1”</strong>否则为“0”。</p><p id="bc38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在<strong class="js iu">我们希望矢量化数据</strong>在24小时内压缩，并与第二天的亚马逊股价保持一致。</p><p id="5063" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你需要添加你的<strong class="js iu">矢量器的id </strong>(它是在你创建它的时候打印出来的，或者你可以在OpenBlender中得到它)。</p><pre class="lt lu lv lw gt mw mx my mz aw na bi"><span id="a824" class="nb kp it mx b gy nc nd l ne nf">blend_source = { <br/>                'id_textVectorizer':'<strong class="mx iu">5f74fb7895162967ca2160fe</strong>'<br/>               }df_blend = OpenBlender.timeBlend( token = token,<br/>                                  anchor_ts = df_anchor.timestamp,<br/>                                  blend_source = blend_source,<br/>                                  blend_type = 'agg_in_intervals',<br/>                                  interval_size = 60 * 60 * 24,<br/>                                  direction = 'time_prior_strict') .add_prefix('VEC.')df_anchor = pd.concat([df_anchor, df_blend.loc[:, df_blend.columns != 'timestamp']], axis = 1)<br/>df_anchor.head()</span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nx"><img src="../Images/ac0f31bb190fb5960de6c9e829724e11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VPPzo6ElJf-WdMhM.png"/></div></div></figure><p id="d06c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了<strong class="js iu"> 1068 </strong>个观测值和<strong class="js iu"> 4887 </strong>个特征。我们的原始数据集加上过去24小时的矢量化和聚合新闻。</p><h1 id="3dba" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">第五步。准备数据并应用ML</h1><p id="fb2a" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">没有更多的争论或清理要做，我们只需要<strong class="js iu">创建我们的目标特性</strong>正POC和负POC(我们将使用‘正POC’来实现前面定义的目的)。</p><pre class="lt lu lv lw gt mw mx my mz aw na bi"><span id="33d0" class="nb kp it mx b gy nc nd l ne nf"># Where ‘change’ <strong class="mx iu">decreased</strong> more than 0.5%<br/>df_anchor['negative_poc'] = [1 if log_diff &lt; -0.005 else 0 for log_diff in df_anchor['change']]</span><span id="f770" class="nb kp it mx b gy nh nd l ne nf"># Where ‘change’ <strong class="mx iu">increased</strong> more than 0.5%<br/>df_anchor['positive_poc'] = [1 if log_diff &gt; 0.005 else 0 for log_diff in df_anchor['change']]</span><span id="9182" class="nb kp it mx b gy nh nd l ne nf"># We need to shift our target one day so that we predict <br/># for what will happen 'tomorrow' with news and data from 'today'<br/>df_anchor['target'] = df_anchor['positive_poc'].shift(-1)<br/>df_anchor[['change', 'positive_poc', 'target']]</span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/8b2220a425c8800abd6b7c037f4a2918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*sQFNjX7EDCnG_yPe2Ix0YQ.png"/></div></figure><p id="bcf3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了“<strong class="js iu">目标</strong>”功能，它只需<strong class="js iu">将</strong>的“变化”值与“<strong class="js iu">前一天的数据</strong>对齐，这正是我们所需要的。最近的观察(最后一次)是NaN，因为那是我们想要为“明天”预测的。</p><p id="caa4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们尝试一些ML来学习和预测<strong class="js iu">目标</strong>。</p><pre class="lt lu lv lw gt mw mx my mz aw na bi"><span id="7a20" class="nb kp it mx b gy nc nd l ne nf"># Import libraries<br/>from sklearn.ensemble import RandomForestRegressor<br/>from sklearn.metrics import roc_auc_score<br/>from sklearn.metrics import accuracy_score<br/>from sklearn import metrics<br/>df_anchor = df_anchor[:-1] # Remove the last one with NaN# Define target<br/>target = 'target'<br/>df_positive = df_anchor[1:].select_dtypes(['number'])# Create train/test sets<br/>X = df_positive.loc[:, df_positive.columns != target].values<br/>y = df_positive.loc[:,[target]].values<br/>div = int(round(len(X) * 0.71))X_train = X[:div]<br/>y_train = y[:div]<br/>X_test = X[div:]<br/>y_test = y[div:]print('Train:')<br/>print(X_train.shape)<br/>print(y_train.shape)<br/>print('Test:')<br/>print(X_test.shape)<br/>print(y_test.shape)</span></pre><p id="edd2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">产出:</p><pre class="lt lu lv lw gt mw mx my mz aw na bi"><span id="a7db" class="nb kp it mx b gy nc nd l ne nf">Train:<br/>(970, 4888)<br/>(970, 1)<br/>Test:<br/>(396, 4888)<br/>(396, 1)</span></pre><p id="8912" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们训练模型并预测:</p><pre class="lt lu lv lw gt mw mx my mz aw na bi"><span id="9fa5" class="nb kp it mx b gy nc nd l ne nf">rf = RandomForestRegressor(n_estimators = 1000, random_state = 1)<br/>rf.fit(X_train, y_train)<br/>y_pred = rf.predict(X_test)</span></pre><h1 id="5889" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">第六步。分析结果</h1><p id="178e" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">现在公布结果。</p><pre class="lt lu lv lw gt mw mx my mz aw na bi"><span id="bc75" class="nb kp it mx b gy nc nd l ne nf">print("AUC score:")<br/>print(roc_auc_score(y_test, y_pred))<br/>print('---')# Let's binarize and look at the confusion matrix<br/>preds = [1 if val &gt; 0.5 else 0 for val in y_pred]<br/>print('Confusion Matrix:')<br/>print(metrics.confusion_matrix(y_test, preds))<br/>print('---')# Lets look at the accuracy score<br/>print('Accuracy:')<br/>print(accuracy_score(y_test, preds))<br/>print('---')</span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nz"><img src="../Images/82efa84e4b5844df8dbe54636e3a4a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RUVDTxpYeNFytb7JG1WIRg.png"/></div></div></figure><p id="4380" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们来分析一下结果。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi oa"><img src="../Images/6d27a0cdea56f835ac9086a262b1c316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D1TTBh3pCFdaGJYq6ph9xQ.png"/></div></div></figure><p id="25db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该模型正确地检测到了98次起义(总共140次),从180次“起义”预测中，它正确了98次。它还正确地过滤掉了174个“非起义”案例(共216个)。</p><p id="ec62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们在一天结束时运行模型，我们可以在第二天早上买入/做空，期待当天结束时的结果。</p><h1 id="d4c2" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">第七步。打破时间的数据</h1><p id="3652" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">现在，我们需要一种方法，在这种方法中，数据经过训练和测试，以观察结果是否一致。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/1395593ff20309ecbb6f0aeff26cbe70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/0*xKjSdpZLZjFBmo4z.png"/></div></figure><p id="99f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们运行我们刚刚做的，但是在这个循环中中断数据。</p><pre class="lt lu lv lw gt mw mx my mz aw na bi"><span id="015f" class="nb kp it mx b gy nc nd l ne nf">results = []<br/>for i in range(0, 90, 5): <br/>    time_chunk = i/100<br/>    print('time_chunk:' + str(time_chunk) + ' starts')<br/>    df_ml = df_positive[:int(round(df_positive.shape[0] * (time_chunk + 0.4)))]<br/>    X = df_ml.loc[:, df_ml.columns != target].values<br/>    y = df_ml.loc[:,[target]].values<br/>    div = int(round(len(X) * 0.71))<br/>    X_train = X[:div]<br/>    y_train = y[:div]<br/>    X_test = X[div:]<br/>    y_test = y[div:]</span><span id="41ff" class="nb kp it mx b gy nh nd l ne nf">    rf = RandomForestRegressor(n_estimators = 1000, random_state = 1)<br/>    rf.fit(X_train, y_train)<br/>    y_pred = rf.predict(X_test)<br/>    preds = [1 if val &gt; 0.5 else 0 for val in y_pred]<br/>    try:<br/>        roc = roc_auc_score(y_test, y_pred)<br/>    except:<br/>        roc = 0<br/>    conf_mat = metrics.confusion_matrix(y_test, preds)<br/>    accuracy = accuracy_score(y_test, preds)<br/>    results.append({<br/>        'roc' : roc,<br/>        'accuracy' : accuracy,<br/>        'conf_mat' : conf_mat,<br/>        'time_chunk' : time_chunk<br/>    })</span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/0447f62093c633bce9213acf899f4777.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/0*N1bozZjSDlrH0mmR.png"/></div></figure><p id="2361" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到<strong class="js iu">指标增加</strong>并稳定低谷时间！</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi od"><img src="../Images/90e449d229b76733845c88d4af4dfc2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/0*rbERQMVvOh_JNkBB.png"/></div></figure></div></div>    
</body>
</html>