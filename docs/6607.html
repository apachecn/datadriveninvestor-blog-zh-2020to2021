<html>
<head>
<title>Big O Notation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O符号</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/big-o-notation-14fa1e4538a1?source=collection_archive---------2-----------------------#2020-11-02">https://medium.datadriveninvestor.com/big-o-notation-14fa1e4538a1?source=collection_archive---------2-----------------------#2020-11-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2fe2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">数组及其内置方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fa83494ae65074992ab77a567028d853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qA5a6_cUqBXjDWa-"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@oliverschwendener?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Oliver Schwendener</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2dfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我以前的大O符号博客中，我们讨论了<a class="ae kv" href="https://medium.com/swlh/big-o-notation-128b7b8051c9" rel="noopener">时间</a>和<a class="ae kv" href="https://medium.com/@sedlacek1991/big-o-notation-8a0a28f00813" rel="noopener">空间</a>复杂性和<a class="ae kv" href="https://sedlacek1991.medium.com/big-o-notation-6b19d3f03f7f" rel="noopener">物体</a>。现在我们来看看大O，以及它与数组及其内置方法的关系。</p><p id="1e6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数组是一种有序的数据结构，可用于存储任何类型的数据。或者，用更专业的术语来说，“当我们用编程语言初始化一个数组时，该语言为你的数组分配内存空间，然后将那个起始变量指向内存中的那个地址。然后程序为每个元素分配固定数量的内存”(Learn)。下面是一个简单的多数据类型数组的例子。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="bf5f" class="lx ly iq lt b gy lz ma l mb mc"><strong class="lt ir">const</strong> array = [ "a", {}, 7, [], false]</span></pre><p id="4211" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就大O而言，当我们需要快速访问元素时，数组是有利的。在上面的例子中，我们可以通过索引来访问每个元素；array[0] = "a "，array[4] = false。因为元素是有索引的，所以我们的计算机知道元素的确切位置，并且可以直接找到元素。此外，对于访问方法，具有2个元素或2，000个元素的数组具有相同的时间复杂度O(1)。</p><p id="257c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在某些插入或移除方法中，数组也可以很快。这些类型的方法要么有O(1)，要么有O(n)。不同之处在于元素在数组中的插入或移除位置。如果从数组末尾插入或移除元素，这些方法的值为O(1 ),因为只有最后一个索引元素受到影响。但是，如果从数组的开头插入或移除元素，所有元素都会受到影响。例如，如果我们将一个元素添加到数组的开头，则添加的元素将占据索引0，而之前位于索引0的元素现在位于索引1，依此类推。因为操作的数量随着数组中元素的数量而增长，所以这些方法有一个O(n)。</p><p id="f296" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，数组有一个O(n)用于搜索方法。这是因为搜索方法的最坏情况是检查数组中的每个元素。</p><div class="md me gp gr mf mg"><a href="https://www.datadriveninvestor.com/2020/07/23/learn-data-science-in-a-flash/" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd ir gy z fp ml fr fs mm fu fw ip bi translated">一瞬间学会数据科学！？数据驱动的投资者</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">在我之前的职业生涯中，我是一名训练有素的古典钢琴家。还记得那些声称你可以…</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu kp mg"/></div></div></a></div><p id="4eb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">数组内置方法</strong></p><p id="5118" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数组有许多不同的内置方法，但是我们在这里要看的方法是push、pop、shift、unshift、concat、slice、splice、sort和map。</p><p id="0ed8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前两种方法push和pop涉及在数组末尾添加或移除元素。正如我们前面提到的，这些类型的方法有一个O(1 ),因为它们只影响数组的最后一个元素。</p><p id="6557" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">移位和取消移位，包括从数组的开头添加或删除。如前所述，这些方法的运行时间随着输入或O(n)而增长，因为它们影响数组中的所有索引。</p><p id="0c2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与移位和取消移位类似，串联、切片和拼接都有一个O(n)。Concat用于将两个或多个数组组合成一个新数组。此外，随着您正在组合的每个数组中的输入数量的增长，运行时间也以线性方式增长。Slice涉及到复制一个数组，并且运行时间随着输入以线性方式增长。Splice是一种“通过删除现有元素和/或添加新元素来更改数组内容”的方法(MDN)。虽然splice可以从数组中的任何位置删除/添加元素，但它有一个O(n ),因为在最坏的情况下，所有数组输入都会受到影响。</p><p id="e607" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">排序方法的O(n * log n)比O(n)更差。这是因为排序方法需要在元素之间进行比较，并且元素可能需要被访问多次。</p><p id="11de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将讨论的数组的最后一个内置方法是map。这个方法有一个O(n)并且通过创建“…一个新的数组，该数组填充了在调用数组中的每个元素上调用一个提供的函数的结果”(MDN)。这个函数有O(n)的原因是因为它必须与数组中的每个元素至少交互一次。因此，数组的大小直接影响运行时间。</p><p id="224e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是这篇博客中讨论的方法类型和内置方法的总结，以及它们与大O符号的关系。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/74328cd3a5586ff9802619ee873833b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*wL1t9t-pFiBX528sZTZw1g.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Summary Table based on lecture material presented in Colt Steele’s Udemy Course</figcaption></figure><p id="d43b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您花时间通过大O符号的视角来了解更多关于数组的知识。这是我的大O符号系列的最后一篇博客，我希望你现在理解了大O符号的重要性，并能在你编写和解释代码时应用它。</p><p id="206f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">资源</strong></p><p id="1a6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">斯蒂尔，加州(未注明)。<em class="mw"> JavaScript算法和数据结构大师班</em>。在线课程。</p><p id="08fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的数组。(未注明)。检索于2020年10月30日，发自https://learn.co/lessons/arrays-underneath<a class="ae kv" href="https://learn.co/lessons/arrays-underneath" rel="noopener ugc nofollow" target="_blank"/></p><p id="f92b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">" Array.prototype.splice()。"<em class="mw"> MDN Web Docs </em>，developer . Mozilla . org/en-US/Docs/Web/JavaScript/Reference/Global _ Objects/Array/splice。</p><p id="cb40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">" Array.prototype.map()"<em class="mw"> MDN Web Docs </em>，developer . Mozilla . org/en-US/Docs/Web/JavaScript/Reference/Global _ Objects/Array/map。</p><h2 id="8e28" class="lx ly iq bd mx my mz dn na nb nc dp nd lf ne nf ng lj nh ni nj ln nk nl nm nn bi translated">访问专家视图— <a class="ae kv" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank">订阅DDI英特尔</a></h2></div></div>    
</body>
</html>