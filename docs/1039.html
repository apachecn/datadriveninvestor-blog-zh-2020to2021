<html>
<head>
<title>Make secure your API Gateway Lambda Authorizers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">确保API网关Lambda授权器的安全</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/make-secure-your-api-gateway-lambda-authorizers-c1c1ea03d099?source=collection_archive---------1-----------------------#2020-02-28">https://medium.datadriveninvestor.com/make-secure-your-api-gateway-lambda-authorizers-c1c1ea03d099?source=collection_archive---------1-----------------------#2020-02-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e426" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我不确定是不是几乎所有人都已经知道了。对我来说，通过添加新的层来防止任何人从API网关访问我们的核心API，来制作安全的API网关是一种新的和有用的方法。</p><p id="1182" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">众所周知，API Gateway中有三种类型的认证。其中，现在我计划展示如何用lambda授权器认证API网关，以及如何用Cloudformation模板设置下面的架构。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/652adbc8f4764393abd39decfbb08cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*MSfq_yxUGsP5BXksFLJjLA.jpeg"/></div></figure><p id="89b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如上图所示，当一个请求被核心api使用时，它必须首先通过Lambda认证函数，然后Lambda将验证该请求是否有效。如果有效，该函数将生成策略文档并发送给我们核心api。</p><div class="kw kx gp gr ky kz"><a href="https://www.datadriveninvestor.com/2019/02/25/6-alternatives-to-the-yahoo-finance-api/" rel="noopener  ugc nofollow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd iu gy z fp le fr fs lf fu fw is bi translated">雅虎财经API |数据驱动投资者的6种替代方案</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">长期以来，雅虎金融API一直是许多数据驱动型投资者的可靠工具。许多人依赖于他们的…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="li l"><div class="lj l lk ll lm li ln ku kz"/></div></div></a></div><p id="0541" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我将写如何为其API网关Lambda认证的整个架构创建Cloudformation模板。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><p id="682e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，IAM角色现在需要先创建来消费核心Lambda函数。这个角色就是允许在我的账户中消费任何lambda服务。</p><pre class="kp kq kr ks gt lv lw lx ly aw lz bi"><span id="f5fd" class="ma mb it lw b gy mc md l me mf">CoreIAMAPILambdaRole:<br/>    Type: AWS::IAM::Role<br/>    Description: Lambda Function Role that will access to Core API.<br/>    Properties:<br/>      RoleName: CoreIAMAPILambdaRole<br/>      AssumeRolePolicyDocument:<br/>        Version: 2012-10-17<br/>        Statement:<br/>          - Action:<br/>              - sts:AssumeRole<br/>            Effect: Allow<br/>            Principal:<br/>              Service:<br/>                - lambda.amazonaws.com<br/>                - apigateway.amazonaws.com</span><span id="78d9" class="ma mb it lw b gy mg md l me mf">      Policies:<br/>        - PolicyDocument:<br/>            Version: 2012-10-17<br/>            Statement:<br/>              - Effect: Allow<br/>                Action:<br/>                  - <strong class="lw iu">lambda:InvokeFunction</strong><br/>                Resource: "*"<br/>          PolicyName: CoreIAMAPILambdaPolicy</span></pre><p id="e09f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我在这里创建简单的lambda函数作为核心服务。不，这只是简单的代码，没别的。</p><pre class="kp kq kr ks gt lv lw lx ly aw lz bi"><span id="fa4a" class="ma mb it lw b gy mc md l me mf">CoreAPILambda:<br/>    Type: AWS::Lambda::Function<br/>    Properties:<br/>      Code:<br/>        ZipFile: |<br/>          'use strict'<br/>          exports.handler = async (event) =&gt; {<br/>            response = {<br/>              statusCode: 200,<br/>              body: {<br/>                message: 'Yay, I am passed'<br/>              }<br/>            }<br/>            return response;<br/>          }          <br/>      Description: This is Our Core Lambda API<br/>      FunctionName: our-core-lambda-pai<br/>      Handler: index.handler<br/>      MemorySize: 128<br/>      <strong class="lw iu">Role: !GetAtt CoreIAMAPILambdaRole.Arn</strong><br/>      Runtime: nodejs10.x<br/>      Timeout: 5</span></pre><p id="f873" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">希望您会注意到，以前创建的IAM角色附加到该功能。重要的是你永远不会忘记这件事。请继续收听，主要演员马上就要来了。</p><p id="f3ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，下面是如何在我们的主参与者中验证请求。</p><pre class="kp kq kr ks gt lv lw lx ly aw lz bi"><span id="5df1" class="ma mb it lw b gy mc md l me mf">CoreAuthenticationAPILambda:<br/>    Type: AWS::Lambda::Function<br/>    Properties:<br/>      Code:<br/>        ZipFile: |<br/>          exports.handler = async event =&gt; {<br/>            let response = {}, token = {};<br/>            <strong class="lw iu">let authorizationToken = event.authorizationToken;</strong><br/>            <strong class="lw iu">if (authorizationToken === 'ignoreme') {</strong><br/>              token = {<br/>                effect: 'allow'<br/>              };<br/>            } else {<br/>              token = validation(authorizationToken);<br/>            }<br/>            switch (token.effect) {<br/>              case "allow":<br/>                response = generatePolicy("user", "Allow", event.methodArn);<br/>                break;<br/>              case "deny":<br/>                response = generatePolicy("user", "Deny", event.methodArn);<br/>                break;<br/>              case "unauthorized":<br/>                response = "Unauthorized";<br/>                break;<br/>              default:<br/>                response = "Error: Invalid token";<br/>            }<br/>            return response;<br/>          };</span><span id="b4e6" class="ma mb it lw b gy mg md l me mf">         <strong class="lw iu">const validation = token =&gt; {</strong><br/>            /*<br/>              Add your business logic and request validation HERE<br/>            */<br/>            let response = {<br/>              effect: "allow"<br/>            };<br/>            return response;<br/>          };</span><span id="0cb0" class="ma mb it lw b gy mg md l me mf">         <strong class="lw iu">const generatePolicy = (principalId, effect, resource) =&gt; {</strong><br/>            let authResponse = {};<br/>            authResponse.principalId = principalId;<br/>            if (effect &amp;&amp; resource) {<br/>              let policyDocument = {};<br/>              policyDocument.Version = "2012-10-17";<br/>              policyDocument.Statement = [];<br/>              let statementOne = {};<br/>              statementOne.Action = "execute-api:Invoke";<br/>              statementOne.Effect = effect;<br/>              statementOne.Resource = resource;<br/>              policyDocument.Statement[0] = statementOne;<br/>              authResponse.policyDocument = policyDocument;<br/>            }<br/>            return authResponse;<br/>          };      <br/>      Description: This is Our Core Lambda API<br/>      FunctionName: our-core-lambda-pai<br/>      Handler: index.handler<br/>      MemorySize: 128<br/>      <strong class="lw iu">Role: !GetAtt CoreIAMAPILambdaRole.Arn</strong><br/>      Runtime: nodejs10.x<br/>      Timeout: 5</span></pre><p id="08f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的代码片段中，你会注意到很多我们将要关注的亮点。</p><pre class="kp kq kr ks gt lv lw lx ly aw lz bi"><span id="8624" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">let authorizationToken = event.authorizationToken;</strong></span></pre><p id="ae15" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它向我们的api网关发送认证令牌。这个toke应该是您生成的OAuth或AWS Cognito令牌或其他什么。</p><pre class="kp kq kr ks gt lv lw lx ly aw lz bi"><span id="6336" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">if (authorizationToken === ‘ignoreme’) {</strong></span></pre><p id="5da4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这也很重要。现在，所有api都不需要进行验证，有些API也应该加入白名单。在这种情况下，您将向<strong class="js iu"> authorizationToken </strong>传递一些验证应该忽略的指示。到目前为止，明白了吗？</p><pre class="kp kq kr ks gt lv lw lx ly aw lz bi"><span id="6002" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">const validation = token =&gt; {</strong></span></pre><p id="9575" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，这就是有效<strong class="js iu">授权令牌</strong>的地方。您可以在这里添加您的业务逻辑和验证逻辑。对我来说，我使用AWS Cognito令牌作为<strong class="js iu">授权令牌</strong>传递，并将该Cognito令牌和访问时间添加到AWS ElasticCache ( <strong class="js iu"> Redis </strong>)中。因此，Cognito令牌是否过期是有效的。如果yes过期，则需要根据Redis中的访问时间再次刷新。</p><pre class="kp kq kr ks gt lv lw lx ly aw lz bi"><span id="9d0b" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">const generatePolicy = (principalId, effect, resource) =&gt; {</strong></span></pre><p id="5408" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它将根据验证结果为请求生成<strong class="js iu">允许</strong>还是<strong class="js iu">拒绝</strong>的策略。你可以在AWS官方文档中查看详细信息。</p><p id="1549" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae mh" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/API gateway/latest/developer guide/API gateway-use-lambda-authorizer . html</a></p><p id="01c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们将把IAM角色和两个lambda函数集成到API Gateway中。</p><pre class="kp kq kr ks gt lv lw lx ly aw lz bi"><span id="7b9f" class="ma mb it lw b gy mc md l me mf">OurOpenAPI:<br/>  <strong class="lw iu">Type: AWS::ApiGateway::RestApi</strong><br/>  Properties:<br/>    Name: our-open-api<br/>    EndpointConfiguration:<br/>      Types:<br/>      - EDGE</span><span id="c398" class="ma mb it lw b gy mg md l me mf">OurOpenAPIResource:<br/>  <strong class="lw iu">Type: AWS::ApiGateway::Resource</strong><br/>  Properties:<br/>    ParentId:<br/>      Fn::GetAtt:<br/>      - OurOpenAPI<br/>      - RootResourceId<br/>    <strong class="lw iu">PathPart: "/users"</strong><br/>    RestApiId: !Ref OurOpenAPI</span><span id="6b99" class="ma mb it lw b gy mg md l me mf">Authorizer:<br/><strong class="lw iu">  Type: AWS::ApiGateway::Authorizer<br/>  Properties:<br/>    AuthorizerCredentials: !GetAtt CoreIAMAPILambdaRole.Arn</strong><br/>    <strong class="lw iu">AuthorizerResultTtlInSeconds: '0'</strong><br/>    AuthorizerUri: !Join <br/>      - ''<br/>      - - 'arn:aws:apigateway:'<br/>        - !Ref 'AWS::Region'<br/>        - ':lambda:path/2015-03-31/functions/'<br/>        - !GetAtt <br/>          - <strong class="lw iu">CoreAuthenticationAPILambda</strong><br/>          - Arn<br/>        - /invocations<br/>    Type: TOKEN<br/><strong class="lw iu">    IdentitySource: method.request.header.Authentication<br/>    Name: apiAuthorizer<br/>    RestApiId: !Ref OurOpenAPI</strong><br/>    <br/><strong class="lw iu">OurOpenAPIMethod:<br/>  Type: "AWS::ApiGateway::Method"<br/>  DependsOn: LambdaPermission<br/>  Properties: <br/>    AuthorizationType: CUSTOM<br/>    AuthorizerId: !Ref Authorizer<br/>    RestApiId: !Ref OurOpenAPI<br/>    ResourceId: !Ref OurOpenAPIResource</strong><br/>    HttpMethod: GET<br/>    Integration: <br/>      Type: AWS<br/>      IntegrationHttpMethod: GET<br/>      Uri: !Sub 'arn:${AWS::Partition}:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${CoreAPILambda.Arn}/invocations'<br/>      IntegrationResponses: <br/>        - StatusCode: 200<br/>      RequestTemplates: <br/>        application/json: |<br/>          {<br/>            "body" : $input.json('$')<br/>          }<br/>      RequestParameters: <br/>        <strong class="lw iu">method.request.header.Authorization: true</strong><br/>      MethodResponses: <br/>        StatusCode: 200</span></pre><p id="4f60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，上面的代码片段是API Gateway的完整Cloudformation模板解决方案，用于集成我上面说过的两个lambda函数。正如您再次注意到的，还有许多您可能知道的高亮文本。</p><pre class="kp kq kr ks gt lv lw lx ly aw lz bi"><span id="638b" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">Type: AWS::ApiGateway::RestApi</strong></span></pre><p id="d07c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是在api gateway里面创建我们的OpenAPI，没什么。</p><pre class="kp kq kr ks gt lv lw lx ly aw lz bi"><span id="4276" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">Type: AWS::ApiGateway::Resource</strong></span></pre><p id="c03f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个资源，也就是我们api的路径。作为例子，我将like "/users "设置为路径。如果你想创建<strong class="js iu">学校</strong>或者<strong class="js iu">宠物</strong>或者<strong class="js iu">其他的</strong>，这是你的选择。</p><pre class="kp kq kr ks gt lv lw lx ly aw lz bi"><span id="f9cb" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">Type: AWS::ApiGateway::Authorizer<br/>  Properties:<br/>    AuthorizerCredentials: !GetAtt CoreIAMAPILambdaRole.Arn</strong><br/>    <strong class="lw iu">AuthorizerResultTtlInSeconds: '0'</strong></span></pre><p id="e283" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它将在API网关中添加我们的自定义lambda authoriser作为自定义身份验证方法，并附加到CoreAPI网关。</p><pre class="kp kq kr ks gt lv lw lx ly aw lz bi"><span id="0a22" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">OurOpenAPIMethod:<br/>  Type: "AWS::ApiGateway::Method"<br/>  DependsOn: LambdaPermission<br/>  Properties: <br/>    AuthorizationType: CUSTOM<br/>    AuthorizerId: !Ref Authorizer<br/>    RestApiId: !Ref OurOpenAPI<br/>    ResourceId: !Ref OurOpenAPIResource</strong></span></pre><p id="cd7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在要消费<a class="ae mh" href="https://myapi.com/users" rel="noopener ugc nofollow" target="_blank">https://myapi.com/users</a>，它的请求必须要通过我们的Lambda authoriser函数，上面的代码片段是在哪里配置它的。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><p id="0886" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，以上就是如何用Cloudformation模板在AWS Api Gateway中配置自定义lambda authoriser。希望对你多多少少会有帮助。谢了。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mi mj l"/></div></figure></div></div>    
</body>
</html>