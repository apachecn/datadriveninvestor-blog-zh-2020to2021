<html>
<head>
<title>Time and Space Complexity Intuition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时空复杂性直觉</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/time-and-space-complexity-intuition-c51434507da?source=collection_archive---------12-----------------------#2020-02-17">https://medium.datadriveninvestor.com/time-and-space-complexity-intuition-c51434507da?source=collection_archive---------12-----------------------#2020-02-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4ca4b0519bcd15d2e47d96ebb6a40bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N_9jMvhA9Z2bqkRg.jpg"/></div></div></figure><p id="da72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常，可以解决一个问题的算法不止一个。因此，我们需要度量来帮助我们确定哪种算法更有效地解决手头的问题。时间和空间复杂度是我们最常用来比较算法的两个指标。这篇文章旨在为一个非常重要的概念提供一些直觉，这个概念有时看起来过于模糊或混乱。</p><p id="332e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">算法的时间复杂度表示作为输入长度的函数的时间增长率。由于计算机完成的每一次运算都需要大约恒定的时间c，所以我们最关心的是运算次数如何随着输入长度的增加而增加。</p><div class="kw kx gp gr ky kz"><a href="https://www.datadriveninvestor.com/2019/03/22/the-seductive-business-logic-of-algorithms/" rel="noopener  ugc nofollow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">算法诱人的商业逻辑|数据驱动的投资者</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">某些机器行为总是让我感到惊讶。我对他们从自己的成就中学习的能力感到惊讶…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="li l"><div class="lj l lk ll lm li ln jw kz"/></div></div></a></div><p id="4f4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">举个简单的例子，假设一个教室里有100个学生，你知道其中一个学生有一支笔。您希望尽快找到拥有该笔的学生(本示例由geeks4geeks.org提供)。让我们想象一下，问一个学生，代表了这个场景中的常数时间运算。O(N)的解决方案是询问班上的每个学生是否有笔，然后询问每个学生关于其他99个人的情况(这里学生代表N)。一个O(N)的解决方案是单独询问每个学生。O(log(N))解决方案是将学生分成两半，问“笔在右边还是左边”(假设每组有一个学生可以告诉你)，然后重复这个过程，直到剩下两个学生，其中一个拿着笔。</p><p id="bcfd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，时间和空间的复杂性取决于程序员无法直接控制的几个因素:硬件、操作系统、处理器等。当我们提到时间和空间复杂性时，我们打算重点关注的是算法的执行时间(您可以想到代码需要的操作数量(因为每个操作需要恒定的时间))和代码在机器上需要的工作内存量。</p><p id="462e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们有一个数组A和一个元素x，我们被告知遍历A并确定x是否在A中。</p><p id="4464" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们编写了以下伪代码来解决这个问题:</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/ffaf0320440e53c54e8cda1e0fd79fbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*L80EXymTId6rexETB3yqCw.png"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk">Courtesy of Hackerearth.com</figcaption></figure><p id="5444" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个算法的运行时间将是N*c+c，其中N是数组A的长度，而“+c”表示返回语句。</p><p id="82fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，算法的执行时间的增长顺序是线性的。也就是说，算法执行所需的时间将作为数组a长度的函数线性增加。在讨论增长顺序时，我们通常会忽略低阶项，因为当我们处理大量输入时，它们变得无关紧要。</p><p id="cf93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果我们有一个算法，它的运算次数可以用下面的表达式来表示:N +5+N，我们会说这个算法就是O(N)。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/02d172dca8ab3d8ed7d1fc50a747de70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*V14WobLW5nIuHNm7jFkB_w.png"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk">Courtesy of Hackerearth.com</figcaption></figure><p id="44aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个例子是O(N)。想想count++会运行多少次。如果N是5，我们知道外部循环将运行5次。对于外部循环的每次迭代，内部循环将运行I次。我们可以将这种增长顺序表示为N*(N-1)/2。</p><p id="f286" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">算法的时间复杂度不等于执行特定代码所需的实际时间，而是一条语句执行的次数。通过使用时间实用程序执行代码，您可以看到这一点。下面是一个简单的程序，打印出一个整数数组中最大的整数。当我们用时间工具执行这个程序时，我们得到不同的时间:</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/9bd34252990668b21be51949fe5830ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ucyl6Wp-uhz06pm3ZByGfA.png"/></div></div></figure><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/03b7653d55e7ca2a99d4bf254451aeaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9irVC6Nxfj_XecI9UP2JJQ.png"/></div></div></figure><p id="ca4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一切都是为了说明在同一台机器上运行的同一程序需要不同的执行时间。这可能很大程度上是由于资源的可用性——在任何给定的时间，您的机器可用于执行程序的资源可能更多/更少。这就是为什么时间复杂度不关注程序执行所花费的时间，而是关注一条语句必须执行的次数。上面的程序在时间复杂度上是O(N )(并且可以在任何机器上运行),尽管它花费了不同的时间来执行。</p><p id="3c28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">空间复杂度是随着输入长度的增加“算法需要的工作存储量”(northwestern.edu)的度量。</p><p id="5931" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一些空间复杂性的例子:</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/f3c8bab5af56ba363d3c891c973bd958.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*gZ9VSbe5J_K8puvngfp8GA.png"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk">Courtesy of Northwestern.org</figcaption></figure><p id="6d75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个简单的程序需要三个内存单元。由于这个永远不变，所以这个程序的空间复杂度是O(1)。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/7eb0c44a119beb53a1bba3ef7694919b.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*eLe52Y_K67dJUjBDMGK5rg.png"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk">Courtesy of Northwestern.org</figcaption></figure><p id="8c54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个简单的程序(N是数组a的长度)需要N个空间，或者空间复杂度为O(N)。</p><p id="6264" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后要注意的几件事:</p><p id="6061" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果函数A占用4个单位的空间，并调用同样占用4个单位空间的函数B，那么函数A的空间复杂度将为O(N+M)或简单地为O(N)。如果函数A调用函数B三次——并且函数B在每次调用后终止——空间复杂度仍然是O(N ),因为空间可以重用。然而，如果函数A递归调用自身，那么空间复杂度将是O(N ),因为每个递归调用都将增加调用堆栈。</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="mc md l"/></div></figure></div></div>    
</body>
</html>