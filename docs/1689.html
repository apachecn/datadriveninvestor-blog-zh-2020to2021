<html>
<head>
<title>Consistent Hashing — An Efficient &amp; Scalable Data Distribution Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一致哈希——一种高效且可扩展的数据分发算法</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/consistent-hashing-an-efficient-scalable-data-distribution-algorithm-a81fc5c0a6c7?source=collection_archive---------1-----------------------#2020-03-28">https://medium.datadriveninvestor.com/consistent-hashing-an-efficient-scalable-data-distribution-algorithm-a81fc5c0a6c7?source=collection_archive---------1-----------------------#2020-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e26c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">用简单的文字说明一致的散列法</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/4a648adee9775b6789ff4a859a3b5bb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v1Kusc_qoZo9OC53YZqsSA.jpeg"/></div></div></figure><h1 id="aaa4" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h1><p id="f985" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">假设你正在为亚马逊这样的电子商务网站设计一个可伸缩的后端。数据量将是巨大的，并且每年都呈指数级增长。您认为您能够在一台服务器上存储和管理数据吗？答案是否定的。</p><p id="b198" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您的数据无法容纳在一台机器上时，您将不得不启动更多的机器。最重要的设计目标之一是在服务器之间高效地分配数据。同时，优化从服务器集群中检索数据也很重要。</p><p id="7a2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Instagram、脸书或Twitter等社交媒体网站在服务器的文件系统中存储了大量数据。他们使用缓存服务器来快速处理频繁访问的数据请求，例如:病毒性帖子。即使是内存中的高速缓存，对可以存储的数据量也有限制。因此，也有必要水平缩放缓存层。</p><div class="mb mc gp gr md me"><a href="https://www.datadriveninvestor.com/2019/03/22/the-seductive-business-logic-of-algorithms/" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">算法诱人的商业逻辑|数据驱动的投资者</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">某些机器行为总是让我感到惊讶。我对他们从自己的成就中学习的能力感到惊讶…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms kw me"/></div></div></a></div><p id="ca22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本帖中，我们将介绍解决上述挑战的一致性哈希算法。我们将从一个非常简单的解决数据分区问题的方法开始，看看一致性散列是如何克服所有瓶颈的。该算法被许多开源应用程序采用，如Cassandra、Riak、Dynamo DB等</p><h1 id="b8e8" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">数据分发策略</h1><h2 id="cb9c" class="mt kz iq bd la mu mv dn le mw mx dp li jy my mz lm kc na nb lq kg nc nd lu ne bi translated">线性分布</h2><p id="1ab4" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们有一组服务器，我们想想出一个在它们之间分配数据的策略。让我们从一个非常幼稚的解决这个问题的方法开始。假设，我们一个接一个地填满服务器，也就是说，只有当前服务器变满时，我们才开始向下一个服务器写入数据。</p><p id="651d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下图中，我们有一个简单的服务器，一次只能存储4条记录。当一个服务器变满时，我们添加一个新的服务器，新的数据被添加到其中。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nf"><img src="../Images/10c266cbe1143d07e09cf19ecd47da56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pdoOQHMl1rnksuckZS_QfQ.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk"><strong class="bd la">Linearly storing data among servers</strong></figcaption></figure><p id="94da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，这种方法在任何服务器上写数据时都工作得很好。当你被要求读取一个特定的数据时会发生什么？您需要识别存储给定数据的服务器，然后获取它。如何识别服务器？你会走过所有的服务器，线性扫描每一个吗？这将妨碍读取性能。</p><p id="96d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如:-在上面的例子中，如果你被要求查找“<em class="kl">纽约</em>”，因为在密钥和服务器之间没有直接的映射，你将不得不线性地扫描所有的服务器并搜索这个密钥。</p><p id="9282" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一节中，我们将了解一种可以解决这个问题的方法。</p><h2 id="3bc1" class="mt kz iq bd la mu mv dn le mw mx dp li jy my mz lm kc na nb lq kg nc nd lu ne bi translated">散列法</h2><p id="d902" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在上一节中，我们看到，如果我们有N个服务器，获取记录的时间复杂度将是O(N)。我们希望高效地读写O(1)中的数据。首先映入我们脑海的是提供O(1)查找和写入的HashMap数据结构。</p><p id="be6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看散列法能否解决我们的问题。假设我们有N台存储数据的服务器和一个具有分发数据策略的应用程序。这种方法类似于HashMap使用的方法。首先，散列关键字，然后确定数据将存放在哪个桶中。应用程序将首先散列密钥，然后通过计算<em class="kl">散列(数据)% N </em>来确定哪个服务器。</p><p id="3aaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上述算法将给出数据将被写入的服务器号。此外，在检索数据时，它将使用相同的逻辑，获取服务器号并获取数据。读取和写入都在O(1)中完成。</p><p id="f241" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看一个例子。假设我们有三台服务器，分别名为S0、S1和S2。我们的钥匙是世界城市名。使用散列法，我们计算出需要分配密钥的桶或服务器。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nk"><img src="../Images/f17405e5f90a18241e4ff169f6b2757b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kr47CepJd5-wThNS8ZfrUg.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk"><strong class="bd la">Hashing &amp; Computing bucket of the keys</strong></figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nl"><img src="../Images/16726909b9c57c3a82ce56dab5a6563d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Nqp9kQkTjsTV5ogciV4MQ.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk"><strong class="bd la">Allocation of Keys</strong></figcaption></figure><p id="4a66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这在分布式系统中会一直有效吗？我们会遇到以下问题</p><ul class=""><li id="3786" class="nm nn iq jp b jq jr ju jv jy no kc np kg nq kk nr ns nt nu bi translated">如果我们添加更多的服务器，那么<em class="kl">散列(数据)% N </em>将会不同。这意味着我们将不得不在添加新服务器时重新分配所有数据。</li><li id="ace4" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk nr ns nt nu bi translated">如果其中一台服务器被移除，我们也会遇到同样的问题。因为服务器的数量N在这里是可变的，所以所有的键都会受到影响。</li></ul><p id="4d68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图说明了添加新服务器时会发生什么情况。随着服务器的数量从3增加到4，桶计算逻辑将变为<em class="kl">散列% 4 </em>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oa"><img src="../Images/dad66a0a746c2a843add77caa8fdebb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W3I9yWzCuBIQcOs7x1gzyQ.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk"><strong class="bd la">Old &amp; New Allocation of Keys</strong></figcaption></figure><p id="d131" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在添加新服务器时，我们观察到三个密钥中的两个受到影响。如果我们添加一个新的服务器，密钥“<em class="kl"> Madrid </em>”的桶将是0 (S0)而不是1(S1)。我们必须将这个密钥移动到服务器S1，以确保我们的应用程序能够找到它。因此，我们必须重新散列所有现有的密钥，并将它们分配给不同的服务器。在最坏的情况下，这会影响系统中的所有键。</p><h1 id="3195" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是一致性哈希？</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/2d132861469e378802587623fa72a2fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*6W1FxcFdYJkvEm06UOHH4g.gif"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk"><strong class="bd la">Consistent Hashing in Action</strong></figcaption></figure><p id="4f43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们想要动态添加或删除服务器时，一致散列法解决了我们的问题。在简单散列的情况下，服务器的添加或移除将影响存储在系统中的所有M个密钥。然而，一致散列法确保只有M/N个密钥受到影响，其中N是服务器的数量。</p><p id="0224" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一致散列使得密钥的分发与系统使用的服务器数量无关。因此，我们可以在不影响整个系统的情况下扩大或缩小规模。</p><p id="0bb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，一致散列使用散列环。该算法将每个服务器映射到圆上的一个点。它首先使用服务器的IP地址，计算它的散列值，并在圆上给它分配一个点(角度)。以下是如何为S1、S2和S3的3台服务器计算角度的简单说明</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oc"><img src="../Images/a8d691a3efe7da727ec107c91c7be248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ruCHHi2vXQpc1XWxXYeQBg.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk"><strong class="bd la">Assigning servers to points on the Hash Ring</strong></figcaption></figure><p id="df76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，每个键都使用相同的散列算法进行散列&amp;在服务器上分配一个点。对于每个散列键，我们顺时针方向移动，找到最近的服务器&amp;分配给它。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi od"><img src="../Images/bf55854bff58f655fd128b7740acb19f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ii6fX2A8GC5DQnrDL06CqQ.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk"><strong class="bd la">Assigning keys to points on the Hash Ring</strong></figcaption></figure><p id="963e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们得到上面一组键的如下分配:-</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oe"><img src="../Images/a205bb870bbfbcabfb705a88e5e582a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GPti0Qu9VojaTvERL98Nzw.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk"><strong class="bd la">Allocation of Keys to Servers</strong></figcaption></figure><p id="1cc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是在散列环上对不同服务器的上述密钥分配的图形表示</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi of"><img src="../Images/c6a9516aff08bcf68b31b1f9d2c00bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KqgF8LpG6xDovHXheaLFRw.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk"><strong class="bd la">Allocation of Keys to the server on a Hash Ring</strong></figcaption></figure><p id="8ef7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你从上图中看到的，我们从每个键开始顺时针方向移动来找到它的服务器。</p><h1 id="2b0d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">扩展和添加新服务器</h1><p id="e778" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">如前一节所述，我们首先计算服务器IP地址的散列值&amp;找到它在圆圈上的位置。例如:如果我们添加一个服务器S4，并发现它位于S2和S0之间的圆圈。此外，我们重新分配S0的键，这些键的角度小于S3，或者换句话说，它们出现在圆上的S3之前。</p><p id="aa80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图说明了添加新服务器S3的过程，它位于S2和S0之间。最初，密钥“<em class="kl"> Mumbai </em>”被分配给服务器S0。除了S3，我们看到从键“<em class="kl">孟买</em>”顺时针方向遇到的第一个服务器是S3，因此我们把这个键分配给S3。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi og"><img src="../Images/e826135b6ffa1ba0f55626c7b551665c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tEzXhsAhhvAbNI8PSMf98g.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk"><strong class="bd la">Adding a new server S3</strong></figcaption></figure><p id="0ebe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上面可以看出，添加新的服务器并不会影响所有的键。只有出现在散列环上的两个服务器之间的密钥需要重新分配。</p><h1 id="333b" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">删除现有服务器</h1><p id="2d50" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">删除现有服务器时，只需重新分配属于该服务器的密钥。对于属于被移除的服务器的密钥，在顺时针方向上找到散列环上的下一个服务器。此外，然后将密钥分配给新服务器。</p><p id="1174" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图说明了删除现有服务器的过程:-</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oh"><img src="../Images/44304d822790b22cb910de84d161068f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XnOsYO1nAuQD1lLo-R_P1A.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk"><strong class="bd la">Removal of Server S1</strong></figcaption></figure><p id="a4bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上图中，删除了服务器S1。键“<em class="kl">纽约</em>”被分配给服务器S1。删除S1后，我们从关键字“New York”中找到第一个服务器，并找到服务器S2。因此，关键字“<em class="kl"> New York </em>被重新分配给服务器S2。</p><p id="ce8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与普通散列不同，服务器的移除不需要重新散列所有的密钥。只有被移除的服务器的密钥必须被重新分配。</p><h1 id="848c" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">虚拟节点</h1><p id="f604" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们看到，当一个节点被移除时，分配给该节点的所有键将被移动到哈希环中的下一个节点。通常，删除一个节点后，数据分布会变得不均匀，其中一个节点上的负载会增加。</p><p id="8aaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，如果我们从系统中删除S0，那么键"<em class="kl"> London </em>"将被映射到服务器S2。最终，我们会发现S2处理三把钥匙，而S1只管理一把钥匙。因此，数据分布不均匀。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oi"><img src="../Images/78cb1d0b12a6b86afd3fe274800c81fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2EP_zE_cY7CS4aMLacoqxQ.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk"><strong class="bd la">Removal of S0 places more load on S2</strong></figcaption></figure><p id="12e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在理想情况下，当有<em class="kl"> M </em>个密钥和<em class="kl"> N </em>个服务器时，每个服务器必须有接近M/N个密钥。因此，节点的添加或移除会影响系统中最多M/N个键。为了确保接近理想的分布，我们在系统中引入了虚拟节点。每个物理节点在哈希环上都有多个虚拟节点。</p><p id="d64e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用多个散列函数来寻找散列环上虚拟节点的位置。每个服务器都用Sij表示，其中I表示实际的服务器号，j表示它的虚拟副本。例如:对于第一台服务器，虚拟副本将是S00、S01、S02、S03等。我们使用不同的哈希函数来计算每个虚拟副本的哈希。</p><p id="cd6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，我们得到了虚拟服务器的如下分配</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oj"><img src="../Images/aa65e6cb9016313319fc8de425f30b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZRK2gd8KkITwn4qBhTMzbA.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk"><strong class="bd la">Virtual servers on a hash ring</strong></figcaption></figure><p id="51de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上图可以看出，服务器S1的虚拟副本是S10、S12和S13。这同样适用于服务器S0。这导致了节点之间近乎均匀的数据分布。</p><p id="46b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于给定的密钥，如果散列环中的下一个服务器是S12，那么它将被分配给第一个物理服务器。概括地说，分配给虚拟服务器Sij的密钥将存储在物理服务器Si上。</p><h1 id="4fbe" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">一致性散列的应用</h1><p id="4e70" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">1997年引入了一致散列法。然而，它在许多分布式系统应用程序中得到了发展。它在Amazon的Dynamo DB中用作分区组件。此外，Apache Cassandra和Voldermort等开源应用程序使用它进行数据分区。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ok"><img src="../Images/a3a5593571977d40f075b0775a75170d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HV8SKWaEdZBXRAhVJublmQ.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk"><strong class="bd la">Applications of Consistent Hashing</strong></figcaption></figure><h1 id="ab05" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">参考</h1><ul class=""><li id="c870" class="nm nn iq jp b jq lw ju lx jy ol kc om kg on kk nr ns nt nu bi translated"><a class="ae oo" href="https://en.wikipedia.org/wiki/Consistent_hashing" rel="noopener ugc nofollow" target="_blank">一致哈希</a></li><li id="954f" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk nr ns nt nu bi translated"><a class="ae oo" href="https://www.toptal.com/big-data/consistent-hashing" rel="noopener ugc nofollow" target="_blank">一致性哈希的终极指南</a></li><li id="db73" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk nr ns nt nu bi translated"><a class="ae oo" href="https://www.google.com/imgres?imgurl=https%3A%2F%2Fae01.alicdn.com%2Fkf%2FHTB1U33YmFuWBuNjSszbq6AS7FXaq%2FNew-1-1-scale-Iron-Man-Arc-Reactor-A-generation-of-glowing-iron-man-heart.jpg&amp;imgrefurl=https%3A%2F%2Fwww.aliexpress.com%2Fitem%2F32866723610.html&amp;tbnid=j1x6a7eo5CmntM&amp;vet=12ahUKEwjUk-KPtrzoAhXI2nMBHanXBVMQMygdegQIARBn..i&amp;docid=A64T34tdFEqOZM&amp;w=750&amp;h=672&amp;itg=1&amp;q=iron%20man%20heart&amp;ved=2ahUKEwjUk-KPtrzoAhXI2nMBHanXBVMQMygdegQIARBn" rel="noopener ugc nofollow" target="_blank">封面图片</a></li><li id="3fec" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk nr ns nt nu bi translated"><a class="ae oo" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank">吉菲</a></li><li id="3073" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk nr ns nt nu bi translated"><a class="ae oo" href="https://www.akamai.com/us/en/multimedia/documents/technical-publication/consistent-hashing-and-random-trees-distributed-caching-protocols-for-relieving-hot-spots-on-the-world-wide-web-technical-publication.pdf" rel="noopener ugc nofollow" target="_blank">一致哈希&amp;随机树</a></li></ul><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="op oq l"/></div></figure></div></div>    
</body>
</html>