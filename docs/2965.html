<html>
<head>
<title>Linux Bootstrapping 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Linux引导101</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/linux-bootstrapping-101-2c2a8c067253?source=collection_archive---------1-----------------------#2020-05-25">https://medium.datadriveninvestor.com/linux-bootstrapping-101-2c2a8c067253?source=collection_archive---------1-----------------------#2020-05-25</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="0179" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">对于Ubuntu 18.04</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/df5950712088d0471df3da5a5a4980a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yLvpTirFejCAurNHbg-lEg.jpeg"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/@adigold1?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Adi Goldstein</a> on <a class="ae kz" href="https://unsplash.com/s/photos/start?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d08a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们从维基百科如何描述<strong class="lc iv">引导</strong>开始:</p><blockquote class="lw lx ly"><p id="d327" class="la lb lz lc b ld le jv lf lg lh jy li ma lk ll lm mb lo lp lq mc ls lt lu lv in bi translated">一般来说，<strong class="lc iv">自举</strong>通常指的是一个<strong class="lc iv">自启动过程</strong>，它应该在没有外部输入的情况下进行。在计算机技术中，这个术语(通常简称为<strong class="lc iv">引导</strong>)指的是开机后将基本软件加载到计算机内存中的过程，特别是操作系统，它将根据需要负责加载其他软件。</p></blockquote><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj md"><img src="../Images/9f2a481fddbc3a083eb96efd2efd31d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*k3gfGaRdiOYkaOJ3D038cw.jpeg"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk">The saying “to pull oneself up by one’s bootstraps” was an old phrase referring to an impossible task.</figcaption></figure><p id="0a28" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在Linux中，典型的引导过程有6个不同的阶段。在这里，我试图用一些例子来清晰地描述每个阶段。下面，你可以看到高层的引导过程。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj me"><img src="../Images/0fb6f7fe3df6d7b55588905a61f95f22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h4Qo0tQQzPGEdiOV"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk">Typical booting processes</figcaption></figure><p id="1ac2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">引导从BIOS开始。BIOS是什么？它代表“<strong class="lc iv">基本输入/输出系统</strong>”，是一个在可引导介质(如硬盘、光盘、USB等)上寻找引导加载程序的小程序。</p><p id="31d8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">BIOS程序完全独立于操作系统，它在任何其他引导过程之前执行。它对CPU、内存和其他存储设备执行简短的完整性检查，以确保系统是可引导的。它还收集所有可用的可引导设备的列表，并根据其可配置的优先级列表开始引导它们。如果它不能引导一个设备，它将转到列表中的下一个设备。例如，下面是一个引导优先级顺序列表的示例。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj mf"><img src="../Images/be60507222e55e02b3290ca6e188e8ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bgQAiZnT_ZNeD_NmmR554A.jpeg"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk">A list of available Bootable media. You can change this order as you wish.</figcaption></figure><p id="dfa0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这些可引导介质的每一个上，都有一个包含引导加载程序信息的小文件。这个文件被称为<strong class="lc iv">主引导记录(MBR) </strong>，BIOS的工作是找到它并读取指令以定位引导加载程序。</p><p id="f67f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">MBR是一个非常小的文件(512字节大小)，位于可引导磁盘(如硬盘、USB等)的第一个扇区。该文件包含主引导程序、分区表和MBR验证检查的信息。</p><p id="7d2d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第一部分，<strong class="lc iv">主引导加载程序</strong>，包含作为已安装操作系统的加载程序的可执行代码——由于其有限的小尺寸，它通常用于将控制传递给加载程序的第二阶段(GRUB)。第二部分，<strong class="lc iv">分区表</strong>，包含关于包含文件系统的逻辑分区如何在该介质上组织的信息(例如，分区的数量及其类型)。最后一部分是<strong class="lc iv"> MBR验证检查</strong>，是2字节签名(又名幻数)。如果是(0x55，0xaa)(十六进制格式)，那么BIOS将尝试引导系统。如果不是，那么你会从你的BIOS得到一个错误信息，说它没有找到一个引导盘。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj mg"><img src="../Images/1947ae46f1fab9cf598f6895108acbfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8ql-utqnCtZ98kK1.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk">Master Boot Record(MBR), which is always located at cylinder 0, head 0, and sector 1, the first sector on the disk. source: <a class="ae kz" href="https://neosmart.net/wiki/mbr-boot-process/" rel="noopener ugc nofollow" target="_blank">https://neosmart.net/wiki/mbr-boot-process/</a></figcaption></figure><p id="cdd9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一旦BIOS找到引导加载程序，它就会将引导代码加载到内存中，启动引导加载程序进程。</p><p id="6742" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在Ubuntu中，第二阶段引导程序是GRUB。代表<strong class="lc iv"> GR </strong>和<strong class="lc iv">U</strong>ni fied<strong class="lc iv">B</strong>oot loader，属于GNU项目。</p><p id="bb1a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它是一个负责启动操作系统并了解文件系统的小软件包。如果您的计算机上安装了多个内核映像，或者特定操作系统有多种配置，GRUB允许您引导其中一个。它会显示一个闪屏，等待几秒钟，如果没有用户输入，那么它会加载配置文件中指定的默认内核映像。下面，你可以看到我的电脑上安装了很多内核镜像。你可以在CLT上输入<code class="fe mh mi mj mk b">$ dpkg --list | grep linux-image</code>来查看这个列表。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ml"><img src="../Images/9f250402f08cdf62d789b85b8c2da7b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s88cz-dH0uTf94W2zj_Tug.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk">List of all available linux kernel images on my computer</figcaption></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj mm"><img src="../Images/20fc34f980e5af757e9d68aa3d7c2dfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*O6bhIvGQ7aMZyIdZ2ByIJg.png"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk">The default linux kernel on my computer.</figcaption></figure><p id="87a3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于每个操作系统或内核配置，GRUB都有一组写在配置文件中的指令。该配置位于<code class="fe mh mi mj mk b">/boot/grub/grub.cfg</code>上。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj mn"><img src="../Images/8bface81f42d1fe1e6a5bc5f6fd42ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*ulQb5RppgziZ-aVFuy1PCQ.png"/></div></figure><p id="acef" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">配置文件包含关于内核和<code class="fe mh mi mj mk b">initrd</code>(初始RAM磁盘)映像的信息。<code class="fe mh mi mj mk b">initrd</code>映像包含加载实际操作系统文件系统所需的模块/驱动程序。内核使用这些映像作为临时根文件系统。一旦加载了根文件系统，内核就会卸载这些临时文件并加载真正的文件系统。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj mo"><img src="../Images/c4f1db34cbf2c0ff365690baa217c413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*ve4lz8D8_HtgQsSzAgRw-g.png"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk">The contents of boot directory. You can see initrd images on the directory</figcaption></figure><p id="e682" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，内核接管了。但是内核是什么呢？它是操作系统的核心，提供对服务和硬件的访问。它是一个压缩的图像文件，其位置在GRUB配置文件中指定。</p><p id="9678" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，当内核被加载到内存中时，开始检查处理器家族和架构。内核执行许多硬件特定的操作。它使用“initramfs”来读取驱动程序和引导系统所需的模块。它还挂载GRUB配置文件中指定的“根文件系统”。</p><p id="a96d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这个阶段，内核执行<code class="fe mh mi mj mk b">/sbin/init</code>二进制。它是Linux内核在用户空间中执行的第一个程序。你可以检查这个二进制的进程ID (PID)，它总是1。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj mp"><img src="../Images/c5e8537bc62033a201a50cfd14fafb8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*whlRaCjW5TzcIIHjaiSxHw.png"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk">You can check a program’s PID with $ ps -ef command</figcaption></figure><p id="883b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这个阶段，init程序启动init进程，该进程运行一系列被称为<code class="fe mh mi mj mk b">init.d</code> bash脚本的初始化脚本。你可以在<code class="fe mh mi mj mk b">/etc/init.d</code>目录下查看这些脚本。每个守护进程或服务都有一个脚本。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj mq"><img src="../Images/660fa4bfe2491e7a5f7ede2ed5e136a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w_DUJPEFpMUplfePCb-1jA.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk">init.d scripts</figcaption></figure><p id="6d2d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该初始化从运行程序级别0至6 ( <code class="fe mh mi mj mk b">init 0</code>至<code class="fe mh mi mj mk b">init 6</code>)的<code class="fe mh mi mj mk b">init</code>开始。程序分为6个目录(每个<code class="fe mh mi mj mk b">init</code>级别)。目录名的格式是<code class="fe mh mi mj mk b">/etc/rc.*d</code>，每个目录包含特定于该程序级别的文件。根据运行级别(目标)，内核从以下目录之一开始执行程序:</p><ul class=""><li id="b202" class="mr ms iu lc b ld le lg lh lj mt ln mu lr mv lv mw mx my mz bi translated">位于<code class="fe mh mi mj mk b">/etc/rc0.d</code>上的init 0 <code class="fe mh mi mj mk b">halt</code>文件</li><li id="cd83" class="mr ms iu lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated">位于<code class="fe mh mi mj mk b">/etc/rc1.d</code>上的init 1 <code class="fe mh mi mj mk b">single-user mode</code>文件</li><li id="8761" class="mr ms iu lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated">位于<code class="fe mh mi mj mk b">/etc/rc2.d</code>上的初始化2 <code class="fe mh mi mj mk b">multi-user mode without NFS</code>文件</li><li id="0282" class="mr ms iu lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated">位于<code class="fe mh mi mj mk b">/etc/rc3.d</code>上的init 3 <code class="fe mh mi mj mk b">multi-user mode with NFS</code>文件</li><li id="f2fa" class="mr ms iu lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated">初始化位于<code class="fe mh mi mj mk b">/etc/rc4.d</code>上的4个<code class="fe mh mi mj mk b">unused</code>文件</li><li id="bee2" class="mr ms iu lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated">初始化位于<code class="fe mh mi mj mk b">/etc/rc5.d</code>上的5个<code class="fe mh mi mj mk b">X11- GUI mode</code>文件</li><li id="305c" class="mr ms iu lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated">初始化位于<code class="fe mh mi mj mk b">/etc/rc6.d</code>上的6个<code class="fe mh mi mj mk b">Reboot</code>文件</li></ul><p id="7420" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在每个目录中，有两种类型的文件，一种是以字母<code class="fe mh mi mj mk b">S</code>开头的启动脚本，另一种是以字母<code class="fe mh mi mj mk b">K</code>开头的停止/终止脚本。第一个字母后有一个数字，表示执行的顺序。</p></div><div class="ab cl nf ng hy nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="in io ip iq ir"><h2 id="845c" class="nm nn iu bd no np nq dn nr ns nt dp nu lj nv nw nx ln ny nz oa lr ob oc od oe bi translated">参考</h2><ul class=""><li id="6c4d" class="mr ms iu lc b ld of lg og lj oh ln oi lr oj lv mw mx my mz bi translated">Linux启动过程——它是如何执行的(<a class="ae kz" href="https://medium.com/linux-point/linux-boot-process-how-it-executes-2089c0b2c648" rel="noopener">链接</a></li><li id="d015" class="mr ms iu lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated">Linux引导过程(<a class="ae kz" href="https://medium.com/the-devops-journey/linux-booting-process-a43554dc72cd" rel="noopener">链接</a>)</li><li id="4ba3" class="mr ms iu lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated">Linux启动过程(<a class="ae kz" href="https://medium.com/@genexu/linux-booting-process-f7d1f8574580" rel="noopener">链接</a>)</li></ul></div><div class="ab cl nf ng hy nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="in io ip iq ir"><p id="4544" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我希望你喜欢读这篇文章。如果你愿意支持我成为一名作家，考虑注册成为一名媒体成员。每月只需5美元，你就可以无限制地使用Medium。</p></div></div>    
</body>
</html>