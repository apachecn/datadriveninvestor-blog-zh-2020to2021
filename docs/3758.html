<html>
<head>
<title>Working with Binary Search Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与二叉查找树合作</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/working-with-binary-search-tree-feb61eb2ef44?source=collection_archive---------6-----------------------#2020-07-06">https://medium.datadriveninvestor.com/working-with-binary-search-tree-feb61eb2ef44?source=collection_archive---------6-----------------------#2020-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2fae" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数据科学基础Python中的算法和编程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/42a9ee2524334180d4beeaaee484de3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kaNlCFUMoBWW2YcA"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@cgower?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christopher Gower</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="73f3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="c0ee" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">树结构由分层组织数据的节点和边组成。编程语言世界中的任何树都可以比作家谱，其中祖先、父母和孩子的组合被广泛使用。数据元素使用通常称为节点的存储桶来存储，而每个节点使用边来连接到其他节点。在我们进入二叉树如何操作之前，让我们先理解一些关键的概念。</p><div class="mn mo gp gr mp mq"><a href="https://www.datadriveninvestor.com/2019/04/08/algorithms/" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">算法本身并没有偏见，它是预期的结果，会带来意想不到的后果</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">对于科技公司如何在软件中使用算法，有很多批评倾向于…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ks mq"/></div></div></a></div><ol class=""><li id="8688" class="nf ng it lt b lu nh lx ni ma nj me nk mi nl mm nm nn no np bi translated"><strong class="lt iu">根节点</strong> —树的开始/最顶端节点</li><li id="edc5" class="nf ng it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated"><strong class="lt iu">路径</strong> —为了访问树中的其他节点，在目的节点到达之前需要沿着某些边。这种从一个节点到另一个节点的遍历形成了一条路径</li><li id="92b6" class="nf ng it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated"><strong class="lt iu">父节点</strong>——任何细分为更多节点的节点都称为路径</li><li id="5158" class="nf ng it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated"><strong class="lt iu">子节点</strong> —根节点被细分或分支成更多的节点称为子节点。<em class="nv">注意，一棵二叉树最多可以有2个子节点</em></li><li id="6efa" class="nf ng it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated"><strong class="lt iu">内部节点</strong> —至少有一个子节点的节点</li><li id="bec0" class="nf ng it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated"><strong class="lt iu">叶节点</strong> —没有子节点的节点</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/409162508a04f95c1d5c618d02fa175d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HIwNXrdt5cHUtzgebKKSJg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Figure 1. The sample tree with (a) the parent, child, and the sibling relationship; (b) representation of interior nodes and leaves (Reference — <em class="nx">Data Structures and Algorithms using Python, Rance D. Necaise, Chapter 13, Page 371)</em></figcaption></figure><h1 id="5a81" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">性能</h1><p id="2551" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">二叉树是一种非线性数据结构，它允许使用节点来组织数据。一棵二叉树最多可以有两个子树，一个标识为左，另一个标识为右。节点不仅用于存储数据元素，还用于存储左右子/子树的地址。可以使用下面提到的规则来构建二叉树:</p><ol class=""><li id="2906" class="nf ng it lt b lu nh lx ni ma nj me nk mi nl mm nm nn no np bi translated">节点的左子树包含小于根的值</li><li id="2366" class="nf ng it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">节点右边的子树包含大于根的值</li><li id="c2ab" class="nf ng it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">左侧和右侧的子树也必须是没有任何重复值的二叉查找树</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/e7b60a6fef08bbb58914b369b096f937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*la3H_o1SQ3ny9QKd4cp8qw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Figure 2. Signifies how BST (Binary Search Tree) is implemented using Python. Node that T, X, C, B and so on represents the data element where as the dots stores address of left and right child nodes (Reference — <em class="nx">Data Structures and Algorithms using Python, Rance D. Necaise, Chapter 13, Page 377)</em></figcaption></figure><h1 id="c447" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">履行</h1><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="a241" class="oe la it oa b gy of og l oh oi">class Node:<br/><br/>    <em class="nv">"""<br/>    A constructor is used to initialize the data, left_add, and right_add variables. The variable, data,<br/>    stores the data item, whereas the left_add and the right_add variable stores the address of the left and right child.<br/>    """<br/>    </em>def __init__(self,data,left_add=None,right_add=None):<br/>        self.data=data<br/>        self.left_add=left_add<br/>        self.right_add=right_add<br/><br/>    """<br/>    insert() is used to add value to a binary tree. Remember the rules discussed above:<br/>    1. The left subtree of a node contains values smaller than the root<br/>    2. The right subtree of a node contains values larger than the root<br/>    3. The left and right subtree each must also be a binary search tree without any duplicate values<br/>    """<br/>    def insert_data(self,item):<br/>        #--Decision trees can't have duplicates, hence the condition is checked before an item is inserted<br/>        if self.data==item:<br/>            return False<br/><br/>        elif item&lt;self.data: #--if data to be inserted is smaller than the data at root node<br/>            if self.left_add: #--Check if the left child exists<br/>                self.left_add.insert_data(item)<br/>            else:<br/>                self.left_add=Node(item) #--Else add a node and store the object address in left_add<br/>                return True<br/>        #--Similar methodology discussed above is followed when item is greater than the item in the root node<br/>        else:<br/>            if self.right_add:<br/>                self.right_add.insert_data(item)<br/>            else:<br/>                self.right_add = Node(item)<br/>                return True<br/>    """<br/>    find() is used to search for a particular value in the tree. It follows the similar structure used for inserting an element.<br/>    Remember binary tree uses a node based approach that has three components to it.<br/>    1. Data item<br/>    2. left address to store object address of the left child<br/>    3. right address to store the object address of the right child<br/>    """<br/>    def find_data(self,item):<br/><br/>        if self.data==item:<br/>            return True<br/>        elif item&lt;self.data:<br/>            if self.left_add:<br/>                self.left_add.find_data(item)<br/>            else:<br/>                return False<br/>        else:<br/>            if self.right_add:<br/>                self.right_add.find_data(item)<br/>            else:<br/>                return False<br/><br/>    def preorderTraversal(self, list_item):<br/>        #--Traverses the binary tree<br/>        #--first element is the element from the root<br/>        list_item.append(self.data)<br/><br/>        #--If left_add is present then it adds element from the left child to the list<br/>        #--Once all items from the left of the tree are added, it moves to the right child<br/><br/>        if self.left_add:<br/>            self.left_add.preorderTraversal(list_item)<br/>        if self.right_add:<br/>            self.right_add.preorderTraversal(list_item)<br/>        return list_item<br/><br/>    def inorderTraversal(self,list_item):<br/><br/>        if self.left_add:<br/>            self.left_add.inorderTraversal(list_item)<br/><br/>        list_item.append(self.data)<br/><br/>        if self.right_add:<br/>            self.right_add.inorderTraversal(list_item)<br/><br/>        return list_item<br/><br/>    def postorderTraversal(self,list_item):<br/><br/>        if self.left_add:<br/>            self.left_add.inorderTraversal(list_item)<br/>        if self.right_add:<br/>            self.right_add.inorderTraversal(list_item)<br/><br/>        list_item.append(self.data)<br/><br/>        return list_item</span></pre><p id="f6b5" class="pw-post-body-paragraph lr ls it lt b lu nh ju lw lx ni jx lz ma oj mc md me ok mg mh mi ol mk ml mm im bi translated">下一部分涉及到创建二叉查找树类。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="6696" class="oe la it oa b gy of og l oh oi">class BinarySearchTree(object):<br/><br/>    def __init__(self):<br/>        self.root=None<br/><br/><br/>    def insert(self, d):<br/><br/>        if self.root:<br/>            return self.root.insert_data(d)<br/>        else:<br/>            self.root = Node(d)<br/>            return True<br/><br/>    def find(self, d):<br/><br/>        if self.root:<br/>            return self.root.find_data(d)<br/>        else:<br/>            return False<br/><br/>    def __str__(self):<br/>        # return list of data elements resulting from preorder tree traversal<br/>        if self.root:<br/>            return ",".join(map(str, self.root.postorderTraversal([])))<br/>        else:<br/>            return "the tree is empty"<br/><br/><br/>if __name__ == "__main__":<br/>    test_tree = BinarySearchTree()  # initialize the binary search tree<br/>    # add elements to the tree<br/>    items = [3, 5, 4, 7, 6, 1]<br/>    for item in items:<br/>        test_tree.insert(item)<br/><br/>    print(test_tree)  # tree traversal<br/>    print(test_tree.find(10))  # tree search</span></pre><h2 id="7c4a" class="oe la it bd lb om on dn lf oo op dp lj ma oq or ll me os ot ln mi ou ov lp ow bi translated">参考</h2><p id="c557" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Necaise研发中心(2011年)。<em class="nv">使用Python的数据结构和算法</em>。新泽西州霍博肯:约翰·威利父子公司。</p></div><div class="ab cl ox oy hx oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="im in io ip iq"><p id="5ad6" class="pw-post-body-paragraph lr ls it lt b lu nh ju lw lx ni jx lz ma oj mc md me ok mg mh mi ol mk ml mm im bi translated"><em class="nv">关于作者:高级分析专家和管理顾问，帮助公司通过对组织数据的商业、技术和数学的组合找到各种问题的解决方案。一个数据科学爱好者，在这里分享、学习、贡献；可以和我在</em> <a class="ae ky" href="https://www.linkedin.com/in/angel-das-9532bb12a/" rel="noopener ugc nofollow" target="_blank"> <em class="nv">上联系</em></a><em class="nv"/><a class="ae ky" href="https://twitter.com/dasangel07_andy" rel="noopener ugc nofollow" target="_blank"><em class="nv">上推特</em></a><em class="nv">；</em></p></div><div class="ab cl ox oy hx oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="im in io ip iq"><p id="f78b" class="pw-post-body-paragraph lr ls it lt b lu nh ju lw lx ni jx lz ma oj mc md me ok mg mh mi ol mk ml mm im bi translated"><strong class="lt iu">进入专家视图— </strong> <a class="ae ky" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>