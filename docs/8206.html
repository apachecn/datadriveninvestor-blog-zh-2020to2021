<html>
<head>
<title>Building a Blockchain in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python构建区块链</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/building-a-blockchain-in-python-f194a26530fd?source=collection_archive---------2-----------------------#2021-01-05">https://medium.datadriveninvestor.com/building-a-blockchain-in-python-f194a26530fd?source=collection_archive---------2-----------------------#2021-01-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1a94" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用挖矿！</h2></div><p id="64f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最好的学习方法是通过做、教和示范。通过用Python构建一个，我巩固了我对区块链和编程的知识。</p><p id="23a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我第一次编写区块链代码时，请跟我来，教你我所学到的，并在这个过程中了解我自己！</p><p id="5524" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你不确定区块链是如何工作的，可以看看我为初学者写的关于区块链的文章。</p><p id="f701" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选择哪种语言和哪种解释器来构建区块链的过程是这一努力中最困难的部分。我对Python的经验很少，希望呆在自己的舒适区内。最后，我意识到没有人能在自己的极限内完成任何事情，于是我决定勇往直前，开始用Python编程。Python很棒，因为它对初学者来说很简单，同时对高级编码也很有效。</p><h2 id="fd9c" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">设置</h2><p id="87b8" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我下载了Python 3.9，打开它，试图打印我的名字，然后迅速关上笔记本电脑，走出房间。哦，亲爱的。我缺少一个IDE(集成代码编辑器),并且不能用纯Python执行任何代码。一些研究和几个小时后，我回到了笔记本电脑。这一次，我尝试了一些翻译，直到我选择了一个我最喜欢的。是皮查姆。PyCharm在Python用户中最受欢迎是有原因的。它的界面简单，适合各个层次。我尝试编写简单的命令，直到对PyCharm很熟悉。现在，是时候建立区块链了。</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="396f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我引用了YouTube上的<a class="ae lb" href="https://www.youtube.com/watch?v=b81Ib_oYbFk&amp;t=50s" rel="noopener ugc nofollow" target="_blank">这个</a>视频和<a class="ae lb" href="https://github.com/howCodeORG/Simple-Python-Blockchain/blob/master/blockchain.py" rel="noopener ugc nofollow" target="_blank">这个</a> GitHub源代码。</p><p id="d026" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你是第一次编程，我强烈建议你跟随视频或文章教程。它帮助我理解了我写的是什么，以及我为什么写它。</p><p id="f81b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我<strong class="kh ir">导入了hashlib </strong>和<strong class="kh ir"> datetime，</strong>来让我们分别计算散列和时间戳块。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/a9688a63490cf10083ed671cb3016f38.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*_LiyNFynALbU4dKEeoGsgw.png"/></div></figure><p id="05e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">导入是将代码从一个模块转移到另一个模块的修改。如果没有datetime导入，我的区块链就不能处理时间戳，如果没有hashlib导入，就不能创建散列。</p><p id="517e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">区块链包含两个类:一个<strong class="kh ir">区块</strong>类和一个<strong class="kh ir">区块链</strong>类。使用<strong class="kh ir">块</strong>类，添加到区块链的每个块都建模相同。</p><h2 id="2571" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">块类</h2><p id="5194" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">该块必须包括以下属性:</p><ul class=""><li id="d7a0" class="mk ml iq kh b ki kj kl km ko mm ks mn kw mo la mp mq mr ms bi translated"><strong class="kh ir">块</strong>的编号，设置为0，因为它是链中的第一块，称为<em class="mt">生成块</em></li><li id="7522" class="mk ml iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><strong class="kh ir">数据，</strong>设置为无</li><li id="a951" class="mk ml iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><strong class="kh ir">接下来，</strong>设置为无。这充当指向下一个块的指针，继续<em class="mt">链接的趋势。</em></li><li id="68a9" class="mk ml iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><strong class="kh ir">哈希，</strong>设置为无。块的散列是至关重要的，因为它是使区块链如此安全和不可改变的加密的一部分。</li><li id="5767" class="mk ml iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><strong class="kh ir"> nonce，</strong>设置为0。随机数是一个随机的整数，反复迭代直到找到“黄金随机数”。为了证明工作，矿工们竞相首先找到正确的哈希。nonce会改变很多次，直到它帮助生成正确的散列。这完成了块的验证，并且该块可以被添加到链中。</li><li id="fee1" class="mk ml iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><strong class="kh ir">先前哈希，</strong>设置为0x0。存储前一个块的散列使得区块链不可变，因为改变块的散列会影响所有后续的块。</li><li id="cf2c" class="mk ml iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><strong class="kh ir">时间、</strong>或<strong class="kh ir">时间戳、</strong>描述交易发生的时间，用于同步网络中的所有模块。</li></ul><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/61f27ce5299699ac24159a3edf5d5cdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*r3y0NFBcffbKrhwdwryvYw.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">The <strong class="bd le">Block</strong> class, which determines the criteria for each block added to the chain</figcaption></figure><p id="fc43" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们创建一个块时，我们存储它的数据。构造函数<strong class="kh ir"> init </strong>初始化类的属性。<strong class="kh ir"> Self </strong>和<strong class="kh ir"> data </strong>表示一个对象内将包含什么，即块。</p><h2 id="998b" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">混杂</h2><p id="25c0" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">下一步是添加哈希函数，该函数计算块的哈希。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ne"><img src="../Images/e3367fffc218c276bb402853c7d6f794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rN7eYKO6dsXTU-vmvYHN7w.png"/></div></div></figure><p id="8025" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将<strong class="kh ir">随机数</strong>、<strong class="kh ir">数据</strong>、<strong class="kh ir">先前散列</strong>、<strong class="kh ir">时间戳</strong>和<strong class="kh ir">块号</strong>放入一个字符串中，并通过SHA-256函数运行。SHA-256是一种常用于区块链的加密哈希算法。"<strong class="kh ir"> h </strong>"是使用SHA-256的变量。因为我在代码的开头导入了hashlib，所以SHA-256是可用的。散列函数中的所有组件将创建块的散列，当创建新块时，该散列将被添加到<em class="mt">散列</em>字段中。</p><p id="0757" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图中的最后一行描述了将在输出中显示的内容，或打印的内容。在这种情况下，输出将显示块的<strong class="kh ir">散列</strong>和<strong class="kh ir">块号</strong>。</p><h2 id="78d8" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">区块链类</h2><p id="2e7c" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">下一步是创建代码的第二个类:<strong class="kh ir">区块链</strong>类。区块链级包括:</p><ul class=""><li id="9211" class="mk ml iq kh b ki kj kl km ko mm ks mn kw mo la mp mq mr ms bi translated"><strong class="kh ir">难度，</strong>设置为20。通过增加难度，我们有效地<em class="mt">缩小了目标范围。</em>减小目标范围会使挖掘块变得更加困难，这在处理有许多节点在努力寻找可接受散列的网络时非常有用。</li></ul><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/b68ace2055f7d2c45e910f49ea9b2ecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*82XR44Jyc8s5sN6PZNNVDg.png"/></div></figure><ul class=""><li id="91f0" class="mk ml iq kh b ki kj kl km ko mm ks mn kw mo la mp mq mr ms bi translated"><strong class="kh ir">最大nonce </strong>，设置为2的32次方，这是一个32位数字可以存储的最大数。随机数必须小于要被接受的<em class="mt">目标数</em>。</li><li id="2334" class="mk ml iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><strong class="kh ir">目标数，</strong>设为2的256次方减去难度。在这种情况下，难度为20。</li></ul><p id="b75b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">区块链中的第一个块是Genesis块，如第34行所示。现在，我陷入了下一行代码:<strong class="kh ir"> dummy = head = block。</strong>任何链表的开始都称为<strong class="kh ir">头</strong>。因为我们的链表的头是Genesis块，所以我们用代码把它写成<em class="mt"> head = block。然而，仅仅这样还不够具体——在Python中，对象是通过引用传递的。<em class="mt">头</em>和<em class="mt">块</em>会指向相同的东西。在<em class="mt">头</em>变量之前必须写一个随机变量(本例中为<em class="mt">哑变量</em>，告诉计算机<em class="mt">头</em>与<em class="mt">块</em>不指向同一个对象。</em></p><h2 id="47c8" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">添加块</h2><p id="097f" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我们将继续区块链是<em class="mt"> add </em>函数的链表的想法，用于向链中添加块。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/fa00e93b6a839997b673a711513c21c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*p-BnMV0j_fEPuKkrH_iD5w.png"/></div></figure><p id="c457" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">区块链在哈希的帮助下以链表的形式出现。哈希将块绑定在一起，使其不可变。必须将<strong class="kh ir">先前散列</strong>(第39行)设置为等于当前列表顶部的块。然后，新块被设置为等于当前块加1，如第三行代码所示。</p><p id="12df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后两条线帮助形成了区块链的形状。如“self.block.next = block”所示，每个块都有一个指向下一个块的指针，因此将<em class="mt">下一个</em>指针设置为<em class="mt">块。</em>这将块添加到列表的末尾。下一行“self.block = self.block.next”将指针向前移动，以继续将块添加到列表末尾的趋势。</p><h2 id="fa6c" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">采矿</h2><p id="705e" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">接下来，我添加了一个挖掘函数。我用了一个<strong class="kh ir">工作证明</strong>共识机制，像比特币。为了将块添加到链中，节点尝试不同的随机数，直到找到小于目标范围的散列。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/bd0cf2012ddabf84e4634c1b82a9ac15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*I8cgZ1HUd_s2tPHthH14TA.png"/></div></figure><p id="1b1c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第46行开始一个循环。它首先设置一些猜测准则(范围)，从0到最大nonce。它在第47行继续检查当前块的散列值是否小于或等于目标值。在Python中散列必须被转换成整数，因此<em class="mt"> int。</em>如果散列低于目标，则该过程继续，并且可以添加该块(第48行)。接下来，打印块，最后，我们休息一下停止采矿。然而，如果散列值不小于目标数，我们将nonce加1，然后重试。</p><h2 id="e8c4" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">收尾工作</h2><p id="ec70" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我们以从第56行开始的循环结束代码。它计算10个随机块。你可以摆弄这些数字，但是它总是会停在你插入的整数上。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/09e81570e3a261ac769afb7f01d570a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*gQfr02Y_Tax9dWybryHSGw.png"/></div></figure><p id="1c57" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第60行提示打印10个块。我喜欢在代码上按下run，然后看着它运行。一旦你完成这一行，你就正式完成了！运行几次，检查错误，欣赏你的杰作。只用61行代码，您就创建了一个区块链，它可以生成块、计算哈希值，并把所有这些放在一起！</p><p id="0352" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我第一次尝试编写区块链代码并使用Pycharm！总的来说，最难的部分是理解我为什么要写东西，而不是简单地把它抄下来然后就收工。我花了大量时间在我的笔记本电脑上，试图弄清楚各种Python术语的含义，以及如何以其他人也能理解的方式解释它们。这个项目无疑是一个坚实的基础。我什么都尝了一点，对区块链建筑有了更深的了解。</p><p id="e0d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看<a class="ae lb" href="https://github.com/howCodeORG/Simple-Python-Blockchain/blob/master/blockchain.py" rel="noopener ugc nofollow" target="_blank">源代码</a>，并在您自己的终端中使用它！正如他们所说，实践是最好的学习方式之一(这一点我可以担保)。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="2dc6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有什么我可以做得更好的吗？你发现什么错误了吗？对我有什么建议吗？告诉我！LinkedIn 和<a class="ae lb" href="https://annekatracey.medium.com/" rel="noopener"> Medium </a>是留下你的想法和捕捉更多类似本文的文章的好地方。</p><p id="987c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">访问专家视图— </strong> <a class="ae lb" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>