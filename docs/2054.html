<html>
<head>
<title>useDimension React Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Dimension反应钩</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/usedimension-react-hook-dcd0ecaf1160?source=collection_archive---------0-----------------------#2020-04-12">https://medium.datadriveninvestor.com/usedimension-react-hook-dcd0ecaf1160?source=collection_archive---------0-----------------------#2020-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/ffccb0d9f69a0b539b363f5a58f444b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uZfXAT5LdqRDreeKrbdZcA.png"/></div></div></figure><div class=""/><p id="10b4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">获取元素高度和宽度的自定义react挂钩</p><p id="d2e6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当设计一个必须遵循RWD(响应式网页设计)的网页应用程序时，无论你对CSS有多了解，你都会面临一些限制。在某些领域，你会想“为什么不能用CSS来做这件事”，你会做很多研究，但最终你会意识到，这是一个死胡同。</p><blockquote class="kw kx ky"><p id="d16b" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka jc"> <em class="jb">这个为什么？</em>T3】</strong></p></blockquote><p id="2a76" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这发生在我身上，我面临的问题是创建响应图。作为一名开发人员，我们首先想到的是，显然已经有了解决方案，所以我开始研究。我碰到过两个这样的库:<a class="ae ld" href="https://www.npmjs.com/package/react-with-dimensions" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc">react-with-dimensions</strong></a>和<a class="ae ld" href="https://www.npmjs.com/package/@vx/responsive" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc">VX/response</strong></a><strong class="ka jc">。</strong>第二个是因为我在用<a class="ae ld" href="https://vx-demo.now.sh" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> VX </strong> </a>处理图形。</p><p id="f567" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这两个库都为您提供了包装主组件的高阶组件，因此看起来像:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9682" class="ln lo jb lj b gy lp lq l lr ls"><strong class="lj jc">import</strong> { withParentSize } <strong class="lj jc">from</strong> '@vx/responsive';</span><span id="3a4d" class="ln lo jb lj b gy lt lq l lr ls">let chartToRender <strong class="lj jc">=</strong> withParentSize(myComponent);</span></pre><p id="dfe9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">他们会把<em class="kz">高度和宽度道具</em>传给你，你可以用它们来制作<em class="kz">风格道具</em>，让你的元素看起来像是动态的。</p><p id="77fb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我用它完成手头的任务后，我意识到这个实现有一个巨大的缺点，<em class="kz">它只能用来获得最顶层元素的宽度。这意味着如果我想在我的元素树中间得到一个元素的宽度，我将不得不移动到另一个组件，这看起来工作量太大了。</em></p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><blockquote class="kw kx ky"><p id="80f2" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka jc"> <em class="jb">该如何</em> </strong></p></blockquote><p id="3fc3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过创建一个更高阶的组件，我将做与上述库相同的事情。我在一篇文章中读到过，一个HOC所做的大部分事情都可以通过使用钩子来完成。因为钩子只是函数，所以我可以灵活地创建多个元素引用。</p><p id="519c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个<strong class="ka jc">定制钩子</strong>就是方法。那么，我需要什么来创建这个自定义钩子呢，一个是检查我的元素的观察器，第二个是对我的元素的引用，这是一个我将从观察器绑定我的值的状态。</p><p id="443c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当创建一个定制钩子时，名字必须以<strong class="ka jc"> use，</strong>开始，当我返回元素的尺寸时，名字是这个钩子最简单的部分，<strong class="ka jc"> useDimension。</strong></p><blockquote class="kw kx ky"><p id="3551" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><em class="jb">观察者</em></p></blockquote><p id="22e9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个任务是我需要一个观察者来观察元素的任何变化，这更容易找到，我只是检查了npm上的依赖部分</p><figure class="le lf lg lh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mb"><img src="../Images/68269860ec6413a00ed4385077df1fd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U4x3LiA3r9pYf3TC0EccuQ.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">vx/responsive dependencies</figcaption></figure><p id="3488" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个名字足以让我知道我必须从这里去哪里，<a class="ae ld" href="https://www.npmjs.com/package/resize-observer-polyfill" rel="noopener ugc nofollow" target="_blank"> resize-observer-polyfill </a>是HTML5提供的<a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver" rel="noopener ugc nofollow" target="_blank"> ResizeObserver api </a>的实现/polyfill。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e6cb" class="ln lo jb lj b gy lp lq l lr ls">npm install resize-observer-polyfill --save-dev</span></pre><p id="8f17" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按照Mozilla的说法:<code class="fe mg mh mi lj b"><strong class="ka jc">ResizeObserver</strong></code>接口报告了<code class="fe mg mh mi lj b"><a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/API/Element" rel="noopener ugc nofollow" target="_blank">Element</a></code>的内容或边框尺寸的变化，或者<code class="fe mg mh mi lj b"><a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/API/SVGElement" rel="noopener ugc nofollow" target="_blank">SVGElement</a></code>的边框尺寸的变化。</p><blockquote class="kw kx ky"><p id="975c" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka jc"> <em class="jb">引用</em> </strong></p></blockquote><p id="aab1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是React提供的<strong class="ka jc"> useRef钩子</strong>和<strong class="ka jc"> ref回调</strong>的作用。我必须使用useRef创建一个Ref，并将其添加到元素的ref回调中以获取节点。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="12a0" class="ln lo jb lj b gy lp lq l lr ls">const divRef = useRef(null);<br/>useEffect(() =&gt; {<br/> if (divRef.current) {<br/>   //add logic here;<br/> }<br/>}, [divRef]);</span><span id="f9be" class="ln lo jb lj b gy lt lq l lr ls">&lt;div ref={divRef}&gt;&lt;/div&gt;</span></pre><p id="4997" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于divRef在初始化时没有任何引用，建议与useEffect一起使用，因为元素引用只设置一次，useEffect只调用一次。</p><p id="a3a6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了观察者和对元素的引用，是时候创建钩子并将维度绑定到组件可以使用的状态了。</p><blockquote class="kw kx ky"><p id="8261" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka jc"> <em class="jb">状态</em> </strong></p></blockquote><p id="d56a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">状态由useState挂钩维护。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="39f6" class="ln lo jb lj b gy lp lq l lr ls">const initialState = { width: 0, height: 0 };</span><span id="866a" class="ln lo jb lj b gy lt lq l lr ls">const [dimensions, setdDimensions] = useState(initialState);</span><span id="2ad6" class="ln lo jb lj b gy lt lq l lr ls">return dimensions;</span></pre><p id="5ffa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> dimensions </strong>是钩子将要返回的对象，可以在调用钩子的组件中使用。</p><blockquote class="kw kx ky"><p id="1250" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka jc"> <em class="jb">钩子</em> </strong></p></blockquote><p id="2cf0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是时候把所有的积木组合起来，创造我们的钩子了:</p><p id="a017" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一步，我们需要将元素ref绑定到observer，这样我们就可以在元素发生变化时获取元素信息。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="870e" class="ln lo jb lj b gy lp lq l lr ls">const resizeObserverRef = useRef(null);</span><span id="f546" class="ln lo jb lj b gy lt lq l lr ls">useEffect(() =&gt; {<br/>resizeObserverRef.current = new ResizeObserver((entries = []) =&gt; {<br/> entries.forEach((entry) =&gt; {<br/>  const { width, height } = entry.contentRect;<br/>  //change state here<br/> });<br/>});<br/>//checking whether the ref exists <br/>if (ref.current) resizeObserverRef.current.observe(ref.current);</span></pre><p id="e5db" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将resizeObserverRef作为Ref而不是变量的原因是，useEffect将在每次调用回调时创建ResizeObserver的新实例。</p><p id="68d8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Observe就像一个订阅，并且像所有订阅一样，如果它没有关闭，就会有内存泄漏，所以我们需要在卸载组件时销毁它。为此，我们可以在useEffect钩子中使用return回调函数，这个函数在组件被卸载时被调用。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="c39b" class="ln lo jb lj b gy lp lq l lr ls">useEffect(() =&gt; {<br/>resizeObserverRef.current = new ResizeObserver((entries = []) =&gt; {<br/> entries.forEach((entry) =&gt; {<br/>  const { width, height } = entry.contentRect;<br/>  // update state here<br/>  });<br/>});<br/>if (ref.current) resizeObserverRef.current.observe(ref.current);<br/>return () =&gt; {<br/> if (resizeObserverRef.current)  resizeObserverRef.current.disconnect();<br/> };<br/>}, [ref]);</span></pre><p id="6ff6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">至此，我们所有的钩子都准备好了，我们只需要在每次调用观察者回调时更新状态。最终产品:</p><figure class="le lf lg lh gt is"><div class="bz fp l di"><div class="mj mk l"/></div></figure><blockquote class="kw kx ky"><p id="139e" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka jc"> <em class="jb">使用钩子:</em> </strong></p></blockquote><figure class="le lf lg lh gt is"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="e737" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，useDimension钩子给出了ref元素的高度和宽度</p><figure class="le lf lg lh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/dad1d6bc3c42f2e4ed4813d2f83d9bfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VqAB5tZjMCTaG_kY42GhXw.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">demo</figcaption></figure></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><p id="3d9a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这有助于你理解钩子的用法。如果你对我的实现有什么意见，请告诉我。</p></div></div>    
</body>
</html>