<html>
<head>
<title>Rapid Prototyping for Quantitative Investing with d6tflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">d6tflow量化投资快速原型</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/rapid-prototyping-for-quantitative-investing-with-d6tflow-3c238e272ffd?source=collection_archive---------7-----------------------#2020-10-24">https://medium.datadriveninvestor.com/rapid-prototyping-for-quantitative-investing-with-d6tflow-3c238e272ffd?source=collection_archive---------7-----------------------#2020-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/06ebb92141b2714a50609481da8a1fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRxnsMVgX33uA5Z7ZbrcTg.png"/></div></div></figure><p id="e29c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">量化投资研究通常涉及管理复杂的数据依赖性和优化许多可调策略参数。d6tflow是一个易于使用的python库，用于快速原型制作和实验管理，以管理量化投资研究工作流。</p><div class="kw kx gp gr ky kz"><a href="https://github.com/d6t/d6tflow" rel="noopener  ugc nofollow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">d6t/d6t流量</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">对于数据科学家和数据工程师来说，d6tflow是一个python库，它使得构建复杂的数据科学工作流…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">github.com</p></div></div><div class="li l"><div class="lj l lk ll lm li ln jw kz"/></div></div></a></div><p id="750c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有代码都在github 上<a class="ae lo" href="https://github.com/d6tdev/d6tflow-binder-interactive/blob/master/example-trading.ipynb" rel="noopener ugc nofollow" target="_blank">发布，你可以</a><a class="ae lo" href="https://mybinder.org/v2/gh/d6tdev/d6tflow-binder-interactive/master?filepath=example-trading.ipynb" rel="noopener ugc nofollow" target="_blank">在这个互动笔记本</a>上试用。</p><h1 id="608f" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">为什么标准回溯测试代码不好</h1><p id="773e" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">编写回溯测试的标准方式通常涉及函数，手动将数据缓存在pickle文件中，并到处传递参数。这很糟糕，因为:</p><ul class=""><li id="de7f" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">必须手动跟踪功能、参数、文件</li><li id="5ae6" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">随着复杂性的增加，无法很好地扩展</li><li id="bba9" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">比较不同模型/参数的输出很麻烦</li><li id="ebcf" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">其他人难以阅读和审计</li><li id="5bd3" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">生产成本高</li></ul><h1 id="f590" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">d6tflow快速原型制作</h1><p id="7a90" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">与其写函数，量化投资代码不如写成一组任务，它们之间有依赖关系。那就是你的工作流程应该是一个DAG。</p><p id="d0fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样做的好处是:</p><ul class=""><li id="cd19" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">使用依赖项和参数轻松定义任务</li><li id="93c2" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">智能运行具有依赖关系/参数的工作流</li><li id="d0d2" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">轻松比较不同模型/参数的结果</li><li id="3a1c" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">轻巧、易学但功能强大</li><li id="5b32" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">代码伸缩性好，易于审计</li><li id="523f" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">快速生产</li></ul><p id="d6b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更多细节请看<a class="ae lo" href="https://github.com/d6t/d6t-python/blob/master/blogs/reasons-why-bad-ml-code.rst" rel="noopener ugc nofollow" target="_blank">你的机器学习代码可能不好的4个原因</a></p><h1 id="20e2" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">d6tflow的量化交易回溯测试示例</h1><p id="8288" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">下面是一个典型的量化投资回溯测试的程式化例子。</p><p id="a3c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过3个简单的步骤，您将:</p><ol class=""><li id="db0b" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv ng my mz na bi translated">定义回溯测试工作流程:获取宏观数据、生成交易信号、获取定价数据和执行回溯测试</li><li id="cd9a" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv ng my mz na bi translated">定义多种策略进行回溯测试:改变投资领域和回溯测试周期</li><li id="48f1" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv ng my mz na bi translated">运行回溯测试并比较不同策略的pnl性能</li></ol><p id="af58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">github 上有<a class="ae lo" href="https://github.com/d6tdev/d6tflow-binder-interactive/blob/master/example-trading.ipynb" rel="noopener ugc nofollow" target="_blank">底层笔记本，你可以</a><a class="ae lo" href="https://mybinder.org/v2/gh/d6tdev/d6tflow-binder-interactive/master?filepath=example-trading.ipynb" rel="noopener ugc nofollow" target="_blank">在这个交互式笔记本</a>上试用。</p><h1 id="530c" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">步骤1:定义回溯测试工作流</h1><p id="a98f" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">使用d6tflow，您可以定义具有依赖关系、参数和输入/输出数据的任务，而不是定义函数。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="96cf" class="nq lq iq nm b gy nr ns l nt nu"><strong class="nm ir">import</strong> <strong class="nm ir">d6tflow</strong><br/><strong class="nm ir">import</strong> <strong class="nm ir">pandas</strong> <strong class="nm ir">as</strong> <strong class="nm ir">pd</strong><br/><strong class="nm ir">import</strong> <strong class="nm ir">numpy</strong> <strong class="nm ir">as</strong> <strong class="nm ir">np</strong><br/><strong class="nm ir">import</strong> <strong class="nm ir">pandas_datareader</strong> <strong class="nm ir">as</strong> <strong class="nm ir">pddr</strong><br/><strong class="nm ir">import</strong> <strong class="nm ir">datetime</strong></span><span id="113f" class="nq lq iq nm b gy nv ns l nt nu"><em class="nw">#************************************************************</em><br/><em class="nw"># define workflow</em><br/><em class="nw">#************************************************************</em></span><span id="656f" class="nq lq iq nm b gy nv ns l nt nu"><em class="nw"># get economic data</em><br/><strong class="nm ir">class</strong> <strong class="nm ir">GetDataEcon</strong>(d6tflow.tasks.TaskPqPandas):<br/>    date_start = d6tflow.DateParameter() <em class="nw"># define backtest parameter</em><br/>    date_end = d6tflow.DateParameter() <em class="nw"># define backtest parameter</em></span><span id="e9b4" class="nq lq iq nm b gy nv ns l nt nu">    <strong class="nm ir">def</strong> run(self):<br/>        df_gdp = pddr.DataReader('CPGDPAI', 'fred', self.date_start, self.date_end)<br/>        self.save(df_gdp) <em class="nw"># save task output</em></span><span id="5c67" class="nq lq iq nm b gy nv ns l nt nu"><em class="nw"># generate l/s signals</em><br/>@d6tflow.requires(GetDataEcon) <em class="nw"># define dependency</em><br/><strong class="nm ir">class</strong> <strong class="nm ir">TradingSignals</strong>(d6tflow.tasks.TaskPqPandas):<br/>    lookback_period = d6tflow.IntParameter() <em class="nw"># define strategy parameter</em></span><span id="f26b" class="nq lq iq nm b gy nv ns l nt nu">    <strong class="nm ir">def</strong> run(self):<br/>        df_gdp = self.inputLoad() <em class="nw"># load input data</em></span><span id="8e31" class="nq lq iq nm b gy nv ns l nt nu">        <em class="nw"># generate l/s trading signals</em><br/>        df_signal = (df_gdp['CPGDPAI'].diff(self.lookback_period)&gt;0)<br/>        df_signal = df_signal.to_frame(name='position')<br/>        df_signal['position'] = np.where(df_signal['position'],1,-1)</span><span id="f59a" class="nq lq iq nm b gy nv ns l nt nu">        self.save(df_signal)</span><span id="b73d" class="nq lq iq nm b gy nv ns l nt nu"><em class="nw"># get stock prices</em><br/>@d6tflow.requires(GetDataEcon)<br/><strong class="nm ir">class</strong> <strong class="nm ir">GetDataPx</strong>(d6tflow.tasks.TaskPqPandas):<br/>    symbols = d6tflow.ListParameter() <em class="nw"># define universe</em></span><span id="9073" class="nq lq iq nm b gy nv ns l nt nu">    <strong class="nm ir">def</strong> run(self):<br/>        df = pddr.DataReader(self.symbols, 'yahoo', self.date_start, self.date_end)<br/>        df_rtn = df['Adj Close'].pct_change()<br/>        self.save(df_rtn)</span><span id="28e4" class="nq lq iq nm b gy nv ns l nt nu"><em class="nw"># run backtest</em><br/>@d6tflow.requires(TradingSignals,GetDataPx)<br/><strong class="nm ir">class</strong> <strong class="nm ir">Backtest</strong>(d6tflow.tasks.TaskPqPandas):<br/>    persist = ['portfolio','pnl'] <em class="nw"># save multiple outputs</em></span><span id="0e3e" class="nq lq iq nm b gy nv ns l nt nu">    <strong class="nm ir">def</strong> run(self):<br/>        df_signal = self.input()[0].load()<br/>        df_rtn = self.input()[1].load()</span><span id="fff5" class="nq lq iq nm b gy nv ns l nt nu">        <em class="nw"># combine signals and returns</em><br/>        df_portfolio = pd.merge_asof(df_rtn, df_signal, left_index=<strong class="nm ir">True</strong>, right_index=<strong class="nm ir">True</strong>)</span><span id="f863" class="nq lq iq nm b gy nv ns l nt nu">        <em class="nw"># calc pnl</em><br/>        df_pnl = df_portfolio[list(self.symbols)].multiply(df_portfolio['position'],axis=0)<br/>        df_pnl = df_pnl.add_prefix('rtn_')</span><span id="7f0e" class="nq lq iq nm b gy nv ns l nt nu">        self.save({'portfolio':df_portfolio,'pnl':df_pnl})</span><span id="91c2" class="nq lq iq nm b gy nv ns l nt nu"><em class="nw"># for demo purposes only: reset everything at every run</em><br/><strong class="nm ir">import</strong> <strong class="nm ir">shutil</strong><br/>shutil.rmtree(d6tflow.settings.dirpath, ignore_errors=<strong class="nm ir">True</strong>)</span></pre><h1 id="ab6b" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">第二步:制定策略</h1><p id="c380" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">我们现在将定义我们想要回溯测试的3个策略:<br/> 1)基本策略<br/> 2)改变投资领域<br/> 3)改变时间段</p><p id="bb96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建新策略就像更改或添加新参数一样简单，d6tflow会智能地计算出如何运行回溯测试。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="26d0" class="nq lq iq nm b gy nr ns l nt nu"><em class="nw">#************************************************************</em><br/><em class="nw"># define different strategies to backtest</em><br/><em class="nw">#************************************************************</em></span><span id="5406" class="nq lq iq nm b gy nv ns l nt nu">strategies = {}<br/>strategies['strategy1'] = dict(<br/>    date_start=datetime.date(2018,1,1),<br/>    date_end=datetime.date(2020,1,1),<br/>    symbols = ['CAT','WMT'],<br/>    lookback_period = 1<br/>    )<br/>strategies['strategy2'] = strategies['strategy1'].copy()<br/>strategies['strategy2']['symbols']=['MSFT','FB'] # run another universe<br/>strategies['strategy3'] = strategies['strategy1'].copy()<br/>strategies['strategy3']['date_start']= datetime.date(2019,1,1) # run another time period</span></pre><h1 id="324b" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">步骤3:运行回溯测试并比较策略损益</h1><p id="83e0" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">对于每一个策略，我们希望运行回溯测试，并查看策略pnl。首先，让我们通过给定最终任务和策略参数来定义工作流。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="b251" class="nq lq iq nm b gy nr ns l nt nu">flow = d6tflow.WorkflowMulti(Backtest, strategies)</span></pre><p id="4515" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，d6tflow自动执行所有回溯测试依赖项。在执行回溯测试之前，您可以看到到底执行了什么。这不仅可以很容易地看到将要发生的事情，还可以使代码易于审计。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="2fde" class="nq lq iq nm b gy nr ns l nt nu">flow.preview('strategy1')  # show which tasks will be run</span><span id="b122" class="nq lq iq nm b gy nv ns l nt nu">===== Luigi Execution Preview ===== <br/><br/><br/>└─--[Backtest-{'date_start': '2018-01-01', 'date_end': '2020-01-01', 'lookback_period': '1', 'symbols': '["CAT", "WMT"]'} (PENDING)]<br/>   |--[TradingSignals- (PENDING)]<br/>   |  └─--[GetDataEcon- (PENDING)]<br/>   └─--[GetDataPx- (PENDING)]<br/>      └─--[GetDataEcon- (PENDING)]<br/><br/> ===== Luigi Execution Preview =====</span><span id="4700" class="nq lq iq nm b gy nv ns l nt nu">flow.run('strategy1') # run backtest including dependencies</span><span id="6b35" class="nq lq iq nm b gy nv ns l nt nu">===== Luigi Execution Summary =====<br/><br/>Scheduled 4 tasks of which:<br/>* 4 ran successfully:<br/>    - 1 Backtest(date_start=2018-01-01, date_end=2020-01-01, lookback_period=1, symbols=["CAT", "WMT"])<br/>    - 1 GetDataEcon(date_start=2018-01-01, date_end=2020-01-01)<br/>    - 1 GetDataPx(date_start=2018-01-01, date_end=2020-01-01, symbols=["CAT", "WMT"])<br/>    - 1 TradingSignals(date_start=2018-01-01, date_end=2020-01-01, lookback_period=1)<br/><br/>This progress looks :) because there were no failed tasks or missing dependencies<br/><br/>===== Luigi Execution Summary =====</span></pre><p id="f7ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行了基本策略之后，我们现在可以运行附加策略了。美妙之处在于，所有可以重用的先前计算的数据都将被重用，而不必重新计算。对于不同领域的策略，只有2个任务需要重新运行。对于具有更新时间段的策略，d6tflow智能地计算出所有任务都必须重新运行。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="abf5" class="nq lq iq nm b gy nr ns l nt nu">flow.run()</span><span id="e8ba" class="nq lq iq nm b gy nv ns l nt nu">===== Luigi Execution Summary =====<br/><br/>Scheduled 1 tasks of which:<br/>* 1 complete ones were encountered:<br/>    - 1 Backtest(date_start=2018-01-01, date_end=2020-01-01, lookback_period=1, symbols=["CAT", "WMT"])<br/><br/>Did not run any tasks<br/>This progress looks :) because there were no failed tasks or missing dependencies<br/><br/>===== Luigi Execution Summary =====<br/><br/><br/>===== Luigi Execution Summary =====<br/><br/>Scheduled 4 tasks of which:<br/>* 2 complete ones were encountered:<br/>    - 1 GetDataEcon(date_start=2018-01-01, date_end=2020-01-01)<br/>    - 1 TradingSignals(date_start=2018-01-01, date_end=2020-01-01, lookback_period=1)<br/>* 2 ran successfully:<br/>    - 1 Backtest(date_start=2018-01-01, date_end=2020-01-01, lookback_period=1, symbols=["MSFT", "FB"])<br/>    - 1 GetDataPx(date_start=2018-01-01, date_end=2020-01-01, symbols=["MSFT", "FB"])<br/><br/>This progress looks :) because there were no failed tasks or missing dependencies<br/><br/>===== Luigi Execution Summary =====<br/><br/><br/>===== Luigi Execution Summary =====<br/><br/>Scheduled 4 tasks of which:<br/>* 4 ran successfully:<br/>    - 1 Backtest(date_start=2019-01-01, date_end=2020-01-01, lookback_period=1, symbols=["CAT", "WMT"])<br/>    - 1 GetDataEcon(date_start=2019-01-01, date_end=2020-01-01)<br/>    - 1 GetDataPx(date_start=2019-01-01, date_end=2020-01-01, symbols=["CAT", "WMT"])<br/>    - 1 TradingSignals(date_start=2019-01-01, date_end=2020-01-01, lookback_period=1)<br/><br/>This progress looks :) because there were no failed tasks or missing dependencies<br/><br/>===== Luigi Execution Summary =====</span></pre><p id="36a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以很容易地比较不同策略的结果。我们加载回溯测试输出并计算策略pnl。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="f376" class="nq lq iq nm b gy nr ns l nt nu">data_pnl = flow.outputLoad(task=Backtest, as_dict=True)<br/>for istrategy, df_pnl in data_pnl.items():<br/>    print(f'pnl strategy #{istrategy}:', df_pnl['pnl'].sum().sum().round(3))</span><span id="c15b" class="nq lq iq nm b gy nv ns l nt nu">pnl strategy #strategy1: -0.029<br/>pnl strategy #strategy2: -0.16<br/>pnl strategy #strategy3: -0.449</span></pre><h1 id="4150" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">额外收获:更快速的原型制作</h1><p id="8802" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">在最初的回溯测试之后，通常团队成员和其他利益相关者会有类似“如果你做了XYZ会怎么样？”。这通常意味着引入新的参数和/或更新任务。d6tflow很容易容纳这样的问题。</p><ol class=""><li id="2dd9" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv ng my mz na bi translated"><strong class="ka ir">新参数</strong>:只需添加参数并运行回溯测试，d6tflow就会智能地指出该做什么</li><li id="0cf8" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv ng my mz na bi translated"><strong class="ka ir">更新任务</strong>:编辑代码，重置任务，d6tflow会自动重新计算所有下游依赖关系</li></ol><p id="0d5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们想改变交易信号的任务。您重置了该任务，并且只需要重新计算5个步骤中的2个，即任务本身和1个下游依赖项，在本例中是回溯测试任务。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="9af3" class="nq lq iq nm b gy nr ns l nt nu">flow.reset(task=TradingSignals, confirm=False)</span><span id="3f86" class="nq lq iq nm b gy nv ns l nt nu">flow.preview('strategy1')</span><span id="017a" class="nq lq iq nm b gy nv ns l nt nu">===== Luigi Execution Preview ===== <br/><br/><br/>└─--[Backtest-{'date_start': '2018-01-01', 'date_end': '2020-01-01', 'lookback_period': '1', 'symbols': '["CAT", "WMT"]'} (PENDING)]<br/>   |--[TradingSignals- (PENDING)]<br/>   |  └─--[GetDataEcon- (COMPLETE)]<br/>   └─--[GetDataPx- (COMPLETE)]<br/>      └─--[GetDataEcon- (COMPLETE)]<br/><br/> ===== Luigi Execution Preview =====</span></pre><h1 id="6fb3" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">后续步骤:将代码转换到d6tflow</h1><p id="fe52" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">更新您的代码以使用d6tflow通常很容易，只需将您的旧函数包装到d6tflow工作流中。</p><p id="346d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">参见<a class="ae lo" href="https://d6tflow.readthedocs.io/en/latest/transition.html" rel="noopener ugc nofollow" target="_blank">https://d6tflow.readthedocs.io/en/latest/transition.html</a></p><h1 id="52e5" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">参考</h1><p id="01aa" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">github 上有<a class="ae lo" href="https://github.com/d6tdev/d6tflow-binder-interactive/blob/master/example-trading.ipynb" rel="noopener ugc nofollow" target="_blank">底层笔记本，你可以</a><a class="ae lo" href="https://mybinder.org/v2/gh/d6tdev/d6tflow-binder-interactive/master?filepath=example-trading.ipynb" rel="noopener ugc nofollow" target="_blank">在这个交互式笔记本</a>上试用。</p><h1 id="2e97" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">放弃</h1><p id="5a88" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">这些材料以及与这些材料相关的任何其他信息或数据仅供参考。在任何情况下，这些材料或与该报告相关的任何信息或数据都不得被视为购买或出售任何公司任何证券的要约或邀约。也不得以任何方式将这些材料或与该报告相关的任何信息或数据作为法律、税务或投资建议。这些信息和数据并不打算用作投资决策的主要依据，此处包含的或传达的任何信息都不能预测适用公司证券的市场价格变动。陈述的事实和观点仅代表作者个人，不代表任何金融机构的官方观点。</p></div></div>    
</body>
</html>