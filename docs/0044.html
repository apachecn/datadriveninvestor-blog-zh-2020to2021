<html>
<head>
<title>Classifying Malignant and Benign Breast Cancer Tumours with a Neural Network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用神经网络分类恶性和良性乳腺癌肿瘤</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/classifying-malignant-and-benign-breast-tumours-with-a-neural-network-ab470562d0e?source=collection_archive---------1-----------------------#2020-01-05">https://medium.datadriveninvestor.com/classifying-malignant-and-benign-breast-tumours-with-a-neural-network-ab470562d0e?source=collection_archive---------1-----------------------#2020-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><blockquote class="jq jr js"><p id="8385" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">这篇文章中的代码基于一个教程，可以在这里找到。</p><p id="8182" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">答:本文假设对神经网络有一个基本的直观理解。关于背景，<a class="ae ks" href="https://medium.com/datadriveninvestor/neural-networks-demystified-34bee0c45fb7" rel="noopener">看看这个</a>。</p></blockquote><p id="06f1" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">使用<a class="ae ks" href="https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+%28Diagnostic%29" rel="noopener ugc nofollow" target="_blank">这个</a>数据集，我创建了一个能够对乳腺肿瘤进行分类的神经网络。这些特征是肿瘤内细胞核的测量特征，包括周长、凹度和光滑度。标签为0或1，分别代表良性和恶性诊断。通过我的网络，我绘制了这两个变量之间的关系。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi kw"><img src="../Images/6c280f0d5e994112494c28ed6dea25ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*b10UHrarzk6D1oXy.png"/></div></div></figure><h1 id="9f7a" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">我是这样做的</h1><p id="9061" class="pw-post-body-paragraph jt ju it jw b jx mg jz ka kb mh kd ke kt mi kh ki ku mj kl km kv mk kp kq kr im bi translated">我们将首先导入以下库。</p><pre class="kx ky kz la gt ml mm mn mo aw mp bi"><span id="99b1" class="mq lj it mm b gy mr ms l mt mu">import numpy as np</span><span id="ae03" class="mq lj it mm b gy mv ms l mt mu">import tensorflow as tf</span><span id="1e6d" class="mq lj it mm b gy mv ms l mt mu">from tensorflow.keras.models import Sequential</span><span id="efb8" class="mq lj it mm b gy mv ms l mt mu">from tensorflow.keras.layers import Dense, Dropout</span><span id="009d" class="mq lj it mm b gy mv ms l mt mu">import pandas as pd</span><span id="2776" class="mq lj it mm b gy mv ms l mt mu">from sklearn import preprocessing</span><span id="54d3" class="mq lj it mm b gy mv ms l mt mu">from sklearn.model_selection import train_test_split</span><span id="c3e6" class="mq lj it mm b gy mv ms l mt mu">from matplotlib import pyplot as plt</span></pre><p id="1fd7" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">然后，我们将使用pandas读入我们的要素和标注数据，方法是将每组数据分配给变量x和y。在pandas中，这些数据被称为数据帧，基本上与数据集相同。</p><pre class="kx ky kz la gt ml mm mn mo aw mp bi"><span id="1642" class="mq lj it mm b gy mr ms l mt mu">x = pd.read_csv(‘https://raw.githubusercontent.com/antaloaalonso/Classification-Model-YT-Video/master/X_data.csv')</span><span id="a6a0" class="mq lj it mm b gy mv ms l mt mu">y = pd.read_csv(‘<a class="ae ks" href="https://raw.githubusercontent.com/antaloaalonso/Classification-Model-YT-Video/master/Y_data.csv" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/antaloaalonso/Classification-Model-YT-Video/master/Y_data.csv</a>')</span></pre><p id="afec" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">然后，作为预处理阶段的一部分，我们将缩放要素数据。</p><pre class="kx ky kz la gt ml mm mn mo aw mp bi"><span id="b0b3" class="mq lj it mm b gy mr ms l mt mu">x = preprocessing.scale(x)</span></pre><p id="92e6" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">现在是时候将我们的数据分成测试和训练数据了。训练数据是我们的神经网络用来学习如何将我们的特征映射到我们的标签的数据，而测试数据是我们用来查看我们的模型在它以前从未见过的数据样本上的行为的数据。我们20%的数据将是测试数据，80%将是训练数据。</p><pre class="kx ky kz la gt ml mm mn mo aw mp bi"><span id="f96c" class="mq lj it mm b gy mr ms l mt mu">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2)</span></pre><p id="db88" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">现在让我们将我们的训练和测试数据转换成numpy数组，以便我们可以将它们用于Keras神经网络。</p><pre class="kx ky kz la gt ml mm mn mo aw mp bi"><span id="5847" class="mq lj it mm b gy mr ms l mt mu">x_train = np.array(x_train)</span><span id="85ee" class="mq lj it mm b gy mv ms l mt mu">y_train = np.array(y_train)</span><span id="e9f1" class="mq lj it mm b gy mv ms l mt mu">x_test = np.array(x_test)</span><span id="a9b0" class="mq lj it mm b gy mv ms l mt mu">y_test = np.array(y_test)</span></pre><p id="d79b" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">让我们现在建立我们的实际模型。我们只是在构建一个前馈神经网络，所以顺序模型很容易就足够了。我们的模型由具有ReLU激活函数和20个节点的密集层组成，然后以代表最终分类预测的1个节点结束。为了了解更多关于激活函数sigmoid和ReLU的含义，<a class="ae ks" href="https://medium.com/@joshua.payne/activation-functions-in-artificial-neural-networks-8aa6a5ddf832" rel="noopener">看看这个</a>。</p><p id="c94d" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">我们的输入形状代表了我们的特征数组的形状。</p><pre class="kx ky kz la gt ml mm mn mo aw mp bi"><span id="134f" class="mq lj it mm b gy mr ms l mt mu">model = Sequential()</span><span id="8a1b" class="mq lj it mm b gy mv ms l mt mu">model.add(Dense(20, input_shape=(30,)))</span><span id="411e" class="mq lj it mm b gy mv ms l mt mu">model.add(Dense(20, activation=’relu’))</span><span id="fe8f" class="mq lj it mm b gy mv ms l mt mu">model.add(Dense(20, activation=’relu’))</span><span id="2006" class="mq lj it mm b gy mv ms l mt mu">model.add(Dense(20, activation=’relu’))</span><span id="de4b" class="mq lj it mm b gy mv ms l mt mu">model.add(Dense(1, activation=’sigmoid’))</span></pre><p id="db3c" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">我们现在将编译我们的模型。Adam优化器非常有效，二元交叉熵是两类分类问题的首选损失函数。它将sigmoid输出舍入为整数，然后将其与数据集的输出进行比较，以测量误差。“输出”代表乳腺癌的预测或实际诊断——0代表良性，1代表恶性。我们将使用精确度指标，以便了解我们的模型在分类这些类型的乳腺肿瘤时有多精确。</p><div class="mw mx gp gr my mz"><a href="https://www.datadriveninvestor.com/2019/02/08/machine-learning-in-finance/" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd iu gy z fp ne fr fs nf fu fw is bi translated">金融中的机器学习|数据驱动的投资者</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">在我们讲述一些机器学习金融应用之前，我们先来了解一下什么是机器学习。机器…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn lg mz"/></div></div></a></div><p id="377d" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">之后，我们将使我们的模型适合我们的训练数据，传递数据500次，并且具有0.3的验证分割。这意味着我们的数据的30%成为验证数据，我们的模型测试它的验证准确性。这些不同于测试样本，因为这些样本用于我们自己的预测，不在我们模型的训练范围内。然后我们会保存我们神经网络的历史。</p><pre class="kx ky kz la gt ml mm mn mo aw mp bi"><span id="2744" class="mq lj it mm b gy mr ms l mt mu">model.compile(optimizer=’adam’, loss=’binary_crossentropy’, metrics=[‘accuracy’])</span><span id="3a9e" class="mq lj it mm b gy mv ms l mt mu">history = model.fit(x_train, y_train, epochs=500, validation_split=0.3)</span><span id="8e24" class="mq lj it mm b gy mv ms l mt mu">history_dict = history.history</span></pre><p id="2647" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">现在是时候在图表上绘制我们在模型训练期间测量的训练损失和验证损失，以更好地了解我们的网络是如何运行的。</p><pre class="kx ky kz la gt ml mm mn mo aw mp bi"><span id="df32" class="mq lj it mm b gy mr ms l mt mu">loss_values = history_dict[‘loss’]</span><span id="f5ab" class="mq lj it mm b gy mv ms l mt mu">val_loss_values = history_dict[‘val_loss’]</span><span id="a295" class="mq lj it mm b gy mv ms l mt mu">plt.figure()</span><span id="b83e" class="mq lj it mm b gy mv ms l mt mu">plt.plot(loss_values, ‘bo’, label=’training loss’)</span><span id="d6ac" class="mq lj it mm b gy mv ms l mt mu">plt.plot(val_loss_values, ‘r’, label=’validation loss’)</span></pre><p id="0cbd" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">经过500次迭代训练模型后，这里是最后一个时期的指标和我们的图表。</p><pre class="kx ky kz la gt ml mm mn mo aw mp bi"><span id="1587" class="mq lj it mm b gy mr ms l mt mu">Epoch 500/500<br/>317/317 [==============================] - 0s 155us/sample - loss: 0.0851 - accuracy: 0.9621 - val_loss: 0.1539 - val_accuracy: 0.9270</span></pre><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi no"><img src="../Images/65e8c00acb6949b80f64dc13bf8f7167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4KGJK0qqYfw0kh0IuFHRw.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">Labels and legend added by me :)</figcaption></figure><p id="5d3c" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">我们显然超级成功！由于验证和训练数据的超低损失率和高准确性，我们的模型非常成功。</p><h1 id="f1c1" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">让我们看看它的实际效果吧！</h1><p id="066e" class="pw-post-body-paragraph jt ju it jw b jx mg jz ka kb mh kd ke kt mi kh ki ku mj kl km kv mk kp kq kr im bi translated">我们将使用测试数据中的第一个数据样本，并查看我们的模型预测的标签。这意味着我们将使用x_test[1]。</p><pre class="kx ky kz la gt ml mm mn mo aw mp bi"><span id="f70a" class="mq lj it mm b gy mr ms l mt mu">x_test[1] = [1.096e+01 1.762e+01 7.079e+01 3.656e+02 9.687e-02 9.752e-02 5.263e-02 2.788e-02 1.619e-01 6.408e-02 1.507e-01 1.583e+00 1.165e+00 1.009e+01 9.501e-03 3.378e-02 4.401e-02 1.346e-02 1.322e-02 3.534e-03 1.162e+01 2.651e+01 7.643e+01 4.075e+02 1.428e-01 2.510e-01 2.123e-01 9.861e-02 2.289e-01 8.278e-02]</span></pre><p id="3684" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">但是，当使用Keras进行预测时，我们需要有逗号，并传递一个列表的列表。让我们创建一个新的变量，以便满足这些要求。</p><pre class="kx ky kz la gt ml mm mn mo aw mp bi"><span id="6d00" class="mq lj it mm b gy mr ms l mt mu">x_test_1 = [[1.096e+01, 1.762e+01, 7.079e+01, 3.656e+02, 9.687e-02, 9.752e-02, 5.263e-02, 2.788e-02, 1.619e-01, 6.408e-02, 1.507e-01, 1.583e+00, 1.165e+00, 1.009e+01, 9.501e-03, 3.378e-02, 4.401e-02, 1.346e-02, 1.322e-02, 3.534e-03, 1.162e+01, 2.651e+01, 7.643e+01, 4.075e+02, 1.428e-01, 2.510e-01, 2.123e-01, 9.861e-02, 2.289e-01, 8.278e-02]]</span></pre><p id="604d" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">“0”的输出意味着肿瘤被预测为良性，而“1”的输出意味着恶性预测。通过创建一个类变量，我们可以修改我们的输出来表示肿瘤的类型，而不是0或1。</p><pre class="kx ky kz la gt ml mm mn mo aw mp bi"><span id="0c18" class="mq lj it mm b gy mr ms l mt mu">classes = [‘benign’, ‘malignant’]</span></pre><p id="20dd" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">我们现在可以实际使用我们的模型了！为第一个测试数据样本预测的数字标签0或1被用作classes变量的索引。如果预测0，良性是预测，如果预测1，恶性是预测。</p><pre class="kx ky kz la gt ml mm mn mo aw mp bi"><span id="eef6" class="mq lj it mm b gy mr ms l mt mu">prediction = classes[int(model.predict(x_test_1))]</span></pre><p id="ec13" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">让我们看看我们的模型预测了什么！</p><pre class="kx ky kz la gt ml mm mn mo aw mp bi"><span id="1138" class="mq lj it mm b gy mr ms l mt mu">print(prediction)<br/>&gt;&gt;&gt; benign</span></pre><p id="f7f0" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">我们现在可以检查这个预测是否准确，因为我们知道数据集上的标签实际上是什么。该模型预测第一个测试数据样本的标签(y ),我们在测试数据集中可以交叉引用该标签。</p><pre class="kx ky kz la gt ml mm mn mo aw mp bi"><span id="5d84" class="mq lj it mm b gy mr ms l mt mu">print(classes[int(y_test[1])])<br/>&gt;&gt;&gt; benign</span></pre><p id="dd10" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">实际诊断是良性的，这意味着我们的模型成功地预测了输入数据属于良性还是恶性乳腺癌肿瘤！</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="505b" class="li lj it bd lk ll oa ln lo lp ob lr ls lt oc lv lw lx od lz ma mb oe md me mf bi translated">关键要点</h1><ul class=""><li id="8673" class="of og it jw b jx mg kb mh kt oh ku oi kv oj kr ok ol om on bi translated">分析了良性和恶性肿瘤的医学图像中的现有细胞核</li><li id="af4d" class="of og it jw b jx oo kb op kt oq ku or kv os kr ok ol om on bi translated">使用带有Keras的神经网络，我们能够根据输入数据对乳腺肿瘤进行分类</li><li id="d30c" class="of og it jw b jx oo kb op kt oq ku or kv os kr ok ol om on bi translated">我们实现了96%的准确率和92%的验证准确率！</li><li id="91ec" class="of og it jw b jx oo kb op kt oq ku or kv os kr ok ol om on bi translated">我们的模型准确地预测了我们的第一个测试数据样本是一个良性肿瘤</li></ul><p id="2a5f" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated"><em class="jv">如果你喜欢这篇文章，请随时在joshuapayne1275@gmail.com的</em> <a class="ae ks" href="https://www.linkedin.com/in/joshua-payne-0bb2a7194/" rel="noopener ugc nofollow" target="_blank"> <em class="jv"> LinkedIn </em> </a> <em class="jv">联系我。感谢阅读！</em></p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="ot ou l"/></div></figure></div></div>    
</body>
</html>