<html>
<head>
<title>What Happens When you Call a Function?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当你调用一个函数时会发生什么？</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/what-happens-when-you-call-a-function-3ef37f891175?source=collection_archive---------0-----------------------#2020-04-07">https://medium.datadriveninvestor.com/what-happens-when-you-call-a-function-3ef37f891175?source=collection_archive---------0-----------------------#2020-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0714047f357ea37d3c4edd8caae6f10f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QMm-L4_8KxKiBhAk"/></div></div></figure><p id="62d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当一个函数调用另一个函数时会发生什么？</p><p id="1ce7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，理解堆栈帧很重要。每个函数都有一个堆栈框架。堆栈帧是“与子程序调用相关的数据集合”(<a class="ae kz" href="http://www.cs.uwm.edu/" rel="noopener ugc nofollow" target="_blank">www.cs.uwm.edu</a>)。堆栈帧的大小和结构变化很大，并且是在编译时确定的。我们称这个数据集合为“堆栈框架”，因为我们在堆栈数据结构中组织每个子程序调用。这意味着压入调用堆栈的第一个子程序调用(数据收集)将是最后一个要解析(终止)的堆栈帧。下面是如何构建调用堆栈以及如何执行调用堆栈的逐步分解:</p><ol class=""><li id="cbf2" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">函数期望的任何参数都被推送到堆栈框架上。它们按与在被调用函数参数列表中声明的顺序相反的顺序被推送到堆栈框架上。</li><li id="4f39" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">调用函数的返回地址被推送到堆栈上。这将用于稍后在被调用函数终止后将控制返回给调用函数。</li><li id="6a2c" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">现在被调用的函数处于控制中。被调用函数中定义的任何局部变量也将被推送到堆栈上。</li><li id="34de" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">步骤1–3为被调用的函数组成被认为是“堆栈框架”的东西。被调用的函数可以遍历堆栈帧来获取它需要的任何数据。现在让我们来看看一旦被调用函数终止，它是如何将控制权返回给调用函数的。</li></ol><p id="eb4d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3.被调用函数中的任何局部变量都被弹出堆栈。</p><p id="da55" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.被调用函数通过我们推到堆栈上的调用函数的返回地址将控制权返回给调用函数。</p><ol class=""><li id="2141" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">调用函数(在本例中并不总是)负责清理堆栈的其余部分——被调用函数所期望的参数。</li></ol><p id="23e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">0.被调用的函数现在再次处于控制中。将对创建的堆栈帧重复步骤3-1，直到堆栈清空。</p><p id="b728" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">帧指针通常表示堆栈帧的底部(最高地址，因为堆栈在视觉上是朝着较低的内存增长的)。堆栈指针通常表示堆栈的顶部(最低地址)。框架指针和堆栈指针之间的字节差由编译器决定，代表堆栈框架的大小。</p><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/3edc02cc127478da57521ef77a016446.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*QT2ST4Lc8u1Xz9UDOlegFQ.png"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk">The call stack holding multiple subroutine calls</figcaption></figure><p id="5846" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们在一个叫做“<a class="ae kz" href="https://www.hackerrank.com/challenges/the-power-sum/problem" rel="noopener ugc nofollow" target="_blank">幂和</a>”的棘手递归算法问题的上下文中检查堆栈帧会发生什么</p><div class="lx ly gp gr lz ma"><a href="https://www.datadriveninvestor.com/2020/01/16/software-development-process-how-to-pick-the-right-process/" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd iu gy z fp mf fr fs mg fu fw is bi translated">软件开发过程:如何选择正确的过程？数据驱动的投资者</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">软件是任何企业组织成功的生命线。没有软件的帮助，一个…</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo jz ma"/></div></div></a></div><p id="ec0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">幂和问题给你两个整数X和N作为输入。它要求你“找出一个给定的整数X可以用唯一自然数的幂的和来表示的方法。”</p><p id="d2c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">例如:</strong></p><p id="fbc0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">X = 100</p><p id="5b96" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">N = 2</p><p id="2e36" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要找出平方和为100的唯一数字的组合数。</p><p id="ff79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，答案是3:</p><ol class=""><li id="7c98" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi">10² = 100</li><li id="f5c5" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi">6² + 8² = 100</li><li id="db49" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi">1² + 3² + 4² + 5² + 7² = 100</li></ol><p id="9115" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们快速解决这个问题。我们将使用X = 10和N = 2来使事情更容易管理。</p><p id="b7ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们需要从用户那里获取命令行参数来获得X和n。然后我们需要用三个参数调用我们的函数p _ sum():X、N和num。对于我们的第一个调用，num将被设置为1。num有什么意义？</p><p id="5775" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好吧，我们需要找到所有的数字组合，当它们被提升到N时，等于x。我们将告诉我们的p_sum()函数期待另一个参数num，我们将开始提升它的N次幂，并查看结果是大于、等于还是小于我们的目标x。</p><p id="d2f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是一些伪代码，希望能让这一点更清楚:</p><ol class=""><li id="6b42" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">接受main()中的命令行参数，用X、N和num调用p_sum()</li></ol><p id="51f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意:现在我们在p_sum()中</p><ol class=""><li id="9735" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">检查是否pow(num，N)&lt; X</li></ol><ul class=""><li id="b0f6" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky mp lg lh li bi translated">If num raised to the N is less than X, we can make another recursive call to p_sum() but this time with num+1.</li></ul><p id="2bfa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">jump to instruction #2.</p><ul class=""><li id="22aa" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky mp lg lh li bi translated">In the second recursive call, we are searching for the number squared that will make up the difference from whatever we generated in the first recursive call minus X. That is, we want to call p_sum() again with (X-pow(num, N), N, num+1).</li></ul><p id="9e98" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2. If pow(num, N) is not less than X, we should check if pow(num, N) == X. This is a base case and we would return 1.</p><p id="d0c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3. If pow(num, N) is not less than or equal to X it must be greater than X. This is also a base case and we would just return 0.</p><p id="3ccc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Let’s assume that either base case #2 or #3 hit. We will return either 0 or 1 and terminate the current stack frame. Now we’d need to jump back to the second bullet point and make the next recursive call in the previous stack frame.</p><p id="0c93" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Now let’s take a look at a C implementation of the above pseudo-code (this code was largely inspired by @sourabhsingh’s implementation on HackerRank:</p><p id="5731" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">#include <stdio.h><br/># include&lt;math . h&gt;<br/># include&lt;stdlib . h&gt;</stdio.h></p><p id="2418" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">int p_sum(int X，int N，int num) <br/> { <br/> if (pow(num，N) &lt; X) <br/> return p_sum(X，N，num+1) + p_sum(X-pow(num，N)，N，num+1)；<br/> else if (pow(num，N) == X) <br/>返回1；<br/>否则<br/>返回0；<br/> }</p><p id="4a7e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">int main(int argc，char* argv[]) <br/> { <br/> int X，N，ans</p><p id="a772" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">if (argc &lt; 3)<br/>返回1；</p><p id="d9fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">x = atoi(argv[1])；<br/>N = atoi(argv[2])；</p><p id="f9ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">ans = p_sum(X，N，1)；<br/> printf("ans is: %d\n "，ans)；</p><p id="7e08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">返回ans<br/> }</p><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mq"><img src="../Images/0c62312cb0b3c1686a1eeef3eeaecb00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ZKxfDeqLwBU-aQ_SsqSbQ.jpeg"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk">Visual of the call stack executing. Start at frame #0.</figcaption></figure><p id="700a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我上面的调用堆栈执行的视觉效果可能看起来令人不知所措/混乱不堪。我强烈建议你自己去追查。Python Tutor(可以处理许多其他语言)也是可视化栈如何变化的一个很好的资源。</p><p id="16f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们简单地看一下当我们从main()的第0帧开始递归调用p_sum()时发生了什么:</p><ol class=""><li id="0e69" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">p_sum()的参数按它们在参数列表中列出的相反顺序压入堆栈。</li><li id="05a0" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">main()函数的返回地址被推送到堆栈上，所以p_sum()将知道一旦它完成执行，将控制返回到哪里。控制权现在转移到p_sum()。</li><li id="3e3b" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">p_sum()中定义的任何局部变量都被推送到堆栈框架上。</li></ol><p id="9442" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">重复相同的过程(使用更新的值),直到达到基本情况，帧开始弹出堆栈:</p><p id="270d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3.从堆栈框架中弹出局部变量。</p><p id="feab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.控制返回到先前的堆栈帧，返回地址从堆栈帧中弹出。</p><ol class=""><li id="0735" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">用于调用刚刚终止的函数的参数被弹出堆栈框架。</li></ol><p id="ddb3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">0.堆栈框架现在是空的，并从堆栈中弹出。</p><p id="2648" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望您更清楚在调用函数时调用堆栈上实际发生了什么。这将使您更好地处理递归，并使调试递归程序更容易。</p><figure class="lp lq lr ls gt ju"><div class="bz fp l di"><div class="mr ms l"/></div></figure></div></div>    
</body>
</html>