<html>
<head>
<title>Introduction To Functional Programming using Ramda JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Ramda JS的函数式编程简介</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/introduction-to-functional-programming-using-randa-js-94c7a54977fe?source=collection_archive---------8-----------------------#2020-11-22">https://medium.datadriveninvestor.com/introduction-to-functional-programming-using-randa-js-94c7a54977fe?source=collection_archive---------8-----------------------#2020-11-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d40eb7c71451d65bc64295b62d9c2444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I51LgPIYjD2viQQsiJWnVA.png"/></div></div></figure><p id="ee5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当个人谈论函数式编程时，通常会提到一些函数特性，如不可变数据、纯函数和尾调用优化。</p><p id="2f2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对我来说，函数式编程是关于声明式编程风格和数据流，而不是控制流。</p><p id="09ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们举个例子，</p><p id="de8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设您正在构建一个电子商务系统。这个电子商务系统应该接收一个订单，并对其应用一些折扣；如果有两个以上的折扣适用，您的函数应该返回两个最高折扣的平均值。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="96b0" class="lf lg iq lb b gy lh li l lj lk">export interface Order {</span><span id="7800" class="lf lg iq lb b gy ll li l lj lk">         Amount: number</span><span id="afde" class="lf lg iq lb b gy ll li l lj lk">         Name: string</span><span id="e5e4" class="lf lg iq lb b gy ll li l lj lk">}</span><span id="3f38" class="lf lg iq lb b gy ll li l lj lk">export interface Discount {</span><span id="40b2" class="lf lg iq lb b gy ll li l lj lk">            Apply: (amount: number) =&gt; number;</span><span id="c6c9" class="lf lg iq lb b gy ll li l lj lk">            IsValid: (order: Order) =&gt; boolean;</span><span id="f85f" class="lf lg iq lb b gy ll li l lj lk">}</span><span id="bcd1" class="lf lg iq lb b gy ll li l lj lk">function ApplyValidDiscounts(order: Order, discounts: Discount[], numberOfDiscounts: number)<br/>{<br/>}</span></pre><p id="bd11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">试图使用命令式编程代码来编写这个方法会导致一大块庞大的代码。(如果你不相信我，你自己试试)</p><h1 id="d174" class="lm lg iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">我将以这个规则定义(R.When)开始我的解决方案。</h1><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="b966" class="lf lg iq lb b gy lh li l lj lk">const ApplyDiscountIfValid = (discount: Discount, order: Order) =&gt; R.when((order: Order) =&gt; CanApplyDiscount(discount, order),<br/>       (order: Order) =&gt; ApplyDiscount(discount, order), order);</span></pre><p id="f3dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我认为给定订单和折扣，这是不言自明的。如果适用，应用折扣。</p><h1 id="b848" class="lm lg iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">现在我们需要定义“CanApplyDiscount”和“ApplyDiscount”:</h1><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="ec1e" class="lf lg iq lb b gy lh li l lj lk">const CanApplyDiscount = (discount: Discount, order: Order) =&gt; discount.IsValid(order);</span></pre><p id="1128" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然CanApplyDiscount非常简单明了，但ApplyDiscount要简单得多。复杂，因为它应该调用“折扣”方法。Apply()"来获得折扣价，然后用新的金额创建一个新的Order对象。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="3b2c" class="lf lg iq lb b gy lh li l lj lk">const ApplyDiscount = (discount: Discount, order: Order) =&gt; <br/>R.pipe(<br/>        () =&gt; discount.Apply(order.Amount),<br/>        (newAmount) =&gt; WithAmount(newAmount, order))();</span></pre><p id="51b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们有一个操作链，并且每个操作都依赖于前一个操作的输出时，我们称之为流水线。</p><p id="b273" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前面的代码相当于</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="3beb" class="lf lg iq lb b gy lh li l lj lk">const ApplyDiscount = (discount: Discount, order: Order)=&gt;{<br/>      var newAmount=discount.Apply(order.Amount);<br/>      return WithAmount(newAmount , order)</span><span id="7326" class="lf lg iq lb b gy ll li l lj lk">}</span></pre><h1 id="6cd0" class="lm lg iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">现在我们需要带mount的函数</h1><p id="6a49" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">该函数应该返回一份修改了金额的订单。修改复制订单的数量意味着突变。在函数式编程中访问和设置属性最好由镜头来完成。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="ca66" class="lf lg iq lb b gy lh li l lj lk">const AmountLens=R.lensProp("Amount");</span><span id="9909" class="lf lg iq lb b gy ll li l lj lk">const WithAmount = (newAmount: number, order: Order) =&gt; R.over(AmountLens, (_) =&gt; newAmount, order);</span></pre><blockquote class="mo mp mq"><p id="1283" class="jy jz mr ka b kb kc kd ke kf kg kh ki ms kk kl km mt ko kp kq mu ks kt ku kv ij bi translated">镜头是什么？为什么要使用它？</p><p id="1dae" class="jy jz mr ka b kb kc kd ke kf kg kh ki ms kk kl km mt ko kp kq mu ks kt ku kv ij bi translated">透镜是一种封装了特定属性的setter和getter的类型，使用透镜的主要好处是:</p><p id="45f3" class="jy jz mr ka b kb kc kd ke kf kg kh ki ms kk kl km mt ko kp kq mu ks kt ku kv ij bi translated">1-镜头可重复使用:例如，上面定义的AmountLens可用于任何具有称为Amount属性的对象。</p><p id="1287" class="jy jz mr ka b kb kc kd ke kf kg kh ki ms kk kl km mt ko kp kq mu ks kt ku kv ij bi translated">2-代码可读性和意图声明:在函数中定义Lens表明underline属性是函数关注点；这暗示了这个属性会在某个时候发生变异。</p></blockquote><p id="8040" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">R.Over将复制订单(最后一个参数)，然后访问带下划线的透镜属性(数量)，并使用setter函数设置它(第二个参数)。</p><div class="mv mw gp gr mx my"><a href="https://www.datadriveninvestor.com/2019/02/21/best-coding-languages-to-learn-in-2019/" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd ir gy z fp nd fr fs ne fu fw ip bi translated">2019年最值得学习的编码语言|数据驱动的投资者</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">在我读大学的那几年，我跳过了很多次夜游去学习Java，希望有一天它能帮助我在…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm jw my"/></div></div></a></div><h1 id="4f6a" class="lm lg iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">应用所有折扣</h1><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="98c5" class="lf lg iq lb b gy lh li l lj lk">const ApplyAllDiscounts = (order: Order, discounts: Discount[]) =&gt; R.map(discount =&gt; ApplyDiscountIfValid(discount, order), discounts);</span></pre><p id="8f8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该函数将对所有折扣进行循环，并使用ApplyDiscountIfValid应用它们。</p><h1 id="f7ce" class="lm lg iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">应用有限数量的折扣</h1><p id="3a38" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">由于ApplyAllDiscounts将在折扣适用的情况下返回新的order对象，而在折扣不适用的情况下返回相同的旧对象，因此我们需要过滤订单。</p><h2 id="5a15" class="lf lg iq bd ln nn no dn lr np nq dp lv kj nr ns lz kn nt nu md kr nv nw mh nx bi translated">过滤折扣订单</h2><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="06a8" class="lf lg iq lb b gy lh li l lj lk">const ApplyLimitedNumberOfDiscounts = (order: Order, discounts: Discount[], numberOfDiscounts: number) =&gt; <br/>R.pipe(() =&gt;<br/>          ApplyAllDiscounts(order, discounts),<br/>          result =&gt; <br/>                R.filter(discountedOrder =&gt; discountedOrder.Amount  <br/>                                            != order.Amount, result)<br/>)();</span></pre><h2 id="529e" class="lf lg iq bd ln nn no dn lr np nq dp lv kj nr ns lz kn nt nu md kr nv nw mh nx bi translated">按金额升序排列。</h2><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="e421" class="lf lg iq lb b gy lh li l lj lk">const ApplyLimitedNumberOfDiscounts = (order: Order, discounts: Discount[], numberOfDiscounts: number) =&gt; <br/>R.pipe(() =&gt;<br/>          ApplyAllDiscounts(order, discounts),<br/>          result =&gt; <br/>                R.filter(discountedOrder =&gt; discountedOrder.Amount  <br/>                                            != order.Amount,result),<br/>          result=&gt;R.sortBy(discount=&gt;discount.Amount,result)</span><span id="900f" class="lf lg iq lb b gy ll li l lj lk">)();</span></pre><h2 id="b127" class="lf lg iq bd ln nn no dn lr np nq dp lv kj nr ns lz kn nt nu md kr nv nw mh nx bi translated">最后，只从列表中选择所需的折扣数量。</h2><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="472a" class="lf lg iq lb b gy lh li l lj lk">const ApplyLimitedNumberOfDiscounts = (order: Order, discounts: Discount[], numberOfDiscounts: number) =&gt; <br/>R.pipe(() =&gt;<br/>          ApplyAllDiscounts(order, discounts),<br/>          result =&gt; <br/>                R.filter(discountedOrder =&gt; discountedOrder.Amount  <br/>                                            != order.Amount,result),<br/>          result =&gt; R.sortBy(discount=&gt;discount.Amount,result),<br/>          result =&gt; R.take(numberOfDiscounts, result)<br/>)();</span></pre><h1 id="3b1f" class="lm lg iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">将订单列表缩减(聚合)为一个订单</h1><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="31f4" class="lf lg iq lb b gy lh li l lj lk">export const ApplyValidDiscounts = (order: Order, discounts: Discount[], numberOfDiscounts: number) =&gt;<br/>          R.reduce(ReduceDiscountedOrders, WithAmount(0,order), ApplyLimitedNumberOfDiscounts(order, discounts, numberOfDiscounts))</span></pre><p id="162d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">R.Reduce需要一个reducing函数(order1，order2=&gt;order)、一个初始对象和数据源。数据源是ApplyLimitedNumberOfDiscounts的结果，初始订单对象应该是一个金额为零的空订单。</p><h2 id="e2b7" class="lf lg iq bd ln nn no dn lr np nq dp lv kj nr ns lz kn nt nu md kr nv nw mh nx bi translated">缩减功能</h2><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="09a9" class="lf lg iq lb b gy lh li l lj lk">const ReduceDiscountedOrders = (order1: Order, order2: Order)=&gt;<br/>        R.pipe(<br/>               ()=&gt;Median(order1.Amount, order2.Amount),<br/>               (newAmount:number)=&gt; WithAmount(newAmount, order1)<br/>)();</span></pre><p id="4283" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它接受两个订单对象，计算它们的中值，并返回第一个订单的克隆，金额=中值。</p><h2 id="cb81" class="lf lg iq bd ln nn no dn lr np nq dp lv kj nr ns lz kn nt nu md kr nv nw mh nx bi translated">中位数函数</h2><p id="ac04" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">不幸的是，R.Median只能处理数组，所以要处理params(动态参数数),我们需要使用R.unapply</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="0e7f" class="lf lg iq lb b gy lh li l lj lk">const Medium=R.unapply(R.Medium);</span></pre><p id="6ce6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们需要过滤零金额，所以我们不会忽略空单。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="1d7a" class="lf lg iq lb b gy lh li l lj lk">const Median = R.unapply&lt;number&gt;((inputs)=&gt;<br/>R.pipe((numbers:number[])=&gt;<br/>                        R.filter(val=&gt;val!=0,numbers),R.median) (&lt;number[]&gt;inputs));</span></pre><h1 id="07df" class="lm lg iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">完整的代码</h1><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="18c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和测试函数</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="00f4" class="lf lg iq lb b gy lh li l lj lk">function Test() {</span><span id="6f2e" class="lf lg iq lb b gy ll li l lj lk">var result = Main.OrderProcessing.ApplyValidDiscounts({ Name: "order1", Amount: 1000 }, [</span><span id="40e0" class="lf lg iq lb b gy ll li l lj lk">{ Apply: (amount) =&gt; amount - amount / 3, IsValid: (order) =&gt; order.Amount &gt;= 5000 },</span><span id="17b3" class="lf lg iq lb b gy ll li l lj lk">{ Apply: (amount) =&gt; amount - amount / 2.5, IsValid: (order) =&gt; order.Amount &gt;= 2000 },</span><span id="3eb4" class="lf lg iq lb b gy ll li l lj lk">{ Apply: (amount) =&gt; amount - amount / 2, IsValid: (order) =&gt; order.Amount &gt;= 1000 },</span><span id="01b7" class="lf lg iq lb b gy ll li l lj lk">{ Apply: (amount) =&gt; amount - amount / 2.25, IsValid: (order) =&gt; order.Amount &gt;= 500 },</span><span id="a5a4" class="lf lg iq lb b gy ll li l lj lk">{ Apply: (amount) =&gt; amount - 100, IsValid: (order) =&gt; order.Name.endsWith("1") },</span><span id="cc85" class="lf lg iq lb b gy ll li l lj lk">{ Apply: (amount) =&gt; amount - 200, IsValid: (order) =&gt; order.Name.endsWith("2") },</span><span id="8428" class="lf lg iq lb b gy ll li l lj lk">], 1);</span><span id="f9f3" class="lf lg iq lb b gy ll li l lj lk">console.log(result);</span><span id="0a3d" class="lf lg iq lb b gy ll li l lj lk">}</span></pre><p id="a1f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">进入专家视角— </strong> <a class="ae oa" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>