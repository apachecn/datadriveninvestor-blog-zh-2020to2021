<html>
<head>
<title>Axios Instance &amp; Interceptors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Axios实例和拦截器</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/axios-instance-interceptors-682868f0de2d?source=collection_archive---------0-----------------------#2020-03-29">https://medium.datadriveninvestor.com/axios-instance-interceptors-682868f0de2d?source=collection_archive---------0-----------------------#2020-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/c5821b008f2120d346ed291e6e218337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*80J2Wa21DYXxMbbtBziJHg.png"/></div></div></figure><div class=""/><p id="4212" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Api调用从未如此简单</p><p id="7f63" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我有机会重构我团队的旧代码。当我浏览它时，我发现api调用部分没有模块化。他们使用过Axios，但没有充分利用它的功能。</p><p id="f9b0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我必须重构的主要需求是:</p><ul class=""><li id="434b" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">为多个端点创建实例，我们使用了。</li><li id="da1b" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">为需要授权的实例设置令牌。</li><li id="66ff" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">在进行http调用之前，对报头进行多重验证。</li></ul></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><blockquote class="lr ls lt"><p id="7c0e" class="jy jz lu ka b kb kc kd ke kf kg kh ki lv kk kl km lw ko kp kq lx ks kt ku kv ij bi translated"><strong class="ka jc"> <em class="jb">那么什么是AXIOS </em> </strong></p></blockquote><p id="50f0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Axios基本上是一个外部库，用于进行基于promise的HTTP调用(使获取变得容易，并为我们提供结构化的响应)。它是推荐的库之一，与ReactJs一起使用。人们没有真正意识到的是，它不仅仅是发出一个get/post请求。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="d29b" class="mh mi jb md b gy mj mk l ml mm">npm i --s axios</span></pre><p id="9312" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看一个基本实现:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="5fbd" class="mh mi jb md b gy mj mk l ml mm">import axios from 'axios';</span><span id="b2b9" class="mh mi jb md b gy mn mk l ml mm">axios.get('<a class="ae mo" href="https://jsonplaceholder.typicode.com/todos" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos</a>').then(func)</span></pre><p id="8ffe" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">* <em class="lu">注意:我将为我的虚拟api调用使用</em><strong class="ka jc"><em class="lu">jsonplaceholder</em></strong><em class="lu">。</em></p><blockquote class="lr ls lt"><p id="1399" class="jy jz lu ka b kb kc kd ke kf kg kh ki lv kk kl km lw ko kp kq lx ks kt ku kv ij bi translated"><em class="jb">创建实例</em></p></blockquote><p id="7544" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们对同一个端点进行多次api调用会怎么样呢？必须添加完整的url似乎不太合适，而且如果后来端点被更改，这些更改看起来需要太多的手工修改。</p><div class="ip iq gp gr ir mp"><a href="https://www.datadriveninvestor.com/2020/02/19/five-data-science-and-machine-learning-trends-that-will-define-job-prospects-in-2020/" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd jc gy z fp mu fr fs mv fu fw ja bi translated">将定义2020年就业前景的五大数据科学和机器学习趋势|数据驱动…</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">数据科学和ML是2019年最受关注的趋势之一，毫无疑问，它们将继续发展…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd ix mp"/></div></div></a></div><p id="56f3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们通过使用<strong class="ka jc"> create </strong>方法来创建我们的实例，这是您在上面做的axios导入的一部分。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="6a5c" class="mh mi jb md b gy mj mk l ml mm">const instance = axios.create()</span></pre><p id="6487" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们将端点设置为上述实例的baseurl。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="0232" class="mh mi jb md b gy mj mk l ml mm">const instance = axios.create({baseURL:"<a class="ae mo" href="https://jsonplaceholder.typicode.com/todos" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/</a>"})</span></pre><p id="bb40" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lu">对于给定的axios实例，可以设置更多的选项，baseURL和headers是最常见的，试着在评论中分享你的配置</em></p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/2b1bdb940d13fceccdb3f56f7a381f0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gQ60GCTrf-0W4bKKi-WpLw.png"/></div></div></figure><p id="3646" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">企业应用程序通常有多个端点，创建多个实例来为每个端点创建单个源更容易。</p><p id="e112" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lu">对于命名约定，我使用endpointName.instatnce.js。这是我个人使用的，自从我开始使用React以来。</em></p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/e714368f003e5434c09b68e89b2aad7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*B7AnP20g8dUZg84SWxPhMw.png"/></div></figure><p id="a311" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，第一个要求就完成了。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><blockquote class="lr ls lt"><p id="fde1" class="jy jz lu ka b kb kc kd ke kf kg kh ki lv kk kl km lw ko kp kq lx ks kt ku kv ij bi translated">在标头中设置身份验证令牌</p></blockquote><p id="0d4b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以这比看起来要简单一点，我们只需要更新上面的实例来设置这个令牌一次。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="f25f" class="mh mi jb md b gy mj mk l ml mm">export const setAuthToken = token =&gt; {<br/> if (token) {<br/> //applying token<br/> instance.defaults.headers.common['Authorization'] = token;<br/> } else {<br/> //deleting the token from header<br/> delete instance.defaults.headers.common['Authorization'];<br/> }<br/>}</span></pre><p id="4243" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，当我们得到令牌时，我们只需调用方法，令牌就会添加到头部。对于我们使用实例对端点进行的每个调用，都会添加auth令牌。</p><p id="98b0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果我们仍然想在调用之前验证它，那么拦截器就派上用场了。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><blockquote class="lr ls lt"><p id="a7a0" class="jy jz lu ka b kb kc kd ke kf kg kh ki lv kk kl km lw ko kp kq lx ks kt ku kv ij bi translated">Axios拦截器</p></blockquote><p id="34ef" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么什么是拦截器，为什么我们应该使用它们？</p><p id="e092" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">拦截器是在main方法之前被触发的方法。拦截器有两种类型:</p><ul class=""><li id="35d0" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka jc">请求拦截器</strong>:这是在实际调用端点之前调用的。</li><li id="9906" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka jc">响应拦截器</strong>:在承诺完成，数据被then回调接收之前调用。</li></ul><p id="76f7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以把拦截器看作是请求/响应和实际承诺之间的隧道。</p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ng"><img src="../Images/14e28ad0440e81c38383737ec8e39070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*417ikPv6tK1iGQAsvZHk6Q.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Interceptor tunnel</figcaption></figure><p id="b863" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以这是第三个要求的一部分。我们将更新上面的例子，然后检查最终的输出。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="421b" class="mh mi jb md b gy mj mk l ml mm">instance.interceptors.request.use(req =&gt; {<br/>  if (axios.defaults.headers.common["Authorization"]) return req;<br/>  throw ({message:"the token is not available"});<br/> },error=&gt;{<br/>  return Promise.reject(error);<br/> }<br/>);</span></pre><p id="b609" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们添加一个响应拦截器，看看如何使用它:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="81b6" class="mh mi jb md b gy mj mk l ml mm">//on successful response<br/>instance.interceptors.response.use(response=&gt;response,<br/>error=&gt;{<br/>  const fallbackValue = [<br/>    {userId: "Not authorized",id: "aerw15311sq",<br/>     title: "Please try     again",completed: false}];<br/>   return Promise.reject(fallbackValue);}<br/>);</span></pre><p id="9792" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果使用得当，拦截器会非常有用，因为它允许我们甚至在执行main方法之前进行检查甚至修改。</p><p id="215c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lu">我个人更喜欢使用响应拦截器，而不是请求拦截器。</em></p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><p id="3e39" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这有助于你理解Axios的强大，使用它，如果有任何问题，请告诉我。</p><figure class="ly lz ma mb gt is"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div></div>    
</body>
</html>