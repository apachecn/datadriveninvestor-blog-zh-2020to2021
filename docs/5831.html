<html>
<head>
<title>Simple way to stream Kubernetes logs with sidecar pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用sidecar模式传输Kubernetes日志的简单方法</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/simple-way-to-stream-kubernetes-logs-with-sidecar-pattern-5240ee88e8f0?source=collection_archive---------0-----------------------#2020-10-02">https://medium.datadriveninvestor.com/simple-way-to-stream-kubernetes-logs-with-sidecar-pattern-5240ee88e8f0?source=collection_archive---------0-----------------------#2020-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ee0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们在容器中托管无状态应用程序时，尤其是在Kubernetes中，我们面临的最大挑战之一是如何将应用程序日志数据流式传输到任何类型的目的地。库伯内特生态系统是一个高度分布和动态的环境。在真实的生产环境中，可能会运行许多包含数百个容器的机器，这些容器可以在任何时间点终止、重启或重新调度。这是自然的，系统的容器化本身就是一个挑战，最好考虑一下如何获得不会丢失的应用程序日志。</p><p id="ae1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes架构提供了许多管理应用程序日志的方法。可以考虑的一些方法有:</p><ul class=""><li id="5541" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">使用运行在应用程序窗格中的日志边车容器。</li><li id="6ff7" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">使用在每个节点上运行的节点级日志代理和DaemonSet。</li><li id="7c8a" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">将应用程序中的日志直接推送到一些日志存储系统。</li></ul><p id="cd39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中，我将提供如何用<strong class="jp ir"> EFKK </strong>栈(EFKK代表ElasticSearch、Fluentd、Kibana和Kubernetes)捕获应用程序日志并发送到日志存储系统。</p><h1 id="c374" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">什么是边车模式</h1><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi lx"><img src="../Images/60ccb1f30bb077efb2cec371b6827856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_3R1d16wXx2SNtSaInIHbA.jpeg"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk">Linn Naing is one of more than 26,000 licensed sidecar drivers in Yangon, Myanmar. With fares ranging from 20 cents to 50 cents, sidecars remain a cheaper option than taxis for short-distance trips. (Julie Makinen / Los Angeles Times)</figcaption></figure><p id="6f01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个单节点模式是sidecar模式。sidecar模式是由两个容器组成的单节点模式。第一个是应用程序容器，另一个容器将从应用程序容器获取日志并传输到日志系统，称为<strong class="jp ir"> sidecar </strong>容器。sidecar也与父应用程序共享相同的生命周期，与父应用程序一起创建和退出。</p><p id="d5c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，docker容器日志将保存在主机上的<strong class="jp ir"> /var/log/containers </strong>目录中。如果您的应用程序没有输出到stdout和stderr，那么您可以在您的应用程序旁边部署一个sidecar容器，该容器将获取应用程序日志并将它们分别传输到<strong class="jp ir"> stdout </strong>和<strong class="jp ir"> stderr </strong>。</p><div class="mn mo gp gr mp mq"><a href="https://www.datadriveninvestor.com/2020/05/14/the-sway-of-individuality-for-the-benefit-of-mainstream-and-sake-of-rebellious-minority/" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">为了主流的利益和反叛的少数民族的利益，个性的摇摆|数据…</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">在一个给定的社会中，个人独立行动的能力受到多种因素的影响，例如…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne mh mq"/></div></div></a></div><p id="c0be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将配置<strong class="jp ir"> Fluentd </strong>配置文件如下:</p><pre class="ly lz ma mb gt nf ng nh ni aw nj bi"><span id="78e6" class="nk la iq ng b gy nl nm l nn no">&lt;source&gt;<br/>  <a class="ae np" href="http://twitter.com/type" rel="noopener ugc nofollow" target="_blank">@type</a> tail<br/>  <a class="ae np" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a> in_tail_container_logs<br/>  <a class="ae np" href="http://twitter.com/label" rel="noopener ugc nofollow" target="_blank">@label</a> <a class="ae np" href="http://twitter.com/TO_ES" rel="noopener ugc nofollow" target="_blank">@TO_ES</a><br/>  path "/var/log/containers/myapp-namespaces-*.log"<br/>  pos_file "/var/log/mynodejs.log.pos"<br/>  tag "kubernetes.mynodejs.api_server"<br/>  &lt;parse&gt;<br/>    <a class="ae np" href="http://twitter.com/type" rel="noopener ugc nofollow" target="_blank">@type</a> json<br/>    time_format %Y-%m-%dT%H:%M:%S.%NZ<br/>  &lt;/parse&gt;<br/>&lt;/source&gt;</span><span id="a6f0" class="nk la iq ng b gy nq nm l nn no">&lt;label <a class="ae np" href="http://twitter.com/TO_ES" rel="noopener ugc nofollow" target="_blank">@TO_ES</a>&gt;<br/>  &lt;match kubernetes.*.*&gt;<br/>    <a class="ae np" href="http://twitter.com/type" rel="noopener ugc nofollow" target="_blank">@type</a> copy<br/>    &lt;store&gt;<br/>      <a class="ae np" href="http://twitter.com/type" rel="noopener ugc nofollow" target="_blank">@type</a> elasticsearch<br/>      host elasticsearch<br/>      port 9200<br/>      ...<br/>      ...<br/>      &lt;buffer&gt;<br/>        flush_interval 1s<br/>        flush_thread_count 2<br/>      &lt;/buffer&gt;<br/>    &lt;/store&gt;<br/>    &lt;store&gt;<br/>      <a class="ae np" href="http://twitter.com/type" rel="noopener ugc nofollow" target="_blank">@type</a> stdout<br/>    &lt;/store&gt;<br/>  &lt;/match&gt;<br/>&lt;/label&gt;</span></pre><p id="6331" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae np" href="https://docs.fluentd.org/input/tail" rel="noopener ugc nofollow" target="_blank">https://docs.fluentd.org/input/tail</a></p><p id="2b4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上述代码片段中，fluentd将从<strong class="jp ir"> myapp </strong>开始跟踪所有日志文件名，并传输到ElasticSearch，fluentd配置将需要放入ConfigMap，如下所示:</p><pre class="ly lz ma mb gt nf ng nh ni aw nj bi"><span id="2ee6" class="nk la iq ng b gy nl nm l nn no">apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: fluentd-config<br/>  namespace: price-service-dev<br/>  labels:<br/>    k8s-app: fluentd-logging<br/>    version: v1<br/>    kubernetes.io/cluster-service: "true"<br/>data:<br/>  fluent.conf: |<br/>    &lt;source&gt;<br/>      <a class="ae np" href="http://twitter.com/type" rel="noopener ugc nofollow" target="_blank">@type</a> tail<br/>      <a class="ae np" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a> in_tail_container_logs<br/>      <a class="ae np" href="http://twitter.com/label" rel="noopener ugc nofollow" target="_blank">@label</a> <a class="ae np" href="http://twitter.com/TO_ES" rel="noopener ugc nofollow" target="_blank">@TO_ES</a><br/>      ...<br/>      ...<br/>      ...<br/>    &lt;/source&gt;<br/>    &lt;label <a class="ae np" href="http://twitter.com/TO_ES" rel="noopener ugc nofollow" target="_blank">@TO_ES</a>&gt;<br/>      &lt;match kubernetes.*.*&gt;<br/>        <a class="ae np" href="http://twitter.com/type" rel="noopener ugc nofollow" target="_blank">@type</a> copy<br/>        ...<br/>        ...<br/>        ...<br/>    &lt;/label&gt;</span></pre><p id="7732" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，是时候在Kubernetes部署文件中将fluentd容器配置为sidecar了。默认情况下，官方的<a class="ae np" href="https://hub.docker.com/r/fluent/fluentd/" rel="noopener ugc nofollow" target="_blank"> fluentd </a> docker映像不与<a class="ae np" href="https://github.com/uken/fluent-plugin-elasticsearch" rel="noopener ugc nofollow" target="_blank"> elasticsearch </a>插件一起传输，因此我们需要使用<a class="ae np" href="https://hub.docker.com/r/fluent/fluentd-kubernetes-daemonset" rel="noopener ugc nofollow" target="_blank">自定义映像</a>将应用程序日志传输到elasticsearch集群。</p><pre class="ly lz ma mb gt nf ng nh ni aw nj bi"><span id="332e" class="nk la iq ng b gy nl nm l nn no">- name: fluentd<br/>  image: fluent/fluentd-kubernetes-daemonset:v1-debian-elasticsearch<br/>  env:<br/>    - name:  FLUENT_ELASTICSEARCH_HOST<br/>      value: "localhost"<br/>    - name:  FLUENT_ELASTICSEARCH_PORT<br/>      value: "9200"<br/>    - name: FLUENT_ELASTICSEARCH_SCHEME<br/>      value: "http"<br/>    - name: FLUENT_ELASTICSEARCH_USER<br/>      value: "elastic"<br/>    - name: FLUENT_ELASTICSEARCH_PASSWORD<br/>      value: "mypassword"<br/>    - name: FLUENT_UID<br/>      value: "0"<br/>  volumeMounts:<br/>    - name: fluentd-config<br/>      mountPath: /fluentd/etc/fluent.conf<br/>      subPath: fluent.conf<br/>    - name: varlog<br/>      mountPath: /var/log<br/>    - name: varlibdockercontainers<br/>      mountPath: /var/lib/docker/containers<br/>      readOnly: true</span></pre><ul class=""><li id="ae6b" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">使用专门配置了弹性搜索的<code class="fe nr ns nt ng b">fluent/fluentd-kubernetes-daemonset:v1-debian-elasticsearch</code> Docker图像作为Fluentd输出。</li><li id="f041" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">您会看到<strong class="jp ir">配置图</strong>也附在边车容器中。</li><li id="af57" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">它应该提供一些环境变量，以便连接到您的Elasticsearch集群。这些是您的Elasticsearch主机、端口和凭证(用户名、密码)。</li><li id="b832" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">Fluentd需要root权限才能读取<code class="fe nr ns nt ng b">/var/log</code>中的日志并将<code class="fe nr ns nt ng b">pos_file</code>写入<code class="fe nr ns nt ng b">/var/log</code>。为了避免权限错误，在您的清单文件中将<code class="fe nr ns nt ng b">FLUENT_UID</code>环境变量设置为<code class="fe nr ns nt ng b">0</code>。</li></ul><p id="8793" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用我们的自定义Fluentd配置配置一个新的<code class="fe nr ns nt ng b">ConfigMap</code>卷，并将其安装在容器中的<code class="fe nr ns nt ng b">/fluentd/etc/fluent.conf</code>路径。</p><pre class="ly lz ma mb gt nf ng nh ni aw nj bi"><span id="ac9d" class="nk la iq ng b gy nl nm l nn no">volumes:<br/>  - name: fluentd-volume<br/>    configMap:<br/>      name: fluentd-config<br/>  - name: varlog<br/>    hostPath:<br/>      path: /var/log<br/>  - name: varlibdockercontainers<br/>    hostPath:<br/>      path: /var/lib/docker/containers</span></pre><p id="9b86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在<code class="fe nr ns nt ng b">fluentd-efkkk.yml</code>中保存清单并创建部署文件:</p><pre class="ly lz ma mb gt nf ng nh ni aw nj bi"><span id="e827" class="nk la iq ng b gy nl nm l nn no">kubectl apply -f fluentd-<!-- -->efkkk<!-- -->.yml</span></pre><p id="6e2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">部署之后，您将能够看到两个容器在相同的节点上运行，一个是应用程序容器，另一个是日志代理容器，在您的Kubernetes中称为sidecar容器。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nu"><img src="../Images/745841d76c03f56d89b742e660541195.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dJxHFtI5l_NZLaBCBAsG4A.png"/></div></div></figure><h1 id="a5a6" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="c809" class="pw-post-body-paragraph jn jo iq jp b jq nv js jt ju nw jw jx jy nx ka kb kc ny ke kf kg nz ki kj kk ij bi translated">好了，您已经学习了如何将Fluentd部署到Kubernetes集群，以及如何将Kubernetes应用程序及其日志流式传输到Elasticsearch。这只是一个将Kubernetes日志流式传输到ElasticSearch的简单示例，我使用Fluentd作为日志代理，但您也可以使用Fluent Bit或Logstash或类似的东西，这取决于您的选择或您项目的要求。您可以创建更复杂的过滤器，并在Fluentd配置文件中转换日志更复杂的功能。希望你们会喜欢我的文章，也请不要忘记鼓掌。</p><p id="794c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顺便说一下，下一篇文章我将描述如何为你的复杂架构编写集中日志记录系统的Helm Chart库。敬请期待，伙计们…！！！</p><h2 id="2290" class="nk la iq bd lb oa ob dn lf oc od dp lj jy oe of ln kc og oh lr kg oi oj lv ok bi translated">访问专家视图— <a class="ae np" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank">订阅DDI英特尔</a></h2></div></div>    
</body>
</html>