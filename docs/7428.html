<html>
<head>
<title>“Hey Selenium, scrape me a shopping list”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“嘿硒，刮我一张购物清单”</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/hey-selenium-scrape-me-a-shopping-list-bde9628e1536?source=collection_archive---------8-----------------------#2020-12-08">https://medium.datadriveninvestor.com/hey-selenium-scrape-me-a-shopping-list-bde9628e1536?source=collection_archive---------8-----------------------#2020-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="88b8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个有趣而简单的使用python的web抓取示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/df146d1b96bc5d94448b19fb472dde85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*kRtTbUzmR6fjnud6.gif"/></div></figure><p id="cbc4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我最近在做一个项目，涉及到从网站上收集一些数据。我是刮擦的新手。幸运的是，python使用一个名为<a class="ae lm" href="https://pypi.org/project/selenium/" rel="noopener ugc nofollow" target="_blank"> Selenium </a>的库使得基本的web抓取变得非常简单。我将使用Selenium完成一个非常简单的项目，导航<a class="ae lm" href="https://www.zappos.com/" rel="noopener ugc nofollow" target="_blank"> Zappos </a>网站，并为自己创建一个假日购物清单。我将一步一步地展示python代码和检查网站元素，同时展示Selenium中的一些有用的功能，这些功能可以让您立即启动并运行自己的web抓取项目。</p><h2 id="78dd" class="ln lo it bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">硒简介</h2><p id="01b8" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">在进入“有趣的东西”之前，让我们快速介绍一下什么是Selenium。根据PyPI页面，Selenium是一个包<em class="ml">“用于自动化来自Python的web浏览器交互”。</em>几乎所有你可以像人一样做的事情(浏览、搜索、滚动、点击、登录等)，你都可以使用Selenium库编写一个python脚本来完成这些任务。下面是我们将要经历的一个刮擦项目的基本步骤:</p><ol class=""><li id="81a3" class="mm mn it ks b kt ku kw kx kz mo ld mp lh mq ll mr ms mt mu bi translated">打开web浏览器</li><li id="ac7a" class="mm mn it ks b kt mv kw mw kz mx ld my lh mz ll mr ms mt mu bi translated">转到所需网页</li><li id="1edc" class="mm mn it ks b kt mv kw mw kz mx ld my lh mz ll mr ms mt mu bi translated">执行所需的操作</li><li id="0fff" class="mm mn it ks b kt mv kw mw kz mx ld my lh mz ll mr ms mt mu bi translated">从呈现的网页中抓取信息</li></ol><p id="048e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">正如你所看到的，尽管只提到了4个步骤，但这可能包括在到达所需网页之前在网站内的大量导航。这里是Git repo 的<a class="ae lm" href="https://github.com/aviolante/web_scrape_shopping_list" rel="noopener ugc nofollow" target="_blank">链接，包含所有的分步代码和最终的CSV文件，如果你想继续或者直接跳到前面。现在，让我们跳进项目，开始刮！</a></p><h2 id="d9eb" class="ln lo it bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">假日购物清单项目<em class="na"> ct </em></h2><p id="fddf" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated"><em class="ml"> 1。打开网络浏览器</em></p><p id="2f5d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第一步，导入selenium web driver，打开一个空白浏览器或“艺术画布”。我发现火狐作为一个浏览器更容易使用。我们将打开并调用我们的新浏览器<code class="fe nb nc nd ne b">driver</code>,这样我们就可以通过这个驱动程序对象继续“驱动”或操纵浏览器。图1展示了令人兴奋的新打开的Firefox浏览器窗口。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="0bde" class="ln lo it ne b gy nj nk l nl nm">from selenium import webdriver</span><span id="684b" class="ln lo it ne b gy nn nk l nl nm"># open blank browser<br/>driver = webdriver.Firefox()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi no"><img src="../Images/58da3651344317dc318250c0dcec11ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PC7pHixkufX1b4tuqRhRWQ.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">Figure 1 - Empty Firefox web browser</figcaption></figure><p id="d053" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="ml"> 2。转到所需网页</em></p><p id="57cf" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下一步是去你想要的网页。我将导航到零售网站<a class="ae lm" href="https://www.zappos.com/" rel="noopener ugc nofollow" target="_blank"> Zappos </a>。完全公开，我曾经在Zappos工作，但我仍然是一个超级粉丝。随着你做越来越多的网页抓取，你会很快发现，仅仅因为一个网站看起来漂亮并不意味着它编码良好。这导致了所有网站都是独一无二的，所以一个项目可能不会完全翻译成另一个。</p><p id="7c13" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下面你会看到指定的网页，<code class="fe nb nc nd ne b">url</code>，然后我们使用步骤1中的驱动程序对象来打开想要的网页。恭喜你。通过python，你只需打开一个新的Firefox浏览器，并将该浏览器指向一个特定的URL。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="3ef3" class="ln lo it ne b gy nj nk l nl nm"># navigate to a url<br/>url = 'https://www.zappos.com/'<br/>driver.get(url)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi no"><img src="../Images/26e01b7e90a62f0794b9ef8b515ed525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cRkhNKxgEy3QkwagjzuEnw.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">Figure 2 - Navigate to web page</figcaption></figure><p id="5db1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="ml"> 3。执行所需的操作</em></p><p id="78e7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在是大部分工作的时候了，我们将通过具体的动作遍历整个网站。对于这个简单的项目，我们将执行对“<em class="ml">节日礼物</em>的搜索，单击按钮进入所需的网页，并从该页面抓取信息以创建我们的购物清单。</p><p id="4dfd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在开始这些操作之前，我首先想讨论一下我们将在这个项目中使用的主要函数。我们将使用<code class="fe nb nc nd ne b">find_element_by_xpath()</code>。术语XPath指的是XML路径，它帮助您查看网页的HTML结构来查找元素。我发现这个功能是在网页上找到想要的元素的最可靠的方法。当使用XPath时，你会注意到我们将使用一个相对路径，这意味着我们从HTML结构中间的某个地方开始。我不打算深入研究HTML / CSS，但我想向您展示它的样子，以便您可以将HTML和python代码联系起来。你很快就会明白我的意思。让我们看看它是如何工作！</p><p id="f4e8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们看看图2中的搜索栏和搜索按钮。当您在浏览器中右键单击并执行“inspect element”时，您将看到HTML(图3)。有一种<code class="fe nb nc nd ne b">div class</code>叫做“ef”。在这个div中有一个名为“ff”的<code class="fe nb nc nd ne b">form class</code>和一个名为“searchAll”的<code class="fe nb nc nd ne b">id</code>的<code class="fe nb nc nd ne b">input</code>。这个类内还有一个<code class="fe nb nc nd ne b">button</code>，带<code class="fe nb nc nd ne b">type</code>名为“submit”。使用XPath，我们可以定位所有这些不同的元素，并与它们进行交互，或者如您稍后将看到的那样，从中提取信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nx"><img src="../Images/3b6e0610dedde6c58c8d3a8346e86a0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YAkxRVA3IXHdTWNrgVHYzA.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">Figure 3 - Inspect element HTML Code for search bar and button</figcaption></figure><p id="8b68" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果您检查了<code class="fe nb nc nd ne b">form class</code>“ff”上的元素，并右键单击→复制→ XPath，您会看到类似这样的内容。这是完整的XPath，不是相对路径，所以我们不需要它。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="a84d" class="ln lo it ne b gy nj nk l nl nm">/html/body/div[1]/div[1]/header/div[3]/div/div[1]/form</span></pre><p id="e3a5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">函数<code class="fe nb nc nd ne b">find_element_by_xpath()</code>使用相对XPath。当您查看图3及其相关代码时，会觉得更有意义。就操作而言，我们想要做的是在搜索栏中插入一些文本，然后单击搜索按钮。够简单了吧？我们开始吧！</p><p id="c3d7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下面的代码找到搜索栏，清除所有默认文本，然后输入搜索词“<em class="ml"> holiday gifts </em>”。请注意我们是如何使用图3中的HTML函数<code class="fe nb nc nd ne b">find_element_by_xpath()</code>找到搜索栏元素的。XPath就是这样工作的！在浏览器中检查HTML，找到你想要的元素，并使用<code class="fe nb nc nd ne b">find_element_by_xpath()</code>指向给定路径的特定元素。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="b9cb" class="ln lo it ne b gy nj nk l nl nm"># find search bar, clear, and enter search text for item<br/>search_bar = driver.find_element_by_xpath("<br/>   //form[@class='ff']<br/>   //input[@id='searchAll']")<br/>search_bar.clear()<br/>search_bar.send_keys('holiday gifts')</span></pre><p id="2021" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，您应该看到浏览器中的搜索栏包含了新的搜索词，但是我们仍然需要实际单击search按钮。再次使用XPath，找到click按钮，我们已经在图3中这样做了，然后我们简单地<code class="fe nb nc nd ne b">.click()</code>按钮来执行动作。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="c37a" class="ln lo it ne b gy nj nk l nl nm"># find and click 'search' button<br/>search_btn = driver.find_element_by_xpath("<br/>   //form[@class='ff']<br/>   //button[@type='submit']")<br/>search_btn.click()</span></pre><p id="570b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，您应该会看到下面的页面(图4)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi ny"><img src="../Images/0ccef14698c69b2814433d7236f8f8d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*llMw_FcICcPtxThe8qW3XQ.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">Figure 4 - After searching “holiday gifts” from Zappos home page</figcaption></figure><p id="1b95" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">至此，您已经了解了使用selenium浏览网站的足够知识！我将使用我们已经学到的知识，单击图4中下方的“<em class="ml"> $100 &amp;”方块。</em></p><p id="14ad" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">特别是对于这个网页，图4中的所有6个小块都在div中，都在精确名称的div中。有时候，如果你在寻找一个特定的元素，这可能是一个问题。在下面的图5中，您可以看到下的图块1- " <em class="ml"> $50 &amp;，以及</em>下的图块2 - " <em class="ml"> $100 &amp;具有相同的<code class="fe nb nc nd ne b">div</code>、<code class="fe nb nc nd ne b">p</code>和<code class="fe nb nc nd ne b">a</code>类名称。然而，<code class="fe nb nc nd ne b">a</code>类中也有类似<code class="fe nb nc nd ne b">id</code>、<code class="fe nb nc nd ne b">aria-label</code>等属性。独一无二的。我将使用<code class="fe nb nc nd ne b">aria-label</code>并在我的<code class="fe nb nc nd ne b">find_element_by_xpath()</code>函数中使用一种“and”子句来指向特定的元素。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nz"><img src="../Images/fa7f522d6cdf149baaec9e676d371db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Mj6wn6-rvZJqjW4Jz1aew.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">Figure 5 - Same HTML for 2 clickable tiles</figcaption></figure><p id="3edb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下面是查找并点击下的瓷砖“<em class="ml"> $100 &amp;”的代码。一旦找到我们想要的元素，我们就使用上面的<code class="fe nb nc nd ne b">.click()</code>函数。这里要注意的一件事是，当我搜索<code class="fe nb nc nd ne b">a[@class='hatch-element...'</code>时，我没有像在其他代码块中那样有<code class="fe nb nc nd ne b">//</code>的延续。相反，我加上<code class="fe nb nc nd ne b">[@aria-label='image shop $100 &amp; Under']</code>。这意味着寻找提到的特定类和属性。</em></p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="ee76" class="ln lo it ne b gy nj nk l nl nm">gifts_under_100 = driver.find_element_by_xpath("<br/>   //div[@class='h_markdown']<br/>   //p[@class='h_hatch-element--p h_hatch-element--body-1 h_markdown__p']<br/>   //a[@class='h_hatch-element--a ez_image-link ez_image-link'][@aria-label='image Shop $100 &amp; Under']")<br/><br/>gifts_under_100.click()</span></pre><p id="b047" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您现在应该在一个搜索结果页面上，如图6所示。这是我想开始抓取的网页，也就是我的购物清单。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi oa"><img src="../Images/c1dc7855d08c16f7abc33909d2e96b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_lHax6JdT3x8S7EnEFQ_oQ.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">Figure 6 - Product result page for “$100 &amp; Under” Tile</figcaption></figure><p id="821e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="ml"> 4。从渲染的网页中抓取信息</em></p><p id="30df" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">从这个搜索结果页面中，我们需要遍历所有的产品，并收集诸如名称、品牌、价格、图片、产品url等信息。这个特定的页面不会加载产品，直到您滚动它们，这引入了另一个常见的问题。</p><p id="b8fc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">像脸书这样的网站，在他们的feed里，有这个“无限滚动”的功能。幸运的是，我们的产品页面不是无限的，但是我们确实需要我们的驱动程序来滚动以呈现产品。请记住，如果它不渲染，那么它不能被发现和刮。</p><p id="5ede" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对于这个特殊的页面，直接滚动到底部并不能呈现中间的所有内容，所以我需要编写一个简单的循环来逐节滚动我们的驱动程序。下面的代码按照指定的像素部分大小滚动。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="4716" class="ln lo it ne b gy nj nk l nl nm"># step scroll to bottom by pixel size to load all images<br/>for i in range(35):<br/>       driver.execute_script("window.scrollBy(0, 900)")<br/>       time.sleep(1)</span></pre><p id="4cd9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您可能需要将第一个代码块中的像素滚动从900调整为适合您的浏览器窗口的任何值。我还使用了<code class="fe nb nc nd ne b">time.sleep()</code>功能，在进入下一部分之前“暂停”1秒钟，让产品完全加载。我在我的循环中使用了35次迭代，但是你可以将它设置得更高而没有任何问题，即使你在指定的范围限制之前达到了底部。</p><div class="ob oc gp gr od oe"><a href="https://www.datadriveninvestor.com/2020/12/01/how-to-build-a-twitter-scraping-app-with-python/" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">如何用Python |数据驱动投资者构建Twitter抓取应用</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">每秒发出约6000条推文，每天发布5亿条推文，普通人甚至不能…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="on l"><div class="oo l op oq or on os ko oe"/></div></div></a></div><p id="8896" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">你现在应该在你的结果页的底部。让我们检查并找到所有需要的产品元素。这就是重名实际上对我们有利的地方。每个单独的产品块都有相同的<code class="fe nb nc nd ne b">div</code>、<code class="fe nb nc nd ne b">article</code>和<code class="fe nb nc nd ne b">a</code>类名(图7)。然而，在每个<code class="fe nb nc nd ne b">a</code>类中，在<code class="fe nb nc nd ne b">label</code>属性中有唯一且有价值的信息。在这里，我们可以看到产品名称、品牌和价格。此外，在<code class="fe nb nc nd ne b">href</code>属性中，我们可以找到产品URL。这就是我们要刮的！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi ot"><img src="../Images/e1d67a56ac8c833245c4cbc9d77dac71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5OmX7hVJxIlf_RWNwbjm5w.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">Figure 7 - Duplicate HTML tag names across different products</figcaption></figure><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="d9c0" class="ln lo it ne b gy nj nk l nl nm"># get all product info: brand, product name, price, and product url<br/>product_info = driver.find_elements_by_xpath("<br/>   //div[@class='h_quick-shop-style-tile']<br/>   //article[@class='h_hatch-style-tile']<br/>   //a[@class='h_hatch-element--a h_hatch-style-tile__link']")</span></pre><p id="4f3f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们在HTML中找到所有产品通用的标签。从上面的代码中，Selenium将返回一个名为<code class="fe nb nc nd ne b">product_info</code>的元素列表。到目前为止，我们返回的所有对象都只是我们与之交互的单个唯一项目(单击、添加文本等)。).然而，由于我们传递给驱动程序的XPath存在多次，在结果页面中每个产品一次，我们将收到返回的元素列表。确切地说，<code class="fe nb nc nd ne b">len(product_info)</code>将是190个元素，看起来是这样的:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="9c9e" class="ln lo it ne b gy nj nk l nl nm">[&lt;selenium.webdriver.firefox.webelement.FirefoxWebElement (session="f0d90584-efa8-3e4d-b44a-3c6b3ba88e23", element="34c2a959-f3ff-a042-ad7c-909aad9b7438")&gt;, &lt;selenium.webdriver.firefox.webelement.FirefoxWebElement (session="f0d90584-efa8-3e4d-b44a-3c6b3ba88e23", element="2e0b1bcb-9f69-0c43-a281-8a0281059bcc")&gt;...]</span></pre><p id="1d33" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这并没有真正给我们提供有用的信息。我们需要遍历这个元素列表来提取信息。我将创建2个列表:1个用于产品描述信息(价格、品牌和名称)，1个用于产品URL。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="59ff" class="ln lo it ne b gy nj nk l nl nm">product_desc = []<br/>product_urls = []<br/><br/>for info in product_info:<br/>    product_desc.append(info.text.split('\n'))<br/>    product_urls.append(info.get_attribute("href"))</span></pre><p id="619c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对于产品描述，我将从我们的列表(<code class="fe nb nc nd ne b">product_info</code>)中的每个项目(<code class="fe nb nc nd ne b">info</code>)中提取所有的<code class="fe nb nc nd ne b">text</code>。我在这里使用了<code class="fe nb nc nd ne b">split</code>函数在每个换行符处进行分割，作为分隔符。新的列表<code class="fe nb nc nd ne b">product_desc</code>将是这样的:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="e116" class="ln lo it ne b gy nj nk l nl nm">[['Blank NYC', 'Jumpsuit w/ Ruffle Detail', '$89.99MSRP $148.00'],['Blue by Betsey Johnson', 'Kassie', '$89.00'], ['Matt &amp; Nat', 'Brave Micro - Dwell', '$94.95'], ['Swatch', 'Redvremya - SO29R700', '$80.00'],...]]</span></pre><p id="647a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">看起来相当不错！你可以看到，由于Zappos的统一命名惯例，它遵循了品牌、产品名称和价格的模式。我们有一点混乱的价格特点，但可以清理。</p><p id="f054" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">要获取产品URL，我们只需使用<code class="fe nb nc nd ne b">get_attribute()</code>函数并查找所有<code class="fe nb nc nd ne b">href</code>项目。让我们来看看这个列表:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="b876" class="ln lo it ne b gy nj nk l nl nm">['<a class="ae lm" href="https://www.zappos.com/p/blank-nyc-jumpsuit-w-ruffle-detail-the-one/product/9489968/color/544009'" rel="noopener ugc nofollow" target="_blank">https://www.zappos.com/p/blank-nyc-jumpsuit-w-ruffle-detail-the-one/product/9489968/color/544009'</a>, '<a class="ae lm" href="https://www.zappos.com/p/blue-by-betsey-johnson-kassie-red-multi/product/9492197/color/590'" rel="noopener ugc nofollow" target="_blank">https://www.zappos.com/p/blue-by-betsey-johnson-kassie-red-multi/product/9492197/color/590'</a>, '<a class="ae lm" href="https://www.zappos.com/p/matt-nat-brave-micro-dwell-chai/product/9478594/color/29228'" rel="noopener ugc nofollow" target="_blank">https://www.zappos.com/p/matt-nat-brave-micro-dwell-chai/product/9478594/color/29228'</a>,...]</span></pre><p id="d50e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">看起来棒极了！我仔细检查了两者都是相同长度的190个元素，所以我们在一个好的轨道上！</p><p id="7334" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，我想获得所有的图片网址，这样我就可以查看产品。这看起来与上面的代码非常相似。我们必须在XPath中深入一点才能找到图片项，但是现在我们知道我们要找的是什么，这并不困难。下面的图8显示了我们将要抓取的图片<code class="fe nb nc nd ne b">src</code>和<code class="fe nb nc nd ne b">alt</code>属性的HTML。您可以从图8和代码块中看到我们是如何沿着这条路走下去的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi ou"><img src="../Images/302bf07033ff3269415150bad786eaaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1TTDWrc-dBPgFDd1Bx6gpw.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">Figure 8 - Inspected image element to show path</figcaption></figure><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="258a" class="ln lo it ne b gy nj nk l nl nm"># get product image url and name<br/>product_image = driver.find_elements_by_xpath("<br/>   //div[@class='h_quick-shop-style-tile']<br/>   //article[@class='h_hatch-style-tile']<br/>   //a[@class='h_hatch-element--a h_hatch-style-tile__link']<br/>   //div[@class='h_hatch-style-tile__image']<br/>   //div[@class='h_media h_media--3x4']<br/>   //span[@class='h_media__container']<br/>   //span[@class='h_media__image-container']  <br/>   //img[@class='h_media__image h_media__image--loaded']")</span></pre><p id="a307" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一旦我们的列表(<code class="fe nb nc nd ne b">product_image</code>)完成，我们再次在一个循环中使用<code class="fe nb nc nd ne b">get_attribute()</code>函数来获取产品图片URL(<code class="fe nb nc nd ne b">src</code>)和产品名称(<code class="fe nb nc nd ne b">alt</code>)。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="e23a" class="ln lo it ne b gy nj nk l nl nm">product_image_url = []<br/>product_image_alt = []<br/><br/>for image in product_image:<br/>    product_image_url.append(image.get_attribute("src"))<br/>    product_image_alt.append(image.get_attribute("alt"))</span></pre><p id="18d6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nb nc nd ne b">alt</code>标签与上面的产品名称完全匹配，因此不需要这些信息。也许，在一个更复杂的项目中，你可以用它来连接数据。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="f60c" class="ln lo it ne b gy nj nk l nl nm"># image urls<br/>[‘<a class="ae lm" href="https://m.media-amazon.com/images/I/717EZ8bvbsL.AC_SX1200.jpg'" rel="noopener ugc nofollow" target="_blank">https://m.media-amazon.com/images/I/717EZ8bvbsL.AC_SX1200.jpg'</a>,<br/> ‘<a class="ae lm" href="https://m.media-amazon.com/images/I/814o2ReEo5L.AC_SX600.jpg'" rel="noopener ugc nofollow" target="_blank">https://m.media-amazon.com/images/I/814o2ReEo5L.AC_SX600.jpg'</a>,<br/> ‘<a class="ae lm" href="https://m.media-amazon.com/images/I/711GstLp0gL.AC_SX600.jpg'" rel="noopener ugc nofollow" target="_blank">https://m.media-amazon.com/images/I/711GstLp0gL.AC_SX600.jpg'</a>,...]</span><span id="3311" class="ln lo it ne b gy nn nk l nl nm"># image alt tags<br/>['Jumpsuit w/ Ruffle Detail', 'Kassie', 'Brave Micro - Dwell',...]</span></pre><h2 id="f0e1" class="ln lo it bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">最终购物清单</h2><p id="8e73" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">现在我们有了几个列表，我们实际上可以很容易地将这些数据连接在一起。因为所有的产品信息都是按照相同的顺序和页码收集的，所以很容易按照正确的顺序添加。我已经在<a class="ae lm" href="https://github.com/aviolante/web_scrape_shopping_list" rel="noopener ugc nofollow" target="_blank"> Git repo </a>中添加了所有这些额外的步骤，但简而言之，我创建了一个pandas dataframe，清理了列，并添加了我认为有助于快速排序和过滤购物清单的列。</p><p id="93ca" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">你可以看到下面的最终CSV快照，我只是“美化”了一下。我们有品牌，产品名称，产品网址，图像网址，如果它的销售，销售价格，建议零售价，销售折扣的标志。现在，你已经准备好拿着这张购物清单，按照你想要的方式过滤/排序，完成你的假日购物！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi ov"><img src="../Images/acece9c5dc98e7bc8931229af2d53cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UcWR6lISy9g9FLi3KUYb1w.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">Figure 9 - The final shopping list</figcaption></figure><h2 id="b446" class="ln lo it bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">奖励:等待</h2><p id="e25b" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">关于“等待”，我想补充最后一点。在抓取网页时，你将会处理网页和页面元素的加载时间。通常，您会遇到需要等待或暂停以完全加载这些特定元素的情况。您将在某个时候收到关于元素未被找到的错误。根据我的经验，这很大程度上是由于元素没有被及时加载。您可以使用基本的python <a class="ae lm" href="https://docs.python.org/3/tutorial/errors.html" rel="noopener ugc nofollow" target="_blank">异常处理</a>和使用<a class="ae lm" href="https://selenium-python.readthedocs.io/waits.html" rel="noopener ugc nofollow" target="_blank"> Selenium的等待功能</a>来克服这些障碍。很容易将它合并到您的代码中。对于这个项目，我采用了懒惰的快捷方式，即使用<code class="fe nb nc nd ne b">time</code> python库，并在两个动作之间进行几秒钟的<code class="fe nb nc nd ne b">time.sleep()</code>调用。这对于较小的学习项目是可行的，但是由于使用<code class="fe nb nc nd ne b">time.sleep()</code>时没有任何条件，所以扩展性不好。查看上面的两个链接。他们应该会为你解决很多未来的头痛问题！</p><h2 id="1284" class="ln lo it bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">结论</h2><p id="28ec" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">这就是我们简单的刮擦项目！在这个项目中，我们成功地使用python库Selenium打开浏览器、访问网页、浏览网页，并为购物清单收集所需的信息。最重要的是，我们了解了Selenium的几个核心功能和能力，您可以轻松地将它们扩展到更大的项目中。检查给定web页面中的元素，然后使用XPath找到这些元素实际上已经成功了一半，所以您应该为下一个项目做好准备。</p><p id="5648" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们在这个项目中非常幸运，数据非常清晰。这主要是由于Zappos网站标签，但也是我们项目的简单性。希望你觉得这很有趣，也很有帮助。</p><p id="5727" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">刮的开心，逛的开心！</p><h2 id="6032" class="ln lo it bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">参考</h2><ol class=""><li id="df63" class="mm mn it ks b kt mg kw mh kz ow ld ox lh oy ll mr ms mt mu bi translated"><a class="ae lm" href="https://selenium-python.readthedocs.io/" rel="noopener ugc nofollow" target="_blank">硒的非官方文献</a>。这是一个伟大的资源！</li><li id="2e43" class="mm mn it ks b kt mv kw mw kz mx ld my lh mz ll mr ms mt mu bi translated"><a class="ae lm" href="https://github.com/aviolante/web_scrape_shopping_list" rel="noopener ugc nofollow" target="_blank"> GitHub Repo </a>带所有分步代码和CSV文件。</li><li id="a415" class="mm mn it ks b kt mv kw mw kz mx ld my lh mz ll mr ms mt mu bi translated"><a class="ae lm" href="https://selenium-python.readthedocs.io/waits.html" rel="noopener ugc nofollow" target="_blank">硒等待</a>和Python <a class="ae lm" href="https://docs.python.org/3/tutorial/errors.html" rel="noopener ugc nofollow" target="_blank">异常处理</a>文档</li></ol><h2 id="5018" class="ln lo it bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">获得专家观点— <a class="ae lm" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank">订阅DDI英特尔</a></h2></div></div>    
</body>
</html>