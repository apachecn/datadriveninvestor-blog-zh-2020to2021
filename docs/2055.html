<html>
<head>
<title>Tower of Hanoi: Solve and Optimize with Memoization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">汉诺塔:记忆化求解与优化</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/tower-of-hanoi-solve-and-optimize-with-memoization-f215a1bd201f?source=collection_archive---------1-----------------------#2020-04-12">https://medium.datadriveninvestor.com/tower-of-hanoi-solve-and-optimize-with-memoization-f215a1bd201f?source=collection_archive---------1-----------------------#2020-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="dc5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://en.wikipedia.org/wiki/Tower_of_Hanoi" rel="noopener ugc nofollow" target="_blank">汉诺塔</a>，一个数学游戏，经常被用作常见的递归和优化问题。这是:</p><p id="321e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kp">给定3个peg(A、B、C)和n个磁盘，其中每个磁盘的大小不同，并且磁盘最初是按照大小递减的顺序(从下到上)放在peg A上，按照规则将所有磁盘以相同的顺序移动到peg B:</em></p><ul class=""><li id="2673" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn kv kw kx ky bi translated"><em class="kp">一次只能移动一个磁盘。</em></li><li id="50d8" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">没有磁盘可以放在更小的磁盘上。为了前任。如果磁盘3在一个挂钩上，磁盘3下面的所有磁盘的数字必须大于3。</li></ul><p id="6ad2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们手工做几次，我们会发现有一个模式。</p><p id="ab5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设给了我们3个磁盘。然后:</p><ol class=""><li id="45a7" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn le kw kx ky bi translated">我们把上面的圆盘从A移到B</li><li id="6872" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">我们将下一个顶部磁盘从A移动到C</li><li id="5b2a" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">我们把磁盘从B移到C</li><li id="f09c" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">我们将剩余的磁盘从A移动到B</li><li id="89c4" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">我们将顶部的磁盘从C移到A</li><li id="fab0" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">我们将剩余的磁盘从C移到B</li><li id="6209" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">我们把最后一个磁盘从A移到B</li></ol><p id="8b91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后<em class="kp">瞧</em>，我们已经将所有磁盘按照它们在a上的顺序移动到了B上。下面是模式:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="6078" class="lo lp it lk b gy lq lr l ls lt">1. Shift 'n-1' disks from 'A' to 'B'.<br/>2. Shift last disk from 'A' to 'C'.<br/>3. Shift 'n-1' disks from 'B' to 'C'<br/>4. repeat</span><span id="05ff" class="lo lp it lk b gy lu lr l ls lt"><a class="ae ko" href="https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/" rel="noopener ugc nofollow" target="_blank"><em class="kp">source</em></a></span></pre><h2 id="9afd" class="lo lp it bd lv lw lx dn ly lz ma dp mb kb mc md me kf mf mg mh kj mi mj mk ml bi translated">我将实现三个解决方案，最后一个是最有效的。</h2><h1 id="b7be" class="mm lp it bd lv mn mo mp ly mq mr ms mb mt mu mv me mw mx my mh mz na nb mk nc bi translated">具有视觉表现的简单缓慢的解决方案</h1><p id="a43e" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">时间和空间效率低下，但这提供了一个很好的视觉效果，可以看到我们的算法逻辑地工作。我们将使用数组输入作为我们的磁盘，看看我们是否可以使用给定的规则和参数来移动它们。</p><div class="ni nj gp gr nk nl"><a href="https://www.datadriveninvestor.com/2020/02/22/algorithms-for-fairness/" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">公平算法|数据驱动的投资者</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">许多人都有算法偏见。软件工程师关心算法偏差，因为我们关心…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz oa nl"/></div></div></a></div><p id="01c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">利用递归，我们可以对这个问题进行逆向工程。在第一次递归调用时，我们将告诉我们的算法将除最后一个元素之外的所有元素移动到我们的temp ('C') peg，然后将最后一个元素移动到我们的end peg ('B ')，因为最后一个元素将是最大的，然后我们将告诉我们的下一次递归调用将所有元素从我们的temp ('C ')移动到(' B ')，并假设我们的递归调用将保持相同的顺序。</p><figure class="lf lg lh li gt oc gh gi paragraph-image"><div role="button" tabindex="0" class="od oe di of bf og"><div class="gh gi ob"><img src="../Images/840ef2510a6098e61e7a8ad43dd595f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_0Vpiq0j6GkCGw0B0oZP8A.png"/></div></div></figure><h1 id="91c3" class="mm lp it bd lv mn mo mp ly mq mr ms mb mt mu mv me mw mx my mh mz na nb mk nc bi translated">简单缓慢的解决方案，包括步骤说明</h1><p id="4872" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">时间效率低，但空间效率高。</p><p id="9dd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个和上面类似的解决方案，但是我们不使用数组，而是传入peg名‘A’、‘B’和‘C’，并打印我们的每一步/移动。</p><figure class="lf lg lh li gt oc gh gi paragraph-image"><div role="button" tabindex="0" class="od oe di of bf og"><div class="gh gi oi"><img src="../Images/e7d206e51fb2ce8881af8124b25a032e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4nx7iituO-CVExFcYN_PlA.png"/></div></div></figure><h1 id="4ad8" class="mm lp it bd lv mn mo mp ly mq mr ms mb mt mu mv me mw mx my mh mz na nb mk nc bi translated">该是我们优化解决方案的时候了。这样就能算出解决河内需要多少步。</h1><p id="67fe" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">时间效率低而空间效率高。</p><p id="a512" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个与上面类似的解决方案，但是我们没有使用数组或字符串，我们只是传入磁盘的数量，然后返回移动磁盘需要多少步。我们将记住这个解决方案，这样就不用花很多年来解决(相信我，否则会的。如果你不相信我，你可以试试没有记忆)。</p><figure class="lf lg lh li gt oc gh gi paragraph-image"><div role="button" tabindex="0" class="od oe di of bf og"><div class="gh gi oj"><img src="../Images/98a7a79eacfd1fd7c1edfd1b43f8c4fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z8skvciS1myEsfsAMxaINA.png"/></div></div></figure><p id="38d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只用了一秒钟就解决了这个问题。然而，您不能在我们以前的解决方案中使用输入1000，因为它们将永远无法完成。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="e507" class="mm lp it bd lv mn or mp ly mq os ms mb mt ot mv me mw ou my mh mz ov nb mk nc bi translated">感谢阅读！我希望这很有趣。</h1><p id="17ad" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">让我知道你的想法，并在下面自由提问。尽情享受吧！</p><figure class="lf lg lh li gt oc"><div class="bz fp l di"><div class="ow ox l"/></div></figure></div></div>    
</body>
</html>