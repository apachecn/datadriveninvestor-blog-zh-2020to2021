<html>
<head>
<title>How to Train an MRI Classifier with PyTorch🔥</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用PyTorch训练一个MRI分类器🔥</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/deep-learning-and-medical-imaging-how-to-provide-an-automatic-diagnosis-f0138ea824d?source=collection_archive---------1-----------------------#2020-02-17">https://medium.datadriveninvestor.com/deep-learning-and-medical-imaging-how-to-provide-an-automatic-diagnosis-f0138ea824d?source=collection_archive---------1-----------------------#2020-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="db77" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用PyTorch训练高精度的MRI扫描膝关节损伤分类器</h2></div><p id="6ae6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将建立和训练一个卷积神经网络，它可以从MRI扫描中检测和分类严重的膝盖损伤。我们将在<strong class="kk iu"> PyTorch </strong>中实现它🔥来充分利用这个框架的功能。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/477c6f309deea76387790ae9842eb97f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WHuAGgCeIMCIdHS4HQ6Lxg.jpeg"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk">Photo by <a class="ae lu" href="https://unsplash.com/@nci?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">National Cancer Institute</a> on <a class="ae lu" href="https://unsplash.com/s/photos/medical?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="33e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您不熟悉我们将使用的数据集，不要担心！你可以看看我以前的帖子。</p><div class="lv lw gp gr lx ly"><a href="https://towardsdatascience.com/deep-learning-and-medical-imaging-part-1-explore-the-mrnet-mri-dataset-of-knee-injuries-f519d063165" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">深度学习和医学成像🚑—探索膝盖MRI扫描</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">了解如何在医学影像中应用深度学习。在本帖中，我们将探索膝关节磁共振扫描的MRNet数据集。</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm lo ly"/></div></div></a></div><h2 id="b358" class="mn mo it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">在这篇文章结束时，你会学到一些东西💫</h2><ul class=""><li id="7089" class="ng nh it kk b kl ni ko nj kr nk kv nl kz nm ld nn no np nq bi translated">如何构建一个专门设计用于处理给定平面(轴向、矢状和冠状)MRI扫描的卷积神经网络:我们将看到所选架构<strong class="kk iu">如何考虑磁共振成像的3D特性</strong></li><li id="b1c9" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">如何实现一个<strong class="kk iu">元模型</strong>，它结合了三个CNN模型的预测，这三个CNN模型被单独训练以对每个平面上的ACL损伤进行分类</li><li id="adf4" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">如何使用<strong class="kk iu">迁移学习</strong>和<strong class="kk iu">数据增强</strong>处理数据缺失</li><li id="0fc5" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">如何组织一个<strong class="kk iu">端到端的训练管道</strong>来加载和处理数据、训练、监控和评估模型</li></ul><p id="939c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您阅读完本文，您应该对ACL撕裂分类问题及其检测有一个全面的了解。</p><blockquote class="nw nx ny"><p id="f458" class="ki kj nz kk b kl km ju kn ko kp jx kq oa ks kt ku ob kw kx ky oc la lb lc ld im bi translated"><strong class="kk iu"> <em class="it">注意ℹ️: </em>如果诊断膝盖损伤不是您特别感兴趣的医学任务，不要担心，您仍然可以将代码用于其他目的。</strong></p></blockquote><h1 id="9006" class="od mo it bd mp oe of og ms oh oi oj mv jz ok ka my kc ol kd nb kf om kg ne on bi translated">1 —问题的提醒</h1><p id="6b2f" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr oo kt ku kv op kx ky kz oq lb lc ld im bi translated">这张图表总结了问题和我们要解决的方法:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi or"><img src="../Images/7ded60abcbb2e0d413d4f6dc1bf81c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0V-mgkbSaLTYMlztR_HE9A.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk">Source: <a class="ae lu" href="https://www.ahmedbesbes.com/blog/acl-tear-detection-part-2" rel="noopener ugc nofollow" target="_blank">ahmedbesbes.com</a></figcaption></figure><p id="2b93" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个病人在三个不同的平面上进行三次MRI扫描:<strong class="kk iu">轴向</strong>、<strong class="kk iu">矢状面</strong>和<strong class="kk iu">冠状面</strong>。</p><p id="2472" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这些飞机中的每一架，我们都要建立一个独立的模型。</p><p id="6040" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些网络中的每一个都将专门从给定的角度检测ACL撕裂。为了有一个在任何地方都表现良好的模型，我们将使用一个<strong class="kk iu">堆栈操作将这三个模型组合成一个<strong class="kk iu">元模型</strong>。</strong></p><blockquote class="nw nx ny"><p id="44a1" class="ki kj nz kk b kl km ju kn ko kp jx kq oa ks kt ku ob kw kx ky oc la lb lc ld im bi translated">这种架构应该模拟放射科医生考虑单个患者的不同MRI扫描(在不同平面)的方式，以便做出可靠的诊断。</p></blockquote><h1 id="9cd9" class="od mo it bd mp oe of og ms oh oi oj mv jz ok ka my kc ol kd nb kf om kg ne on bi translated">2 —模型架构:MRNet</h1><p id="776c" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr oo kt ku kv op kx ky kz oq lb lc ld im bi translated">现在让我们详细描述模型架构。我们将按原样使用它来为每架飞机训练一个模型。斯坦福团队将这个网络命名为MRNet。</p><h2 id="ad97" class="mn mo it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">输入与输出</h2><p id="7246" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr oo kt ku kv op kx ky kz oq lb lc ld im bi translated">MRNet是一个卷积神经网络，它将MRI扫描作为输入，输出撕裂概率(一个标量)。 <br/>一个输入MRI具有(s，3，256，256)的维数，其中<em class="nz"> s </em>是MRI扫描中切片的数量。3是每个切片的颜色通道数，256是每个切片的宽度/高度。</p><h2 id="c1f8" class="mn mo it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">预训练特征提取器</h2><p id="842e" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr oo kt ku kv op kx ky kz oq lb lc ld im bi translated">当MRNet将MRI作为输入时，切片首先通过基于预处理AlexNet的特征提取器。给定每个MRI的<em class="nz"> s </em>个切片，结果是一个形状张量(s，256，7，7)。<br/>注:(256，7，7)简单来说就是AlexNet最后一个卷积层得到的大小为7x7的一组256个特征图。</p><h2 id="d64a" class="mn mo it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">全球平均池层</h2><p id="2cac" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr oo kt ku kv op kx ky kz oq lb lc ld im bi translated">然后，通过计算每个7×7正方形的平均值，将每个形状张量(256，7，7)简化为形状向量(256)。这个操作叫做<strong class="kk iu">全局平均池。</strong>现在输出的形状是(s，256)</p><h2 id="fe49" class="mn mo it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">最大池化</h2><p id="84d8" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr oo kt ku kv op kx ky kz oq lb lc ld im bi translated">为了在将(s，256)形状的张量传递到分类部分之前将其转换为列向量，我们在切片之间应用了<strong class="kk iu">最大池</strong>。因此，我们得到一个形状向量(256，)。</p><h2 id="6539" class="mn mo it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">全连接层</h2><p id="0cf8" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr oo kt ku kv op kx ky kz oq lb lc ld im bi translated">现在我们有了一个列向量，我们将它通过具有ReLU激活函数和dropout的完全连接的层。</p><p id="bcd1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的图表摘自斯坦福的论文，说明了这种架构。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi os"><img src="../Images/8c35fb479cd24c55b690d3a893e29445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2HrLp6zrD1kvzz9qeOplEA.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk">Source: <a class="ae lu" href="https://journals.plos.org/plosmedicine/article?id=10.1371/journal.pmed.1002699" rel="noopener ugc nofollow" target="_blank">PLOS Medicine</a></figcaption></figure><p id="61b6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">关于这个架构的两点注意:</strong></p><ul class=""><li id="44fd" class="ng nh it kk b kl km ko kp kr ot kv ou kz ov ld nn no np nq bi translated">鉴于s因患者而异，不可能批量堆叠成堆的MRI。因此，我们将在训练中使用尺寸为1的<strong class="kk iu">批次。这通常会引入损耗波动，但有一些技术可以克服这种波动。</strong></li><li id="60e5" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">最好将切片并行通过AlexNet，而不是顺序通过。</li></ul><h1 id="f293" class="od mo it bd mp oe of og ms oh oi oj mv jz ok ka my kc ol kd nb kf om kg ne on bi translated">3 —培训程序</h1><h2 id="d173" class="mn mo it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">损失和优化器</h2><p id="771f" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr oo kt ku kv op kx ky kz oq lb lc ld im bi translated">使用<strong class="kk iu"> Adam优化器</strong>通过最小化<strong class="kk iu">交叉熵损失</strong>来完成模型的训练。</p><h2 id="c336" class="mn mo it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">不平衡数据</h2><p id="b5eb" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr oo kt ku kv op kx ky kz oq lb lc ld im bi translated">考虑到类的不平衡性质，实例的损失与该实例的类在数据集中的流行度成反比，以便更多地惩罚最不存在的实例上的错误。</p><h2 id="fdad" class="mn mo it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">数据扩充</h2><p id="c0f8" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr oo kt ku kv op kx ky kz oq lb lc ld im bi translated">在训练期间，使用反向传播算法对每个训练样本计算损失的梯度，然后在梯度的相反方向上调整网络的参数。</p><div class="lv lw gp gr lx ly"><a href="https://www.datadriveninvestor.com/2020/03/04/on-artificial-intelligence-and-surveillance-capitalism/" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">人工智能和监督资本主义|数据驱动的投资者</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">大科技，总是现在:人工智能推动的大科技，已经使购物，搜索，在你的…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="mh l"><div class="ow l mj mk ml mh mm lo ly"/></div></div></a></div><p id="f086" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在训练期间，一些<strong class="kk iu">几何变换</strong>被应用于输入MRI。这些变换是标签不变的。它们旨在带来数据集中的多样性，增加模型的稳定性，同时降低其过度拟合的趋势。</p><p id="f752" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将依次对每个输入MRI应用3个几何变换。</p><ul class=""><li id="09ea" class="ng nh it kk b kl km ko kp kr ot kv ou kz ov ld nn no np nq bi translated">-25到25度之间的随机旋转</li><li id="40fc" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">-25到25个像素之间的双向随机偏移</li><li id="074e" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">50%概率的随机水平翻转</li></ul><p id="3e6b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">注意:数据增强是在核磁共振成像的所有切片上进行的。</strong></p><h1 id="f345" class="od mo it bd mp oe of og ms oh oi oj mv jz ok ka my kc ol kd nb kf om kg ne on bi translated">4 — PyTorch代码结构</h1><p id="5c69" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr oo kt ku kv op kx ky kz oq lb lc ld im bi translated">现在让我们把刚才看到的变成PyTorch实现。你可以在我的Github repo中找到代码:</p><div class="lv lw gp gr lx ly"><a href="https://github.com/ahmedbesbes/mrnet" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">ahmedbesbes/mrnet</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">这个知识库包含一个卷积神经网络的实现，该网络对特定的膝盖损伤进行分类…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">github.com</p></div></div><div class="mh l"><div class="ox l mj mk ml mh mm lo ly"/></div></div></a></div><p id="5ba1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码被组织成三个文件。下面的图表总结了每个脚本的职责。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oy"><img src="../Images/0e4aa715883d942b91314d255be8a83a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-hP0PsjzkXOSFKfbcECMng.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk">Source: <a class="ae lu" href="https://www.ahmedbesbes.com/blog/acl-tear-detection-part-2" rel="noopener ugc nofollow" target="_blank">ahmedbesbes.com</a></figcaption></figure><h2 id="1acc" class="mn mo it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">1 —模型架构:model.py</h2><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="b06b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个模型很简单。我们将其定义为从<strong class="kk iu"> torch.nn.Module </strong>类继承而来的名为MRNet的类。</p><p id="4a4a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在构造函数中，我们定义了三个对象:</p><ul class=""><li id="0901" class="ng nh it kk b kl km ko kp kr ot kv ou kz ov ld nn no np nq bi translated">预先训练的AlexNet模型</li><li id="3349" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">汇集层</li><li id="3b18" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">作为分类层的密集层</li></ul><p id="c411" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在正向方法中，我们实际上编写了正向传递，即网络在计算预测之前对输入执行的操作。</p><p id="cf4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面我们来详细介绍一下:</p><ul class=""><li id="8ce4" class="ng nh it kk b kl km ko kp kr ot kv ou kz ov ld nn no np nq bi translated">这个方法接收shape (1，s，256，256，3)的输入x，因为正如我们前面所说的，我们正在处理大小为1的批</li><li id="c75b" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">它通过“挤压”输入并将其形状变为(s，256，256，3)来移除第一维</li><li id="492d" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">now (s，256，256，3)是一个规则的张量形状，它可以被馈送到AlexNet，后者随后产生形状(s，256，7，7)的特征</li><li id="5d19" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">使用产生形状输出的全局平均汇集层来汇集特征(s，256)</li><li id="1b0f" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">汇集的特征在256维向量中被展平，该向量最终被馈送到输出标量值的分类器。注意，我们在这里没有使用sigmoid激活。sigmoid运算被集成到损失定义中。</li></ul><h2 id="06a6" class="mn mo it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">2-自定义数据集:dataloader.py</h2><p id="4910" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr oo kt ku kv op kx ky kz oq lb lc ld im bi translated">在这个脚本中，我们定义了一个自定义数据集对象，它在主程序中加载MRNet数据。</p><p id="c26c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了创建数据集，我们定义了一个名为MRDataset的类，它继承了类<strong class="kk iu"> torch.utils.data.Dataset </strong>。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="0e89" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在MRDataset的构造函数中，我们定义了一组参数:</p><ul class=""><li id="dfb7" class="ng nh it kk b kl km ko kp kr ot kv ou kz ov ld nn no np nq bi translated">根目录:。/数据/</li><li id="50c1" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">任务:前交叉韧带，半月板或异常。在本帖中，我们将重点关注<strong class="kk iu"> ACL </strong></li><li id="76a4" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">平面:矢状、冠状或轴向</li><li id="33a2" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">train:一个布尔变量，表示我们是否正在处理训练数据(验证)</li><li id="90b7" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">转换:一系列数据扩充操作。如果没有，则没有数据扩充</li><li id="70af" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">权重:每个类的自定义权重(默认为无):这用于调整损失函数。如果没有，将自动计算权重。</li></ul><p id="8ef5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在构造函数的剩余部分，我们准备了对应于每个数据样本的路径、标签和权重。</p><p id="b04b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<strong class="kk iu"> __len__ </strong>函数中，我们返回数据的长度</p><p id="31ca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<strong class="kk iu"> __getitem__ </strong>函数中，我们返回MRI扫描。npy文件，标签和重量后，应用较小的预处理和最终的数据增加。</p><h2 id="6e8b" class="mn mo it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">3 —培训地点:train.py</h2><p id="5a70" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr oo kt ku kv op kx ky kz oq lb lc ld im bi translated">这个脚本是应用程序的主要部分。它完成繁重的工作，并输出(即保存)训练好的模型。</p><p id="aaec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简而言之，它是这样做的:</p><ul class=""><li id="2faf" class="ng nh it kk b kl km ko kp kr ot kv ou kz ov ld nn no np nq bi translated">它导入dataloader.py来加载来自训练集或验证集的数据。</li><li id="a84e" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">它导入model.py并在更新其权重之前实例化一个MRNet模型。</li><li id="3f2b" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">它在给定数量的时期内启动训练和验证循环。</li></ul><p id="c23d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们跳过所有内容，看一下从终端调用脚本时执行的第一行代码:</p><pre class="lf lg lh li gt pb pc pd pe aw pf bi"><span id="af17" class="mn mo it pc b gy pg ph l pi pj">if __name__ == "__main__":<br/>    args = parse_arguments()<br/>    run(args)</span></pre><p id="8588" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">…我们将看到它首先加载命令行中给出的一些参数。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="8637" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦参数被加载到<strong class="kk iu"> args </strong>变量中，run函数就开始执行。</p><p id="0e98" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无需深入细节，该功能首先创建一个文件夹，Tensorboard将使用该文件夹来保存训练日志并可视化该课程的指标。</p><p id="5839" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">脚本每次运行时，都会创建一个新文件夹(以时间戳命名):</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="adfb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们定义数据扩充管道</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="763b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并实例化训练和验证MRDataset。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="c675" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些数据集现在被传递到Dataloader，这是一个方便的PyTorch对象，允许通过利用批处理、洗牌、多处理和数据扩充来有效地迭代数据。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="05e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们实例化MRNet模型，并将其参数传递给GPU。</p><p id="6787" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们定义了Adam优化器和学习率调度器。</p><p id="bd6a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们举例说明了时期的数量和耐心，即在损失没有改善的情况下时期的最小数量。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="b74a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在是最精彩的部分，训练部分:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="e40f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每个时代，许多事情被执行:</p><ul class=""><li id="1236" class="ng nh it kk b kl km ko kp kr ot kv ou kz ov ld nn no np nq bi translated">我们使用train_model训练模型</li><li id="992a" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">我们使用evaluate_model来评估模型</li><li id="b697" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">我们打印AUC指标以及训练和验证数据的损失</li><li id="ec47" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">我们让学习率调度器更新学习率</li><li id="93a6" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">如果验证AUC提高，我们将模型检查点保存到磁盘</li><li id="8ec9" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">如果损失没有改善的时期数高于耐心，我们中断训练</li></ul><p id="6c1b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们关注在每个时期调用的train_model函数。</p><p id="f8a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是完整的代码:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="396e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们把它分成几块:</p><p id="c949" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们首先将模型设置为训练模式，然后将其传递给GPU，并初始化包含预测、真实标签和每个单独样本的损失的列表。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="1dc6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们遍历数据加载器:</p><p id="bf8c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每一步:</p><ul class=""><li id="bc69" class="ng nh it kk b kl km ko kp kr ot kv ou kz ov ld nn no np nq bi translated">单个MRI扫描及其相应的标签和重量被传递给GPU</li><li id="d93b" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">网络计算MRI扫描的正向传递，这导致预测</li><li id="ebaa" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">计算预测和真实标签之间的损失</li><li id="cf0f" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">损失的反向传播:梯度的计算</li><li id="0cab" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">权重由优化器更新</li></ul><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="452a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每个时期执行的剩余代码监控训练指标，并将它们记录到Tensorboard。</p><h1 id="ac61" class="od mo it bd mp oe of og ms oh oi oj mv jz ok ka my kc ol kd nb kf om kg ne on bi translated">5-结果:矢状面上前交叉韧带撕裂的分类</h1><p id="1ab5" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr oo kt ku kv op kx ky kz oq lb lc ld im bi translated">设置:Nvidia 1080 Ti和i7 8700K CPU。训练持续了大约1小时11分钟。35个时代。</p><p id="6db4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最佳模型保存在磁盘上，AUC分数如下</p><ul class=""><li id="2490" class="ng nh it kk b kl km ko kp kr ot kv ou kz ov ld nn no np nq bi translated"><strong class="kk iu">车次:0.8669 </strong></li><li id="0cdd" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated"><strong class="kk iu">确认:0.8850 </strong></li></ul><p id="adcd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以在Tensorboard中查看每个时期和每个批次的AUC和损失:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi pk"><img src="../Images/9acda86ca607e035455f7cdf96f86e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kv8xV5QJa0RWWPuexdPQfQ.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk">Source: <a class="ae lu" href="https://www.ahmedbesbes.com/blog/acl-tear-detection-part-2" rel="noopener ugc nofollow" target="_blank">ahmedbesbes.com</a></figcaption></figure><h1 id="04b9" class="od mo it bd mp oe of og ms oh oi oj mv jz ok ka my kc ol kd nb kf om kg ne on bi translated">6 —构建全局ACL撕裂分类器</h1><p id="2f03" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr oo kt ku kv op kx ky kz oq lb lc ld im bi translated">既然我们已经看到了如何在矢状面上训练ACL撕裂分类器，我们可以对其他两个平面遵循相同的程序。结果不相上下。</p><p id="0dd5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当这三个模型被训练并保存到磁盘上时，我们用它们来计算对每个样本的预测训练和验证。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="f198" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在训练数据上计算的预测成为训练一个<strong class="kk iu">逻辑回归的新特征。</strong></p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="23aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦训练了逻辑回归，我们就根据验证特征对其进行评估，即模型对验证数据的预测。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oz pa l"/></div></figure><blockquote class="nw nx ny"><p id="f38a" class="ki kj nz kk b kl km ju kn ko kp jx kq oa ks kt ku ob kw kx ky oc la lb lc ld im bi translated"><strong class="kk iu">结果:我们得到的AUC为0.95 </strong></p></blockquote><h1 id="8c09" class="od mo it bd mp oe of og ms oh oi oj mv jz ok ka my kc ol kd nb kf om kg ne on bi translated">7 —想要改进模型？</h1><p id="895e" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr oo kt ku kv op kx ky kz oq lb lc ld im bi translated">显然还有改进的余地。事实上，您可以:</p><ul class=""><li id="039a" class="ng nh it kk b kl km ko kp kr ot kv ou kz ov ld nn no np nq bi translated">通过使用不同的预训练网络(VGG、ResNet、Inception)或者通过将3个平面组合成单个网络来构建新的架构</li><li id="9dfe" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">通过添加复杂的技术改进数据扩充</li><li id="71bb" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">微调学习率或采用学习率调度方案</li><li id="79e6" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">使用累积梯度来防止损失波动</li><li id="5ca7" class="ng nh it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">训练更长的时间</li></ul><h1 id="c062" class="od mo it bd mp oe of og ms oh oi oj mv jz ok ka my kc ol kd nb kf om kg ne on bi translated">总结:何去何从？</h1><p id="4a33" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr oo kt ku kv op kx ky kz oq lb lc ld im bi translated">您刚刚学习了使用PyTorch中实现的深度卷积神经网络进行ACL撕裂分类。</p><p id="7dd5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在是时候检查这个模型实际学到了什么。在下一篇文章中，我们将研究一种<strong class="kk iu">可解释性方法</strong>，这种方法可以突出显示在ACL断裂时激活的图像区域。我们将使用这种方法作为验证和增强诊断的支持。这也是一个有用的工具，允许放射科医生信任机器学习模型。</p></div><div class="ab cl pl pm hx pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="im in io ip iq"><p id="458f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nz">原载于</em><a class="ae lu" href="https://www.ahmedbesbes.com/blog/acl-tear-detection-part-2" rel="noopener ugc nofollow" target="_blank"><em class="nz">https://www.ahmedbesbes.com</em></a><em class="nz">。</em></p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ps pa l"/></div></figure></div></div>    
</body>
</html>