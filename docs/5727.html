<html>
<head>
<title>A dive into Support Vector Regression with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python支持向量回归初探</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/a-dive-into-support-vector-regression-with-python-3c1875b08215?source=collection_archive---------10-----------------------#2020-09-29">https://medium.datadriveninvestor.com/a-dive-into-support-vector-regression-with-python-3c1875b08215?source=collection_archive---------10-----------------------#2020-09-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9db9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所知，SVM算法主要用于分类，很少用于回归。</p><p id="b8d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然它为我们提供了SVR算法来完成必要的工作。</p><p id="aa1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我之前的<a class="ae kl" href="https://medium.com/datadriveninvestor/support-vector-machines-an-easy-interpretation-of-categorizing-inseparable-data-943631046eec" rel="noopener">博客</a>中，我主要谈论了如何在SVM使用kernel trick对数据进行分类，在这里我将解释SVR如何帮助数据回归。</p><p id="1b29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">支持向量的目标是在N维空间中找到一个能够分类数据点的超平面。</p><p id="c962" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">位于边缘并且最靠近超平面的数据点称为支持向量。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/63e2a97602b4b1bc3fb949e9ca4c21d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/0*gc_RP2lCQtIdoRTy.png"/></div></figure><p id="6d78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当大多数数据大部分位于超平面每一侧的最佳边界内时，则可以使用SVR或支持向量回归来非常清楚地识别和预测相关数据..</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ku"><img src="../Images/76716b10c120e3ca79c0f184bc9d0673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IRTrvHUkd883wuzDpc-F7g.jpeg"/></div></div></figure><p id="3d69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它具有数学公式，对于超平面的每一侧的边缘线表示为:</p><p id="0cea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Yi = (w，)+ b +偏差</p><p id="a779" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Yi = (w，)+ b偏差</p><p id="17a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">建立支持回归模型应遵循的步骤:</strong></p><p id="7215" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1)找到您的X和Y独立和相关数据集来训练模型。</p><p id="0b3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2)快速查看数据，并尝试适应最合适的内核参数。您也可以尝试绘制数据点并查看相关性。</p><p id="029f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据复杂性，它可以是线性的、高斯的或多项式的。</p><p id="b00b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最常用的核是高斯核。</p><p id="0bda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">*多项式核:K(x，y) =(x .y +1)d，其中d&gt;0是定义核的常数</p><p id="daf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">秩序。</p><p id="c978" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">*高斯RBF内核:K(x，y)= exp(| x y | 2/2σ2)，其中σ&gt;0是一个参数，它</p><p id="2a1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">定义内核宽度。在训练阶段确定相关的参数d和σ。</p><p id="1a00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3)绘图</p><p id="6b6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4)预测任何独立值。</p><p id="8f99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在不要太深入理论部分，让我们看看如何在Python中实现它。</p><p id="4c6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤1)导入库</strong></p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="e5d9" class="le lf iq la b gy lg lh l li lj">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span></pre><p id="a922" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤2)导入数据集</strong></p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="318e" class="le lf iq la b gy lg lh l li lj">dataset=pd.read_csv('D:/blog/SVR/PostVsSalary.csv')</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/ac75a802179dc0c022168fefb7882034.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*ko1Laag86WHk8pBTELUVmg.png"/></div></figure><p id="2d56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤3)定义X和Y变量</strong>，即因变量和自变量。</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="3062" class="le lf iq la b gy lg lh l li lj">X=dataset.iloc[:,1:2].values<br/>y=dataset.iloc[:,2:].values</span></pre><p id="18da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们取x为职位级别，y为薪资。</p><p id="94d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤4)将数据转换成标量</strong></p><p id="e70d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所看到的，职位或职位(1-10)的价值与工资(45000-1000000)的价值之间存在巨大的均等，我们需要有类似基础的数据，以使支持向量回归模型发挥作用。</p><div class="ll lm gp gr ln lo"><a href="https://www.datadriveninvestor.com/2020/07/07/introduction-to-time-series-forecasting-of-stock-prices-with-python/" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd ir gy z fp lt fr fs lu fu fw ip bi translated">用Python |数据驱动投资者进行股票价格时间序列预测简介</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">在这个简单的教程中，我们将看看如何将时间序列模型应用于股票价格。更具体地说，一个…</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="lx l"><div class="ly l lz ma mb lx mc ks lo"/></div></div></a></div><p id="8686" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">样品x的标准分数计算如下:</p><p id="4f93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">x标准= (x —平均值(x) )/标准偏差</p><p id="28dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们通过使用Python的StandardScaler库来实现。</p><p id="070b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在其他线性模型中，我们不使用它，因为这些模型已经内置了它，但为了在我们的模型中使用它，我们需要编写以下代码:</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="fe45" class="le lf iq la b gy lg lh l li lj">from sklearn.preprocessing import StandardScaler<br/> <br/>st_x=StandardScaler()<br/>st_y=StandardScaler()<br/> <br/>X=st_x.fit_transform(x)<br/>Y=st_y.fit_transform(y)</span></pre><p id="edb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤5)绘制数据来看看</strong></p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="0b2d" class="le lf iq la b gy lg lh l li lj">fig=plt.figure()<br/>ax=fig.add_axes([0,0,1,1])<br/>ax.scatter(X,Y,color='r')</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi md"><img src="../Images/4a9e22f670c2c022abdb162303b4315b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*QdWEfDojbh4RVrJGc2sirw.png"/></div></figure><p id="1ae6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将独立的数据变量绘制成红点。</p><p id="d4a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在使值成为标量后</p><p id="0dbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤6)选择一个内核来训练数据。</strong></p><p id="df39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最重要的SVR参数是内核类型。它可以是多项式或高斯SVR。</p><p id="9e02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有一个非线性条件，我们可以选择多项式或高斯，但这里我们选择RBF(一种类型)核(参数='rbf ')。</p><p id="6b89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">多项式核需要大量复杂的计算，这需要时间来计算。</p><p id="6ba2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">高斯核是模式识别中最常用的核。</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="f2dc" class="le lf iq la b gy lg lh l li lj">from sklearn.svm import SVR <br/>regressor=SVR(kernel='rbf') <br/>regressor.fit(X,y)</span></pre><p id="c82f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤6)绘制预测线</strong>的X和Y 点</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="df45" class="le lf iq la b gy lg lh l li lj">plt.scatter(X, Y, color = 'magenta')<br/>plt.plot(X, regressor.predict(X), color = 'green')<br/>plt.title('PostVsSalary(Support Vector Regression Model)')<br/>plt.xlabel('Post')<br/>plt.ylabel('Salary')<br/>plt.show()</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/d2d25ae1128b097a5f0cf4e9f3697d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*xjQkxFLXhrpstSKH6I-8Yw.png"/></div></figure><p id="7552" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤7)找出预测点:</strong></p><p id="d8f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，我们在这里进行了数据缩放。现在，如果我们想要以类似的格式返回数据，我们需要做的是在运行预测时缩小规模。</p><p id="46a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，如果我们想预测一个7.5级别职位的工资，那么我们需要用7.5创建一个数组，并把它交给我们的predict函数。然后我们将它求逆，得到缩小后的值。</p><p id="8a08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的代码将完成必要的工作。</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="9b50" class="le lf iq la b gy lg lh l li lj"># Predicting a new result<br/>X_pred = sc_X.transform(np.array([[7.5]]))<br/>y_scale_back = sc_y.inverse_transform(regressor.predict(X_pred))</span></pre><p id="1338" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">支持向量回归机最合适..</strong></p><p id="bb6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们能够生成训练数据时，我们知道什么是正确的答案。但是，如果我们为每个新的数据点需求计算答案，那么成本可能会非常高。SVR或高斯过程是一种很好的袖珍友好的替代昂贵的方法。如果我们调用的函数计算起来很平滑，那么这些函数可以重复调用，因此通过预先计算训练集，然后使用SVR模型来预测结果，可以节省大量成本。</p><p id="825b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望上面的博客有助于理解SVR。</p><p id="d2dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><p id="60cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mm">原载于2020年9月29日https://www.numpyninja.com</em><a class="ae kl" href="https://www.numpyninja.com/post/a-dive-into-support-vector-regression-with-python" rel="noopener ugc nofollow" target="_blank"><em class="mm"/></a><em class="mm">。</em></p><h2 id="e22e" class="le lf iq bd mn mo mp dn mq mr ms dp mt jy mu mv mw kc mx my mz kg na nb nc nd bi translated">访问专家视图— <a class="ae kl" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank">订阅DDI英特尔</a>访问专家视图— <a class="ae kl" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank">订阅DDI英特尔</a></h2></div></div>    
</body>
</html>