<html>
<head>
<title>Underneath Numpy array &amp; Python list</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Numpy数组和Python列表下</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/underneath-numpy-array-python-list-42a30e62f693?source=collection_archive---------2-----------------------#2020-07-16">https://medium.datadriveninvestor.com/underneath-numpy-array-python-list-42a30e62f693?source=collection_archive---------2-----------------------#2020-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f269d78929e5f2f902dc60ca07f5a47c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mrDFie-EHuicw6r2.jpeg"/></div></div></figure><p id="f1b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">我已经使用Numpy很长时间了，我总是注意到Numpy数组在执行任务的速度和空间方面比python列表更快。我想分享我对这两种数据结构的深入编译和执行过程的发现。让我们开始吧！</p><p id="11e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">外面有很多<a class="ae lf" href="https://towardsdatascience.com/how-fast-numpy-really-is-e9111df44347" rel="noopener" target="_blank">教程</a>/博客比较Python list和Numpy array，你可以参考那些。在本教程中，我们将探索它们的内部工作方式，它们是如何工作的，它们的优点和缺点，以及一些基准测试来获得更好的想法。</p><p id="b08b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们深入研究这两种数据结构的性能之前，首先，我们需要理解它们的内部工作方式(编译成C的时间),因为它们的库和数据结构都是用C实现的。</p><p id="0019" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当python软件安装在您的机器上时，它至少有一个解释器和支持库。解释器只不过是运行我们的Python脚本的软件。有趣的是，它可以用任何编程语言实现！<a class="ae lf" href="https://en.wikipedia.org/wiki/CPython" rel="noopener ugc nofollow" target="_blank"> CPython </a>是用C编程语言编写的Python的默认解释器。</p><p id="01cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CPython、<a class="ae lf" href="https://en.wikipedia.org/wiki/Cython" rel="noopener ugc nofollow" target="_blank"> Cython </a>、<a class="ae lf" href="https://www.jython.org/" rel="noopener ugc nofollow" target="_blank"> Jython </a>、<a class="ae lf" href="https://ironpython.net/" rel="noopener ugc nofollow" target="_blank"> IronPython </a>这些大惊小怪的是什么？我会解答你所有的疑惑。请坚持到最后，并准备好python中使用的一些高级术语。让我们首先详细了解所有这些。</p><p id="9ddf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> CPython </strong></p><ul class=""><li id="411a" class="lg lh iq ka b kb kc kf kg kj li kn lj kr lk kv ll lm ln lo bi translated">CPython是Python编程语言的参考实现。用C和Python写的。由python的同一作者吉多·范·罗苏姆于1994年开发</li><li id="1173" class="lg lh iq ka b kb lp kf lq kj lr kn ls kr lt kv ll lm ln lo bi translated">CPython将您的Python代码编译成字节码(透明地),并解释该字节码，随后执行它。Python使用CPython作为基础</li></ul><p id="2b9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Cython </strong></p><ul class=""><li id="cb1c" class="lg lh iq ka b kb kc kf kg kj li kn lj kr lk kv ll lm ln lo bi translated">CPython本身不会将您的Python代码翻译成C。相反，它运行一个解释器循环，所以，这里Cython开始将Python代码翻译成c。</li><li id="726f" class="lg lh iq ka b kb lp kf lq kj lr kn ls kr lt kv ll lm ln lo bi translated">Cython为python语言添加了一些扩展，并允许您将代码编译成C扩展，即插入到CPython解释器中的代码。</li></ul><p id="4561" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Jython </strong>、<strong class="ka ir"> IronPython </strong>、<strong class="ka ir"> PyPy </strong>是目前Python编程语言的“其他”实现；这些分别用Java、C#和RPython(Python的一个子集)实现。Jython将您的Python代码编译成Java字节码，因此您的Python代码可以在JVM上运行。IronPython允许您在Microsoft CLR上运行Python。PyPy是用Python(的一个子集)实现的，它可以让你比CPython更快地运行Python代码</p><p id="7da9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们深入python列表和Numpy数组的内部实现</p><h1 id="1e05" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">目录</h1><p id="f0f3" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">列表是python中最通用的数据类型，每个人都知道列表能做什么以及我们为什么使用列表。因此，举例来说，一个列表可以作为一个堆栈，作为一个容器来存储不同数据类型的值，列表有一些基本的功能，如追加，扩展，弹出，删除等。</p><p id="1cd1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但问题是如何实施？</p><p id="a3d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CPython的列表是可变长度的数组，而不是<a class="ae lf" href="http://www.gigamonkeys.com/book/they-called-it-lisp-for-a-reason-list-processing.html" rel="noopener ugc nofollow" target="_blank"> Lisp风格的</a>列表(使用链表)。CPython对列表的实现使用了一个引用其他对象的连续数组，并在列表头结构中保存了一个指向该数组和数组长度的指针。这使得索引列表成为一种[i]操作，其成本与列表的大小或索引的值无关。</p><p id="2d4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当追加或插入项时，引用数组的大小将被调整。一些小技巧被用来提高重复添加项目的性能；当数组必须增长时，会分配一些额外的空间，因此接下来的几次不需要实际调整大小。</p><p id="b945" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面显示了一个用C实现的列表结构。不要担心这个C代码，这只是为了你的知识，所以如果有人问列表是如何在幕后工作的，那么你至少可以说一些关于C中列表对象结构的事情，而且，我相信知道细节总是更好的。</p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/6a95f1bc7579239e0d4666d093d7a7fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o49qrfH4jvRMMNymg5bIKw.png"/></div></div></figure><p id="8aed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们来看看numpy是如何工作的。</p><h1 id="65dc" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">Numpy</h1><p id="8de1" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">在这一节中，我们将看到在使用NumPy数组时会发生什么。</p><p id="c824" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">NumPy数组是同一类型对象的多维数组，基本上由元数据(特别是维数、形状和数据类型)和实际数据来描述。</p><p id="095d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">数据存储在系统内存(随机存取内存，或RAM)中特定地址的同构连续内存块中。这个内存块被称为<strong class="ka ir">数据缓冲器</strong>。</p><p id="b06b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是数组和纯python结构(如列表)的主要区别，列表中的项目分散在系统内存中。这是使NumPy数组如此高效的关键特性。</p><p id="031c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面快速看一下C语言中numpy数组对象的样子。结构<code class="fe nc nd ne nf b">PyArrayObject</code>有四个元素(<code class="fe nc nd ne nf b">*data</code>、<code class="fe nc nd ne nf b">nd</code>、<code class="fe nc nd ne nf b">*dimensions</code>、<code class="fe nc nd ne nf b">*strides</code>，它们是从C代码中访问数组数据所必需的，为了简洁起见，请忽略其他字段:</p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/88c1c4d111eee9e5196ac434db9f24d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c36tnSrqbVo2QzArE2_TGg.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Numpy arrays structure in C</figcaption></figure><h1 id="e117" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">为什么NumPy高效？</h1><ul class=""><li id="44b6" class="lg lh iq ka b kb ms kf mt kj nl kn nm kr nn kv ll lm ln lo bi translated">用C之类的低级语言编写的数组计算非常有效(NumPy的大部分实际上是用C编写的)。例如，知道了内存块的地址和数据类型，只需简单的运算就可以遍历所有项。在python中用列表做这件事会有很大的开销。</li><li id="1006" class="lg lh iq ka b kb lp kf lq kj lr kn ls kr lt kv ll lm ln lo bi translated">内存访问模式中的空间局部性会显著提高性能，这主要归功于CPU缓存。事实上，缓存将字节从RAM成批地加载到CPU寄存器中。然后，非常有效地加载相邻的项目(<a class="ae lf" href="https://en.wikipedia.org/wiki/Locality_of_reference" rel="noopener ugc nofollow" target="_blank">参考位置</a>)</li><li id="f7a7" class="lg lh iq ka b kb lp kf lq kj lr kn ls kr lt kv ll lm ln lo bi translated">最后，项目连续存储在内存中的事实使NumPy能够利用现代CPU的矢量化指令，如英特尔的SSE和AVX，AMD的XOP，等等。例如，可以将多个连续的浮点数加载到128、256或512位寄存器中，用于作为CPU指令实现的矢量化算术计算。</li><li id="41dc" class="lg lh iq ka b kb lp kf lq kj lr kn ls kr lt kv ll lm ln lo bi translated">此外，NumPy可以通过<a class="ae lf" href="http://math-atlas.sourceforge.net/faq.html#doc" rel="noopener ugc nofollow" target="_blank"> ATLAS </a>或英特尔数学内核库(MKL)链接到高度优化的线性代数库，如<a class="ae lf" href="http://www.netlib.org/blas/" rel="noopener ugc nofollow" target="_blank"> BLAS </a>和<a class="ae lf" href="http://www.netlib.org/lapack/" rel="noopener ugc nofollow" target="_blank"> LAPACK </a>。一些特定的矩阵计算也可能是多线程的，利用现代多核处理器的能力。</li></ul><p id="081a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，numpy也有一些缺点。它必须要求连续的内存分配。当数据存储在连续的存储位置时，插入和删除操作变得昂贵</p><p id="b963" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总之，将数据存储在一个连续的内存块中，可以确保现代CPU的架构得到最佳利用，在内存访问模式、CPU缓存和矢量化指令方面，这在python列表中是不可能的。</p><p id="a520" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Python列表支持高效的插入、删除、追加和连接，Python的列表理解使它们更容易构建和操作。</p><p id="2cc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，python的列表有一定的局限性:</p><ul class=""><li id="65a5" class="lg lh iq ka b kb kc kf kg kj li kn lj kr lk kv ll lm ln lo bi translated">Python的列表不支持“向量化”操作，比如基于元素的加法和乘法</li><li id="4df2" class="lg lh iq ka b kb lp kf lq kj lr kn ls kr lt kv ll lm ln lo bi translated">Python的列表可以包含不同类型的对象，这意味着python必须存储每个元素的类型信息，并且在操作每个元素时必须执行类型调度代码。这导致在每次迭代中检查类型。</li></ul><p id="8404" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，我们知道了为什么numpy比python的list更快更高效。现在，让我们在一个非常高的水平上比较它的性能。</p><h1 id="3fc3" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">性能比较</h1><p id="a630" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">在这一节中，我们将从内存消耗和执行时间方面对python的list和Numpy数组进行基准测试。先导入，必要的模块，比较不同大小的数组/链表的性能。在本例中，我们将计算python list和numpy array的时间/内存结果之间的比率，看看哪一个性能更好。此外，该比率将被视为一个<em class="no"> python列表:numpy_array </em>，因此结果显示numpy比python列表好多少倍。</p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/a240e2ad5252df65a37416e186ed6384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7OK49mbn3EcwXRCQZKNhQ.png"/></div></div></figure><p id="914a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">内存消耗</strong></p><p id="f2b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个简单的例子，展示了存储不同大小的数组的内存消耗。</p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/532585542d4167c788b846d45c9dd633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xT2lHPN-wlaYh9b1WcePhA.png"/></div></div></figure><p id="1cfd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们把它绘制成一个图表，通过取两者之间的比率来更好地形象化。</p><figure class="my mz na nb gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/ae81d60310c2a3a308521edd20c8863e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*_zfFKdrsaNh2-GHxf8XlQQ.png"/></div></figure><p id="9a06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上图显示numpy优于所有不同大小的产品。这是因为python为每个元素存储了类型信息，这当然需要更多的空间，而numpy则不同，它拥有相同类型的所有元素。</p><p id="82a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">时间对比</strong></p><p id="677e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的例子是关于计算列表/数组中每个元素的平方并测量时间。</p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/76324fe3951e1899017c1ccbc4444996.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bKxpaC5_Opt95kFrlTMKZA.png"/></div></div></figure><figure class="my mz na nb gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/2cdc6e116c3ae5a40fecbe4e45fabc1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*165Vmc5PWJal2kb-uVvBng.png"/></div></figure><p id="11ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上图中，对于<code class="fe nc nd ne nf b">size=1</code>, python列表的性能更好，而在所有其他情况下，numpy的性能更好。原因是，尽管python list速度很快(两者都使用C作为后端)，但它只是检查每个元素的<code class="fe nc nd ne nf b">dtype</code>的开销。在numpy中，通过类型检查，它还必须检查我们在C结构中看到的其他头信息，即维度、跨度等。而在python中只有<code class="fe nc nd ne nf b">dtype</code>就足够了。</p><p id="6843" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个例子，一个<strong class="ka ir">向量化操作</strong>，这个例子把两个数组的元素相加。</p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/b7fb845990ae6809b01fd46b18d5a9e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1-5lJQo50UqPHWONSedPA.png"/></div></div></figure><figure class="my mz na nb gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/8312c71ccba36bb6b5dd8518e6a0ee69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*O9npNvssJJsWM79gzSyy5A.png"/></div></figure><p id="9241" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上图中，对于所有大小，numpy都表现出色，因为它能够按元素进行操作，并且由于高度优化的线性代数库，它还可以利用多线程中的计算。但是这里有很多因素在起作用，包括使用的底层库(<a class="ae lf" href="http://www.netlib.org/blas/" rel="noopener ugc nofollow" target="_blank">BLAS</a>/<a class="ae lf" href="http://www.netlib.org/lapack/" rel="noopener ugc nofollow" target="_blank">LAPACK</a>/<a class="ae lf" href="http://math-atlas.sourceforge.net/faq.html#doc" rel="noopener ugc nofollow" target="_blank">Atlas</a>)</p><p id="d4d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我希望我对python的动态分配列表和NumPy的数组的内部工作有所了解。</p><p id="7437" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读。和平。</p><h1 id="5ff3" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">参考</h1><ul class=""><li id="355e" class="lg lh iq ka b kb ms kf mt kj nl kn nm kr nn kv ll lm ln lo bi translated"><a class="ae lf" href="https://ipython-books.github.io/" rel="noopener ugc nofollow" target="_blank">https://ipython-books.github.io/</a></li><li id="5ed5" class="lg lh iq ka b kb lp kf lq kj lr kn ls kr lt kv ll lm ln lo bi translated">https://www.scipy.org/<a class="ae lf" href="https://www.scipy.org/" rel="noopener ugc nofollow" target="_blank"/></li><li id="de03" class="lg lh iq ka b kb lp kf lq kj lr kn ls kr lt kv ll lm ln lo bi translated"><a class="ae lf" href="https://stackoverflow.com/questions/3917574/how-is-pythons-list-implemented" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/3917574/how-is-python-list-implemented</a></li><li id="3b35" class="lg lh iq ka b kb lp kf lq kj lr kn ls kr lt kv ll lm ln lo bi translated"><a class="ae lf" href="http://folk.uio.no/inf3330/scripting/doc/python/NumPy/Numeric/numpy-13.html" rel="noopener ugc nofollow" target="_blank">http://folk . uio . no/INF 3330/scripting/doc/python/NumPy/Numeric/NumPy-13 . html</a></li><li id="97c0" class="lg lh iq ka b kb lp kf lq kj lr kn ls kr lt kv ll lm ln lo bi translated"><a class="ae lf" href="https://stackoverflow.com/questions/17130975/python-vs-cpython" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/17130975/python-vs-cpython</a></li></ul></div></div>    
</body>
</html>