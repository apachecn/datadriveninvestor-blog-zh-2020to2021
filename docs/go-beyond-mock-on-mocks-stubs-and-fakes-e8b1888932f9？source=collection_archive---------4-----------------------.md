# 超越模仿:模仿，存根和假货

> 原文：<https://medium.datadriveninvestor.com/go-beyond-mock-on-mocks-stubs-and-fakes-e8b1888932f9?source=collection_archive---------4----------------------->

![](img/b708141e8d9f3be4bc1559528f954b0c.png)

Go Beyond ̶R̶o̶c̶k̶ Mock :)

作为开发人员，当提到几种不同的测试实践时，我们使用术语“模仿”和“嘲弄”。在这篇文章中，我将标准化 Mocks、Stubs 和 Fakes 的术语:它们的功能，它们之间的区别，以及何时使用它们。

了解不同的模拟替代方案可以帮助您编写更健壮和可维护的代码，享受更快的执行时间，并提高整体代码质量。

让我们从定义开始:

# **嘲弄**

模仿取代了原来的“模仿”对象。基本的 mock 没有自己的实现。模仿记录所有打给他们的电话，所以他们可以稍后被验证。

当您不想调用原始对象/功能时，请使用模拟。

# **存根**

存根是更高级的模拟:它有一个返回静态数据的预定义实现**。**

当您想要测试依赖于固定数据的特定用例时，请使用存根。

# **假的**

fake 是更高级的模拟:它有一个实际的、简化的、有效的实现。

当你想要简单、轻量级的逻辑而不是真正的实现时，使用 fakes。

理论背景讲的够多了，现在来讲一些 Python 代码！

我们想测试这段代码:

这个简短的方法使用 [boto3](https://boto3.amazonaws.com/v1/documentation/api/latest/index.html) (亚马逊 S3 的一个包装器)，将一个现有的对象移动到一个唯一的、随机的地方。boto 中没有“move”方法，所以我们必须复制和删除对象。
唯一性由 [uuid4](https://docs.python.org/3.7/library/uuid.html#uuid.uuid4) 确保，它以`a4a8ec45–3c6f-4a75-b7d7–112611f302`的形式返回标识符，然后对其进行处理，使其更像目录结构:每个连字符('-')都用斜杠('/')替换。在上面的例子中是:`a4a8ec45/3c6f/4a75/b7d7/112611f302`。

我们将编写的第一个测试将演示模拟和存根:

`test_move_to_unique_location_ensure_uniqueness`是对**模拟**的一个很好的介绍:我们在这个方法中想要测试的就是得到唯一的目的地。我们关心算法逻辑，不关心 s3 运算。显而易见的解决方案是**模仿 s3 而不做任何实现。** `@mock.patch('s3._s3')`正是这么做的——它用一个 mock 替换了 boto3 s3 句柄。测试函数的主体非常简单——调用被测试的方法一千次，并收集输出以验证它们都是唯一的。

[](https://www.datadriveninvestor.com/2020/07/07/introduction-to-time-series-forecasting-of-stock-prices-with-python/) [## 用 Python |数据驱动投资者进行股票价格时间序列预测简介

### 在这个简单的教程中，我们将看看如何将时间序列模型应用于股票价格。更具体地说，一个…

www.datadriveninvestor.com](https://www.datadriveninvestor.com/2020/07/07/introduction-to-time-series-forecasting-of-stock-prices-with-python/) 

接下来我们有`test_move_to_unique_location_destination_format`，它是一个**存根**的例子:注意固定的`return_value='a4a8ec45–3c6f-4a75-b7d7–112611f302'`。它允许我们验证我们的格式产生正确的目的地。我们必须存根 uuid4 来获得我们想要的值，否则每次测试执行都会产生不同的目的地。

模仿者还会记录打给他们的电话，这些电话可以被验证。让我们来看看实际情况:

使用`assert_called_once_with`来验证对 s3 模拟的调用。这个例子验证了所使用的确切参数，但是如果我们愿意，我们可以不那么严格。我们稍后将回到这个例子。

到目前为止，我们已经**测试了算法逻辑**，并且看到了一些模拟和存根的例子。我们**尚未验证 s3 操作**，更具体地说，我们尚未回答以下问题:

1.  我们如何知道我们是否使用了带有正确参数的正确 s3 方法？
2.  我们如何知道实际的 s3 对象被正确地移动了？
3.  我们如何知道被测试的代码没有脱离现实？

为了将所有这些理论问题具体化，想象您在`move_to_unique_location` : `_s3.typo()`中添加了下面一行。你的测试会全部通过，但是代码在现实生活中会完全被破坏！

为了解决这些问题(并获得许多额外的好处)，我们可以使用**假货。**在下面的例子中，我们使用 s3 的一个简单实现，称为 [moto](https://pypi.org/project/moto/) :

这比前面的例子要多一点，所以让我们来分解一下。

这个文件有三个方法:`empty_bucket`是一个 [pytest fixture](https://pytest.org/en/latest/fixture.html#fixture) ，它为另外两个测试方法设置了一个干净的、假的 s3 桶。

如果你仔细观察`test_move_to_unique_location_no_source_object`，你会发现它与之前的测试不同:

1.  它测试一个负面的用例
2.  它试图移动物体

这个测试显示了我们之前的测试是如何与现实脱节的:要移动一个物体，你首先需要确保它是存在的。如果你不相信我，试着在没有`@mock.patch('s3._s3')`的情况下运行之前的测试，看看你会得到什么异常。

现在我们准备好了最后一项测试:

1.  它创建了一个对象
2.  使用测试过的代码移动它
3.  通过检查对象的内容来验证对象是否被正确移动
4.  验证对象不再位于我们创建它的原始位置(我们希望该函数移动对象，而不仅仅是复制它)

哇，一个端到端的测试！

我们都完了，还是…

过了一会儿，您决定更改`move_to_unique_location`的实现:

这个替代方案使用`boto3.resource`而不是`boto3.client`来达到相同的结果。

问:你的测试会怎么样？

除了一个人外，其他人都及格了。使用适当的技术测试正确的东西的测试将会通过。最好的例子是`test_move_to_unique_location_verify_read`,它验证对象存在于新位置，而不检查它是如何到达那里的。

`test_move_to_unique_location_destination_format`是另一个很好的例子:它确保目标结构不会改变。

唯一出故障的测试是`test_move_to_unique_location_verify_calls`。原因是它检查了被改变的特定实现。您可以删除这个测试，因为它的主要目标是展示模拟能力。

**总结:仿制品、存根和假货都有其用途。一定要恰当地使用它们:利用它们的优势，避免在它们不能提供真正的价值并且只会让你慢下来的时候使用它们。**

一些最后的话:

光有理论知识是不够的！本文中的代码片段完全可以工作，因此可以通过运行、修改和探索这些代码将这些信息付诸实践。

如果您在实际的代码库中使用几个模拟类型，以查看哪些类型适用于特定的情况，并对常见情况有更深的直觉，那么您将获得最大的好处。

对于进一步的阅读，查看这篇文章，它很好地解释了使用 Java 编程语言的相同主题。

## 访问专家视图— [订阅 DDI 英特尔](https://datadriveninvestor.com/ddi-intel)