<html>
<head>
<title>Backtesting of Trading Strategy with Technical Indicator #4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用技术指标#4对交易策略进行回溯测试</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/backtesting-of-trading-strategy-with-technical-indicator-4-88967b48a3a5?source=collection_archive---------0-----------------------#2020-10-08">https://medium.datadriveninvestor.com/backtesting-of-trading-strategy-with-technical-indicator-4-88967b48a3a5?source=collection_archive---------0-----------------------#2020-10-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2e8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有很多技术指标我们可以交易。问题是对于给定的资产，什么是最好的？我们将通过改进上节课的回溯测试来回答这个问题。</p><p id="73c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上一节课中，我们已经了解了如何通过策略Keltner渠道找到止损水平和参数的最佳组合。在本节中，我们将探索并在回溯测试中添加其他策略。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/e42ae29da7d4eac60e29e2756a06ad92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MiKqEZtcQiwvN1L7.jpeg"/></div></div></figure><p id="0eb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您还没有阅读之前的会议，这里有链接。</p><div class="la lb gp gr lc ld"><a href="https://medium.com/analytics-vidhya/backtesting-of-trading-strategy-with-technical-indicator-3-86ce4e75713e" rel="noopener follow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd iu gy z fp li fr fs lj fu fw is bi translated">用技术指标#3对交易策略进行回溯测试</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">通过调用前面的Python脚本，找到凯特纳通道的止损水平和参数的最佳组合…</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">medium.com</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr ky ld"/></div></div></a></div><div class="la lb gp gr lc ld"><a href="https://medium.com/analytics-vidhya/will-stop-loss-help-trading-with-technical-indicators-30c5fd936c26" rel="noopener follow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd iu gy z fp li fr fs lj fu fw is bi translated">止损对技术指标交易有帮助吗？</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">Python:用技术指标#2对交易策略进行回溯测试</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">medium.com</p></div></div><div class="lm l"><div class="ls l lo lp lq lm lr ky ld"/></div></div></a></div><div class="la lb gp gr lc ld"><a href="https://medium.com/analytics-vidhya/backtesting-of-trading-strategy-with-technical-indicator-1-f782b252d873" rel="noopener follow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd iu gy z fp li fr fs lj fu fw is bi translated">用技术指标#1对交易策略进行回溯测试</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">想交易吗？最好先对想法进行回溯测试。通过这个系列，我想将Python金融系列扩展到…</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">medium.com</p></div></div><div class="lm l"><div class="lt l lo lp lq lm lr ky ld"/></div></div></a></div><h2 id="f9cc" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">快速重新加盖</h2><p id="07fe" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">让我们快速回顾一下到目前为止的逻辑。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/3f84c931907c72a1a0253ce92e3c009d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*hQBrlgwLw6oThRXdSsGEMA.png"/></div></figure><p id="58d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们总共有五个步骤来测试单个策略的可能输入，现在的问题是<strong class="js iu">如何扩展到多个策略</strong>。</p><p id="e08f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们会想到的一个自然的方法是再增加一层循环，也就是说，我们可以定义一个策略列表，对于每个策略，我们运行与上面类似的逻辑。<strong class="js iu">然而，有一个挑战</strong>。</p><blockquote class="mt mu mv"><p id="905f" class="jq jr mw js b jt ju jv jw jx jy jz ka mx kc kd ke my kg kh ki mz kk kl km kn im bi translated"><strong class="js iu">每一个策略都会有不同数量的参数，参数以不同的名称被调用。</strong></p></blockquote><p id="a51c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">怎么才能概括呢？</strong>在我们进入解决方案之前，让我们看一些可能有帮助的例子。</p><h2 id="2f4c" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">输入的唯一组合</h2><p id="669d" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">假设我们有三个参数需要放入策略中，每个参数都有一个可能值的列表。<strong class="js iu">我们如何获得输入的唯一组合列表？</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi na"><img src="../Images/4774b0ee907d47b9d5a815680b775449.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*ZgYYy8dgWl9Gbbv1VrHg_Q.png"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/a47bb2b13aa798e0bebf227c99fc847c.png" data-original-src="https://miro.medium.com/v2/resize:fit:204/format:webp/1*0HuEZ_hqRnY3hPUFoF61cg.png"/></div></figure><p id="f04b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">幸运的是，我们有来自"<strong class="js iu"> itertools </strong>"的python函数"<strong class="js iu"> product </strong>"来帮忙。这里我们有三个列表，“a”、“b”和“c”(想象它们是我们策略的三个参数的可能输入)。函数“product”将获得三个列表的唯一组合列表。</p><p id="6e56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">还有一件事要考虑。</strong>在我们的案例中，我们策略的参数数量可能会改变，那么使用“产品”功能的最佳方式是什么？</p><p id="1634" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以将所有的参数放在一个列表中，并使用<strong class="js iu"> * </strong>来传递列表中的参数。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/277cdfb0239838251a553dbfc9c15f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*5YEv9bsHcdKejKbvb7wfLA.png"/></div></figure><p id="485c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的代码相当于分别传递“a”、“b”和“c”。在这种情况下，我们不需要担心每个策略的参数数量。</p><h2 id="8f65" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">更多关于*</h2><p id="ae5c" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">现在我们知道我们可以生成一个唯一组合的列表，但是对于每个策略，参数名称都是不同的。例如，RSI采用“n”，但MACD可能采用“n_fast”、“n_slow”和“n_sign”。那么我们如何更一般地传入参数呢？看看下面的例子。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/0f70725572f7ab10238da91787ebaf34.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*fQC0Edkpf7beS2j_cBG3Aw.png"/></div></figure><p id="98fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们有一个函数“test_func ”,它可以接受许多键值参数，这也是我们在策略函数中使用的。我们可以调用a=1，b=2，c=3的函数，它应该得到如下输出。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/75eb98c5f36e2f0d08c1ffc0fb43fc30.png" data-original-src="https://miro.medium.com/v2/resize:fit:108/format:webp/1*WT0FiSmYAhmyq1K3nKANoA.png"/></div></figure><p id="602c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有趣的是，我们也可以通过传入字典得到相同的结果，tick使用了<strong class="js iu"> ** </strong>。它应该给我们同样的结果。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/b9a5dbf34ccf8c1d4182095630ca7a47.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*yoY3OA3MHWA0R2cZisAyEA.png"/></div></figure><h2 id="e2d9" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">把这个列表变成一本字典</h2><p id="b765" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">到目前为止，我们知道可以使用函数“<strong class="js iu"> product </strong>来获得一个唯一组合的列表，并且可以使用<strong class="js iu"> ** </strong>和一个字典来将参数传递给我们的策略函数。然而，如何将唯一组合列表变成字典呢？这里有一个很好的例子。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/eb0ccdacb109e7540384e9341b1211d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*LeIKVbWz32UaKjugaD4AgQ.png"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/0dd66c601724cdb37995c87ffb2db1fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:398/format:webp/1*NzsYkXMhptLuEX1DGqyfCQ.png"/></div></figure><p id="0b93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用"<strong class="js iu"> zip </strong>"来组合两个列表，并使用"<strong class="js iu"> dict </strong>"来初始化一个字典。第一个列表是<strong class="js iu">键</strong>，第二个是<strong class="js iu">值</strong>。</p><div class="la lb gp gr lc ld"><a href="https://www.datadriveninvestor.com/2020/09/23/why-most-people-lose-money-day-trading-and-how-to-not-be-one-of-them/" rel="noopener  ugc nofollow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd iu gy z fp li fr fs lj fu fw is bi translated">为什么大多数人在日内交易中亏损(以及如何不成为他们中的一员)|数据驱动的投资者</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">日内交易很难，大多数人都赔钱。我确实有。事实上，我曾经在一个单一的损失更多的钱…</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="lm l"><div class="ni l lo lp lq lm lr ky ld"/></div></div></a></div><p id="31a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看如何把我们见过的所有技巧放在一起。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/c5d7304e5e6ae9a3fae74f4895dc299e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*IZg3W88ZYn46qm7rSWB_lw.png"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/eac4c1f7ad2d6a5d38899929c8041ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*AR8GACCBGl4L_zAewaeV9Q.png"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nl"><img src="../Images/c51cf7c337050301ee94e865a8548cb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*BdmIlZZh_M1X2YOG4wR8Ag.png"/></div></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/9dfe37d6f0a79d5e56b034971ef187c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:132/format:webp/1*69wmPGyRtWMx0j9UqDGFSQ.png"/></div></figure><h2 id="932b" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">定义更多策略</h2><p id="57e8" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">现在回到我们的任务，用多种策略进行回溯测试。我们需要制定更多的策略。在我们的例子中，我将使用以下常见的技术指标。</p><ul class=""><li id="504e" class="nn no it js b jt ju jx jy kb np kf nq kj nr kn ns nt nu nv bi translated">凯尔特纳渠道(我们在过去的三次会议中实施)</li><li id="7dcd" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated">布林线</li><li id="51c5" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated">简单移动平均线</li><li id="d414" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated">指数移动平均线</li><li id="caa5" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated">MACD</li><li id="6a06" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated">RSI</li><li id="e7fd" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated">威廉姆斯%R</li><li id="6439" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated">随机快速</li><li id="c453" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated">随机慢速</li><li id="dd1a" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated">市目</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/28690727e42abcc3bbd94a4a9a691f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*lLpfa9DIo8UeKVKtzYNoFQ.png"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/43a1ab42a8c7af8efa298f974df005c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*puVnVTUPDEOSLI9X0U6rGw.png"/></div></figure><p id="67e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">移动平均线策略的一个快速注释。为了节省几行代码，我们对简单移动平均和指数移动平均都做了通用函数，这是由参数“ma_type”决定的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi od"><img src="../Images/2f5709874bbf0c087f0f3ccf8be155c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*TN8qM0-94lLuWsE4iLKgZw.png"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/25af15ffe25416d63c88094f7b8a1078.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*hCfgKm9KL75lfaiOgwX-8g.png"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi of"><img src="../Images/6502dbc22da606157d6757a9daf61df1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*rnIQl0j3M-5BMjsGiqOp-Q.png"/></div></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi og"><img src="../Images/9670627734dff3b2801819787fb940bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*avxN5b2hvb62JTuS91tKLg.png"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi og"><img src="../Images/1ef62f5b988e2e697956e979677ea431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*mSB-_bEO-l4tnBqB_B--fA.png"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/ceea499e63e0f07b9a4a80f70dd8f58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*lIPfuyKrEdBmEl8OE2KxSg.png"/></div></figure><p id="041a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码结构与我们在前三节中所做的相同，最终我们需要返回四列数据作为交易信号:<strong class="js iu"> LONG </strong>、<strong class="js iu"> EXIT_LONG </strong>、<strong class="js iu"> SHORT </strong>和<strong class="js iu"> EXIT_SHOT </strong>。您可以遵循该模式并定义任何策略，它将与我们的回溯测试函数一起工作，只要我们返回这四个信号列。</p><h2 id="1330" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">把战略放在一个好的结构中</h2><p id="6451" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">现在我们已经定义了所有的策略，我们需要把它们放到一个好的数据结构中，这样我们就可以用可能的输入组合对它们进行回测。当我们考虑一个好的数据结构时，我们指的是一种通用的方式。</p><p id="edce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，它应该是一个列表，因为我们有一个可以循环的策略列表。其次，我们需要用参数名定义所有可能的输入，所以这听起来像一本字典。最后，当我们遍历策略时，我们需要有一个通用名称来获取策略函数和可能的参数，所以列表中的每个元素也应该在一个字典中。最终，它将是一个字典列表。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/bfe2f75f2d3556e14ec78fc079236ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*umiG6lsbZIGtB7tKEKpx6A.png"/></div></figure><p id="7eb7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们定义了一个变量“策略”，它是一个列表。在这个列表中，我们有定义我们需要测试的内容的字典。按键“<strong class="js iu"> func </strong>”将为我们提供策略功能，按键“<strong class="js iu"> param </strong>”将为我们提供所有参数名称的字典，可能的输入为列表。</p><p id="230c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看如何循环策略并生成独特的组合。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oj"><img src="../Images/10f6b2ff2f6011e03e388fab18f0c0ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uh7bkTjXV4598wK1Kp3TWg.png"/></div></div></figure><p id="5157" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我们要做常规的for循环。对于每个循环，我们将获得带有键“func”的策略和带有键“param”的参数字典。因为我们不知道我们将有多少个参数，所以我们有另一个循环来获取参数名及其可能的输入作为一个列表。然后，我们将参数名和可能的输入放入列表“param_name”和“param_list”。最后，我们使用在本节课开始时看到的技巧，将唯一组合列表转换为词典列表。</p><p id="8718" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们运行代码，我们会看到有多少独特的组合，我们需要测试。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ok"><img src="../Images/7b2883080bfe4ca93386f23ece521581.png" data-original-src="https://miro.medium.com/v2/resize:fit:74/format:webp/1*lzLEGmOR05Q472gtWPQN5w.png"/></div></div></figure><p id="7716" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">策略采用的参数越多，组合就越多。在我们的例子中，我们有855个模拟要运行。考虑到我们也有从-1%到-5%的止损，包括没有止损，即6种可能性，我们最终将运行5130次模拟。这是相当多的，回溯测试很容易变得疯狂。最终，我们甚至可能需要并行计算能力。</p><h2 id="d122" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">运行回溯测试</h2><p id="47bb" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">最后一步，我们将集成回溯测试代码并运行模拟。</p><p id="3ec0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从准备数据和初始化结果保存器开始。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/95fa0ffdcedc55e2b33a83556060d456.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*TpoDc1t3B9DZXHV5sp_csg.png"/></div></figure><p id="16ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这和我们以前做的非常相似。我们使用函数“get_stock_backtest_data”来获取历史棒线。然后我们定义我们需要的所有可能的止损水平，包括没有止损。最后，定义“result_dict”来保存每个回溯测试的结果。在这种情况下，我们需要存储策略名称以及经过测试的参数输入。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi om"><img src="../Images/edf888d35b90c8fc414f3f05136f889c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G1lS3w6VGy755xNOdE3LTg.png"/></div></div></figure><p id="7df0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的代码和符号应该可以解释这个想法。只需快速突出显示一下，函数"<strong class="js iu"> clear_output </strong>来自<strong class="js iu"> IPython.display </strong>，我们需要在顶部导入它。该函数将清除打印，因此在这种情况下，当我们运行模拟时，我们将始终打印一行进度文本。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi on"><img src="../Images/186f8e5200ca5a698636bccee2baee5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SikQwH1BojDE0PIsz-ngiw.png"/></div></div></figure><p id="4171" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将需要一段时间来运行和以上是最终结果。我们可以看到，在这种情况下，凯尔特纳渠道仍然是最好的，但我们可以看到，MACD是第二好的策略。因为回溯测试只告诉过去，采取前两个策略肯定会帮助我们的交易。</p><h2 id="acef" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">然后</h2><p id="e8fd" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">有许多方法可以使用回溯测试结果。人们可以用很长的历史进行回溯测试，看看哪种策略可以持续产生最佳性能，我们的代码已经可以做到这一点。然而，单一的策略不可能永远有效，所以我们可能会想，如果我们基于以前的回溯测试结果动态地决定策略，看看它是如何工作的，即基于回溯测试的回溯测试！</p><h2 id="ac80" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">项目Git链接</h2><div class="la lb gp gr lc ld"><a href="https://github.com/bbk-pij-2012-29/trading_with_ta_backtesting/blob/main/ta_trading_study.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd iu gy z fp li fr fs lj fu fw is bi translated">bbk-pij-2012-29/trading _ with _ ta _回溯测试</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">permalink dissolve GitHub是超过5000万开发人员的家园，他们一起工作来托管和审查代码，管理…</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">github.com</p></div></div><div class="lm l"><div class="oo l lo lp lq lm lr ky ld"/></div></div></a></div><h2 id="62b0" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">访问专家视图— <a class="ae op" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank">订阅DDI英特尔</a></h2></div></div>    
</body>
</html>