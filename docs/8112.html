<html>
<head>
<title>Options trading data analysis — Part 1-An introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">期权交易数据分析—第1部分—简介</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/options-trading-data-analysis-part-1-an-introduction-c6dcdc5d9a2f?source=collection_archive---------8-----------------------#2021-01-01">https://medium.datadriveninvestor.com/options-trading-data-analysis-part-1-an-introduction-c6dcdc5d9a2f?source=collection_archive---------8-----------------------#2021-01-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="09e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为期权交易者，能够监控你的表现，至少知道你的策略是否有效，你是否盈利，这很重要。一开始，我用Excel跟踪我的交易，基本上是记录每一笔开仓和平仓交易。参见图1。这些数字显然只是为了举例，但请注意它们之间的关系。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/755f02563047bd3583df6e238a9527c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wG-sWHIbFTOqNM4-dA7Kuw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Figure 1 — Tracking with Excel</figcaption></figure><p id="1417" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于开仓交易，我们记录价格和合约数量，其中价格被记录为买入的借方(负数)和卖出的贷方(正数)。在平仓相应的开仓头寸时，我们将再次对借方和贷方进行求和，并计算平仓金额和开仓金额的总和。这成为我们的利润(负值表示亏损)。每笔交易的运行资金、佣金和费用都会被跟踪。然后，资本回报率的计算方法是利润除以收盘时的资本(注意，这不同于跟踪购买力和根据使用的购买力计算回报率)。颜色用于结算交易，作为个人盈利或亏损的快速指标。已结束的期初交易将以删除线显示。总利润和资本回报率也计算为相应列的总和并显示出来。</p><p id="0dbf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这当然是可行的，但是，它是高度手工的，因此既费时又乏味。作为一名软件开发人员，我倾向于寻找更好(更懒)的方法。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="c5dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想做的第一件事是能够直接从代理获得交易数据，以避免手动输入每个数据。大多数经纪人允许用户通过CSV文件下载账户交易。如果他们提供API来获取JSON格式的事务就更好了。在写这篇文章的时候，我知道TD Ameritrade有一个开发者API来做这件事:<a class="ae ll" href="https://developer.tdameritrade.com/apis" rel="noopener ugc nofollow" target="_blank">https://developer.tdameritrade.com/apis</a>。在这里，我不会使用任何单独的代理工具集来获取事务数据，但是我将使用TD Ameritrade提供的JSON。</p><p id="35e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们能够获得事务数据，下一步就是设置我们的开发环境。这只做一次。我们将为<code class="fe lm ln lo lp b">Python</code>使用<code class="fe lm ln lo lp b">Pandas </code>库，这在数据分析中非常流行。你可以建立自己的Python环境，并使用<code class="fe lm ln lo lp b">pip</code>安装Pandas。Jupyter笔记本也很方便，所以也可以安装它(也可以使用pip)。更好的是，如果你准备好了，去<a class="ae ll" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank">合作实验室</a>吧，一切都已经准备好了。方便。</p><p id="b768" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然我们的笔记本启动了，让我们开始写吧。显然，我们要做的第一件事是包含必要的库，然后加载事务数据文件。</p><pre class="kp kq kr ks gt lq lp lr ls aw lt bi"><span id="5a7d" class="lu lv it lp b gy lw lx l ly lz">import json<br/>import pandas as pd<br/>from pandas.io.json import json_normalize</span><span id="cce1" class="lu lv it lp b gy ma lx l ly lz">with open('transactions.json') as f:<br/>    jsonData = json.load(f)</span><span id="d775" class="lu lv it lp b gy ma lx l ly lz">#by default normalization uses the '.' as the seperator <br/># we're going to use the '_' instead<br/>transactionsDf = pd.json_normalize(jsonData, sep='_')<br/>transactionsDf = transactionsDf.iloc[::-1]</span></pre><p id="43d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将<code class="fe lm ln lo lp b">import json</code>反序列化为<code class="fe lm ln lo lp b">jsonData</code>，然后转换为Pandas数据帧。如果我们简单地使用<code class="fe lm ln lo lp b">transactionsDf = pd.DataFrame(jsonData)</code>，我们将得到一个类似这样的数据帧:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mb"><img src="../Images/a0dc40f05d97d982a1f7c84360b5d2a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RcDdOU-5aAR52ZH9wjemaQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Figure 2</figcaption></figure><p id="ebfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意某些列系列的嵌套对象。当我们想利用Pandas执行数据操作时，这不是很方便。因此，我们导入<code class="fe lm ln lo lp b">json_normalize </code>来“展平”数据。TD Ameritrade还提供了按日期-时间降序排列的数据(从过去开始)，我们还将颠倒数据帧的顺序。现在我们有了这样的东西:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mc"><img src="../Images/1b72c733f9356c9d67f3a00373cc25a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6PnUJpVX_ePO6-whhlKCRA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Figure 3</figcaption></figure><h2 id="6a70" class="lu lv it bd md me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">流动资本和本金</h2><p id="ed23" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">现在数据框架已经准备好了，我们首先要计算的感兴趣的基本信息是流动资本和本金，这将是任何给定点的累积总和。我们定义资本和本金的方式是:</p><ul class=""><li id="914c" class="mz na it js b jt ju jx jy kb nb kf nc kj nd kn ne nf ng nh bi translated">资本——给定时刻的现金等价物总额</li><li id="bc5e" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated">本金——在给定时刻投入的现金等值总额</li></ul><p id="386d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">资本本质上将是本金+收益。对于TD Ameritrade，资本的变化记录在每笔交易的<code class="fe lm ln lo lp b">netAmount</code>字段中。但是，我们确实希望排除与他们的现金转移计划相关的交易。Pandas有一个内置的函数来计算我们可以利用的累计总和。</p><pre class="kp kq kr ks gt lq lp lr ls aw lt bi"><span id="6934" class="lu lv it lp b gy lw lx l ly lz">transactionsDf= transactionsDf.assign(capital = transactionsDf.apply(<br/>    lambda row : row['netAmount'] <br/>    if (str.upper(row['type']) != 'JOURNAL' and str.upper(row['description']) != 'CASH ALTERNATIVES PURCHASE') else 0, axis=1).cumsum())</span></pre><p id="e680" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们在DataFrame上使用<code class="fe lm ln lo lp b">apply</code>函数，遍历每一行(<code class="fe lm ln lo lp b">axis=1</code>)来过滤掉我们想要排除的提到的事务，对于那些事务返回<code class="fe lm ln lo lp b">0</code>，否则返回<code class="fe lm ln lo lp b">netAmount</code>。这导致数据帧中只有一列是净额。然后我们通过<code class="fe lm ln lo lp b">cumsum</code>函数运行它，并使用<code class="fe lm ln lo lp b">assign</code>函数将其作为<code class="fe lm ln lo lp b">capital</code>列添加到<code class="fe lm ln lo lp b">transactionDf</code>数据帧。</p><p id="c09c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至于本金，我们对存款和取款交易感兴趣。这些可以用<code class="fe lm ln lo lp b">ELECTRONIC_FUND</code>来标识为<code class="fe lm ln lo lp b">FI</code>和<code class="fe lm ln lo lp b">FO</code>的<code class="fe lm ln lo lp b">type</code>和<code class="fe lm ln lo lp b">transactionSubType</code>。存款很简单，因为它们直接增加了当前本金。然而，我们需要对提款小心一点。如果有收益，提取需要在应用于本金之前应用于收益。正因为如此，本金的计算对资本有依赖性。如果我们只是简单地添加所有内容，我们可能会得到不理想的结果，如这个简化的示例所示:</p><pre class="kp kq kr ks gt lq lp lr ls aw lt bi"><span id="fb46" class="lu lv it lp b gy lw lx l ly lz">    Type    Amount  Capital Principal<br/>0   D       10      10      10<br/>1   D       10      20      20<br/>2   W       -5      15      15<br/>3   D       10      25      25<br/>4   G       5       30      25<br/>5   G       5       35      25<br/>6   G       5       40      25<br/>7   L       -5      35      25<br/>8   W       -10     25      15   &lt;- should stays at 25<br/>9   G       10      35      15   &lt;- now wrong because of above<br/>10  W       -25     10      -10  &lt;- error escalades<br/>11  G       25      35      -10<br/>12  L       -30     5       -10</span></pre><p id="4863" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们必须注意警告，通过迭代每一行来计算本金。</p><pre class="kp kq kr ks gt lq lp lr ls aw lt bi"><span id="d486" class="lu lv it lp b gy lw lx l ly lz">#calculate the running principal<br/># for withdrawals, we only subtract from the principal only when capital will fall below principal<br/># this is because if capital is above principal, then the withdrawals would be taking out of the "gains"</span><span id="a6dc" class="lu lv it lp b gy ma lx l ly lz">transactionsDf['principal'] = np.nan<br/>currentPrincipal = 0</span><span id="2df3" class="lu lv it lp b gy ma lx l ly lz">for index, row in transactionsDf.iterrows():<br/>    if (row['type'] == 'ELECTRONIC_FUND'):<br/>        if (row['capital'] &lt;= currentPrincipal):<br/>            transactionsDf.loc[index, 'principal'] = row['capital']<br/>        else:<br/>            transactionsDf.loc[index, 'principal'] = currentPrincipal + row['netAmount']<br/>    else:<br/>        transactionsDf.loc[index, 'principal'] = currentPrincipal</span><span id="ee1f" class="lu lv it lp b gy ma lx l ly lz">    currentPrincipal = transactionsDf.loc[index, 'principal']</span></pre><p id="f17e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，为此我们使用<code class="fe lm ln lo lp b">loc</code>一次“分配”一行主体。最后，在笔记本中，我们可以再次使用<code class="fe lm ln lo lp b">loc</code>选择查看本金和资本:<code class="fe lm ln lo lp b">transsactionDf.loc[:0,[‘capital’, ‘principal’]]</code>。</p><p id="84e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至此，通过比较本金和资本，我们能够初步了解我们的业绩。本质上，资本和本金之间的差值就是我们实现的利润。在本系列的后面部分，我们将扩展计算每笔收盘交易的利润和损失的内容，并探索将这些数据分组以提供相关分析视图的技术。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="db06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ll" href="https://phandinhlan.medium.com/options-trading-data-analysis-part-2-visuals-36e659233f" rel="noopener">第2部分——视觉效果</a></p></div></div>    
</body>
</html>