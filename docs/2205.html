<html>
<head>
<title>SQL Views: What They Are and How to Make Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL视图:它们是什么以及如何创建它们</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/sql-views-what-they-are-and-how-to-make-62229b2f0fd7?source=collection_archive---------3-----------------------#2020-04-19">https://medium.datadriveninvestor.com/sql-views-what-they-are-and-how-to-make-62229b2f0fd7?source=collection_archive---------3-----------------------#2020-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/7da95da80f4fbd96fd83c570607fde32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*1iZZ4O2S52_p5YpvZbCntQ.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">“Views” - Drake album cover</figcaption></figure><h1 id="0286" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">动机</h1><p id="4624" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">考虑下面概述的物理模式(如果你不熟悉星型模式，请查看<a class="ae lu" href="https://medium.com/@marcosanchezayala/data-modeling-the-star-schema-c37e7652e206" rel="noopener">我的文章</a>！):</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/afb0e14b853782f1d420ebb8a81960c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*IGdP28VX3cXhjKD-I6mGWA.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk"><a class="ae lu" href="https://www.guru99.com/star-snowflake-data-warehousing.html" rel="noopener ugc nofollow" target="_blank">https://www.guru99.com/star-snowflake-data-warehousing.html</a></figcaption></figure><p id="4d18" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">如果我想知道每种产品在本年度的总收入，那么每当我想检查它时，我就必须运行这个查询(或类似的东西)。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="1851" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">如果SQL能记住这个查询就好了，因为它对我来说很重要。这就是观点的来源！</p><h1 id="c73d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是视图？</h1><p id="694d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">视图是一个非常有用的SQL工具，不幸的是，它与加拿大说唱歌手德雷克没有任何关系(尽管我很乐意在其他时间讨论他)。它们允许我们轻松地管理和查询来自基表的聚合信息。它们有两种类型:视图和物化视图，我将在本文中讨论这两种视图。</p><p id="eea3" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">在更细粒度的级别上，视图是从数据库中的表的存储查询中动态计算的虚拟表。对于“虚拟”表，我们的意思是视图实际上并不成为物理模式的一部分。定义视图的查询实际上是在每次<strong class="ky ir"/>视图被另一个查询引用时运行<strong class="ky ir">。然而，物化视图是一个例外。</strong></p><h1 id="2f4b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">为什么是视图而不是表？</h1><p id="5700" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您可能认为在数据库中创建一个包含所需聚合的新表是有意义的，但是您应该负责保持该表的同步。这可能涉及大量的代码和测试，甚至还会考虑到潜在的漏洞。</p><p id="c761" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">与表相比，视图具有以下优势:</p><ul class=""><li id="a3e8" class="mh mi iq ky b kz ma ld mb lh mj ll mk lp ml lt mm mn mo mp bi translated">视图会自动与用来创建它们的基础表同步。</li><li id="2f88" class="mh mi iq ky b kz mq ld mr lh ms ll mt lp mu lt mm mn mo mp bi translated">它们可以代表底层数据的子集，因此可以用来限制底层信息向某些用户公开的程度。</li><li id="4b7e" class="mh mi iq ky b kz mq ld mr lh ms ll mt lp mu lt mm mn mo mp bi translated">它们占用很少的存储空间，因为数据库只存储视图的定义，而不是其中所有数据的副本。</li><li id="6c27" class="mh mi iq ky b kz mq ld mr lh ms ll mt lp mu lt mm mn mo mp bi translated">它们非常容易制作。</li></ul><div class="mv mw gp gr mx my"><a href="https://www.datadriveninvestor.com/2020/02/19/five-data-science-and-machine-learning-trends-that-will-define-job-prospects-in-2020/" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd ir gy z fp nd fr fs ne fu fw ip bi translated">将定义2020年就业前景的五大数据科学和机器学习趋势|数据驱动…</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">数据科学和ML是2019年最受关注的趋势之一，毫无疑问，它们将继续发展…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm js my"/></div></div></a></div><h1 id="b16f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">如何创建视图</h1><p id="7d85" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">基本语法是:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="b778" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">我们基本上只是声明我们想要创建一个视图，给它一个名称，然后用一个典型的<code class="fe nn no np nq b">SELECT</code>语句跟随它。</p><p id="5eff" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">在本文开头的例子中，我们将创建这样的视图。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="cbfe" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">然后，我们可以使用一个简单的<code class="fe nn no np nq b">SELECT </code>语句来访问该视图中的数据。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="12e4" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">每次编写引用视图的查询时，数据库管理系统(DBMS)都会将其作为子查询执行。在上面的例子中，视图定义中的<code class="fe nn no np nq b">product_revenue</code>被替换为<code class="fe nn no np nq b">SELECT</code>查询。</p><p id="37d0" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">您还可以像使用任何<code class="fe nn no np nq b">SELECT</code>语句一样，在上述查询中添加其他条件。</p><h1 id="38bf" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">如何改变或删除视图</h1><p id="b951" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">改变一个视图只需要<code class="fe nn no np nq b"><strong class="ky ir">ALTER VIEW</strong> view_name (alter command)</code>。</p><p id="350f" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">删除一个视图就像<code class="fe nn no np nq b"><strong class="ky ir">DROP VIEW [IF EXISTS] </strong>view_name</code>一样简单。我们可以添加<code class="fe nn no np nq b">IF EXISTS</code>，因为试图删除一个不存在的视图会抛出一个错误。</p><h1 id="0c71" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">关于视图的附加注释</h1><p id="308c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">可以从其他视图创建视图。这使得第二范式以上的数据库规范化简单得多。</p><p id="55a9" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">视图中的行缺乏排序，就像其基表中的行一样。因此，<code class="fe nn no np nq b">ORDER BY</code>子句在<code class="fe nn no np nq b">CREATE VIEW</code>语句中是没有用的。事实上，SQL标准甚至不允许在<code class="fe nn no np nq b">CREATE VIEW</code>语句中使用<code class="fe nn no np nq b">ORDER BY</code>子句，就像在<code class="fe nn no np nq b">CREATE TABLE</code>语句中一样。</p><p id="5f34" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">视图可以是只读的，也可以是可更新的。其思想是，只有可更新的视图才允许数据库系统将视图模式反向映射到底层表的模式，从而允许进行<code class="fe nn no np nq b">INSERT</code>、<code class="fe nn no np nq b">UPDATE</code>和<code class="fe nn no np nq b">DELETE</code>操作。不同的DBMSs(例如Oracle、MySQL和PostgreSQL)有不同的视图实现。我强烈建议查阅适当的文档，以确保您所做的都是针对您的DBMS的。</p><p id="511f" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">我们还可以创建<strong class="ky ir">物化视图</strong>，这是预执行的非虚拟视图，通常用于数据仓库和商业智能应用程序。它们的工作方式与普通视图非常相似，但是它们的准确性取决于更新背后的触发机制的频率。同样，具体功能的实现取决于您的DBMS，所以请查阅您的文档！</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="fe62" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">在过去的几个月里，我与几位数据工程师交谈过，他们对视图和物化视图赞不绝口。它们显然一直都在被使用！我仍在寻找我的第一份数据工作，所以我自己还没有机会使用它们，但我想我至少应该尝试一下学习它们背后的理论。它们显然提供了普通桌子的许多优点，并且易于制作。我绝对计划在我的下一个项目中使用它们作为练习！</p><h1 id="3fcf" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">来源</h1><ul class=""><li id="1e4f" class="mh mi iq ky b kz la ld le lh ny ll nz lp oa lt mm mn mo mp bi translated"><a class="ae lu" href="https://www.postgresql.org/docs/12/sql-createview.html" rel="noopener ugc nofollow" target="_blank"> PostgreSQL文档</a></li><li id="a537" class="mh mi iq ky b kz mq ld mr lh ms ll mt lp mu lt mm mn mo mp bi translated"><a class="ae lu" href="https://en.wikipedia.org/wiki/View_(SQL)" rel="noopener ugc nofollow" target="_blank">观点(SQL) -维基百科</a></li><li id="3e25" class="mh mi iq ky b kz mq ld mr lh ms ll mt lp mu lt mm mn mo mp bi translated"><a class="ae lu" href="https://dba.stackexchange.com/questions/23280/why-not-use-a-table-instead-of-a-materialized-view" rel="noopener ugc nofollow" target="_blank">牛逼栈溢出答案</a></li></ul><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="ob mg l"/></div></figure></div></div>    
</body>
</html>