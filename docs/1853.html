<html>
<head>
<title>Understanding JavaScript Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript承诺</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/understanding-javascript-promises-87c4d3c349c2?source=collection_archive---------25-----------------------#2020-04-02">https://medium.datadriveninvestor.com/understanding-javascript-promises-87c4d3c349c2?source=collection_archive---------25-----------------------#2020-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/b78584452e2719d18836b512bf976e27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_OiTpHhVoPMb-IBMvjV9Gg.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@pankajpatel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Pankaj Patel</a> on <a class="ae jg" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="86e4" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">带示例..！！！</h2></div><p id="6bdc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> JavaScript Promise </strong>是一个特殊的JavaScript对象，它将“<strong class="la jk">生产代码</strong>和“<strong class="la jk">消费代码</strong>联系在一起。</p><p id="c213" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">承诺只能成功或失败一次。它不能成功或失败两次或更多次，也不能从成功切换到失败，反之亦然。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/ad81f4a65f97e5fa7c7b6da3c2f78449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*tkOU9flRtlXC2cA9.png"/></div></figure><p id="6851" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果<strong class="la jk">承诺</strong>已经成功或失败，并且如果我们后来添加了成功/失败回调，那么将基于输出调用正确的回调，即使事件发生得更早。</p><p id="4834" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JavaScript是单线程脚本语言。一切都是按顺序发生的，它是一行一行写出来的。但是，在<strong class="la jk">中，异步操作</strong>按照它们完成的顺序发生。</p><div class="is it gp gr iu lz"><a href="https://www.datadriveninvestor.com/2018/08/06/ai-forecast-disruption-then-productivity/" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd jk gy z fp me fr fs mf fu fw ji bi translated">艾预测:“颠覆，然后是生产力”|数据驱动的投资者</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">人们越来越担心，随着机器学习和互联网的普及，所有白领工作都将消失</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn ja lz"/></div></div></a></div><p id="9b79" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">事件</strong>非常适合于在同一个对象上可能发生多次的事情，如<strong class="la jk"> keyup </strong>、<strong class="la jk"> touchstart </strong>、<strong class="la jk"> mouseover </strong>等。对于那些事件，我们不必关心发生了什么，直到我们附加了一个侦听器。但是当涉及到成功/失败的异步行为时，<strong class="la jk">回调函数</strong>没有<strong class="la jk">承诺</strong>那么有用。</p><p id="f17e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">promise <strong class="la jk">构造函数</strong>接受一个参数:一个带有两个参数的<strong class="la jk">回调</strong>函数，称为<strong class="la jk"> resolve </strong>和<strong class="la jk"> reject </strong>。我们可以用<strong class="la jk">承诺</strong>作为两种不同的方法。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/1c3630c013adbd35fd31252a1b552979.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*73IF-gj1hMwEuWmIwPnBgA.png"/></div></figure><h1 id="dfa6" class="mp mq jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">承诺创造</h1><pre class="lv lw lx ly gt nh ni nj nk aw nl bi"><span id="8f3f" class="nm mq jj ni b gy nn no l np nq">const promiseObject = new Promise(function(resolve, reject) {<br/>  setTimeout(() =&gt; {<br/>    resolve('Promise Created....!!!');<br/>  }, 200);<br/>});</span></pre><p id="02ce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，在这里，我们创建了一个<strong class="la jk">JavaScript</strong><strong class="la jk">Promise</strong><strong class="la jk">对象</strong>，并向<strong class="la jk"> Promise </strong>构造函数传递了两个参数:<strong class="la jk"> resolve </strong>和<strong class="la jk"> reject。</strong></p><p id="c05f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在消费时，如果<strong class="la jk">承诺解决了</strong>，那么我们可以使用<strong class="la jk"> then() </strong>函数消费该值，如果承诺被拒绝，那么我们将获得<strong class="la jk"> catch() </strong>块中的错误值。</p><h1 id="0709" class="mp mq jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">承诺消费</h1><p id="07d6" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">所以，如果我们解析这个函数，那么我们会得到<strong class="la jk"> <em class="nw"> then() </em> </strong>块中的值。</p><pre class="lv lw lx ly gt nh ni nj nk aw nl bi"><span id="8a7e" class="nm mq jj ni b gy nn no l np nq">const promObject = new Promise(function(resolve, reject) {<br/>  setTimeout(() =&gt; {<br/>    resolve('Promise is created...!!!');<br/>  }, 200);<br/>});</span><span id="46f1" class="nm mq jj ni b gy nx no l np nq">promObject.then(value =&gt; {<br/>  console.log(value);<br/>});</span></pre><p id="bcbd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">承诺</strong>也被拒绝，在这种情况下，我们的代码如下所示。</p><pre class="lv lw lx ly gt nh ni nj nk aw nl bi"><span id="8aa0" class="nm mq jj ni b gy nn no l np nq"><em class="nw">// server.js</em></span><span id="726a" class="nm mq jj ni b gy nx no l np nq">const prom = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; {<br/>    reject('Promise is rejected...!!!');<br/>  }, 200);<br/>});</span><span id="1714" class="nm mq jj ni b gy nx no l np nq">prom.catch(error =&gt; {<br/>  console.log(error);<br/>});</span></pre><p id="2ebc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">执行者通常会启动一些异步工作，然后，一旦完成，要么调用<strong class="la jk"> resolve </strong>函数来解析一个承诺，要么如果出现错误，<strong class="la jk">拒绝</strong>它。</p><p id="6881" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果在executor函数中抛出错误，则意味着拒绝承诺。执行器的返回值被忽略。</p><h1 id="e14f" class="mp mq jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">JavaScript中的承诺状态</h1><p id="bb3a" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated"><strong class="la jk">承诺</strong>是一个价值的代理，当一个承诺被创建时，这个价值不一定是已知的。promise允许我们将处理程序与异步操作的最终成功或失败原因联系起来。</p><p id="f0ff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这使得异步方法像同步方法一样返回值:异步方法不是立即返回最终值，而是返回一个<strong class="la jk">承诺</strong>在未来某个时间提供值。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ny"><img src="../Images/bfb0f4d26b2881d198504491a1ba4aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Zse8k_XDcq97hh2z.png"/></div></div></figure><p id="3294" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">承诺</strong>处于以下状态之一:</p><ul class=""><li id="903b" class="nz oa jj la b lb lc le lf lh ob ll oc lp od lt oe of og oh bi translated"><strong class="la jk">未决</strong>:初始状态或未决状态，既不满足也不拒绝。</li><li id="5868" class="nz oa jj la b lb oi le oj lh ok ll ol lp om lt oe of og oh bi translated"><strong class="la jk">完成</strong>:表示操作成功完成。</li><li id="4d70" class="nz oa jj la b lb oi le oj lh ok ll ol lp om lt oe of og oh bi translated"><strong class="la jk">拒绝</strong>:表示操作失败。</li></ul><h1 id="cd00" class="mp mq jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">承诺方法</h1><p id="07f7" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated"><strong class="la jk"> JavaScript Promise </strong>有以下方法。</p><h2 id="98af" class="nm mq jj bd mr on oo dn mv op oq dp mz lh or os nb ll ot ou nd lp ov ow nf ox bi translated">Promise.all()</h2><p id="4bb7" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">它返回的承诺要么在iterable参数中的所有承诺都实现时实现，要么在iterable参数中的一个承诺拒绝承诺时立即拒绝。如果返回的承诺履行了，那么它将按照iterable中定义的顺序，用一个已履行承诺的值数组来履行。如果返回的承诺被拒绝，则拒绝的原因来自iterable中第一个拒绝的承诺。</p><h2 id="a1dc" class="nm mq jj bd mr on oo dn mv op oq dp mz lh or os nb ll ot ou nd lp ov ow nf ox bi translated">Promise.race(可重复)</h2><p id="ffbd" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">它返回满足或拒绝的承诺。iterable中的一个承诺满足或拒绝，并带有该承诺的值或原因。</p><h2 id="eb7a" class="nm mq jj bd mr on oo dn mv op oq dp mz lh or os nb ll ot ou nd lp ov ow nf ox bi translated">承诺.拒绝(原因)</h2><p id="c2d8" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">返回由于给定原因而被拒绝的承诺对象。</p><h2 id="183d" class="nm mq jj bd mr on oo dn mv op oq dp mz lh or os nb ll ot ou nd lp ov ow nf ox bi translated">承诺.解决(价值)</h2><p id="e7b4" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">它返回用给定值解析的Promise对象。</p><h1 id="9b6a" class="mp mq jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">异步等待承诺示例</h1><p id="63a0" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">让我们举一个例子，看看如何在<strong class="la jk"> <em class="nw">异步等待</em> </strong>中使用Promise。</p><pre class="lv lw lx ly gt nh ni nj nk aw nl bi"><span id="7fc0" class="nm mq jj ni b gy nn no l np nq">function calculateSquare(length) {<br/>  return <strong class="ni jk">new Promise</strong>(resolve =&gt; {<br/>    setTimeout(() =&gt; {<br/>      resolve(Math.pow(length, 2));<br/>    }, 2000);<br/>  });<br/>}</span><span id="047d" class="nm mq jj ni b gy nx no l np nq">async function getSquareArea(length)<br/>{<br/>  const value = await calculateSquare(length);<br/>  console.log(value);<br/>}</span><span id="8595" class="nm mq jj ni b gy nx no l np nq">getSquareArea(2); <em class="nw">// 4</em></span></pre><p id="a4dc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，在输出中，我们会得到4。首先，它将调用<strong class="la jk">异步功能</strong>层，然后等待承诺被履行或拒绝。之后它会给我们输出。</p><p id="5731" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们要用<strong class="la jk"> <em class="nw"> setTimeout </em> </strong>函数来造成手动延迟执行来模拟AJAX请求。如果我们拒绝，那么我们将得到<strong class="la jk">错误对象</strong>。</p><p id="d0ff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">承诺中的错误处理非常容易，因为不管是履行还是拒绝，它都会给出一次。所以它是回调函数的最佳替代品，在回调函数中会产生回调地狱。</p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="oy oz l"/></div></figure></div></div>    
</body>
</html>