<html>
<head>
<title>What to ask an IOS developer in an interview?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面试问一个IOS开发者什么？</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/what-to-ask-an-ios-developer-in-an-interview-d6edb0f5ae96?source=collection_archive---------7-----------------------#2020-07-16">https://medium.datadriveninvestor.com/what-to-ask-an-ios-developer-in-an-interview-d6edb0f5ae96?source=collection_archive---------7-----------------------#2020-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c6db7633b61b2a6a27b84c97c377fa75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gRmUD4C3g-YMEN1Fq1werg.jpeg"/></div></div></figure><p id="56f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Swift编程语言只有五年的历史，但它已经成为iOS的主要开发语言。发展到5.2版本，Swift已经成为一种复杂而强大的语言，同时满足面向对象和函数范式。随着每个新版本的发布，它会添加更多的功能。</p><p id="3393" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是候选人到底有多了解斯威夫特呢？在这篇文章中，你会找到一些快速面试的问题样本。</p><p id="b882" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题分为两组:</p><ul class=""><li id="c20f" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">初学者:适合对语言真正感兴趣的人。这位候选人已经读过几本关于这种语言的书，并且已经开始尝试使用这种语言。</li><li id="694c" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">高级:适合最高级的开发人员，他们喜欢进入语法丛林并使用高级技术。</li></ul><h1 id="4086" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">给初学者的问题。</h1><h2 id="8f96" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kj mo mp lz kn mq mr md kr ms mt mh mu bi translated">问题1:什么是可选的，它解决什么问题？</h2><p id="78e3" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">Optional允许任何类型的变量呈现“无值”情况。在Objective-C中，“无值”仅在使用特殊nil值的引用类型中可用。值类型，如int或float，没有这种能力。</p><p id="311c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Swift将“无价值”的概念扩展到了价值类型。可选变量可以包含一个值或零，表示没有值。</p><div class="na nb gp gr nc nd"><a href="https://www.datadriveninvestor.com/2020/07/13/2020-development-choices-for-multi-platform-saas-application/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">多平台SaaS应用的2020年发展选择|数据驱动的投资者</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">我目前正在为公司做一个新项目。该项目包括一个移动应用程序，由一个…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr jw nd"/></div></div></a></div><h2 id="5091" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kj mo mp lz kn mq mr md kr ms mt mh mu bi translated">问题2:简单列举结构和类的主要区别。</h2><p id="acab" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">类支持继承，但结构不支持。</p><p id="e35d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">类是引用类型，结构是值类型。</p><h2 id="114f" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kj mo mp lz kn mq mr md kr ms mt mh mu bi translated">问题3:什么是泛型，它们有什么用？</h2><p id="5c97" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">在Swift中，您可以在类、结构和枚举中使用泛型。</p><p id="365a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">泛型修复了代码重复。如果您有一个接受一种类型参数的方法，有时您必须复制代码来处理另一种类型的参数。</p><p id="235e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，在这段代码中，第二个函数是第一个函数的“克隆”，只是它有字符串参数，而不是整数。</p><pre class="ns nt nu nv gt nw nx ny nz aw oa bi"><span id="dd48" class="mj lm iq nx b gy ob oc l od oe">func areIntEqual (_ x: Int, _ y: Int) -&gt; Bool {<br/>return x == y<br/>}<br/>func areStringsEqual (_ x: String, _ y: String) -&gt; Bool {<br/>return x == y<br/>}<br/>areStringsEqual ("ray", "ray") // true<br/>areIntEqual (1, 1) // true</span></pre><p id="bc46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用泛型，您可以将两个函数合二为一，同时确保类型安全:</p><pre class="ns nt nu nv gt nw nx ny nz aw oa bi"><span id="da0d" class="mj lm iq nx b gy ob oc l od oe">func areTheyEqual &lt; T: Equatable&gt; (_ x: T, _ y: T) -&gt; Boo<br/>return x == y<br/>}<br/>areStringsEqual ("ray", "ray")<br/>areIntEqual (1, 1)</span></pre><p id="e146" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为您正在测试相等性，所以您将类型限制为那些符合相等协议的类型。这段代码提供了期望的结果，并防止传递错误类型的参数。</p><h2 id="0222" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kj mo mp lz kn mq mr md kr ms mt mh mu bi translated">问题4:在某些情况下，你无法避免隐式解包选项。什么时候，为什么？</h2><p id="d137" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">使用隐式展开选项的最常见原因是:</p><ul class=""><li id="097d" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">当无法初始化创建时不为零的属性时。一个典型的例子是接口生成器中的出口，它总是在它的所有者之后被初始化。在这种特殊情况下，如果在Interface Builder中一切都配置正确，那么在使用插座之前，可以保证它是非零的。</li><li id="f07d" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">当类的两个实例相互引用并且需要对另一个实例的非零引用时，解决强引用循环的问题。在这种情况下，您在一端将链接标记为无主，在另一端使用隐式可选扩展。</li></ul><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/9616a18febaa61acafeacc2d77dcea8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C9yIn2HaP4ls8tjFFLfQbw.jpeg"/></div></div></figure><h1 id="082f" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">问题5:如何部署可选的？根据安全性对它们进行评级</h1><h2 id="6447" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kj mo mp lz kn mq mr md kr ms mt mh mu bi translated">Fvar x:字符串？= "测试"</h2><p id="076b" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">使用隐式展开选项的最常见原因是:</p><ul class=""><li id="23ce" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">强制解包是不安全的。<strong class="ka ir">设a: String = x！</strong></li><li id="b5ef" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">声明变量时隐式部署是不安全的。<strong class="ka ir"> var a = x！</strong></li><li id="21a4" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">可选绑定是安全的。<strong class="ka ir">如果让a = x { </strong> <br/> <strong class="ka ir">打印(" x被成功解开并且是= \ (a)") </strong> <br/> <strong class="ka ir"> } </strong></li><li id="6b36" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">可选链接是安全的。<strong class="ka ir">设a = x？。计数</strong></li><li id="c525" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">零合并运算符是安全的。<strong class="ka ir">设a = x？？" "</strong></li><li id="6242" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">警卫声明是安全的。<strong class="ka ir">守护让a = x else { </strong> <br/> <strong class="ka ir">返回</strong> <br/> <strong class="ka ir"> } </strong></li><li id="4eb4" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">可选模式—安全。<strong class="ka ir">如果格让一？= x { </strong> <br/> <strong class="ka ir">打印(一)</strong> <br/> <strong class="ka ir"> } </strong></li></ul><h2 id="092a" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kj mo mp lz kn mq mr md kr ms mt mh mu bi translated"><strong class="ak">问题6:可以使用扩展将存储属性添加到类型中吗？怎么做或者为什么不做？</strong></h2><p id="8fdc" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">不，这是不可能的。我们可以使用扩展向现有类型添加新的行为，但是我们不能改变类型本身或它的接口。为了存储新存储的属性，我们需要额外的内存，而扩展不能做到这一点。</p><h2 id="c076" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kj mo mp lz kn mq mr md kr ms mt mh mu bi translated"><strong class="ak">问题Swift中的协议是什么？</strong></h2><p id="6199" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">协议是一种定义方法、属性等概要的类型。一个类、结构或枚举可以采用一个协议来实现所有这些。协议本身并不实现功能，而是定义功能。</p><h2 id="758e" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kj mo mp lz kn mq mr md kr ms mt mh mu bi translated"><strong class="ak">问题8:考虑以下代码:</strong></h2><pre class="ns nt nu nv gt nw nx ny nz aw oa bi"><span id="9ea4" class="mj lm iq nx b gy ob oc l od oe">struct Tutorial {<br/>var difficulty: Int = 1<br/>}<br/>var tutorial1 = Tutorial ()<br/>var tutorial2 = tutorial1tutorial2.difficulty = 2</span></pre><p id="10c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">tutorial 1 . difference和tutorial 2 . difference的值是多少？如果教程是一门课会有什么不同吗？为什么？</strong></p><p id="d9cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">辅导1 .难度为1，辅导2 .难度为2。</p><p id="ad64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Swift中，结构是值类型。它们是复制的，而不是引用的。以下代码行复制tutorial1并将其赋给tutorial2:</p><p id="1386" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">var tutorial2 = tutorial1</p><p id="4abf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">教程2中的更改不会影响教程1。</p><p id="e77c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果Tutorial是一个类，tutorial1 .难度和tutorial2 .难度等于2。Swift中的类是引用类型。当您更改tutorial1属性时，您将看到tutorial2的相同变化，反之亦然。</p><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/054d03fb80a476cbd90e69db38e97627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y_-qVKnTSqFy1Nx7"/></div></div></figure><h1 id="3a29" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">高级问题。</h1><p id="303d" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">iOS面试并没有就此结束。问题可能会更复杂。让我们进入高级阶段。</p><h2 id="3ea4" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kj mo mp lz kn mq mr md kr ms mt mh mu bi translated">问题Swift是OOP语言还是函数式编程语言？</h2><p id="ee4a" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">Swift是一种支持这两种类型的混合语言。它实现了OOP的三个基本原则:封装、继承和多态。</p><p id="d7d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">至于Swift作为一种函数式语言，有不同但等价的定义方式。</p><p id="b640" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">维基百科上最常见的一条是这样的:“……一种将计算视为数学函数估计的编程范式，避免了改变状态和可变数据。”</p><p id="a04c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不能说Swift是一种完整的函数式语言，但基本要素是存在的。</p><h2 id="5313" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kj mo mp lz kn mq mr md kr ms mt mh mu bi translated">问题2:在Objective-C中，一个常数可以这样声明:const int number = 0；<strong class="ak">这是Swift的一个选项:let number = 0 </strong></h2><p id="fd5c" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated"><strong class="ka ir">这两者有什么区别吗？如果是这样，你能解释它们有什么不同吗？</strong></p><p id="af58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时iOS面试会包含类似这样的棘手问题。常量是初始化为编译时值的变量，或者是编译时允许的表达式。</p><p id="2516" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过let创建的常量在编译时不一定要取值，但还是有一个条件:一个值只能确定一次。</p><h2 id="f134" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kj mo mp lz kn mq mr md kr ms mt mh mu bi translated">问题3:可以使用扩展添加保存的属性吗？解释为什么/为什么不。</h2><p id="8f34" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">不，这是不可能的。扩展可用于向现有类型添加新行为，但不能更改类型本身或其接口。如果添加已保存的属性，则需要额外的内存来存储新值。该扩展不是为这类任务设计的。</p><h2 id="0600" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kj mo mp lz kn mq mr md kr ms mt mh mu bi translated">问题4:尾随表达式是元素(值)还是引用类型？</h2><p id="7192" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">尾随表达式是引用类型。</p><h2 id="a7b4" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kj mo mp lz kn mq mr md kr ms mt mh mu bi translated">问题5:描述一下在Swift中可以获得循环引用的情况？</h2><p id="1ca5" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">当两个实例包含对彼此的强引用时，循环引用是可能的，这会导致内存泄漏，因为这两个实例都不会被释放。原因是只要存在对实例的强引用，就不能释放该实例。</p><p id="6549" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以通过将其中一个强链接替换为弱链接或无主链接来解决问题。</p><h2 id="82bb" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kj mo mp lz kn mq mr md kr ms mt mh mu bi translated">问题6: Swift允许你创建递归枚举。下面是这样一个枚举的例子，它包含一个具有两个关联类型的节点变量，T和<br/>List:enum List&lt;T&gt;{<br/>case Node(T，List &lt; T &gt; ) <br/> }会出现编译错误。我们错过了什么？</h2><p id="2874" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">我们忘记了indirect关键字，它允许类似的递归枚举选项:</p><pre class="ns nt nu nv gt nw nx ny nz aw oa bi"><span id="5c3e" class="mj lm iq nx b gy ob oc l od oe">enum List &lt;T&gt; {<br/>indirect case node (T, List )<br/>}</span></pre><h2 id="0282" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kj mo mp lz kn mq mr md kr ms mt mh mu bi translated">问题7:解释核心数据。</h2><p id="3d93" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">核心数据是苹果为macOS和iOS应用提供的最强大的框架之一。核心数据用于处理我们的应用程序中的模型层对象。我们可以将核心数据视为一个框架，在iOS应用程序中过滤、修改、保存和跟踪数据。核心数据不是关系数据库。</p><p id="b80c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用核心数据，我们可以轻松地将应用程序中的对象映射到数据库中的表记录，而无需了解任何SQL。核心数据是MVC结构中的M。</p><h2 id="6d15" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kj mo mp lz kn mq mr md kr ms mt mh mu bi translated">问题8:在swift中传递数据有哪些不同的方式？</h2><p id="c0e9" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">在swift中传递数据有几种方式，如KVO、委托、NSNotification &amp; Callbacks、Target-Action等。</p><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/59d1768b26981c45c56298532c690cf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uFox_BfFiKh2mFiyhnWDHw.jpeg"/></div></div></figure><h1 id="b41c" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="e490" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">我们希望此处提供的答案确实有助于理解iOS swift基础和高级主题。这些Swift开发人员面试问题将帮助您检查初级和资深专业人员的知识水平。</p><p id="afca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在你的天才博客上找到更多有趣的文章。</p><p id="4d73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">访问专家视图— </strong> <a class="ae kw" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>