<html>
<head>
<title>Let’s talk about Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们来谈谈Python</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/lets-talk-about-python-d280bc7416ba?source=collection_archive---------36-----------------------#2020-12-29">https://medium.datadriveninvestor.com/lets-talk-about-python-d280bc7416ba?source=collection_archive---------36-----------------------#2020-12-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/6bc7bd784b9248adb846fa07c0a853c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*X7KYutrU--M3LS4Vr1lrig.png"/></div></figure><p id="a540" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最近我发了很多关于自动化、AWS、机器学习、网络等的帖子。今天，我将回到基础来讨论一些核心的python话题。</p><p id="dffe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这篇博客中，我将讨论</p><ul class=""><li id="7da4" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">类别和对象</li><li id="bbb7" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">列出理解</li><li id="7a79" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">迭代器和生成器</li><li id="a1e8" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">功能和模块</li><li id="0497" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">装修工</li></ul><p id="7988" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有些主题是所有语言共有的，如类和函数，有些是python独有的，如列表理解。因此，这篇博客的先决条件是熟悉python概念。</p><p id="8219" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我想从功能和模块开始</p><h1 id="e9fb" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">功能和模块</h1><p id="4ff2" class="pw-post-body-paragraph ju jv iq jw b jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr ij bi translated">假设您有一个程序，它接受用户的输入并打印一条简单的hello消息。</p><p id="1721" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为此，我们只需创建一个打印语句，任务就完成了。然而，这可能不是最好的方法。假设我们有一个100人的列表，而不是一个单独的输入。为100个不同的用户写一个hello语句是没有意义的。即使我们这样做，也是非常多余的，容易出错，也是一项累人的工作。为了解决这个问题，我们使用函数。</p><p id="8471" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个函数就像一个可以反复使用的模板代码。根据使用情况，函数可以接受多个参数。</p><p id="ae22" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个简单的函数看起来像下面给出的例子</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/01d12421d16b3f21f57d9950d8e21931.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*J5Cp00dJZNH5B05PcBA5Kw.png"/></div></figure><p id="c0b6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以我们要做的就是在我们想用的时候调用这个函数。我们只需要定义一次。</p><p id="3cc6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我们不想打印值，我们可以返回它。<strong class="jw ir">返回允许我们将函数的结果保存在一个局部变量中，该变量可用于进一步的任务。</strong></p><h2 id="4e48" class="mo lh iq bd li mp mq dn lm mr ms dp lq kf mt mu lu kj mv mw ly kn mx my mc mz bi translated">那么模块有什么用呢？</h2><p id="634b" class="pw-post-body-paragraph ju jv iq jw b jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr ij bi translated">每当我们有一个大项目要做时，我们都会创建许多函数。所以管理这些功能也变得非常困难。<strong class="jw ir">这样我们就可以将不同类型的函数归入不同的文件</strong>。这些包含python变量、函数、定义的类的文件被称为<strong class="jw ir">模块</strong>。这些模块可以在我们的代码中导入并使用。</p><p id="65ec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以模块使得函数的管理更加容易。</p><h1 id="4312" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">迭代器和生成器</h1><p id="eb7f" class="pw-post-body-paragraph ju jv iq jw b jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr ij bi translated">迭代器是所有语言都有的概念。</p><p id="4fea" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以在理解生成器之前，让我们试着理解迭代器是什么意思。</p><p id="5095" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在python中，任何在定义中定义了next方法的对象都被称为迭代器。</p><h2 id="f761" class="mo lh iq bd li mp mq dn lm mr ms dp lq kf mt mu lu kj mv mw ly kn mx my mc mz bi translated">那么它实际上意味着什么呢？</h2><p id="82d0" class="pw-post-body-paragraph ju jv iq jw b jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr ij bi translated">字符串、列表、数组都是可迭代的。这意味着它们可以被迭代。</p><p id="d25f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以知道迭代器和iterable之间的区别可能会令人困惑。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/6b12952d84c8570341287a9f19921f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*YsE-7PfmX_HaWtDcbcZEmg.png"/></div></figure><p id="582e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以这个例子说明了一切。</p><p id="5cec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最初a是一个字符串。字符串是可迭代的，因为它有一个内部定义的__iter__函数。</p><p id="2b0c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是对它调用next会给出一个错误，说明string不是迭代器。</p><p id="f4a5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后当我们调用“a”上的iter时，我们可以看到它变成了一个字符串迭代器，我们可以很容易地对它调用next。</p><blockquote class="nb nc nd"><p id="e718" class="ju jv ne jw b jx jy jz ka kb kc kd ke nf kg kh ki ng kk kl km nh ko kp kq kr ij bi translated">iterable定义了__iter__函数，迭代器定义了__next__</p></blockquote><h2 id="10f0" class="mo lh iq bd li mp mq dn lm mr ms dp lq kf mt mu lu kj mv mw ly kn mx my mc mz bi translated">发电机:</h2><p id="e71e" class="pw-post-body-paragraph ju jv iq jw b jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr ij bi translated">假设您的任务是对前100万个数字执行某些操作。但是由于资源限制，您不希望在RAM中保存这么大的列表。为此，我们可以使用生成器的概念。</p><p id="86ee" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">生成器是将迭代器返回到可迭代对象的函数。然而，生成器函数的重要性在于它们不会耗尽内存。</p><h2 id="2479" class="mo lh iq bd li mp mq dn lm mr ms dp lq kf mt mu lu kj mv mw ly kn mx my mc mz bi translated">那么他们是如何实现的呢？</h2><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/9161feccb1f5e4bb42a386fa9a2589d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*I8blybT0gXDXkcphnrzXPw.png"/></div></figure><p id="49da" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，我们使用yield关键字来代替return。</p><p id="5fb6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这种情况下，当我们调用next时，生成器函数调用该值的函数。这意味着列表没有存储在存储器中。这节省了很多空间。</p><p id="8e1d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，这里要知道的一点是，当使用生成器时，我们只能迭代一次。</p><h1 id="4bc3" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">列表理解</h1><p id="8d06" class="pw-post-body-paragraph ju jv iq jw b jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr ij bi translated">Python是一种非常用户友好的语言，代码的可读性是它的一个重要方面。</p><p id="1ba1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在很多情况下，我们必须迭代一个iterable并执行某些任务。有时候这些是简单的任务，比如增加列表中数字的值或者检查某个条件。所以为这个创建一个for循环是<strong class="jw ir">不是一个非常pythonic化的方式</strong>。</p><p id="37ef" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为此，我们有列表理解，允许我们迭代一个iterable并返回一个列表。列表理解在后端使用了一个循环，但是允许我们在一行中执行它。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/cfa07aef8058c0ec6d40d509a8e1000e.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*K5vd59EilhO03QJxWz1qdg.png"/></div></div></figure><p id="b8d8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这里你可以看到，对于<strong class="jw ir">列表a </strong>，我使用for循环给所有元素加1，对于<strong class="jw ir">列表b </strong>中的类似任务，我使用列表理解。显然，列表的理解更加简洁，可读性更强。</p><p id="ab72" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以列表理解的典型语法是这样的:</p><blockquote class="nb nc nd"><p id="45cc" class="ju jv ne jw b jx jy jz ka kb kc kd ke nf kg kh ki ng kk kl km nh ko kp kq kr ij bi translated"><operation>为<iterable>中的<iterator/></iterable></operation></p></blockquote><div class="no np gp gr nq nr"><a href="https://www.datadriveninvestor.com/2020/12/07/name-matching-techniques-with-python/" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">使用Python |数据驱动投资者的名称匹配技术</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">我们确实面临很多情况，我们必须匹配一个有很多变体的单词。这可能是因为错别字…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of js nr"/></div></div></a></div><h1 id="f874" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">装饰者和描述符</h1><p id="5aed" class="pw-post-body-paragraph ju jv iq jw b jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr ij bi translated">让我们考虑另一种情况。您有一个像我们之前定义的那样打印hello用户的函数。但是现在我们有一个场景，我们想添加一些欢迎词。为此，我们有两个选择</p><ul class=""><li id="a6bb" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">根据所需用途创建新功能。</li><li id="1141" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">编辑当前功能</li></ul><p id="79ef" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第一种选择的问题是，它会增加代码的大小，并且使管理变得困难。另一方面，编辑当前功能会使旧功能消失。</p><p id="d264" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以在这个场景中，我们可以使用装饰者。装饰器可以理解为在不改变代码结构的情况下向现有函数添加的功能。</p><p id="be4e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在让我们在实践中看到这一点。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/930d1e23531e5fb5b9f2dc82efc8d56d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*904_QPw8ECOz6P4u9MD81Q.png"/></div></figure><p id="3e59" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里我们创建了一个函数，函数作为参数。在这里我们创建了一个嵌套函数。所以这个嵌套函数实际上在传递的函数之上增加了功能。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/ac1ad3e5b5ffc8e12f1c14a143c6cdaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*gKO4rqrw93rvIxuFFNjS1Q.png"/></div></figure><p id="a75c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以要传递一个函数作为装饰，我们使用@符号。所以一个普通的myfunc()只有一个print语句。</p><p id="d0ad" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们看看当我们调用它时会发生什么。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/d5f221b62b37465efa15569eb791d933.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*Plqig0dvizdLf16A8RBouA.png"/></div></figure><p id="6e1d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以在内部调用了mydecorator函数。</p><p id="2a8d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是python中装饰器的用途和功能。</p><h1 id="07a1" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">类别和对象</h1><p id="d903" class="pw-post-body-paragraph ju jv iq jw b jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr ij bi translated">类和对象是面向对象编程的构造块。</p><p id="8f6f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Python是一种“面向对象的编程语言”这意味着几乎所有的代码都是使用一种叫做类的特殊结构来实现的。程序员使用类把相关的东西放在一起。</p><p id="eb43" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">类是可用于创建对象的代码模板。一个类中可以有多个函数，这些函数被称为方法。</p><blockquote class="nb nc nd"><p id="d36e" class="ju jv ne jw b jx jy jz ka kb kc kd ke nf kg kh ki ng kk kl km nh ko kp kq kr ij bi translated">方法是类的函数</p></blockquote><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oj"><img src="../Images/90a7918d98c6ee373263743d580032da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2D23sHRflJJ6g_w2mqhj-A.png"/></div></div></figure><p id="8469" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是一个关于什么是阶级的简单例子。每当创建一个对象时，总是调用__init__方法。这被称为构造函数。</p><p id="7579" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以在一个类中有多个方法。</p><p id="4bf3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">需要注意的一点是，我们不能调用类。相反，我们必须调用名为object的类的实例。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/6988a64e486e53fd4674168f9d7a8523.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*cjj_wmdbAHuRI_D7tQ89Nw.png"/></div></figure><p id="0fbf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以一旦我们创建了一个类的对象，我们就可以访问它的方法和变量。需要注意的一点是，say_my_name()方法没有参数，但是它能够打印名称。</p><p id="8a65" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这意味着类变量在类中有作用域，方法可以毫无问题地访问它们。</p><h1 id="232e" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><p id="f366" class="pw-post-body-paragraph ju jv iq jw b jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr ij bi translated">我在今天的文章中触及了从函数到类的各种概念。Python是一种功能丰富的语言。它在网上有一个非常活跃的社区，由于它是开源的，许多开发者在不断增加新的功能。所以这种语言的浩瀚一开始可能会让人不知所措。然而，一旦你掌握了窍门，事情就变得容易多了。</p><p id="8b56" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">谢谢:)</p><p id="e8f9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">进入专家视角— </strong> <a class="ae ol" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>