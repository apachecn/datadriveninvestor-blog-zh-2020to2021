<html>
<head>
<title>Comparing Bubble, Selection, and Insertion Sort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较冒泡、选择和插入排序</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/comparing-bubble-selection-and-insertion-sort-11012f7736ee?source=collection_archive---------1-----------------------#2020-03-04">https://medium.datadriveninvestor.com/comparing-bubble-selection-and-insertion-sort-11012f7736ee?source=collection_archive---------1-----------------------#2020-03-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cdb250457abc12254c762c905446bdc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NDEsy-NP4KPFclIW00ufZQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jdent?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jason Dent</a> on <a class="ae kc" href="https://unsplash.com/s/photos/compare?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="04e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想比较三种基本的排序算法，冒泡排序、选择排序和插入排序。它们是基本的排序算法，但在数据集较小时更胜一筹。</p><h1 id="d653" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">冒泡排序</h1><p id="48d4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Bobble sort，有时也称为sinking sort，反复遍历列表，比较相邻的元素，如果它们的顺序不对，就交换它们。重复遍历列表，直到列表被排序。该算法是一种比较排序算法，因较小或较大的元素“冒泡”到列表顶部而得名。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/5139399228be7540db5a16c8780d90e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2_wPYGuPbFZRFCtjUV7-8w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">bubble sort</figcaption></figure><h1 id="84c0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">插入排序</h1><p id="0f17" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">插入排序一次构建一个最终排序的数组。它进行迭代，每次重复消耗一个输入元素，并生成一个排序后的输出列表。在每次迭代中，插入排序从输入数据中删除一个元素，找到它在排序列表中的位置，并将其插入到那里。它重复进行，直到没有输入元素。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/8a695571dff08312c02a61a98953773b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*KKKMte8l3ZT7Cyew-BzP5A.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Insertion Sort</figcaption></figure><h1 id="d72b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">选择排序</h1><p id="c56a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">选择排序是一种就地比较排序算法。该算法将输入列表分为两部分:在列表左侧从左到右构建的已排序项目子列表，以及占据列表其余部分的剩余未排序项目子列表。</p><div class="mk ml gp gr mm mn"><a href="https://www.datadriveninvestor.com/2019/03/22/the-seductive-business-logic-of-algorithms/" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd ir gy z fp ms fr fs mt fu fw ip bi translated">算法诱人的商业逻辑|数据驱动的投资者</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">某些机器行为总是让我感到惊讶。我对他们从自己的成就中学习的能力感到惊讶…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb jw mn"/></div></div></a></div><p id="b481" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该算法通过找到未排序子列表中的最小元素，将其与最左边的未排序元素交换，并将子列表边界向右移动一个元素来进行。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/b1a11c3dadf35391d9b4f1449cf448b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mheUvfO_0QZECXRhasVSrQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Selection Sort</figcaption></figure><p id="b5dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我会告诉你它们都有二次的平均时间复杂度。</p><p id="a094" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是他们的大O对比。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/e2256ed7c64dc6ad09de30c72845f147.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cX3i6vBt6btdcmLR58Vgzg.png"/></div></div></figure><p id="4642" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在最好的情况下，它们的时间复杂度有一个不同。在几乎排序的数据中，冒泡排序和插入排序需要很少的交换。然而，选择排序需要相同数量的搜索过程，即使是在几乎排序的数据中。使用这个链接:【https://www.toptal.com/developers/sorting-algorithms】的，你可以看到他们每个人表演的动画版本。如果您需要对数据进行连续排序，插入排序非常有用。它只需要一条路径。另一方面，如果我们使用插入排序，我们将重新排序整个事情。它无法立即确定具体需要去哪里。</p><p id="9a40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，<strong class="kf ir">的空间复杂度</strong>，它们都一样。这是因为这些算法并没有占用太多的空间。一切都发生在一个地方，我们实际上并没有创建新的阵列。我们不是为每个元素创建一个变量。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div></div>    
</body>
</html>