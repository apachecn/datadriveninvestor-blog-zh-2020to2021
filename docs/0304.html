<html>
<head>
<title>A Comparison of Different Methods of Changed Data Detection in SQL Server Integration Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL Server Integration Services中不同更改数据检测方法的比较</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/a-comparison-of-different-methods-of-changed-data-detection-in-sql-server-integration-services-ec606d119311?source=collection_archive---------0-----------------------#2020-01-23">https://medium.datadriveninvestor.com/a-comparison-of-different-methods-of-changed-data-detection-in-sql-server-integration-services-ec606d119311?source=collection_archive---------0-----------------------#2020-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/a428af954063a58a6c7a0f46312df0cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ELSWoopLucrmWG0tbg0Q2Q.png"/></div></div></figure><div class=""/><h1 id="3fbd" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">介绍</h1><p id="a0b4" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在我之前的帖子中:</p><blockquote class="lx ly lz"><p id="22a1" class="kz la ma lb b lc mb le lf lg mc li lj md me lm ln mf mg lq lr mh mi lu lv lw im bi translated"><a class="ae mj" href="https://medium.com/@qiuyujx/manually-implementing-change-data-capture-cdc-on-non-cdc-enabled-tables-using-ssis-b75edb12bae2" rel="noopener"> <strong class="lb jf">使用SSIS </strong> </a>在未启用变更数据捕获(CDC)的表上手动实施CDC</p></blockquote><p id="23d0" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">我介绍了一种手动检测表上数据变化的方法。在与我的同事进行了一些讨论后，我们提出了更多的方法。在本文中，将列出这些不同的方法，并评估它们在SSIS(SQL Server Integration Services)中的性能。</p><p id="9330" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">开始之前，我们先定义一下问题。</p><p id="f9d2" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">Microsoft SQL Server具有CDC功能，可以在特定的表上启用该功能，以便可以检测到表上的每个更改(插入、更新和删除),并将其记录在一个单独的系统表中，这样我们就可以将它用作“CDC源”,以便非常轻松地执行增量加载。这个特性非常有用，尤其是在为数据仓库ETL过程构建数据管道时，因为常规ETL只需要处理源表和目标表之间的差异。</p><p id="0880" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">但是，在某些情况下，我们没有足够的权限来启用CDC功能。这在非IT行业的公司中并不少见，这些公司使用一些第三方软件和软件包中的SQL Server。此外，有时出于安全原因，不应该授予启用CDC功能的权限。</p><p id="a4f9" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">出于上述原因，我们需要手动检测自ETL过程的最后一次运行以来更新了什么。此外，根据不同的需求，我们可能不需要检测删除，因为有些源表永远不会删除条目，比如事务表。因此，我将在两个不同的场景中评估这三种方法:</p><ul class=""><li id="edc6" class="mk ml je lb b lc mb lg mc lk mm lo mn ls mo lw mp mq mr ms bi translated">检测插入、更新和删除</li><li id="9de1" class="mk ml je lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">仅检测插入和更新</li></ul><h1 id="42a3" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">检测插入、更新和删除</h1><p id="afaf" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">第一种方法是我在上一篇文章中提出的，它纯粹利用SSIS内置转换组件来执行源表和目标表之间的完全外部合并连接。</p><h2 id="129c" class="my kc je bd kd mz na dn kh nb nc dp kl lk nd ne kp lo nf ng kt ls nh ni kx nj bi translated">完全使用SSIS内置转换</h2><figure class="nl nm nn no gt iv gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/83ef0b1083757d8e45b5884b34c4e819.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/0*rVGqh4MhSP47hmAk.png"/></div></figure><p id="af17" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">在此方法中，源表和目标表都将被送入SSIS排序转换，以便使用主键字段对整个表进行排序。然后，这两个排序的数据集可以在它们的主键上合并连接。这里，排序是强制性的，因为合并连接转换只能对两个排序关系起作用。</p><p id="e376" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">之后，连接的结果将被送入下一个组件——条件性拆分。在该步骤中，如果右关系主键为空，则插入的结果将被识别。另一方面，如果左关系主键为空，则意味着在源表上发生了删除。对于两个表之间匹配的键，我们仍然需要比较其他感兴趣的字段(在大多数情况下，只有几个字段会被跟踪以检测更新更改)，如果至少有一个字段不同，则将该行标记为已更新。</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi np"><img src="../Images/c6f1956b93b4be4328fc7a4609cec0bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*pgBBWCmmLUeq2L25p8hV6w.png"/></div></div></figure><p id="5851" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">我在上一篇文章中提出的方法是在一个大约有270万行的测试表上实现的。该表中有6列:ID、f1、f2、f3、o1和o2。“ID”是主键，“f1”、“f2”和“f3”是我们要跟踪更改的字段。换句话说，只要其中一个字段发生了变化，我们就称之为更新。然而，“o1”和“o2”对此不感兴趣。</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/e18b950ac1645a53f3d55604e95c45b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*Ni98ODQdoCvRUNnWNpwjLA.png"/></div></figure><p id="9721" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">整个过程耗时2分56秒。</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/be91102f1424d33795abf12dba7bcdea.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*jojC5EavWZmqJCffouymng.png"/></div></figure><h2 id="c364" class="my kc je bd kd mz na dn kh nb nc dp kl lk nd ne kp lo nf ng kt ls nh ni kx nj bi translated">预排序源表和目标表</h2><p id="a648" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我的同事提醒我，排序转换非常耗时，但不是必需的，尽管合并连接需要对左右关系进行排序。也就是说，我们可以使用SQL语句查询表(SELECT *)，然后添加“ORDER BY”子句来手动排序，而不是按原样加载表。</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/97d2fef87a03be6989ec14941326d250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*JLtO4GGV2nxFgw0xXEL_Lg.png"/></div></figure><p id="5b4d" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">这里的技巧是右键单击OLE DB源对象，选择“显示高级编辑器…”。在“输入和输出属性”选项卡中，选择OLE DB源输出项，并将右窗格中的“IsSorted”属性设置为“True”。</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div class="gh gi np"><img src="../Images/a4bfe86b16bb9bc085b462cc37374b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*hBH5IqsuU5UiXROMUr-rsA.png"/></div></figure><p id="4573" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">接下来，转到“ID”字段，将“MappedColumnID”和“SortKeyPosition”设置为1，因为我们只想按ID排序。</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/66007da968c520975a0fa1f106b7a05c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*0Hs99sJDwzWokPVoX57yAA.png"/></div></figure><p id="a553" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">所有其他的转变都保持不变。</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/16a959352aebbce10286f278bb7969d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*8thJi5XjiWLypiZ_5ULklA.png"/></div></figure><p id="d26d" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">从经过的时间来看，我们可以看到性能提高了一点点。我假设这些改进来自于两个排序转换对象的缺失。但是，使用排序转换和SQL语句“ORDER BY”似乎没有太大区别。</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/46c7fa399791982e67164f5bc1dfce52.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*jNXVLuoSEkHQLzTmvabldw.png"/></div></figure><h2 id="3713" class="my kc je bd kd mz na dn kh nb nc dp kl lk nd ne kp lo nf ng kt ls nh ni kx nj bi translated">使用SQL命令“EXCEPT”</h2><p id="18ad" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">实现这一点的另一种方法是使用SQL命令“EXCEPT”。如果您从未使用过该命令，下面是微软给出的解释:</p><blockquote class="nw"><p id="515c" class="nx ny je bd nz oa ob oc od oe of lw dk translated">EXCEPT从左侧输入查询返回右侧输入查询未输出的不同行。</p></blockquote><p id="1b19" class="pw-post-body-paragraph kz la je lb b lc og le lf lg oh li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">但是，根据它的定义，我们可以放心地使用它来标识任何插入和更新的行，而不是删除的行。假设有一行不存在于左关系中，但存在于右关系中,“EXCEPT”命令将找出在左关系中但不在右关系中的内容，因此删除将被忽略。因此，为了识别被删除的行，我们需要使用“EXCEPT”两次。</p><p id="b1a8" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">首先，确定插入和更新的行:</p><pre class="nl nm nn no gt ol om on oo aw op bi"><span id="1111" class="my kc je om b gy oq or l os ot">SELECT [ID]<br/>      ,[f1]<br/>      ,[f2]<br/>      ,[f3]<br/>FROM [dbo].[tbl_source]<br/>EXCEPT<br/>SELECT [ID]<br/>      ,[f1]<br/>      ,[f2]<br/>      ,[f3]<br/>FROM [dbo].[tbl_dest]</span></pre><p id="8516" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">然后，我们交换源表和目标表的位置，以确定是否有任何被删除的行:</p><pre class="nl nm nn no gt ol om on oo aw op bi"><span id="35d4" class="my kc je om b gy oq or l os ot">SELECT [ID]<br/>FROM [dbo].[tbl_dest]<br/>EXCEPT<br/>SELECT [ID]<br/>FROM [dbo].[tbl_source]</span></pre><p id="6372" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">注意，我们只需要比较ID列来检测删除的行，否则:</p><ul class=""><li id="3e06" class="mk ml je lb b lc mb lg mc lk mm lo mn ls mo lw mp mq mr ms bi translated">性能不会得到优化</li><li id="49a0" class="mk ml je lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">如果包含其他字段，我们可能会再次识别更新的行，这会产生不必要的问题</li></ul><p id="8f55" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">此外，为了分离插入的和更新的行，我们需要使用“Lookup”转换来查看ID是否已经在目标表中。如果是，它是一个更新的行，否则，它是一个插入的行。</p><p id="edaa" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">最后，数据流如下所示:</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/889599d5101ae2e6fc3626ed62084fe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*FSYoDhJhae2qwlwSzXDdlQ.png"/></div></figure><p id="a1fd" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">令人惊讶的是，它超级快(只有11秒)，压倒性地优于其他两种方法。</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/019a6f9aba3a2e16af4aad226ee766ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*40uZ0ktsNMz2VuW1Y6hSlQ.png"/></div></figure><p id="66a8" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">一些提示:</p><ul class=""><li id="1246" class="mk ml je lb b lc mb lg mc lk mm lo mn ls mo lw mp mq mr ms bi translated">如数据流程图所示，用于标识插入/更新的行和删除的行的OLE DB源可以并行运行。</li><li id="a1a4" class="mk ml je lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">完整的缓存需要将整个目的表加载到内存中，这将消耗大量的时间。强烈建议对任何大型表使用“无缓存”。</li><li id="ac6e" class="mk ml je lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">对于如何处理没有匹配的行，请确保选择“忽略失败”。否则，不匹配的行可能会导致查找转换失败。</li></ul><figure class="nl nm nn no gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ow"><img src="../Images/8bdeefc83a72e6bc958097aa8d3d3789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c3xrlAJlvHxHnLyx82Rv3w.png"/></div></div></figure><h1 id="7ff6" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论</h1><p id="9c92" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">使用EXCEPT SQL命令比其他两种方法有着极其出色的性能。原因可能是因为以下几点:</p><ul class=""><li id="c6ae" class="mk ml je lb b lc mb lg mc lk mm lo mn ls mo lw mp mq mr ms bi translated">SSIS在幕后使用C编程语言，它将数据流编译成具有固定结构的特定程序，这很大程度上受你如何定义数据流的影响。</li><li id="938c" class="mk ml je lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">EXCEPT命令是一个SQL命令，它将在SQL Server引擎上运行，执行计划并由引擎优化。</li><li id="6ae0" class="mk ml je lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">前两种方法可能需要由SQL Server引擎将源表和目标表都读入内存，然后传输到SSIS进程中执行合并联接。</li><li id="3cf1" class="mk ml je lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">EXCEPT命令将仅在SQL Server引擎上运行，然后仅将差异(插入、更新和删除)行传输到SSIS程序中以供下一步使用</li></ul><p id="a231" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">因此，我们已经证明，当我们想要手动检测表的变化时，使用SQL脚本比一系列SSIS变换要高效得多。</p><div class="is it gp gr iu ox"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd jf gy z fp pc fr fs pd fu fw jd bi translated">通过我的推荐链接加入灵媒-陶</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">medium.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl ja ox"/></div></div></a></div><p id="d912" class="pw-post-body-paragraph kz la je lb b lc mb le lf lg mc li lj lk me lm ln lo mg lq lr ls mi lu lv lw im bi translated">如果你觉得我的文章有帮助，请考虑加入Medium会员来支持我和成千上万的其他作者！(点击上面的链接)</p><h1 id="eeef" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">资源:</h1><ol class=""><li id="e779" class="mk ml je lb b lc ld lg lh lk pm lo pn ls po lw pp mq mr ms bi translated">使用SSIS<br/>T3【https://medium . com/@ qiuyujx/manually-Implementing-Change-Data-Capture-CDC-on-Non-CDC-Enabled-Tables-Using-ssis-b 75 EDB 12 BAE 2在未启用CDC的表上手动实现变更数据捕获(CDC)</li><li id="4596" class="mk ml je lb b lc mt lg mu lk mv lo mw ls mx lw pp mq mr ms bi translated">SQL命令“EXCEPT”文档<br/><a class="ae mj" href="https://docs.microsoft.com/en-us/sql/t-sql/language-elements/set-operators-except-and-intersect-transact-sql?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/SQL/t-SQL/language-elements/set-operators-EXCEPT-and-intersect-transact-SQL？view=sql-server-ver15 </a></li></ol></div></div>    
</body>
</html>