<html>
<head>
<title>Flutter vs React Native 2023-What Should I Pick ? In-depth comparative analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振vs反应原生2023-我该挑什么？深入的比较分析</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/flutter-vs-react-native-2020-what-should-i-pick-in-depth-comparative-analysis-4f45cb539a15?source=collection_archive---------3-----------------------#2020-03-14">https://medium.datadriveninvestor.com/flutter-vs-react-native-2020-what-should-i-pick-in-depth-comparative-analysis-4f45cb539a15?source=collection_archive---------3-----------------------#2020-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a37eeabf7eae5d1026885c74c602be2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xFjB6kdrN8uvoDbpFnRovg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Flutter vs React Native 2023 | In-depth comparative analysis</figcaption></figure><p id="762c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">作为一名经验丰富的flutter和React Native app开发者，我将在本文中通过环境、实现原理、编程开发、插件开发、编译运行、性能稳定性、未来发展等七个方面，对当前的Native和Flutter进行全面的分析和比较，希望能给大家更多有价值的参考。</p><h1 id="b5e6" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">为什么选择跨平台框架？</h1><p id="8436" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">跨平台框架的优势不在于性能或者学习成本，即使是平台适配也会比较费时，但它最终可以让代码逻辑(尤其是业务逻辑)，在各种平台上无缝复用，减少重复代码的维护成本，保证平台之间的统一性，如果这个时候还能保证一定的性能，那就更完美了。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi md"><img src="../Images/63048c39f5fad5a042f402eae1dbf49c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*056T0BvTG-8eTzkIi04PFQ.jpeg"/></div></div></figure><h1 id="9a49" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">第一，环境建设</h1><p id="39e3" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">React Native和Flutter都需要针对<em class="mi"> Android </em>和<em class="mi"> IOS、</em>即<em class="mi"> JDK、Android SDK、Xcode、</em>等的开发环境，区别在于:</p><ul class=""><li id="3347" class="mj mk iq ke b kf kg kj kk kn ml kr mm kv mn kz mo mp mq mr bi translated">本机React需要配置，如、等。<code class="fe ms mt mu mv b">npmnodereact-native-cli</code></li><li id="bf4c" class="mj mk iq ke b kf mw kj mx kn my kr mz kv na kz mo mp mq mr bi translated">Flutter需要<em class="mi"> Android </em> Studio/VSCode上的Dart和Flutter插件。<code class="fe ms mt mu mv b">flutter sdk</code></li></ul><p id="b915" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在配置环境方面，Flutter Native的环境相对简单，而React Native的环境配置相对复杂，并且在个人接触的情况下，第一次配置运行成功率高于React Change Native，而Flutter失败的原因很大程度上是因为网络。<code class="fe ms mt mu mv b">node_module</code></p><blockquote class="nb nc nd"><p id="73b1" class="kc kd mi ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated"><em class="iq">同时开发跨平台的首选MAC，没有理由。</em></p></blockquote><h1 id="1ff0" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">二、实施原则</h1><p id="be78" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">在<em class="mi"> Android </em>和<em class="mi"> IOS上，</em>Flutter和React Native都默认需要原生平台的Activity/ViewController支持，都属于原生级别的“单页app”，两者最大的区别其实是UI搭建:</p><ul class=""><li id="60be" class="mj mk iq ke b kf kg kj kk kn ml kr mm kv mn kz mo mp mq mr bi translated"><strong class="ke ir">反应原生</strong>:</li></ul><p id="5886" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Native React是一组UI框架，默认情况下React Native加载JS文件，然后运行来解析<em class="mi">包</em>文件布局，产生一系列要呈现的原生控件。<code class="fe ms mt mu mv b">ActivityJavaScriptCore</code></p><p id="b4c0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">简单来说就是通过编写JS代码来配置页面布局，然后React Native最终会将渲染解析为原生控件，比如标签对应，标签对应，标签对应等等。<code class="fe ms mt mu mv b">&lt;View&gt;ViewGroup/UIView&lt;ScrollView&gt;ScrollView/UIScrollView&lt;Image&gt;ImageView/UIImageView</code></p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/3241c0dccaaf5491b33eaf9b89db0db5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5bx1xo8qoBH-7Dr6qB9S6w.jpeg"/></div></div></figure><p id="8551" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，与类似的框架相比，React Native进一步提升了页面的性能。<code class="fe ms mt mu mv b">Ionic</code></p><ul class=""><li id="24f0" class="mj mk iq ke b kf kg kj kk kn ml kr mm kv mn kz mo mp mq mr bi translated"><strong class="ke ir">颤振:</strong></li></ul><p id="7b2d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="mi">如果React Native对开发者来说是平台兼容的，那更像是对开发者屏蔽平台的概念。</em></p><blockquote class="nb nc nd"><p id="7531" class="kc kd mi ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated"><em class="iq">在Flutter中只需要一个平台，其余的Flutter说，</em>“你可以躺下，我们会自己移动。”<code class="fe ms mt mu mv b"><em class="iq">SurfaceCanvas</em></code></p></blockquote><p id="406f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Flutter绝大多数是平台无关的，开发者基于开发app并运行在上面，以适配和跨平台支持为支撑。这种跨平台的支持过程实际上是将<code class="fe ms mt mu mv b">the widgets</code>中的【数据】通过<code class="fe ms mt mu mv b">The Engine.</code>上的<code class="fe ms mt mu mv b">Skia</code>直接绘制到屏幕上</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/0b48deb835c984d9c787bffb8dc4ddf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AorK_yQuXCEF7Ol2yfqdNQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Flutter engine Architecture</figcaption></figure><p id="c0a8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以你可以从上面看到:React Native的<em class="mi">学一次，随地写</em>的思路是，只要你能<em class="mi"> react，</em>你就能写<em class="mi"> React </em>然后开发出一个性能不错的app，而Flutter就是只要你忘掉平台，专注于Flutter UI。</p><ul class=""><li id="6e46" class="mj mk iq ke b kf kg kj kk kn ml kr mm kv mn kz mo mp mq mr bi translated">Dom:</li></ul><p id="435a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">补充一下，React的虚拟<em class="mi"> DOM </em>的概念相信大家都知道，这也是React的性能保证之一，而Flutter其实也有类似的虚拟<em class="mi"> DOM </em>概念。</p><blockquote class="nb nc nd"><p id="c66a" class="kc kd mi ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated"><em class="iq">正如我在Flutter系列中看到的，我们在Flutter中写的并不是真正的渲染控件，它类似于React中的标签，更像是一个概要文件，由它组成的树并不是真正的渲染树。</em> <code class="fe ms mt mu mv b"><em class="iq">WidgetWidgetWidget</em></code></p></blockquote><p id="ca5a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe ms mt mu mv b">The widget</code>在渲染时通过<code class="fe ms mt mu mv b">Element</code>变化，最终转化为<code class="fe ms mt mu mv b">RenderObject</code>进行绘制，最终组成的<code class="fe ms mt mu mv b">renderTree</code>是“真正的渲染Dom”，每一次树触发的变化并不一定导致树的完整更新。<code class="fe ms mt mu mv b">WidgetRenderObject</code></p><p id="9b98" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以React和Native在实现原理上是完全不同的思路，而且虽然有类似的“虚拟<em class="mi"> DOM </em>概念”，React Native的平台亲和力很强，而Flutter UI的平台关联性很弱。</p><h1 id="2f24" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">第三，编程开发</h1><p id="a24e" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">Native React使用的JavaScript对这位24岁的年轻人来说并不陌生，这些年来，React Native的移动浪潮已经给了前端JS开发人员在脸书的React开始流行后进行扩展的技能。</p><p id="80a4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">选择的<em class="mi"> Dart </em>语言诞生于2011年，并于2018年发布2.0，这是一种最初发布用于对抗<em class="mi"> JavaScript、</em> <em class="mi">但</em>直到17年后，flutter才成为一种关注，并在继续尝试Web后重返Web世界。</p><p id="eae3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">编程开发涉及的点比较多，下面从<code class="fe ms mt mu mv b">development language,</code> <code class="fe ms mt mu mv b">interface development,</code> <code class="fe ms mt mu mv b">state management,</code> <code class="fe ms mt mu mv b">native controls.</code>进行比较介绍</p><blockquote class="nb nc nd"><p id="9075" class="kc kd mi ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated"><em class="iq">至于最吐槽的一点就是为什么Flutter团队没有选择</em> JS，<em class="iq">要么是因为</em> Dart <em class="iq">团队就在Flutter团队隔壁，要么是因为Google不想在甲骨文的某些事情上走边。同时，React Native已经更新了近4年，版本号依然没有破1.0。</em></p></blockquote><h1 id="a55d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">3.1、语言</h1><p id="6376" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">因为最初是由<em class="mi">网组成，</em> <em class="mi">镖</em>和<em class="mi"> JS </em>有些笼统。</p><p id="5245" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如下面的代码所示，它们都支持定义变量，支持语法糖，支持()等链异步处理，甚至/语法糖也差不多(虽然这个比较不准确)，但是你可以看到它们确实是作为“近亲”存在的。<code class="fe ms mt mu mv b">varasync/awaitPromiseFuture*yield</code></p><pre class="me mf mg mh gt nj mv nk bn nl nm bi"><span id="a84f" class="nn lb iq mv b be no np l nq nr">/// JS</span></pre><pre class="ns nj mv nk bn nl nm bi"><span id="321f" class="nn lb iq mv b be no np l nq nr">    var a = 1</span></pre><pre class="ns nj mv nk bn nl nm bi"><span id="c702" class="nn lb iq mv b be no np l nq nr">    async function doSomeThing() {<br/>        var result = await xxxx()<br/>        doAsync().then((res) =&gt; {<br/>            console.log("ffff")<br/>        })<br/>    }<br/>    function* _loadUserInfo () {<br/>        console.log("**********************");<br/>        yield put(UpdateUserAction(res.data));<br/>    }<br/></span></pre><pre class="ns nj mv nk bn nl nm bi"><span id="98ae" class="nn lb iq mv b be no np l nq nr">/// Dart</span></pre><pre class="ns nj mv nk bn nl nm bi"><span id="6972" class="nn lb iq mv b be no np l nq nr">  var a = 1;</span></pre><pre class="ns nj mv nk bn nl nm bi"><span id="b60d" class="nn lb iq mv b be no np l nq nr">  void doSomeThing() async {<br/>    var result = await xxxx();<br/>    doAsync().then((res) {<br/>      print('ffff');<br/>    });<br/>  }<br/>  _loadUserInfo() async* {<br/>    print("**********************");<br/>    yield UpdateUserAction(res.data);<br/>  }</span></pre><p id="d4b4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但它们也有很大的区别，最大的区别是JS是动态语言，Dart是伪动态语言的强类型语言。</p><p id="084c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在下面的代码中，类型可以直接在中声明，而类型可以通过语法sugar声明，但类型在赋值时实际上是自派生的，声明的是真正的动态变量，它在运行时检测类型。<code class="fe ms mt mu mv b">DartnameStringotherNamevardynamic</code></p><pre class="me mf mg mh gt nj mv nk bn nl nm bi"><span id="2be3" class="nn lb iq mv b be no np l nq nr">// Dart</span></pre><pre class="ns nj mv nk bn nl nm bi"><span id="818a" class="nn lb iq mv b be no np l nq nr">String name = 'dart'; <br/>var otherName = 'Dart';<br/>dynamic dynamicName = 'dynamic Dart';</span></pre><p id="8d29" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在下面的示例中，下面的图形代码最好地反映了这种差异:</p><ul class=""><li id="ebf6" class="mj mk iq ke b kf kg kj kk kn ml kr mm kv mn kz mo mp mq mr bi translated"><code class="fe ms mt mu mv b">var i</code>当一个类型没有被全局声明时，它被指定为，这样在方法中编译时就不会判断该类型，这与JS内部的现象一致。<code class="fe ms mt mu mv b">dymanicinit()</code></li><li id="9b41" class="mj mk iq ke b kf mw kj mx kn my kr mz kv na kz mo mp mq mr bi translated">如果在方法中定义，这已经是强类型了，那么编译器会报错，但这是用jS动态语言写的，默认编译时间不会错。<code class="fe ms mt mu mv b">var i = "";init()iStringi++</code></li></ul><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/36aa96ca685680cb9a8505d9c70361fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fYkyhJZhZ6XsqIy8JMhrtg.png"/></div></div></figure><p id="6d93" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">动态和非动态语言都有各种优缺点，比如JS的开发便利性明显高于Dart，而且Dart在类型安全和重构代码方面比JS更健壮。</p><h1 id="41fb" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">3.2界面开发</h1><p id="81fe" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">Native React在接口开发上延续了<em class="mi">React的开发</em>风格，支持scss/sass，风格代码分离，从0.59版本的<em class="mi"> Hook React </em>函数式编程开始，等等，而<em class="mi"> react </em>则是标签名的替换，由于平台兼容性，削减了风格和属性支持。</p><p id="5bca" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如下图所示，它是一个普通React原生组件的常见实现，继承<code class="fe ms mt mu mv b">Component</code>类，通过<code class="fe ms mt mu mv b">props,</code>传递参数，然后在<code class="fe ms mt mu mv b">render</code>方法中返回所需的布局，对布局中的每个控件进行样式化等等，这对于前端开发人员来说基本上不需要太多的学习成本。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/c407b708536482c169c676dca7fb9e88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UF889dAmYu6IwVOlLAKTlg.jpeg"/></div></div></figure><p id="a811" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如下所示，如果你在<em class="mi">中加入React钩子，函数式开发无疑会使整个代码结构更加简洁。</em></p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/4922a5900340cd3585466d83e42242fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Fk481k3XVmo0KkCF2J6IA.jpeg"/></div></div></figure><p id="de9f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Flutter最大的特点是，Flutter是一个独立于平台的UI框架，它创造了Flutter宇宙中的一切。</p><p id="20b9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如下图所示，Flutter的开发一般是通过继承无状态的<code class="fe ms mt mu mv b">Stateless widget</code>控件或者无状态的<code class="fe ms mt mu mv b">Statefulwidget</code>控件来实现页面，然后在相应的<code class="fe ms mt mu mv b">widget Build (BuildContext context)</code>方法内实现布局，利用不同的<code class="fe ms mt mu mv b">widgets</code> / <code class="fe ms mt mu mv b">children</code>的子控件做嵌套，通过控件的构造方法传递参数，最后对布局中的每个控件进行样式化，等等。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/b0f32a70c31cbd09803d6f4e6c1442e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-wmRjdJSi7nhf_lPJwQ5CA.jpeg"/></div></div></figure><p id="60e0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">而对于颤振控件的开发，目前最槽的就是控件嵌套和样式代码没有分离，样式代码分离这个问题我不做评价，这个真的要实际开发要多点经验，关于嵌套这里可以做一些“粉饰”:</p><p id="8143" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">“在Flutter中这一切都非常彻底，所以小部件的粒度非常精细，例如，它是一个单独的，甚至状态共享都是通过<code class="fe ms mt mu mv b">Inherited widget</code>共享<code class="fe ms mt mu mv b">widget,</code>完成的，这就是为什么slot的代码嵌套样式很难看。”<code class="fe ms mt mu mv b">WidgetPaddingCenterWidget</code></p><p id="cabb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">其实就是因为颗粒感，你可以通过不同的<code class="fe ms mt mu mv b">widgets,</code>自由组合多种业务模板比如在Flutter中常用的那个，就是官方帮你组合的模板之一，而容器内部其实是由<code class="fe ms mt mu mv b">Align,</code> <code class="fe ms mt mu mv b">ConstrainedBox,</code> <code class="fe ms mt mu mv b">DecoratedBox,</code> <code class="fe ms mt mu mv b">Padding,</code>等控件组合而成的，所以嵌套深度等问题完全是人为控制的，甚至在帧率和绘制上更加细致入微。<code class="fe ms mt mu mv b">Container</code></p><p id="47f3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当然官方也在改善优化编写和可视化的体验，而且如下图所示，从目前官方发布来看，未来会进一步改善问题。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/0796762efb3b77f6602d61e7bf7de5d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bYuD5OBj28zyea3-K2bdHQ.gif"/></div></div></figure><p id="e889" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，抛开上面的开发风格，React Native在UI开发中最大的特点是平台相关，而Flutter是平台无关的，比如下拉刷新，在React Native中，平台的不同下拉刷新效果，而在Flutter中，如果需要不同的平台下拉刷新效果，那么就需要使用Refresh <code class="fe ms mt mu mv b">And</code> <code class="fe ms mt mu mv b">Cupertino Sliver Refresh Control</code>做显示，否则多面会有一致的效果。</p><h1 id="632e" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">3.3、状态管理</h1><p id="2810" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">如前所述，Flutter在很多方面借鉴了React Native，所以在状态管理上也是很有“视觉感”的，比如调用<code class="fe ms mt mu mv b">setState</code>进行更新，操作并不是马上生效的，当然它们是不一样的，如下面的代码所示:</p><ul class=""><li id="2fb9" class="mj mk iq ke b kf kg kj kk kn ml kr mm kv mn kz mo mp mq mr bi translated">通常React Native需要在中初始化一个变量，然后通过。<code class="fe ms mt mu mv b">Componentthis.statethis.state.name</code></li><li id="05f3" class="mj mk iq ke b kf mw kj mx kn my kr mz kv na kz mo mp mq mr bi translated">Flutter通过变量继承然后直接访问和触发其对象内的更新。<code class="fe ms mt mu mv b">StatefulWidgetStatesetState</code></li></ul><pre class="me mf mg mh gt nj mv nk bn nl nm bi"><span id="de57" class="nn lb iq mv b be no np l nq nr">/// JS</span></pre><pre class="ns nj mv nk bn nl nm bi"><span id="b006" class="nn lb iq mv b be no np l nq nr">    this.state = {<br/>       name: ""<br/>    };</span></pre><pre class="ns nj mv nk bn nl nm bi"><span id="3be3" class="nn lb iq mv b be no np l nq nr">    ···</span></pre><pre class="ns nj mv nk bn nl nm bi"><span id="6dad" class="nn lb iq mv b be no np l nq nr">    this.setState({<br/>        name: "loading"<br/>    });</span></pre><pre class="ns nj mv nk bn nl nm bi"><span id="9d83" class="nn lb iq mv b be no np l nq nr">    ···</span></pre><pre class="ns nj mv nk bn nl nm bi"><span id="b1e4" class="nn lb iq mv b be no np l nq nr">    &lt;Text&gt;this.state.name&lt;/Text&gt;<br/></span></pre><pre class="ns nj mv nk bn nl nm bi"><span id="0962" class="nn lb iq mv b be no np l nq nr">/// Dart</span></pre><pre class="ns nj mv nk bn nl nm bi"><span id="4b92" class="nn lb iq mv b be no np l nq nr">    var name = "";</span></pre><pre class="ns nj mv nk bn nl nm bi"><span id="6980" class="nn lb iq mv b be no np l nq nr">    setState(() {<br/>       name =  "loading";<br/>    });</span></pre><pre class="ns nj mv nk bn nl nm bi"><span id="04ed" class="nn lb iq mv b be no np l nq nr">    ···</span></pre><pre class="ns nj mv nk bn nl nm bi"><span id="c492" class="nn lb iq mv b be no np l nq nr">    Text(name)</span></pre><p id="bda5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当然，它们的内部实现也有显著的区别，比如React Native，受React diff影响，以及Flutter，哪个<code class="fe ms mt mu mv b">isRepaintBoundary,</code> <code class="fe ms mt mu mv b">Mark NeedsBuild,</code>等等。</p><p id="d249" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在第三方状态管理中，两者有非常高的相似度，比如早期在前端状态管理框架中如:flutter_redux、fish_redux、dva_flutter、flutter_mobx等等，他们的设计思路<em class="mi">非常</em>独特。</p><p id="7e72" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">同时，Flutter官员还提供scoped_model、provider和其他Flutter的状态管理特性。</p><p id="607e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以React和Native在状态管理上非常接近，甚至在React之后。</p><h1 id="ca64" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">3.4，本机控件</h1><p id="0902" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">在跨平台开发中，就不得不谈到对原平台支持的访问，比如对<em class="mi"> Android平台上x5浏览器的访问，对视频播放框架的访问，对Lottie动画框架的访问等等。</em></p><p id="278a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这种需求得到了React Native的支持，甚至在社区中它也提供了类似lottie-react-native的项目。由于React Native的整个渲染过程都是在原生层完成的，所以访问原生平台控件并不困难，而且由于多年来的发展，虽然各种第三方库质量不一，但数量优势坐大。</p><p id="5d58" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">而旋舞显然是弱势的，甚至官方在一开始，甚至没有支持，这实际上涉及到Sis的实施问题。<code class="fe ms mt mu mv b">WebView</code></p><p id="8dfc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">由于Flutter的整体渲染是在原生平面之外，直接与GPU交互，导致原生控件无法直接插入其中，而在视频播放实现上，Flutter提供了外部纹理的设计来实现，但这个过程所需的数据转换显然限制了它的通用性，所以在后续版本中Flutter提供了<code class="fe ms mt mu mv b">platformView</code>模式进行集成。</p><blockquote class="nb nc nd"><p id="85a7" class="kc kd mi ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated"><em class="iq">以</em> Android <em class="iq">为例，一级层上的一级层Ofsi原理，通过二级屏幕显示，利用android </em>控制<em class="iq">在内存中绘制到该层的方式。绘制的textureId，然后通知给</em> Dart <em class="iq">层，其中</em> Dart <em class="iq">层利用定义的并带来textureId，引擎将与textureId对应的数据渲染到内存中。</em> <code class="fe ms mt mu mv b"><em class="iq">PresentationVirtualDisplaySurfaceVirtualDisplaySurfaceAndroidViewWidgetAndroidView</em></code></p></blockquote><p id="22f3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe ms mt mu mv b">PlatformView</code>设计一定导致了性能上的瑕疵，其中最大的表现就是内存使用量的增加，同时也导致了键盘无法弹出和黑屏等问题，甚至在<em class="mi"> Android </em>上性能可能还不如外面质感好。</p><p id="195c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">到目前为止，对Flutter原生控件的访问仍然不如React原生控件稳定。</p><h1 id="5841" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">四、插件开发</h1><p id="93a0" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">Native Native React和Flutter都支持插件开发，不像React Native开发的<a class="ae nv" href="https://link.zhihu.com/?target=https%3A//www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> Npm </a>插件，Flutter开发的pub插件。</p><p id="6ab0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用<em class="mi">NPM</em>插件的好处在于，它使用了丰富的<em class="mi"> npm </em>插件生态系统，同时降低了前端开发人员的学习成本。</p><p id="2778" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是<em class="mi">使用npm </em>的问题是太容易躺枪了，因为<em class="mi"> npm </em>包的复杂程度和深度视情况而定，以至于你很可能不知道<em class="mi"> npm </em>是什么，抛开安全问题，这里最直观的感受就是:<em class="mi">“为什么有人跑起来我跑不起来？”</em>同时，每个项目都是一个独立的node_module，这对于硬盘空间较少的Mac用户来说有点辛酸。</p><p id="d5da" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Flutter的<em class="mi"> pub </em>插件在<em class="mi">pub上默认统一管理，</em>类似于<em class="mi"> npm </em>支持<em class="mi"> git </em> link安装，而文件一般存储在电脑上的统一位置，多个项目引用同一个插件。<code class="fe ms mt mu mv b">flutter packages get</code></p><ul class=""><li id="2b8c" class="mj mk iq ke b kf kg kj kk kn ml kr mm kv mn kz mo mp mq mr bi translated">Win一般在C: users下，' xxxxxx？appData-漫游-发布-缓存路径</li><li id="4970" class="mj mk iq ke b kf mw kj mx kn my kr mz kv na kz mo mp mq mr bi translated">mac目录位于..发布缓存</li></ul><p id="cead" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果找不到插件目录，也可以通过查看文件打开插件目录，或者按如下方式打开。<code class="fe ms mt mu mv b">.flutter-plugins</code></p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/ad64a07f1b1bf8ba3fb7509a020a90bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZAp4b4gVuNx4oHyI2Y-6mQ.jpeg"/></div></div></figure><p id="512c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，谈谈Flutter和原生插件，它们对原生代码有不同的处理:</p><ul class=""><li id="f83a" class="mj mk iq ke b kf kg kj kk kn ml kr mm kv mn kz mo mp mq mr bi translated">在安装了带有本机代码的插件后，Native React需要执行脚本来引入支持，比如Android，egotised in，以及在哪里进行侵入式修改以达到引用。<code class="fe ms mt mu mv b">react-native linksetting.gradlebuild.gradleMainApplication.java</code></li><li id="fa58" class="mj mk iq ke b kf mw kj mx kn my kr mz kv na kz mo mp mq mr bi translated">Flutter的文本是通过文件的，文件保存了插件<em class="mi"> key-value </em>路径和原生代码，Flutter的脚本通过读取动态引入原生代码，最后通过生成这个ignore文件来完成导入，这个过程开发者很大程度上是通过生成ignore文件来完成的。<code class="fe ms mt mu mv b">.flutter-pluginsGeneratedPluginRegistrant.java</code></li></ul><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/7020f6ac86ba1dab4dd8eca58bfc029d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-YLUi7Vnry1NsIkAK6T1Xw.jpeg"/></div></div></figure><p id="b798" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以在这一块插件中，体验比React Native略胜一筹。</p><h1 id="d100" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">动词 （verb的缩写）汇编和产品</h1><p id="ff81" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">Native React编译的文件主要是文件，在<em class="mi"> Android、</em>和<em class="mi"> IOS中。</em> <code class="fe ms mt mu mv b">bundleindex.android.bunldemain.jsbundle</code></p><p id="2272" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Flutter在<em class="mi"> Android </em>上编译的产品主要是:—应用指令段—应用段—虚拟机数据段—虚拟机指令段等。<code class="fe ms mt mu mv b">isolate_snapshot_instrisolate_snapshot_datavm_snapshot_datavm_snapshot_instr</code></p><blockquote class="nb nc nd"><p id="ad67" class="kc kd mi ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated"><em class="iq"> ⚠️注意到，在1.7.8之后，Android下的flutter已经被编译为纯so文件。</em></p></blockquote><p id="5fed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在IOS中主要是App.framework，里面也包含、和四个部分。<code class="fe ms mt mu mv b">kDartVmSnapshotDatakDartVmSnapshotInstructionskDartIsolateSnapshotDatakDartIsolateSnapshotInstructions</code></p><p id="bb45" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后看看完整的结果，如下图所示，是React Native和Flutter在空项目和GSY实际项目下的发布包插槽大小的比较。</p><p id="82c1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以看到在和React Native相同的条件下Android比IOS大很多是因为<em class="mi"> IOS </em>自带JSCore，<em class="mi"> Android </em>需要各种动态so内置支持，而这里<em class="mi"> Android的</em>动态库so是大小过滤的，否则会更大。<code class="fe ms mt mu mv b">ndk</code></p><p id="6618" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">旋舞和React Native则相反，因为<em class="mi"> Android </em>自带skia，所以比没有skia的<em class="mi"> IOS </em>小很多。</p><p id="827f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上述特性与GSY项目中的发布包相同。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/00f285862d6c41ab0338097062e4b09e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*DDw-Ds4FZxXMU-_GahIh1A.jpeg"/></div></figure><p id="f180" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">值得注意的是，Google Play最近发布了64 bit，也表示将停止<em class="mi"> Android Studio </em> 32位维护，而格式支持，React Native需要0.59以后才支持。<code class="fe ms mt mu mv b">arm64-v8a</code></p><p id="a897" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">至于颤振，包装时说明。<code class="fe ms mt mu mv b">flutter build apk --release --target-platform android-arm64</code></p><h1 id="1cbb" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">六、性能</h1><p id="54a7" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">说到性能，这是一个大家都关心的概念，但是有一点要注意，因为性能和代码质量与复杂度有关，所以把性能放在一边显然不合适。</p><p id="dd6a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，Flutter的设计理论性能强于React Native，这是框架设计理念的结果，在没有OEM widgets的情况下，直接与CPU / GPU交互的特性，决定了其固有的能量优势。</p><blockquote class="nb nc nd"><p id="998a" class="kc kd mi ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated"><em class="iq">重要的是不要用模拟器测试性能，尤其是IOS模拟器，因为在IOS模拟器中Flutter是纯CPU，实际设备是GPU硬件加速的同时只比较Release下的性能。</em></p></blockquote><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/5bfd432e6f5feea2b1e7d8245c8437f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Gd0s8lNpBMwZyfa7X4S3Q.jpeg"/></div></div></figure><blockquote class="nb nc nd"><p id="2f8a" class="kc kd mi ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated"><em class="iq">不同的代码实现方式也会导致性能损失，比如Flutter中的skia绘制时，是比较性能密集型的，比如</em>透明合成、clipRRect、<em class="iq">等等，可能需要调用，会清空GPU绘制的缓存，导致性能损失，导致开发时丢帧严重。</em>T3】</p></blockquote><h1 id="b2f1" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">未来的发展</h1><p id="7a20" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">在早前的一篇文章《Airbnb为什么放弃了React？，让很多不知名的吃瓜人认为React Native土著已经被抛弃，然后官方“脸书正在重建React Native，改写了很多底层”的宣传，再次稳定了军心。</p><p id="2e5b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">与此同时，React Native在0.59版本中开始支持<em class="mi"> React Hook </em>等功能，并将原来的平台功能控件从React Native内部剥离到社区中，使得单独升级控件更加容易，模糊了React和Native之间的界限。</p><p id="7aaa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Flutter UI平台的不相关功能让Flutter可以更快地跨平台扩展，虽然React Native也有第三方扩展支持如<em class="mi"> Web </em>和<em class="mi"> Pc，</em>由于平台相关性强，多年来发展缓慢，Flutter在短时间内宣布了<em class="mi"> web </em>支持，甚至扩展到<em class="mi">Pc</em>和嵌入式设备。</p><p id="660d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是对于Flutter Web来说最关心的话题，如下图所示，在Flutter的设计逻辑中，你甚至感觉不到你在开发一个Web app。</p><p id="1e40" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Flutter Web保留了许多现有的移动逻辑，只是在引擎层与dart2Js的功能进行区分，但在现阶段，Flutter Web仍处于技术预览阶段，不建议在生产环境中使用。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/f5492c5e21a27fb79f53d676d5aa61b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*H6PJh04M51X2-VEk6Ym-lg.png"/></div></figure><p id="192c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">由此可见，无论是Flutter还是React Native都不会试图将自己扩展到更多的平台，同时进一步简化自己领域的开发。</p></div></div>    
</body>
</html>