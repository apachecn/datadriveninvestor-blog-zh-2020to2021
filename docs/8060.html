<html>
<head>
<title>Growing Self-Organizing Maps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不断增长的自组织地图</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/growing-self-organizing-maps-2d69b6374398?source=collection_archive---------9-----------------------#2020-12-31">https://medium.datadriveninvestor.com/growing-self-organizing-maps-2d69b6374398?source=collection_archive---------9-----------------------#2020-12-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e91f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">无监督聚类</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/09fefafdac277831b6b45ab5d37d98c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tiqvf9i1332Wnrz8zsmaIw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Clusters: Photo by George Eliot in brainyquote</figcaption></figure><p id="c5a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们看到一个复杂的问题时，我们总是试图理解问题并解决它们。<strong class="la iu">如何理解问题？我们可以将问题分解成更小的块。那么，理解和解决它们就容易了。另一个大问题是处理大数据。数据可能是复杂的或高维的。很难提取数据集背后的信息或隐藏模式。</strong></p><h2 id="5349" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated"><strong class="ak">集群解决了这个问题吗？</strong></h2><p id="d376" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">问题是找不到隐藏在数据中的任何模式。那么，<strong class="la iu">会有什么问题呢？</strong>它是关于在所有其他模式中找到一个有用的模式。无监督学习在这里发挥作用。我们可以使用无监督学习进行聚类。无监督学习自动发现数据的隐藏模式。我们可以使用无监督学习来探索数据，检测异常值，并从数据中提取信息。无监督聚类有穷举算法。</p><h1 id="4d14" class="ms lv it bd lw mt mu mv lz mw mx my mc jz mz ka mf kc na kd mi kf nb kg ml nc bi translated"><strong class="ak">自组织成簇</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/60a0c5c28141e8ba56ff802b9747f81f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hG3uYaUt6Zlu39uVO61Aug.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Self-Organizing: Photo by Sai Ram in codespeedy</figcaption></figure><p id="c924" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用无监督学习算法来识别模式和提取信息。因此，自组织将适用于群集过程。这里，主要思想是从未标记的数据中找到分组。如果我们不知道数据模式，那么我们可以使用聚类概念。因此，我们可以使用数据挖掘中的聚类方法来发现不可预见的和有趣的模式。聚类将有助于我们在处理高维复杂数据之前，对数据有一个清晰的初步了解。</p><p id="57c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，分析数据的最佳工具是聚类算法。聚类可以在数据挖掘过程之前使用。无监督聚类有许多方法？<strong class="la iu">我们可以使用SOM算法进行聚类吗？</strong></p><h2 id="8b1a" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated"><strong class="ak">用于聚类的SOM</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/8df13b52216adb780e38913647292f0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l7gXS01vOaZ3Me7QlHN0bQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Self Organizing Map — Photo by Nima Pasha in Pinterest</figcaption></figure><p id="b65e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">什么是自组织地图(SOM)？它是如何聚集的？</strong>SOM算法将高维数据集映射成低维，特别是二维或三维映射。因此，我们可以在2D或三维地图中可视化集群，并提取一些有用的信息。</p><p id="5407" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以在这里访问示例代码库<a class="ae nf" href="https://colab.research.google.com/drive/12G38G81z_VvlDmUIdHIOZM1QWJ0krDvn?usp=sharing" rel="noopener ugc nofollow" target="_blank">来尝试使用SOM进行集群。此外，您可以在此</a>下载Kaggle数据集<a class="ae nf" href="https://drive.google.com/drive/folders/18APGD-NG2lySrNsh1oTaug6W2RfBdBCX?usp=sharing" rel="noopener ugc nofollow" target="_blank">。您可以尝试代码库来获得下面的集群输出。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/260cbdb26149069f3de0dab3e6ba4278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K96NrftpKzK9afZv_O0jpA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">SOM Clustering : Photo by Author generated for an experiment</figcaption></figure><h2 id="2d73" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">SOM对我们的目的来说足够了吗？</h2><p id="654c" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在继续之前，我们必须再三考虑SOM是否足够。如果不是，SOM缺少什么？</p><blockquote class="nh ni nj"><p id="2eac" class="ky kz nk la b lb lc ju ld le lf jx lg nl li lj lk nm lm ln lo nn lq lr ls lt im bi translated">“已经从理论上证明，SOM在其原始形式下不提供完全的拓扑保持，并且过去一些研究人员已经试图克服这种限制。”</p></blockquote><p id="a7aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是在很多情况下，我们使用SOM将高维空间转换成2D地图。那么，为什么SOM不适合我们呢？主要问题是我们必须定义节点的数量和网格的大小。这是使用SOM的一大障碍。我们能预测适合我们应用的网格尺寸吗？不，我们不能。将会有其他大小的网格来提供更好的聚类。尝试所有网格大小和节点数量都有问题。有可能用不同的网格大小运行几次吗？用户不知道数据的结构。因此，他们不能确保他们获得的集群是正确的。<strong class="la iu">如果我们无法预测网络规模，会有什么解决方案？如何自动获取网格大小？</strong>因此，解决方案是必须在训练阶段检测网格大小。节点必须根据训练自动增长。我们需要一个不断增长的自组织地图吗？是的。</p><h1 id="75e5" class="ms lv it bd lw mt mu mv lz mw mx my mc jz mz ka mf kc na kd mi kf nb kg ml nc bi translated"><strong class="ak">GSOM快速介绍</strong></h1><p id="300f" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">不断增长的自组织映射是SOM的扩展版本。GSOM的关键因素是它能控制节点网络的增长。该算法定义了一个s <strong class="la iu"> pread因子(SF) </strong>用于控制层次聚类。我们可以通过修改SF从高层次或低(更精细)层次来可视化集群。我们可以根据自己的需求来可视化这些集群。通过一个小的分布因子，我们可以在更高的层次上创建集群来理解数据。然后，我们可以增加扩展因子来从数据中提取重要信息。</p><blockquote class="nh ni nj"><p id="6453" class="ky kz nk la b lb lc ju ld le lf jx lg nl li lj lk nm lm ln lo nn lq lr ls lt im bi translated">如果有一种机制可以首先观察最重要的聚类，然后，一旦数据分析师对整个数据集有了一些概念，就可以进一步展开映射并获得更精细的聚类，这将是非常有利的</p></blockquote><p id="1733" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">我们为什么要控制GSOM的增长？</strong></p><p id="053a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们处理大数据时，可视化来自多个层次级别的数据是有利的。然后我们可以选择一些集群，对它们进行深入分析。我们必须知道这些数据是如何传播的，以便将来进行分析，因为我们可能需要它来进行进一步的实验。因此，我们必须保持一个地图传播的措施。该算法有一个称为<em class="nk">的参数，一个扩展因子(SF) </em>来决定扩展的级别。它可以取从0到1的值，其中该因子与数据无关。</p><h1 id="6d3a" class="ms lv it bd lw mt mu mv lz mw mx my mc jz mz ka mf kc na kd mi kf nb kg ml nc bi translated"><strong class="ak"> GSOM算法</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/4a75c171fb52e3d576888ca8064c2586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X3FG7HG_JJnF7YRUKQ8HjA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">GSOM Algorithm : Recreated by Author</figcaption></figure><h2 id="7f81" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">初始阶段</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/e7b614f5b07db0e4bdd6f078f6602243.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*Ji0aQTiHoEQvW6NOAgmJZA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Initial network by Damminda et al.</figcaption></figure><p id="5354" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该算法从初始化具有四个节点的网络开始。然后，网络会根据参数和数据不断增长。节点用随机权重初始化。并且根据用户需求定义增长阈值。<strong class="la iu">什么是成长阈值(GT)？</strong>GT帮助决定是否需要创建一个新节点。<em class="nk"> SF </em>帮助计算<em class="nk"> GT </em>。我们可以在下面的部分中讨论这一点。</p><h2 id="e3ca" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">生长阶段</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/3965a8d9ad3f270d31e045e38dc426f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*akuWOpg7SVhgd8JQ3v6-tA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Growing phase : Recreated by Author</figcaption></figure><p id="f51d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">设节点<strong class="la iu"> <em class="nk"> i </em> </strong>的权重为W(i)，输入向量为x，当给网络一个新的输入时，算法会识别出一个<strong class="la iu">最佳匹配单元</strong>(胜者)。<strong class="la iu">如何选择胜出节点？</strong>通过计算给定输入和网络中所有节点之间的欧几里德距离，确定胜出(最佳匹配单元——BU)节点。</p><p id="9ad8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">= &gt;距离= |X — W(i)|</p><p id="7730" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">距离最小的节点是获胜者(BU)。</p><p id="6c98" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">获胜者节点的误差值(BU和给定输入之间的差值)定义如下:</p><p id="dbc1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">= &gt;误差(BU) = |X-W(BU)|</p><p id="ecfd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">E(t)和E(t+1) —节点在时间t和t+1的误差。</p><p id="20e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">=&gt; E(t+1) = E(t) + |X- W(BU)|</p><p id="ccaa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在误差计算之后，算法必须决定一个新的节点是否到网络。定义了误差距离，以保证现有节点网络是否足够。<strong class="la iu">是怎么做到的？</strong>该算法在每次迭代中不断将误差值加到获胜者节点上。现在新的参数来了:最大误差值<strong class="la iu"> H_error </strong>。</p><p id="5afb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> H_error </strong>指向所有节点的最大误差。每次选择胜出节点(BU)时(错误更新后)，<strong class="la iu">H _ Error = Error(BU)</strong>if E(BU)&gt;H _ Error。</p><p id="8b0a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果H_error &gt; DT，算法生成一个新节点。</p><p id="a2e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="nk">节点生成</em> </strong></p><p id="4c39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个节点将有四个紧邻的空间。它们可能是空的，也可能不是。该算法选择一个节点(n)进行增长，并在空的邻居位置生成新节点。但是一些节点可能是虚拟的。该算法将在接下来的迭代中移除伪节点。</p><p id="55f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">新节点如何初始化权重？</strong>现有网络更新。所以我们必须考虑分配权重。必须基于已经增长的网络来分配权重。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/f2f5aba90363c8f7bf05b288f5bb4ef8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g7UdLmAIZ13EXSYuO4GEgw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Initializing weights for new nodes by Damminda et al.</figcaption></figure><p id="d23f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该算法考虑了四个类别下的权重初始化(上图)。(a)和(b)经常发生。</p><p id="448e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">案例(a&amp;c)</strong></p><p id="da9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果W2&gt;W1: W new = W1-(W2-W1)</p><p id="37d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果W1&gt;W2: W new = W1+(W1-W2)</p><p id="b145" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">案例(b): </strong></p><p id="2ef8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">W new = (W1+W2)/2</p><p id="9e7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">案例(d): </strong></p><p id="6355" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新节点只有一个较旧的相邻节点。这种情况将发生在网络的初始阶段或者当虚拟节点被移除时。</p><p id="decd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">W new = (r1+r2)/2，其中r1和r2是权重的上限和下限。如果W new不在r1和r2之间，它将属于case ( <strong class="la iu"> d </strong>)。</p><p id="d5c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们必须调整邻域节点的权重吗？是的，我们必须这样做。必须更新权重向量。类似于SOM，自适应的量(学习率-LR)将在迭代中以指数方式减少。Wj(k)和Wj(k+1)是更新权重之前和之后的节点的权重。X(k)是输入向量。N(k+1)是获胜者节点的k个相邻节点。</p><p id="4d45" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果j∈N(k+1)= &gt; Wj(k+1)= Wj(k)+LR(k)*(X(k)-Wj(k))</p><p id="9923" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">else =&gt; Wj(K+1) = Wj(k)</p><h2 id="fc52" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">平滑阶段</h2><p id="f0dd" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">当没有更多节点要生成时，平滑阶段开始运行。该算法具有平滑阶段，以平滑在最后阶段或迭代中增长的节点的总误差。甚至平滑阶段的初始LR也低于生长阶段。多次给定输入数据以收敛误差值。在平滑阶段没有新的节点生成。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="b13b" class="ms lv it bd lw mt nz mv lz mw oa my mc jz ob ka mf kc oc kd mi kf od kg ml nc bi translated">GSOM的主要特征</h1><ul class=""><li id="f248" class="oe of it la b lb mn le mo lh og ll oh lp oi lt oj ok ol om bi translated">当我们对数据集一无所知时，我们可以使用GSOM。</li><li id="0231" class="oe of it la b lb on le oo lh op ll oq lp or lt oj ok ol om bi translated">GSOM代表了数据中的聚类和分组，它可能对数据分析人员有用。</li><li id="0353" class="oe of it la b lb on le oo lh op ll oq lp or lt oj ok ol om bi translated">为表示数据而生成的节点数量略少于SOM网络。</li><li id="4b9b" class="oe of it la b lb on le oo lh op ll oq lp or lt oj ok ol om bi translated">在SOM中，新节点被赋予随机的权值，而GSOM根据训练好的网络来分配权值。</li><li id="0dac" class="oe of it la b lb on le oo lh op ll oq lp or lt oj ok ol om bi translated">GSOM用四个节点初始化。它通过在初始阶段使用几个节点来减少处理时间。</li></ul><p id="3108" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">参考文献</strong></p><ol class=""><li id="c209" class="oe of it la b lb lc le lf lh os ll ot lp ou lt ov ok ol om bi translated">阿拉哈库恩，d；哈尔加姆格公司；斯里尼瓦桑，B. (2000年)。<em class="nk">用于知识发现的具有受控增长的动态自组织地图。</em></li><li id="b92b" class="oe of it la b lb on le oo lh op ll oq lp or lt ov ok ol om bi translated">托沃，科霍宁。<em class="nk">自组织地图</em>。第30卷。施普林格科学&amp;商业媒体，2012年。</li></ol><p id="3c96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">访问专家视图— </strong> <a class="ae nf" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>