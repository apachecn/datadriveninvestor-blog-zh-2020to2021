<html>
<head>
<title>Pytest — a beginner guide. 📄</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">pytest——初学者指南。📄</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/pytest-a-beginner-guide-9ba84a18d3dd?source=collection_archive---------1-----------------------#2020-11-02">https://medium.datadriveninvestor.com/pytest-a-beginner-guide-9ba84a18d3dd?source=collection_archive---------1-----------------------#2020-11-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fd32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">pytest框架入门…</p><p id="be09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Pytest是一个为python执行测试自动化的开源框架。开始使用pytest最让我兴奋的是，它非常容易上手，可以用于所有类型和级别的软件测试。Pytest有一堆库，就像是送给我们的礼物。其中的一些待遇就像夹具、参数化、跳过测试等等。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/d50684dfc1d9b3ee9b473bc1759003e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IH_xsDViqUgyA331"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/@marxgall?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Marek Szturc</a> on <a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="e713" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">pytest脱颖而出的原因</h1><p id="5c4a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在谈论pytest时，我给我的朋友们举了一个最好的例子，一个拥有升级功能的房子，其中单元测试就像是一个拥有过时功能的老房子。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mf"><img src="../Images/b88ff50073023a175babac7dc6bb559f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tMXLpPlglNw4tyOR"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/@webaliser?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ярослав Алексеенко</a> on <a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="232a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">pytest的命名约定- </strong></p><ul class=""><li id="ce45" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">Pytest文件应该以<strong class="jp ir"> <em class="mp"> test_filename </em> </strong>或<strong class="jp ir"> <em class="mp"> filename_test </em> </strong>开头</li><li id="75a6" class="mg mh iq jp b jq mq ju mr jy ms kc mt kg mu kk ml mm mn mo bi translated">所有函数的命名惯例应该以<strong class="jp ir"> test_ </strong>开始</li></ul></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="160c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本博客涵盖的主题，</p><ul class=""><li id="8a60" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated"><strong class="jp ir"> <em class="mp">创建pytest文件。</em>T15】</strong></li><li id="4501" class="mg mh iq jp b jq mq ju mr jy ms kc mt kg mu kk ml mm mn mo bi translated"><strong class="jp ir"> <em class="mp">基本pytest命令</em> </strong></li><li id="3e05" class="mg mh iq jp b jq mq ju mr jy ms kc mt kg mu kk ml mm mn mo bi translated"><strong class="jp ir"> <em class="mp">断言陈述</em> </strong></li><li id="799a" class="mg mh iq jp b jq mq ju mr jy ms kc mt kg mu kk ml mm mn mo bi translated"><strong class="jp ir"> <em class="mp">为什么函数的命名约定是强制性的</em> </strong></li><li id="fc36" class="mg mh iq jp b jq mq ju mr jy ms kc mt kg mu kk ml mm mn mo bi translated"><strong class="jp ir"> <em class="mp">子串匹配</em> </strong></li><li id="15f2" class="mg mh iq jp b jq mq ju mr jy ms kc mt kg mu kk ml mm mn mo bi translated"><strong class="jp ir"> <em class="mp">夹具</em> </strong></li><li id="cd6e" class="mg mh iq jp b jq mq ju mr jy ms kc mt kg mu kk ml mm mn mo bi translated"><a class="ae lb" href="http://conftest.py" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="mp">conftest . py</em></strong></a></li></ul><p id="4520" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看pytest的一些入门命令，</p><p id="c077" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Pytest安装- </strong></p><p id="bb4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着python的安装而来的是<strong class="jp ir"> pip- </strong>一个用来安装和管理用Python编写的软件包的包管理系统。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="e726" class="nh ld iq nd b gy ni nj l nk nl">pip install pytest</span></pre><p id="fef5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Pytest版本检查，</strong></p><p id="1f2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要检查pytest的最新版本，请执行以下命令提示符，</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="1445" class="nh ld iq nd b gy ni nj l nk nl">pytest --version</span></pre><p id="70b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">帮助信息，</strong></p><p id="945f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要显示帮助信息，如报告、pytest警告、测试部分调试和配置等，请执行以下命令提示符，</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="1e88" class="nh ld iq nd b gy ni nj l nk nl">pytest -h</span></pre></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="c2d1" class="lc ld iq bd le lf nm lh li lj nn ll lm ln no lp lq lr np lt lu lv nq lx ly lz bi translated">创建pytest文件-</h1><p id="5d32" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">现在，让我们从第一个pytest程序开始。</p><p id="cf21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们必须创建一个目录，然后在该目录中创建一个测试文件。</p><p id="2c39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，<strong class="jp ir"> <em class="mp">测试</em> </strong>是在一个python项目下创建一个包然后创建一个新的python文件。</p><p id="d815" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看第一个测试文件中的操作— <strong class="jp ir"> test_stringOps </strong>。<strong class="jp ir"> py </strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/48c08cb8194dd15a94a8aa738ec84dbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*__vhe1JtHFAX3XfU.png"/></div></figure><p id="b226" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将以下代码写入文件，在文件中执行基本的字符串操作…</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="5a00" class="nh ld iq nd b gy ni nj l nk nl"># Replacing String with another string<br/>def test_strReplace():<br/>    string = "Hello, World!"<br/>    assert string.replace("H", "J") == "Jello, World!"</span><span id="d9a8" class="nh ld iq nd b gy ns nj l nk nl"># String Split - Splits a string to two substrings<br/>def test_strSplit():<br/>    string = "Hello,World"<br/>    assert string.split(",") == ["Hello", "World"]</span><span id="2652" class="nh ld iq nd b gy ns nj l nk nl"># String Strip<br/>def test_strStrip():<br/>    string = " Hello, World! "<br/>    assert string.strip() == "Hello, World!"</span><span id="e302" class="nh ld iq nd b gy ns nj l nk nl"># String Concatenate<br/>def test_strConcat():<br/>    string1 = "Hello"<br/>    string2 = "World"<br/>    assert string1 + string2 == "HelloWorld"</span></pre><p id="3d73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过查看代码，我们可以理解一切都应该在一个函数中，并且每个函数都有一个assert语句。让我们看看这个断言语句做了什么…</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="b9ad" class="lc ld iq bd le lf nm lh li lj nn ll lm ln no lp lq lr np lt lu lv nq lx ly lz bi translated">断言语句</h1><p id="e57d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在每个函数中，最后出现的语句是assert语句。</p><p id="919c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据测试函数的执行情况，将返回一个值。这个返回值可以是<strong class="jp ir">真</strong>或<strong class="jp ir">假。</strong></p><p id="b631" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir"> pytest </strong>中，如果一个测试函数中的<strong class="jp ir">断言</strong>失败，那么该函数执行停止，该测试函数中的下一条语句不执行，继续下一个函数。</p><p id="cd7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们执行上面的字符串操作文件，这可以用不同的方式来完成。</p><p id="d8be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以用来触发<strong class="jp ir">当前目录和子目录</strong>中所有文件的命令是，</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="693d" class="nh ld iq nd b gy ni nj l nk nl">pytest</span></pre><p id="179f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要执行一个特定的测试文件，语法是</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="e316" class="nh ld iq nd b gy ni nj l nk nl">pytest filename.py</span></pre><p id="da9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例-要在test_stringOps.py文件中执行测试，命令应为</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="2f83" class="nh ld iq nd b gy ni nj l nk nl">pytest  test_stringOps.py</span></pre><p id="7eff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们只想执行一个特定的函数，那么就把函数名说成，</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="12a5" class="nh ld iq nd b gy ni nj l nk nl">pytest filename.py::functionname</span></pre><p id="0784" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例— ro在test_stringOps.py文件中执行test_strConcat函数，</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="8a2c" class="nh ld iq nd b gy ni nj l nk nl">pytest test_stringOps.py::test_strConcat</span></pre></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="f488" class="lc ld iq bd le lf nm lh li lj nn ll lm ln no lp lq lr np lt lu lv nq lx ly lz bi translated">为什么函数的命名约定是强制性的</h1><p id="896f" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在这个例子中，我们将看到函数的命名约定是如何工作的。</p><p id="2232" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">文件名为<em class="mp">test _算术. py，</em>其中四个函数符合<em class="mp"> test_naming </em>约定。其中as第三个函数不遵循命名约定。如果我们尝试执行这个文件，只收集了三个函数数据，而另一个函数<em class="mp"> multiply() </em>没有通过。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="dccc" class="nh ld iq nd b gy ni nj l nk nl">def test_subtract():<br/>    a = 6<br/>    b = 6<br/>    assert a - b == 0 <br/>def test_divide():<br/>    a = 6<br/>    b = 6<br/>    assert a / b == 1<br/>def multiply():<br/>    a = 6<br/>    b = 6<br/>    assert a - b == 0 <br/>def test_multiply():<br/>    a = 6<br/>    b = 6<br/>    assert a * b == 36</span></pre><p id="f6c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出，</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="dac6" class="nh ld iq nd b gy ni nj l nk nl">collected 3 items                                                                                                                                                                                                                         </span><span id="cc62" class="nh ld iq nd b gy ns nj l nk nl">test_arithmetic.py ...                                                                                                                                                                                                              [100%]</span><span id="cdef" class="nh ld iq nd b gy ns nj l nk nl">==================================== 3 passed in 0.06s =======================================================================</span></pre></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="6dea" class="lc ld iq bd le lf nm lh li lj nn ll lm ln no lp lq lr np lt lu lv nq lx ly lz bi translated">子串匹配</h1><p id="3e4c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">假设，如果我们只想运行一组特定的测试，这可以通过<strong class="jp ir">标记</strong>测试并基于<strong class="jp ir">子串匹配运行测试来实现。</strong></p><p id="4524" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要执行名称中包含字符串的测试，我们可以使用以下语法</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="d809" class="nh ld iq nd b gy ni nj l nk nl">pytest -k &lt;substring&gt; -v</span></pre><p id="4944" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于下面的测试，让我们用子替换"<strong class="jp ir"> str" </strong>来执行</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="4230" class="nh ld iq nd b gy ni nj l nk nl"># Replacing String with another string<br/>def test_strReplace():<br/>    string = "Hello, World!"<br/>    assert string.replace("H", "J") == "Jello, World!"</span><span id="d5ed" class="nh ld iq nd b gy ns nj l nk nl"># String Split - Splits a string to two substrings<br/>def test_strSplit():<br/>    string = "Hello,World"<br/>    assert string.split(",") == ["Hello", "World"]</span><span id="e337" class="nh ld iq nd b gy ns nj l nk nl"># String Strip<br/>def test_strStrip():<br/>    string = " Hello, World! "<br/>    assert string.strip() == "Hello, World!"</span><span id="609d" class="nh ld iq nd b gy ns nj l nk nl"># String Concatenate<br/>def test_strConcat():<br/>    string1 = "Hello"<br/>    string2 = "World"<br/>    assert string1 + string2 == "HelloWorld"</span></pre><p id="fc43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要基于匹配子字符串执行测试，请使用以下命令执行:</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="2ea9" class="nh ld iq nd b gy ni nj l nk nl">pytest -k str -v</span></pre><p id="fb99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将执行名称中包含单词<strong class="jp ir">‘str’</strong>的所有测试名称。在本例中，它们是<strong class="jp ir"> test_strReplace() </strong>，<strong class="jp ir"> test_strSplit()，test_strStrip() </strong>和<strong class="jp ir"> test_strConcat() </strong>。</p><p id="c91c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试执行过程，</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="a543" class="nh ld iq nd b gy ni nj l nk nl">test_stringOps.py::test_strReplace PASSED                                                                                                                                                                                           [ 25%]<br/>test_stringOps.py::test_strSplit PASSED                                                                                                                                                                                             [ 50%]<br/>test_stringOps.py::test_strStrip PASSED                                                                                                                                                                                             [ 75%]<br/>test_stringOps.py::test_strConcat PASSED                                                                                                                                                                                            [100%]</span><span id="6038" class="nh ld iq nd b gy ns nj l nk nl">============================= 4 passed, 10 deselected in 0.07s =======================================================================</span></pre><p id="d371" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">pytest的另一个重要概念来了。在下面的代码中，str变量被声明了两次，如果我们有更多的函数使用这个变量该怎么办。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="aba0" class="nh ld iq nd b gy ni nj l nk nl"># Uppercase<br/>def test_upper():<br/>    str ="python"<br/>    assert str.upper() == "PYTHON"</span><span id="38db" class="nh ld iq nd b gy ns nj l nk nl"># Is Alpha<br/>def test_isalpha():<br/>    str = "python"<br/>    assert str.isalpha() == True</span></pre><p id="ff22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了减少代码长度，我们可以将这些输入数据保存在一个fixture中，并在需要时使用。这可以使用<strong class="jp ir">夹具来完成。</strong></p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="3b25" class="lc ld iq bd le lf nm lh li lj nn ll lm ln no lp lq lr np lt lu lv nq lx ly lz bi translated">什么是固定装置</h1><p id="5d0d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">Fixtures是向其他函数提供数据的函数。这个概念是pytest框架中最简单却最强大的概念。</p><p id="2c54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些fixtures在测试函数执行之前运行。函数可以被声明为fixture，</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="9422" class="nh ld iq nd b gy ni nj l nk nl">@pytest.fixture</span></pre><p id="35b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们为上面的字符串操作文件创建一个fixture，并从调用fixture开始使用字符串变量。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="c779" class="nh ld iq nd b gy ni nj l nk nl">import pytest</span><span id="b08c" class="nh ld iq nd b gy ns nj l nk nl">@pytest.fixture<br/>def input_value():<br/>    return "python"</span></pre><p id="ff21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，fixture函数名作为相应测试函数的参数传递，并在需要时使用。这里，在fixture函数中，返回字符串变量。这由其余的测试函数访问，而不是一次又一次地重复相同的代码。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="5a5d" class="nh ld iq nd b gy ni nj l nk nl"># Uppercase<br/>def test_upper(input_value):<br/>    assert input_value.upper() == "PYTHON"</span><span id="ca49" class="nh ld iq nd b gy ns nj l nk nl"># Is Alpha<br/>def test_isalpha(input_value):<br/>    assert input_value.isalpha() == True</span></pre><p id="f312" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用fixtures的主要优点是降低了代码复杂性、代码长度和成本。例如，在建立数据库连接时，我们可以利用这些装置在一个地方编写关于建立连接的数据，并在任何需要的地方使用它。</p><p id="93fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法也有一个缺点。如果我们想使用fixture，我们只能在文件中使用它，因为它的作用域在文件中。</p><p id="d222" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里又出现了另一个名为<strong class="jp ir"> conftest.py. </strong>的概念</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="3030" class="lc ld iq bd le lf nm lh li lj nn ll lm ln no lp lq lr np lt lu lv nq lx ly lz bi translated">conftest.py</h1><p id="643a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们在一个名为<a class="ae lb" href="http://conftest.py" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> conftest.py </strong> </a>的文件中定义了一个fixture函数，以便将代码共享给多个测试文件。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nt"><img src="../Images/d0af6dec1c083a7fd384dda5db885870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZAxavjaN7w5Jq0_1"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/@shekatherine?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ekaterina Shevchenko</a> on <a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="91c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看上面的例子，看看它是如何工作的。这里我们有两个名为<strong class="jp ir"> test_strBasicOps.py </strong>和<strong class="jp ir">test _ strpalindome . py .</strong>的测试文件，在这两个文件中，我们执行一些字符串操作，这些输入数据取自一个名为<a class="ae lb" href="http://conftest.py" rel="noopener ugc nofollow" target="_blank"> conftest.py. </a>的公共夹具</p><p id="f0f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae lb" href="http://conftest.py" rel="noopener ugc nofollow" target="_blank"> conftest.py，</a></p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="6083" class="nh ld iq nd b gy ni nj l nk nl">import pytest</span><span id="741c" class="nh ld iq nd b gy ns nj l nk nl">@pytest.fixture<br/>def input_value():<br/>    return "python"</span></pre><p id="4bd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在test_strBasicOps.py中，</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="f408" class="nh ld iq nd b gy ni nj l nk nl"># Uppercase<br/>def test_upper(input_value):<br/>    assert input_value.upper() == "PYTHON"</span><span id="645b" class="nh ld iq nd b gy ns nj l nk nl"># Length of a string<br/>def test_len(input_value):<br/>    assert len(input_value) == 6</span></pre><p id="e5fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在test_strPalindrome.py中，</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="f18d" class="nh ld iq nd b gy ni nj l nk nl"># Palindrome<br/>def test_isPalindrome(input_value):<br/>    assert input_value == input_value[::-1]</span></pre><p id="8d56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">名为input_value的Fixture作为在文件和执行的测试中定义的函数的参数传递。</p><p id="cba2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">两个文件的输出，</p><p id="c476" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用命令pytest test_strBasicOps.py执行文件test_strBasicOps.py</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="bd4a" class="nh ld iq nd b gy ni nj l nk nl">collected 2 items                                                                                                                                                                                                                         </span><span id="3460" class="nh ld iq nd b gy ns nj l nk nl">test_strBasicOps.py ..                                                                                                                                                                                                              [100%]</span><span id="8e24" class="nh ld iq nd b gy ns nj l nk nl">==================================== 2 passed in 0.04s =======================================================================</span></pre><p id="d73b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用命令pytest test_strPalindrome.py执行文件test_strPalindrome.py</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="50ee" class="nh ld iq nd b gy ni nj l nk nl">__________________________________<br/>    test_isPalindrome<br/> ______________________________________</span><span id="9190" class="nh ld iq nd b gy ns nj l nk nl">    input_value = 'python'</span><span id="931c" class="nh ld iq nd b gy ns nj l nk nl">    def test_isPalindrome(input_value):<br/>        if input_value == input_value[::-1]:<br/>            assert True<br/>        else:<br/>&gt; assert False<br/>E<br/>assert False</span><span id="abff" class="nh ld iq nd b gy ns nj l nk nl">test_strPalindrome.py: 7: AssertionError<br/>== == == == short<br/>test<br/>summary<br/>info == == == == == == == == == == == == == == == == == == == == == == <br/>FAILED<br/>test_strPalindrome.py::test_isPalindrome -<br/>assert False<br/>== == == == == = 1<br/>failed in 0.14<br/>s == == == == == == == == == == == == == == == == == == == == == == ==</span></pre><p id="1abd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里断言失败，因为输出不匹配。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="039f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在我的下一篇博客中讨论pytest的其他库和功能。</p><div class="nu nv gp gr nw nx"><a href="https://gunturu-lali.medium.com/pytest-part-2-9c594c36b9f4" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">Pytest —第2部分</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">这个博客是我的pytest初学者指南博客的延续。</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">gunturu-lali.medium.com</p></div></div></div></a></div><p id="b049" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读…！！</p></div></div>    
</body>
</html>