<html>
<head>
<title>Computing Histograms Using Java Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Java数组计算直方图</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/computing-histograms-using-java-arrays-7f81e08ed602?source=collection_archive---------1-----------------------#2020-02-01">https://medium.datadriveninvestor.com/computing-histograms-using-java-arrays-7f81e08ed602?source=collection_archive---------1-----------------------#2020-02-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="6602" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">编程；编排</h2><div class=""/><div class=""><h2 id="09a9" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">直方图清楚地显示了数据的分布情况。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/aeb8906f9b5061b57566556195af466b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bKPPkLNb2d2DNrZZ"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Photo by <a class="ae lh" href="https://unsplash.com/@goumbik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lukas Blazek</a> on <a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d91b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">直方图用于将数据组织到不同的桶中。例如，您可能想要显示大学博士生的年龄范围。你可以选择20-25岁、26-30岁、30-35岁等等年龄段。如果你计算每个桶或箱中的学生人数，你就有一个直方图。</p><div class="me mf gp gr mg mh"><a href="https://www.datadriveninvestor.com/2019/03/25/a-programmers-guide-to-creating-an-eclectic-bookshelf/" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">创建折衷书架的程序员指南|数据驱动的投资者</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">每个开发者都应该有一个书架。他的内阁中可能的文本集合是无数的，但不是每一个集合…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv lb mh"/></div></div></a></div><p id="1694" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设你要根据学生的SAT成绩对他们进行分组。首先，你把所有的SAT分数画在一条线上，然后把这条线分成400个片段</p><ul class=""><li id="c8f6" class="mw mx it lk b ll lm lo lp lr my lv mz lz na md nb nc nd ne bi translated">400到799</li><li id="3672" class="mw mx it lk b ll nf lo ng lr nh lv ni lz nj md nb nc nd ne bi translated">800到1199</li><li id="532e" class="mw mx it lk b ll nf lo ng lr nh lv ni lz nj md nb nc nd ne bi translated">1200年到1599年等等</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nk"><img src="../Images/6bf4f8a21aa78afde45ed642112b74da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xIdYhLy-TblEXzGWLyhy-A.gif"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk"><a class="ae lh" href="https://help.plot.ly/histogram/" rel="noopener ugc nofollow" target="_blank">Source Plotly</a></figcaption></figure><p id="7c32" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在每个碎片/桶/箱中收集所有这些分数，并将其绘制为条形图，并在图上添加一个刻度</p><div class="ks kt ku kv gt ab cb"><figure class="nl kw nm nn no np nq paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/34486d8c956fe0d925e0a943f6f83283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/1*xc4lvpt1ECnFRbMV0Wvffg.gif"/></div></figure><figure class="nl kw nr nn no np nq paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/ea28fdce0d5077d3b98522d7348ff7c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/1*UR-lKr7U8YAOSCqtGMIMKA.gif"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk ns di nt nu"><a class="ae lh" href="https://help.plot.ly/histogram/" rel="noopener ugc nofollow" target="_blank">Source Plotly</a></figcaption></figure></div><p id="b12a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">今天我们将看到给定一个数字数组，我们如何在Java中计算它的直方图数组。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="c7bf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">完整的github代码如下</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="e951" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将使用两种不同的方法来计算直方图。其中一个比另一个慢得多。我们主要使用2个阵列</p><ol class=""><li id="3560" class="mw mx it lk b ll lm lo lp lr my lv mz lz na md oe nc nd ne bi translated">输入数组—这是包含每个学生分数的数组，名为<strong class="lk jd"> student_grades </strong></li><li id="5ae3" class="mw mx it lk b ll nf lo ng lr nh lv ni lz nj md oe nc nd ne bi translated">输出数组——这是一个直方图数组，它告诉我们有多少学生得到了哪个年级的分数，它被称为<strong class="lk jd"> grade_histogram </strong></li></ol><p id="2442" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们以下列方式启动阵列</p><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="cd72" class="ok ol it og b gy om on l oo op"><strong class="og jd">//Generate a random array of student grades</strong><br/>int[] student_grades   = <br/>random.ints(NUM_STUDENTS, 0,HIGHEST_GRADE).toArray();</span><span id="5d97" class="ok ol it og b gy oq on l oo op"><strong class="og jd">//Generate an empty histogram array. Each element represent how many students scored that grade<br/></strong>  int[] grade_histogram   = new int[HIGHEST_GRADE];<br/>  int[] grade_histogram_fast  = new int[HIGHEST_GRADE];</span></pre><h2 id="0a61" class="ok ol it bd or os ot dn ou ov ow dp ox lr oy oz pa lv pb pc pd lz pe pf pg iz bi translated">较慢的方法</h2><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="d73e" class="ok ol it og b gy om on l oo op"><strong class="og jd">//Function to compute histogram O(N^2)</strong><br/> public void getHistSlow(int iArr[], int oArr[])<br/> {<br/>  int i,j;<br/>  for(i=0;i&lt;HIGHEST_GRADE;i++)<br/>  {<br/>   int count=0;<br/>   for(j=0;j&lt;iArr.length;j++)<br/>   {<br/>    if(iArr[j]==i)<br/>    {<br/>     count++;<br/>    }<br/>   }<br/>   oArr[i]=count;<br/>  }<br/> }</span></pre><p id="4d88" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这里，我们检查了<strong class="lk jd">学生成绩数组</strong>的每个元素，并检查该元素还匹配了多少其他元素。然后，我们根据每个等级获得的匹配数量创建直方图。在下面的示例<strong class="lk jd">中，年级2 </strong>由学生1、3和4评分。因此，等级2得到3个匹配，并且其对应的直方图柱反映3。</p><ul class=""><li id="0be7" class="mw mx it lk b ll lm lo lp lr my lv mz lz na md nb nc nd ne bi translated">我们与所有其他元素进行比较的元素位于索引<strong class="lk jd"> i </strong></li><li id="9339" class="mw mx it lk b ll nf lo ng lr nh lv ni lz nj md nb nc nd ne bi translated">与<strong class="lk jd"> i进行比较的元素位于索引j </strong></li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/1d6ba55e50821e0eaa7a04a985c2d14b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OGuMz0draZEZHuQWYx0ziQ.gif"/></div></div></figure><p id="3379" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以看到，这是一种浪费的方法，因为我们多次检查2级。这个<strong class="lk jd">反复扫描</strong>使程序运行在O(N)中。我们不需要一遍又一遍地扫描这个数组。</p><p id="6ffb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看O(N)方法。</p><h2 id="35c9" class="ok ol it bd or os ot dn ou ov ow dp ox lr oy oz pa lv pb pc pd lz pe pf pg iz bi translated">快速方法</h2><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="7386" class="ok ol it og b gy om on l oo op"><strong class="og jd">//Function to compute histogram faster O(N)</strong><br/> public void getHistFast(int iArr[], int oArr[])<br/> {<br/>  int i;<br/>  for(i=0;i&lt;iArr.length;i++)<br/>  { <br/>   oArr[iArr[i]] = oArr[iArr[i]] + 1;<br/>  }<br/> }</span></pre><p id="eb1b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个方法中，我们访问学生成绩数组中的每个学生，并查看其成绩。我们转到相应的等级直方图元素并更新等级计数。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/df82edc17fd9b5b8e2368092fb096feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0VyaMRjNn216m8O53gHBCQ.gif"/></div></div></figure></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="bd2c" class="pi ol it bd or pj pk pl ou pm pn po ox ki pp kj pa kl pq km pd ko pr kp pg ps bi translated">分析</h1><p id="0ce2" class="pw-post-body-paragraph li lj it lk b ll pt kd ln lo pu kg lq lr pv lt lu lv pw lx ly lz px mb mc md im bi translated">当我们取20名分数在0-9之间的学生时，我们得到以下输出</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi py"><img src="../Images/a5b9ca08744db83c5663d1d565240d93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LrtIAY-R7gAEFV5j3V5QMg.png"/></div></div></figure><h2 id="2aae" class="ok ol it bd or os ot dn ou ov ow dp ox lr oy oz pa lv pb pc pd lz pe pf pg iz bi translated">转速试验</h2><p id="32e9" class="pw-post-body-paragraph li lj it lk b ll pt kd ln lo pu kg lq lr pv lt lu lv pw lx ly lz px mb mc md im bi translated">我们通过增加学生的数量来比较快速和慢速方法。虽然我们看不到慢速方法的O(N)行为，但它肯定比快速方法慢很多倍。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pz"><img src="../Images/6afa64bfe71bef239d0e1c095880bb12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*umwH2CwyYyIwAe87Zk_Tyg.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qa"><img src="../Images/4f649888e65a40e34cada48b5748452c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yo0RX42KC81z__F5FPm8NQ.png"/></div></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qb od l"/></div></figure></div></div>    
</body>
</html>