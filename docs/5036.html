<html>
<head>
<title>How to use Java Threads in Scala?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Scala中使用Java线程？</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/how-to-use-java-threads-in-scala-d93d34d3b8b5?source=collection_archive---------2-----------------------#2020-09-03">https://medium.datadriveninvestor.com/how-to-use-java-threads-in-scala-d93d34d3b8b5?source=collection_archive---------2-----------------------#2020-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="df85" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">SCALA概念</h2><div class=""/><div class=""><h2 id="14db" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">多线程是一种同时运行多个线程的机制。它允许您同时执行各种操作。</h2></div><p id="f3e6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">线程是占用较少内存的轻量级子进程。多线程可以用来在Scala中构建并发应用。</p><p id="5137" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">Scala没有为创建线程提供任何单独的库。如果你熟悉Java的多线程概念，你会知道除了Scala语言本身的语法之外，它是相似的。</p><p id="80ca" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">可以通过两种不同的方式创建线程。</p><ul class=""><li id="e7f7" class="ln lo it kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">扩展线程类</li><li id="7813" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">实现Runnable接口</li></ul><div class="mb mc gp gr md me"><a href="https://www.datadriveninvestor.com/2019/09/17/work-begins-on-java-14-as-java-13-set-to-launch/" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd jd gy z fp mj fr fs mk fu fw jc bi translated">Java 14工作开始，Java 13即将发布|数据驱动投资者</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">随着Java 13准备于2019年9月17日上线，科技公司更令人兴奋的发展已经开始了…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms mt me"/></div></div></a></div><h1 id="8c18" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">Scala中的线程类</h1><p id="a37f" class="pw-post-body-paragraph kr ks it kt b ku nm kd kw kx nn kg kz la no lc ld le np lg lh li nq lk ll lm im bi translated">下面的示例从Thread类继承，并重写run方法。使用start()方法点燃一个线程。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="98fa" class="oa mv it nw b gy ob oc l od oe">object Main extends App {<br/> var thread = new ScalaThreadExample()  <br/> thread.start() <br/>}</span><span id="cefc" class="oa mv it nw b gy of oc l od oe">class ScalaThreadExample extends Thread{  <br/> override def run(){  <br/>  println("Thread in scala in running !!");  <br/> }  <br/>}</span></pre><figure class="nr ns nt nu gt oh gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi og"><img src="../Images/725d45180ae76338556e397fcdc9e07c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hiSrRvwG5C8gTNxjJBcE8Q.gif"/></div></div></figure><h1 id="c792" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">在Scala中实现Runnable接口</h1><p id="32d8" class="pw-post-body-paragraph kr ks it kt b ku nm kd kw kx nn kg kz la no lc ld le np lg lh li nq lk ll lm im bi translated">下面的示例实现Runnable接口并重写run方法。使用start方法点燃一个线程。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="c77a" class="oa mv it nw b gy ob oc l od oe">object Main extends App {<br/> var runnableObj = new ScalaRunnableThreadExample()  <br/> var threadRunnable = new Thread(runnableObj)  <br/> threadRunnable.start()  <br/>}</span><span id="e287" class="oa mv it nw b gy of oc l od oe">class ScalaRunnableThreadExample extends Runnable{  <br/> override def run(){  <br/>  println("Thread is running using the Runnable interface !!")  <br/> }  <br/>}</span></pre><figure class="nr ns nt nu gt oh gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi on"><img src="../Images/5d76e991a5925b0f97c21a4a8eb06bef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*la_kNbGLLgbxlgthDB_F7g.gif"/></div></div></figure><h1 id="0127" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">Scala中的线程类提供了</h1><p id="c244" class="pw-post-body-paragraph kr ks it kt b ku nm kd kw kx nn kg kz la no lc ld le np lg lh li nq lk ll lm im bi translated">处理线程状态的各种方法如下:</p><h2 id="e471" class="oa mv it bd mw oo op dn na oq or dp ne la os ot ng le ou ov ni li ow ox nk iz bi translated">Scala线程睡眠()</h2><p id="fdda" class="pw-post-body-paragraph kr ks it kt b ku nm kd kw kx nn kg kz la no lc ld le np lg lh li nq lk ll lm im bi translated">上面的过程让线程休眠一段指定的时间，这段时间以毫秒为参数指定。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="84ca" class="oa mv it nw b gy ob oc l od oe">object Main extends App {<br/> <br/> var thread1=new ThreadSleepExample();<br/> var thread2=new ThreadSleepExample();<br/> thread1.start()<br/> thread2.start()<br/>}</span><span id="5459" class="oa mv it nw b gy of oc l od oe">class ThreadSleepExample extends Thread{  <br/> override def run(){  <br/>  for(i&lt;- 0 to 5){  <br/>   println(i)  <br/>   Thread.sleep(500)  <br/>  }  <br/> }<br/>}</span></pre><figure class="nr ns nt nu gt oh gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi oy"><img src="../Images/694e7822c50be9a3133c79ba1f41d5cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nAO_eR32QDO0n9VyCgYsaw.gif"/></div></div></figure><h2 id="c0d8" class="oa mv it bd mw oo op dn na oq or dp ne la os ot ng le ou ov ni li ow ox nk iz bi translated">Scala线程连接()</h2><p id="6027" class="pw-post-body-paragraph kr ks it kt b ku nm kd kw kx nn kg kz la no lc ld le np lg lh li nq lk ll lm im bi translated">join()方法等待前一个线程死亡，意味着join()进程保持当前正在运行的线程的执行，直到指定的线程完成其执行。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="e720" class="oa mv it nw b gy ob oc l od oe">object Main extends App {<br/> <br/> var thread3=new ThreadSleepExample();<br/> thread1.start()<br/> thread1.join()<br/> thread2.start()<br/> thread3.start()<br/>}</span><span id="e848" class="oa mv it nw b gy of oc l od oe">class ThreadSleepExample extends Thread{  <br/> override def run(){  <br/>  for(i&lt;- 0 to 5){  <br/>   println(i)  <br/>   Thread.sleep(500)  <br/>  }  <br/> }<br/>}</span></pre><figure class="nr ns nt nu gt oh gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi oy"><img src="../Images/89fce4a79d6a9118b2ec9e1e22d440cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9kj5fxhlPlikp8FR0sBiyA.gif"/></div></div></figure><h2 id="051e" class="oa mv it bd mw oo op dn na oq or dp ne la os ot ng le ou ov ni li ow ox nk iz bi translated">Scala集合名称()</h2><p id="631b" class="pw-post-body-paragraph kr ks it kt b ku nm kd kw kx nn kg kz la no lc ld le np lg lh li nq lk ll lm im bi translated">setName方法为线程提供了唯一名称。</p><p id="758b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">对象主扩展应用程序{</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="4403" class="oa mv it nw b gy ob oc l od oe">var thread4=new ThreadSetNameExample();<br/> thread4.setName("Thread 4");<br/> thread4.start()<br/>}</span><span id="2bd6" class="oa mv it nw b gy of oc l od oe">class ThreadSetNameExample() extends Thread{  <br/> override def run(){  <br/>  for(i&lt;- 0 to 5){  <br/>   println(this.getName()+" - "+i)  <br/>   Thread.sleep(500)  <br/>  }  <br/> }  <br/>}</span></pre><figure class="nr ns nt nu gt oh gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi oy"><img src="../Images/c12b5f87f9836fe905bd24a00201d6df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*04aiDJAa3jvKOe_ec-hoZQ.gif"/></div></div></figure></div><div class="ab cl oz pa hx pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="im in io ip iq"><h2 id="60d6" class="oa mv it bd mw oo op dn na oq or dp ne la os ot ng le ou ov ni li ow ox nk iz bi translated">GitHub回购</h2><div class="mb mc gp gr md me"><a href="https://github.com/ssukhpinder/threading-scala" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd jd gy z fp mj fr fs mk fu fw jc bi translated">ssukhpinder/线程-scala</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">如何在Scala中使用java线程概念？为ssukhpinder/threading-scala开发做出贡献，创建一个…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">github.com</p></div></div><div class="mn l"><div class="pg l mp mq mr mn ms mt me"/></div></div></a></div><h2 id="172f" class="oa mv it bd mw oo op dn na oq or dp ne la os ot ng le ou ov ni li ow ox nk iz bi translated">为什么使用线程？</h2><ul class=""><li id="fa60" class="ln lo it kt b ku nm kx nn la ph le pi li pj lm ls lt lu lv bi translated">减少开发时间。</li><li id="c32c" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">降低支持成本。</li><li id="2a20" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">它有助于提高复杂应用程序的性能。</li><li id="cadc" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">对UI的响应很有用。</li><li id="63f3" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">线程在服务器应用程序中用于高吞吐量和资源利用率。</li><li id="7b61" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">并行化作业。</li><li id="6a67" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">如果一个线程不能利用CPU的所有资源，运行另一个线程可以避免这些资源闲置。</li></ul><h2 id="62a7" class="oa mv it bd mw oo op dn na oq or dp ne la os ot ng le ou ov ni li ow ox nk iz bi translated">缺点:</h2><ul class=""><li id="5ab6" class="ln lo it kt b ku nm kx nn la ph le pi li pj lm ls lt lu lv bi translated">多个线程在共享公共硬件资源时可能会相互干扰。</li><li id="a9b5" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">多线程的硬件维护对软件来说更明显，因此比多处理需要对应用程序和操作系统进行更多的修改。</li></ul></div><div class="ab cl oz pa hx pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="im in io ip iq"><p id="e102" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">感谢您的阅读。请继续访问并在你的网络中分享。请把你的想法和反馈放在评论区。</p><p id="a722" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在<a class="ae pk" href="https://www.linkedin.com/in/sukhpinder-singh-532284a2/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><a class="ae pk" href="https://www.instagram.com/sukhpindersukh/" rel="noopener ugc nofollow" target="_blank">insta gram</a><a class="ae pk" href="https://www.facebook.com/sukhpinder.singh.52/" rel="noopener ugc nofollow" target="_blank">脸书</a> <a class="ae pk" href="https://twitter.com/sukhsukhpinder" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p><p id="2fa7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">访问专家视图— </strong> <a class="ae pk" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>