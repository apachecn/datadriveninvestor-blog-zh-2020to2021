<html>
<head>
<title>4 approaches on how to create reliable messaging architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于如何创建可靠的消息传递架构的4种方法</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/4-approaches-on-how-to-create-reliable-messaging-architecture-4aefcfc13cfd?source=collection_archive---------0-----------------------#2020-06-14">https://medium.datadriveninvestor.com/4-approaches-on-how-to-create-reliable-messaging-architecture-4aefcfc13cfd?source=collection_archive---------0-----------------------#2020-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2043dc35046677a3eee4cf0ba4e7e39e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gBrq3UGYUVJ76p5D"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@katemacate?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kate Macate</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7eca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">微服务架构现在很流行。它经常通过消息传递基础设施与异步数据处理结合在一起。我所说的异步处理是指在后台执行的数据处理功能。从这个意义上说，我们公司也不例外，我们在应用程序中使用了大量的消息传递。它允许在后台处理耗时的任务。用户不必等到事情处理完毕。应用程序对用户的响应也变得更快。</p><p id="a16e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你有没有想过如何处理容忍各种错误的消息？并且还需要更少的人工来处理这些错误？让我向您介绍消息管道中的消息重试、等幂和发件箱。</p><p id="786c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将描述如何使用<a class="ae kc" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>和<a class="ae kc" href="https://masstransit-project.com/" rel="noopener ugc nofollow" target="_blank"> MassTransit </a>库实现错误处理。它将使您的数据处理管道更具弹性和可靠性。</p><p id="f3d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在成功运行本文中使用的示例代码之前，有一些先决条件:</p><ul class=""><li id="d4bd" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">在<a class="ae kc" href="https://www.rabbitmq.com/install-windows.html" rel="noopener ugc nofollow" target="_blank"> Windows </a>或者<a class="ae kc" href="https://www.rabbitmq.com/install-debian.html" rel="noopener ugc nofollow" target="_blank"> Linux </a>上安装RabbitMQ。</li><li id="3c05" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">安装<a class="ae kc" href="https://dotnet.microsoft.com/download/dotnet-core/3.1" rel="noopener ugc nofollow" target="_blank">。网芯3.1 SDK </a></li><li id="9364" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">安装<a class="ae kc" href="https://www.mongodb.com/try/download/community" rel="noopener ugc nofollow" target="_blank"> MongoDB </a></li></ul><p id="d669" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，本文假设您已经掌握了C#知识以及RabbitMQ、MassTransit和MongoDB的基础知识。</p><h2 id="69a0" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">一级重试</h2><p id="656b" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">想象一下，您集成的服务之一在几分钟内变得不可用。当调用特定服务时，您很可能会得到服务不可用异常。这可能不会立即导致消息处理失败，因为消息将被移动到错误队列中，谁愿意手动处理潜在的大量消息呢？在这种情况下，第一级重试是救命稻草。</p><div class="mn mo gp gr mp mq"><a href="https://www.datadriveninvestor.com/2018/08/02/making-the-leap-from-speech-to-dialogue-the-challenge-for-human-to-machine-communication/" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">从语音到对话的飞跃:人机交流的挑战</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">机器人无处不在，几乎无所不在。我们甚至已经开始与他们交谈，在这种情况下…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne jw mq"/></div></div></a></div><p id="7b80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们主要用于处理暂时性异常，如数据库死锁、短暂连接不可用，以及其他类型的情况，此时问题持续时间很短，应用程序可以快速恢复。</p><p id="8e10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是如何配置一级重试的代码示例。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a082" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我创建了一个简单的。NET核心控制台应用程序来显示启用重试所需的配置，并添加了一个普通消息处理程序来测试重试逻辑。请注意，当您运行应用程序时，消息会重试三次。</p><p id="e3ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在<a class="ae kc" href="https://masstransit-project.com/usage/exceptions.html#retry" rel="noopener ugc nofollow" target="_blank">大众运输文档</a>中了解更多关于一级重试的信息。</p><h2 id="f126" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">二级(重新传递)重试</h2><p id="4e46" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">当您与其他系统集成时，这些重试特别有用，这些系统可能会由于各种原因而长期不可用。您的应用程序应该容忍这种情况，而不是立即将消息发送到错误队列。错误队列是消息处理管道中的最后一招。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e4ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我通过添加一个支持消息重新传递的配置，对前面的示例做了一些小小的调整。</p><p id="29d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我选择使用<a class="ae kc" href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ延迟消息插件</a>，因为它是Quartz的轻量级替代，不需要RabbitMQ之外的任何存储。</p><p id="6894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您需要完成几个步骤才能进行重新交付。为了让RabbitMQ工作，你还需要按照<a class="ae kc" href="https://www.rabbitmq.com/installing-plugins.html" rel="noopener ugc nofollow" target="_blank">插件安装指南</a>安装<code class="fe nl nm nn no b">rabbitmq_delayed_message_exchange</code>插件。安装完插件后，在RabbitMQ sbin命令行中运行<code class="fe nl nm nn no b">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</code>命令来启用它。</p><p id="5a2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">启用它并启动应用程序后，将创建一个新的交换(见下图)来存储需要在一段配置时间后重试的消息，并保证在RabbitMQ节点重新启动时消息不会丢失。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/92e5df0ed066f0d92cacf8f4986c9cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fVdlwQ_FjhSVfFbkOE5YLg.png"/></div></div></figure><p id="e14e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在<a class="ae kc" href="https://masstransit-project.com/usage/exceptions.html#redelivery" rel="noopener ugc nofollow" target="_blank">大众运输文档</a>中了解更多关于重新交付的信息。当您运行更新后的应用程序时，您会注意到第一级重试是在开始时执行的，只有到那时，对于在第一级重试期间未成功处理的邮件，才会重新传递。在这个例子中，消息最终会出现在错误队列中，因为异常总是被抛出。在这种情况下，重新交付无济于事。</p><p id="d2b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">不重试某些异常</strong></p><p id="fe52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在执行第一级或第二级重试的过程中，您可能会遇到应该忽略特定类型的异常的情况。例如，如果消息没有通过某些特定的验证，就不应该重试。幸运的是，MassTransit提供了这样的功能，它被称为<a class="ae kc" href="https://masstransit-project.com/usage/exceptions.html#exception-filters" rel="noopener ugc nofollow" target="_blank">异常过滤器</a>。您可以忽略某些异常，或者只重试特定的异常。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9004" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与前一个示例相比，我在两个地方添加了这行代码。</p><p id="3a9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nl nm nn no b">retryConfigurator.Ignore(typeof(NameTooShortException));</code></p><p id="c085" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这告诉我们对于第一级和第二级重试都忽略重试<code class="fe nl nm nn no b">NameTooShortException</code>。</p><h2 id="0766" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">消息幂等性</h2><p id="6acb" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">下面是来自<a class="ae kc" href="https://en.wikipedia.org/wiki/Idempotence" rel="noopener ugc nofollow" target="_blank">维基百科</a>的幂等性定义:</p><blockquote class="nq nr ns"><p id="f78c" class="kd ke nt kf b kg kh ki kj kk kl km kn nu kp kq kr nv kt ku kv nw kx ky kz la ij bi translated"><strong class="kf ir">幂等性</strong> ( <a class="ae kc" href="https://en.wikipedia.org/wiki/British_English" rel="noopener ugc nofollow" target="_blank">英国</a> : <a class="ae kc" href="https://en.wikipedia.org/wiki/Help:IPA/English" rel="noopener ugc nofollow" target="_blank"> /ˌɪdɛmˈpoʊtəns/ </a>，<a class="ae kc" href="https://en.wikipedia.org/wiki/Idempotence#cite_note-1" rel="noopener ugc nofollow" target="_blank">【1】</a><a class="ae kc" href="https://en.wikipedia.org/wiki/American_English" rel="noopener ugc nofollow" target="_blank">美国</a>:<a class="ae kc" href="https://en.wikipedia.org/wiki/Help:IPA/English" rel="noopener ugc nofollow" target="_blank">/ˌaɪdəm-/</a>)<a class="ae kc" href="https://en.wikipedia.org/wiki/Idempotence#cite_note-2" rel="noopener ugc nofollow" target="_blank">【2】</a>是<a class="ae kc" href="https://en.wikipedia.org/wiki/Mathematics" rel="noopener ugc nofollow" target="_blank">数学</a>和<a class="ae kc" href="https://en.wikipedia.org/wiki/Computer_science" rel="noopener ugc nofollow" target="_blank">计算机科学</a>中某些<a class="ae kc" href="https://en.wikipedia.org/wiki/Operation_(mathematics)" rel="noopener ugc nofollow" target="_blank">运算</a>的属性，由此它们可以被多次应用而不改变超出初始应用的结果。</p></blockquote><p id="a916" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能会问，这如何适用于信息传递。在消息传递体系结构中，幂等性意味着确保可以无限次处理相同的消息，并且结果总是相同的。这意味着没有重复的数据库记录，没有电子邮件，或其他类型的通知发送多次。这种方法有以下好处:</p><ul class=""><li id="0f60" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">不需要交易。它们在消息传递基础设施中可能相当棘手。通常，消息处理程序调用其他服务，跨多个系统管理事务是相当困难的。</li><li id="d794" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">允许使用重试，而不用担心使用者第二次处理消息时可能会失败。</li></ul><p id="ac1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如何开始使用？为了避免在数据库中创建重复的记录，您需要添加一个检查。它将在添加新记录之前验证该记录是否存在。如果记录已经存在，您应该返回现有记录或跳过创建新记录。这取决于具体的用例。</p><p id="b562" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免重复发送通知，例如电子邮件或短信，您需要将之前发送的信息保存在某个地方。最明显的选择是数据库。然后添加一个逻辑来验证是否已经发送了相同类型的通知。</p><p id="37a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在消费者端的所有地方应用这种模式，您将能够无限次地处理相同的消息。</p><h2 id="ea39" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">邮件发件箱</h2><p id="a7c6" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">提高消息传递可靠性的另一种方法是在生产者(发布者)端使用消息发件箱。当你失去和RabbitMQ的连接时，信息发件箱是一个很好的处理方法。您希望在不使用户操作失败的情况下将消息发送给消费者。</p><p id="c6c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实现这一点的一种方法是添加一些持久性存储来保存序列化的消息。持久存储的类型无关紧要。这可能取决于您公司使用的数据库技术，也可能是您最了解的数据库。您还需要创建一个基于计时器的后台作业，稍后将重新发送这些失败的消息。这将保证消息不会丢失。当然，数据库也可能不可用。在这种情况下，一种选择是在GUI中显示出错的错误消息，用户应该联系支持人员。</p><p id="4874" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我向您展示创建发件箱的两种可能方式。</p><p id="0c27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">MassTransit提供<a class="ae kc" href="https://masstransit-project.com/2020/02/08/in-memory-outbox/" rel="noopener ugc nofollow" target="_blank">内存信息发件箱</a>。你可以观看克里斯·帕特森的一个很棒的<a class="ae kc" href="https://www.youtube.com/watch?v=P41IsVAc1nI" rel="noopener ugc nofollow" target="_blank">视频</a>，在那里他展示了《发件箱》与传奇的实践。你可以在<a class="ae kc" href="https://github.com/phatboyg/Trashlantis" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看他的源代码。</p><p id="c471" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将展示如何实现消息发件箱的另一种方法。在我的例子中，消息发件箱驻留在生产者端，它可以处理RabbitMQ关闭时的情况。</p><p id="c3a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我使用了以下技术:</p><ul class=""><li id="09a7" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><a class="ae kc" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a></li><li id="0ee6" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://masstransit-project.com/" rel="noopener ugc nofollow" target="_blank"> MassTransit </a>库</li><li id="07e1" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://dotnet.microsoft.com/download/dotnet-core/3.1" rel="noopener ugc nofollow" target="_blank">。网络核心3.1 </a></li><li id="a5a5" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a></li></ul><p id="4bb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经创建了。NET核心控制台应用程序，并使用<a class="ae kc" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-3.1&amp;tabs=visual-studio#worker-service-template" rel="noopener ugc nofollow" target="_blank">工人服务</a>模板来托管三种类型的服务:</p><ul class=""><li id="e169" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">消息发布者服务</li><li id="9a78" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">信息发件箱处理服务</li><li id="2ff2" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">消费者服务</li></ul><p id="aabd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果发布失败，Message publisher服务负责将消息保存在MongoDB中。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="999d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">消息发件箱处理服务从MongoDB收集所有未处理的消息，并尝试发布它们。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="0a25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，在进行消息处理时，我使用了MongoDB事务。如果失败，消息状态将设置回未处理。使用事务的另一个原因是确保数据库中的记录在事务期间被锁定。下面是启动事务的方法的示例。该类的完整代码可在<a class="ae kc" href="https://github.com/viktors-telle/mass-transit-examples/blob/master/src/MessageOutbox/Outbox/MessageOutboxRepository.cs" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="dba6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果上一步运行正常，消费者服务将会收到这些消息。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="fb42" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">结论</h2><p id="e154" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这里描述的方法在生产环境中经过了实战检验，效果相当好。消息重发、等幂和发件箱减少了支持工程师的手工工作，使我们的服务更加稳定，对各种错误更有弹性。</p><p id="f20a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在<a class="ae kc" href="https://github.com/viktors-telle/mass-transit-examples" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看完整的例子。</p><p id="e661" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">访问专家视图— </strong> <a class="ae kc" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>