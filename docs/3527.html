<html>
<head>
<title>Node.js Tips — File Operations, Command Line Arguments, and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示—文件操作、命令行参数等等</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/node-js-tips-file-operations-command-line-arguments-and-more-cab0e6646230?source=collection_archive---------3-----------------------#2020-06-23">https://medium.datadriveninvestor.com/node-js-tips-file-operations-command-line-arguments-and-more-cab0e6646230?source=collection_archive---------3-----------------------#2020-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0b30c292a3dfb656f4aa4907a2a90376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aKDeI5nkOI_IND_5"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@thejroc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jared Short</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2ffd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="9b16" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将命令行参数传递给Node.js程序</h1><p id="ff45" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们通过使用<code class="fe mh mi mj mk b">process.argv</code>属性获得命令行参数。</p><p id="cd59" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个包含所有参数的数组，包括<code class="fe mh mi mj mk b">node</code>和脚本名。</p><p id="b49f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">'node'</code>总是第一个进入。</p><p id="b545" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">脚本名称是第二个条目。</p><p id="5be8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其余的参数是剩余的条目。</p><p id="89c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3b51" class="mt lf it mk b gy mu mv l mw mx">node foo.js one two=three four</span></pre><p id="e31e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后<code class="fe mh mi mj mk b">node</code>是<code class="fe mh mi mj mk b">process.argv</code>的第一个条目，<code class="fe mh mi mj mk b">foo.js</code>是第二个，<code class="fe mh mi mj mk b">one</code>是第三个，以此类推。</p><h1 id="7d76" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在Node.js中写入文件</h1><p id="33dd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">writeFile</code>方法在节点app中写一个文件。</p><p id="afc0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8cd4" class="mt lf it mk b gy mu mv l mw mx">const fs = require('fs');</span><span id="aaa3" class="mt lf it mk b gy my mv l mw mx">fs.writeFile("/foo.txt", "hello world!", (err) =&gt; {<br/>  if (err) {<br/>    return console.log(err);<br/>  }<br/>  console.log("file saved");<br/>});</span></pre><p id="24c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们调用<code class="fe mh mi mj mk b">writeFile</code>来写文件。</p><p id="e2fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个参数是文件的路径。</p><p id="f6eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个是文件的内容。</p><p id="eeb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">文件写入过程结束时调用回调。</p><p id="0022" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">err</code>是错误对象，在遇到错误时定义。</p><p id="860c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一个同步版本叫<code class="fe mh mi mj mk b">writeFileSync</code>。</p><p id="f9a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过书写来使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8510" class="mt lf it mk b gy mu mv l mw mx">fs.writeFileSync('/foo.txt', 'hello world');</span></pre><p id="7c43" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个参数是文件路径。</p><p id="4a44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二是内容。</p><h1 id="e12b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">如何调试Node.js应用程序</h1><p id="bd62" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">node-inspector</code>包来调试节点应用程序。</p><p id="2871" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过运行以下命令来安装它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="629d" class="mt lf it mk b gy mu mv l mw mx">npm install -g node-inspector</span></pre><p id="5f71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">全球安装。</p><p id="0628" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用<code class="fe mh mi mj mk b">node-inspector</code>运行<code class="fe mh mi mj mk b">node-debug app.js</code>来运行它，这让我们可以用断点、剖析等来调试它。</p><p id="6a15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以用调试器运行<code class="fe mh mi mj mk b">node inspect app.js</code>来运行<code class="fe mh mi mj mk b">app.js</code>。</p><h1 id="49c5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">读取Node.js中的环境变量</h1><p id="f37a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过使用<code class="fe mh mi mj mk b">process.env</code>对象来读取节点应用程序中的环境变量。</p><p id="bf85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有环境变量<code class="fe mh mi mj mk b">FOO</code>，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="940d" class="mt lf it mk b gy mu mv l mw mx">process.env.FOO</span></pre><h1 id="1b9c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在Javascript中移除数组中的空元素</h1><p id="768f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">要从JavaScript数组中移除empty，我们可以使用<code class="fe mh mi mj mk b">filter</code>方法。</p><p id="6a99" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0030" class="mt lf it mk b gy mu mv l mw mx">const arr = [0, 1, null, undefined, 2,3,,,,6];<br/>const filtered = arr.filter((el) =&gt; (el !== null || typeof el !== 'undefined'));</span></pre><p id="0e16" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将返回一个从<code class="fe mh mi mj mk b">arr</code>创建的数组，所有的<code class="fe mh mi mj mk b">null</code>和<code class="fe mh mi mj mk b">undefined</code>都被移除了。</p><h1 id="d160" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对forEach循环使用async/await</h1><p id="ff61" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以将<code class="fe mh mi mj mk b">async</code>和<code class="fe mh mi mj mk b">await</code>用于for-of循环。</p><p id="34c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f56c" class="mt lf it mk b gy mu mv l mw mx">const printFiles = async (filePaths) =&gt; {<br/>  for (const file of filePaths) {<br/>    const contents = await fs.readFile(file, 'utf8');<br/>    console.log(contents);<br/>  }<br/>}</span></pre><p id="2682" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用承诺版本的<code class="fe mh mi mj mk b">readFile</code>在for-of循环的每次迭代中读取文件。</p><p id="e015" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要并行运行承诺，我们可以使用<code class="fe mh mi mj mk b">Promise.all</code>方法。</p><p id="4fca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="50ba" class="mt lf it mk b gy mu mv l mw mx">const printFiles = async (filePaths) =&gt; {<br/>  await Promise.all(filePaths.map(async (file) =&gt; {<br/>    const contents = await fs.readFile(file, 'utf8')<br/>    console.log(contents)<br/>  }));<br/>}</span></pre><p id="8fec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们称<code class="fe mh mi mj mk b">map</code>为<code class="fe mh mi mj mk b">filePaths</code>来描绘通往承诺的道路。</p><p id="a2e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们在一系列的承诺中称<code class="fe mh mi mj mk b">Promise.all</code>。</p><h1 id="f28f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">获取节点应用程序目录中所有文件的名称列表</h1><p id="bfd7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过使用<code class="fe mh mi mj mk b">readdir</code>或<code class="fe mh mi mj mk b">readdirSync</code>方法获得一个目录中所有文件的名称列表。</p><p id="c582" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9de5" class="mt lf it mk b gy mu mv l mw mx">const fs = require('fs');<br/><br/>fs.readdir('/tesrDir', (err, files) =&gt; {<br/>  files.forEach(file =&gt; {<br/>    console.log(file);<br/>  });<br/>});</span></pre><p id="4397" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">files</code>拥有文件字符串、缓冲区或目录项的数组。</p><p id="3ca5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要同步读取目录，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c416" class="mt lf it mk b gy mu mv l mw mx">const fs = require('fs');<br/><br/>fs.readdirSync('/testDir').forEach(file =&gt; {<br/>  console.log(file);<br/>});</span></pre><p id="8c5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们同步读取一个目录。</p><h1 id="6999" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用Node.js解析JSON</h1><p id="bec8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以要求JSON文件或者用<code class="fe mh mi mj mk b">JSON.parse</code>解析它们。</p><p id="cd62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bfb8" class="mt lf it mk b gy mu mv l mw mx">const config = require('./config.json');</span></pre><p id="850e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cef1" class="mt lf it mk b gy mu mv l mw mx">const config = require('./config');</span></pre><p id="6202" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">扩展是可选的。</p><p id="2760" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以使用<code class="fe mh mi mj mk b">JSON.parse</code>来解析JSON字符串。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/030b03b0a8d62ea7a44ef1a0f6318730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sdLv-Fcf6f49WXP-"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@mattrobinjones?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Matt Jones</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="dfb8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="c1f0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用<code class="fe mh mi mj mk b">process.argv</code>获得命令行参数。</p><p id="546f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">环境变量被读入<code class="fe mh mi mj mk b">process.env</code>对象。</p><p id="022b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">require</code>可以用来导入JSON文件。</p><p id="adfa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">fs</code>模块有读写文件的方法。</p><p id="1316" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">for-of循环可以按顺序运行承诺。</p></div></div>    
</body>
</html>