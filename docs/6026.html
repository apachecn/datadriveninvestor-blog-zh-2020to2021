<html>
<head>
<title>Feature Engineering-Handling Missing Numeric Data with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">要素工程-使用Python处理缺失的数字数据</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/feature-engineering-handling-missing-numeric-data-with-python-7be1e871f85e?source=collection_archive---------0-----------------------#2020-10-09">https://medium.datadriveninvestor.com/feature-engineering-handling-missing-numeric-data-with-python-7be1e871f85e?source=collection_archive---------0-----------------------#2020-10-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8de9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们经常想要填满那些空的空间，不管是家、心还是数据。</p><p id="c069" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在真实的场景中，我们经常看到和观察到数据在数据集中丢失。</p><p id="0697" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在看到处理它们的技术之前，让我们看看它可能会出现什么样的问题，以及各种类型的丢失数据是什么。</p><p id="6f12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺失数据</strong>呈现各种<strong class="jp ir">问题</strong>。</p><p id="293c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1)缺失的<strong class="jp ir">数据</strong>降低了统计功效，统计功效是指当零假设为假时，测试将拒绝零假设的概率。</p><p id="5d22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2)缺失的<strong class="jp ir">数据</strong>会导致参数估计的偏差。</p><p id="37e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3)会降低样本的代表性。</p><p id="873f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">缺失数据会降低试验的效力。预计会有一些数据缺失，因此目标样本量会增加。然而，这并不能消除潜在的偏见。应该更多地关注在研究的设计和执行以及结果数据的分析中缺失的数据。</p><p id="3364" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺失数据有哪些不同类型？</strong></p><p id="cb5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.<strong class="jp ir">完全随机缺失(MCAR): </strong>如果缺失的概率对所有观测值都相同，那么变量就是完全随机缺失(MCAR)。当数据为MCAR时，缺失的数据与数据集中观察到的或缺失的任何其他值之间完全没有关系。换句话说，那些丢失的数据点是数据的随机子集。没有系统化的方法使一些数据比其他数据更容易丢失。</p><p id="15af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">MCAR的数据很少。</p><p id="ac6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的例子中，我们可以看到没有任何规则的数据丢失。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/ec940154a8b14f471c71cc2b382998c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/0*AW7E1XbSn7hJcK_-.png"/></div></figure><p id="660b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">MCAR数据的统计学优势是分析保持无偏性。设计中可能会损失功率，但估计的参数不会因为缺少数据而产生偏差。</p><p id="a542" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<strong class="jp ir">非随机缺失数据(MNAR): </strong>系统性缺失值在数据集中，缺失的数据和任何其他观察到的或缺失的值之间绝对存在某种关系。</p><p id="9c7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，获得参数无偏估计的唯一方法是对缺失数据进行建模。</p><p id="cbfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的例子中，我们可以看到，只有等于或少于30000英镑的工资丢失。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/03d8cb7fae65f439c4eacda211cf8546.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/0*EXU6QimSxHKCFnOI.jpg"/></div></figure><p id="2f46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.<strong class="jp ir">随机缺失(MAR): </strong>这里的缺失数据只受完全(观测)变量的影响，不受缺失数据本身特征的影响。换句话说，对于一个数据点，缺失与缺失的数据无关，但与部分(或全部)观察到的数据有关</p><p id="faed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们可以根据其他数据预测缺失的值。</p><p id="5318" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的例子中，我们可以看到缺失的数据是年龄&gt; 50岁的人的数据</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/6f90ed80ae9972edab8c01f876ced4fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/0*tMjrXFj4grc0YqVA.jpg"/></div></figure><p id="1f38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看如何用各种技术来处理它们。</p><p id="2152" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">处理缺失值的技巧有:</p><p id="8bed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.均值/中值/众数替换</p><p id="1136" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.随机样本插补</p><p id="984f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.用新特性捕获NAN值<strong class="jp ir"/></p><p id="c3ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.分布终点插补</p><p id="2ac7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.任意插补</p><p id="a9d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">6.频繁类别插补</p><h1 id="c920" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">均值/中值/众数插补</h1><p id="4a52" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">均值/中值插补假设数据完全随机缺失(MCAR)。我们通过将NAN替换为最频繁出现的变量来解决这个问题。</p><p id="e435" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">假设:</strong>缺失数据完全是随机的(MCAR)。</p><p id="0a82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在python中，我们可以通过以下代码来实现:</p><pre class="km kn ko kp gt ly lz ma mb aw mc bi"><span id="9700" class="md kw iq lz b gy me mf l mg mh"><strong class="lz ir">def</strong> median_rep(df,field,median):<br/> df[field+"_median"]=df[field].fillna(median)</span></pre><p id="4eb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者</p><pre class="km kn ko kp gt ly lz ma mb aw mc bi"><span id="8788" class="md kw iq lz b gy me mf l mg mh">from sklearn.preprocessing import Imputer<br/> values = mydata.values<br/> imputer = Imputer(strategy=’median’)</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/16d2beaa3c3ba1f6e6b0f19dbfe5cfe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*xVTu0A4IxmHD1ao2I_XhtA.jpeg"/></div></figure><h2 id="3888" class="md kw iq bd kx mj mk dn lb ml mm dp lf jy mn mo lj kc mp mq ln kg mr ms lr mt bi translated">优势</h2><p id="bec3" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">1)易于实施</p><p id="ad61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2)快速获取完整数据集的方法。</p><p id="0a43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3)适用于小型数值数据集。</p><p id="0608" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点</strong></p><p id="43f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1)原始方差的变化或扭曲，如上图所示。</p><p id="4dba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2)影响相关性。</p><p id="815c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3)不太准确。</p><p id="c2c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4)仅适用于列级别。</p><h1 id="644f" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">随机样本插补</h1><p id="5829" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">从变量中随机抽取样本的缺失数据。它适用于数字变量和分类变量。可以显示变量列表，或者估算者将自动选择所有变量。</p><p id="e1ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在python中，我们可以通过以下代码来实现:</p><pre class="km kn ko kp gt ly lz ma mb aw mc bi"><span id="d288" class="md kw iq lz b gy me mf l mg mh"><strong class="lz ir">def</strong> random_rep(df,field):<br/> df[field+"_random"]=df[field]<br/> <em class="mu"># random value to fill the na</em><br/> random_value=df[field].dropna().sample(df[field].isnull().sum(),random_state=0)<br/> <em class="mu">#pandas need to have same index in order to merge the dataset</em><br/> random_value.index=df[df[field].isnull()].index<br/> df.loc[df[field].isnull(),field+'_random']=random_sample</span></pre><p id="f910" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">或</strong></p><pre class="km kn ko kp gt ly lz ma mb aw mc bi"><span id="1b53" class="md kw iq lz b gy me mf l mg mh">imputer = mdi.RandomSampleImputer(random_state=[field1, field2],<br/> seed='observation',<br/> seeding_method='add'/’mutiply’)</span></pre><ul class=""><li id="fbef" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated"><strong class="jp ir"> random_state </strong> ( <em class="mu">，default = None</em>)—random _ state可以取一个整数来设置抽取随机样本时的种子。或者，它可以采用变量名或变量列表，这些值将用于确定每个观察的种子观察。</li><li id="fe6c" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><strong class="jp ir">种子</strong> ( <em class="mu">，default = ' general '</em>)-指示是否应为每个具有缺失值的观察值设置种子，或者是否应使用一个种子一次性估算所有变量。</li><li id="0e1b" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">概述:一个种子将用于估算整个数据框。这相当于在熊猫身上播下种子。样本(random_state)。</li><li id="287c" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">观察:将使用random_state中指示的变量值为每个观察设置种子。</li><li id="3f40" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><strong class="jp ir"> seeding_method </strong> ( <em class="mu">，default='add' </em> ) —如果指示多个字段为每个观察值的随机抽样播种，您可以选择以加法或乘法的方式组合这些值。可以接受值“加”或“乘”。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/c96628369d0935e04b49372de6ce18ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*wwBAseCQoRhwsPX6H03tRg.jpeg"/></div></figure><p id="3a3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">优势</strong></p><p id="842f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1)易于实现。</p><p id="46eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2)随机抽样插补保留了原始分布，这与其他插补技术不同。</p><p id="3d7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3)方差失真较小</p><p id="0679" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点</strong></p><p id="07ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.随机性能否起作用取决于特定的数据条件，但并非在所有情况下都有用。</p><h1 id="6fac" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">通过新增功能获取NAN值</h1><p id="7eda" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">如果数据不是完全随机丢失的(MNAR)，这种策略很有效。</p><p id="497e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用键值0或1捕获Nan值，并用任何策略(如均值、中值或众数)替换字段中的Nan值。</p><p id="cc57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样我们就有了一个密钥，可以进一步查看Nan值是否对数据分布有任何影响。</p><p id="b9e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">假设:</strong>对于随机不完全缺失的数据(MNAR)。</p><p id="9f50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在python中，我们可以通过以下代码来实现:</p><pre class="km kn ko kp gt ly lz ma mb aw mc bi"><span id="6db7" class="md kw iq lz b gy me mf l mg mh"><strong class="lz ir">def</strong> capture_nan(df,field):<br/> <strong class="lz ir">import</strong> <strong class="lz ir">numpy</strong> <strong class="lz ir">as</strong> <strong class="lz ir">np</strong><br/> df[field+’_NAN']=np.where(df[field].isnull(),1,0)</span></pre><p id="5dee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">优势</strong></p><p id="b4de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.实现起来很容易。</p><p id="fdb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.捕捉缺失值的重要性</p><p id="8b4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点</strong></p><p id="a71b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.创建附加功能。</p><p id="8181" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有许多字段需要跟踪缺失值，那么这会产生更高维的数据。(维度的诅咒)</p><h1 id="c7bb" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">分布终点插补</h1><p id="0b34" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">如果通过观察，一个人感觉丢失的值不是随机的，那么获取该信息是重要的。在这种情况下，人们会希望用变量的<strong class="jp ir">分布</strong>尾部的值来替换丢失的数据。</p><p id="b864" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">假设:</strong>缺失值不是随机的。(蒙古国)</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/fbba646778bc817166f4b74428c00458.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*GkqpTIiVG5CDc_m8BcktZw.jpeg"/></div></div></figure><p id="23c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在python中，我们可以通过以下代码来实现:</p><pre class="km kn ko kp gt ly lz ma mb aw mc bi"><span id="7d2d" class="md kw iq lz b gy me mf l mg mh"><strong class="lz ir">def</strong> extreme_rep(df,field,extreme): <br/>  extreme=df.field.mean()+3*df.field.std()<br/> df[field+"_end_distribution"]=df[field].fillna(extreme)</span><span id="3a99" class="md kw iq lz b gy np mf l mg mh">##Or</span><span id="e956" class="md kw iq lz b gy np mf l mg mh"><em class="mu"># set up the imputer</em><br/>import feature_engine.missing_data_imputers as mdi <br/>tail_imputer = mdi.EndTailImputer(distribution='gaussian',tail='right',fold=3,variables=[field])</span></pre><p id="5473" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mu">高斯极限:</em> </strong></p><p id="aac4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">右尾:平均值+3 *标准差</p><p id="be28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">左尾:平均值-3 *标准差</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nq"><img src="../Images/1f0e87cdd68990d68ab8932b86cdbeb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*ytFAhrBfUUPvbigYFYFwxw.jpeg"/></div></div></figure><p id="4d47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">优点</strong></p><p id="f5df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.易于快速实施。</p><p id="5b30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.它捕捉丢失值的重要性(如果有人怀疑丢失的数据是有价值的)</p><p id="ad3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点</strong></p><p id="760c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.如果丢失的数据不重要，这种行为可能会扭曲变量，掩盖预测能力。</p><p id="b457" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.如果缺失数据很大，隐藏真实的异常值，或者创建一个非预期的异常值。</p><h1 id="0167" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">任意值插补</h1><p id="a7a8" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">它被定义为用一个<strong class="jp ir">任意值</strong>替换变量中所有出现的缺失<strong class="jp ir">值</strong>。理想情况下，该值应不同于中值/平均值/众数，并且不在变量的正常<strong class="jp ir">范围</strong>内。</p><p id="56e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">假设:</strong>数据不是随机缺失的。(蒙古国)</p><pre class="km kn ko kp gt ly lz ma mb aw mc bi"><span id="6141" class="md kw iq lz b gy me mf l mg mh"><strong class="lz ir">def</strong> arb_rep(df,field,arbVal):<br/> df[field+"_arbVal"]=df[field].fillna(arbVal)</span></pre><p id="bd48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者</p><pre class="km kn ko kp gt ly lz ma mb aw mc bi"><span id="df29" class="md kw iq lz b gy me mf l mg mh">from sklearn.impute import SimpleImputer<br/># create the imputer, with fill value 99 as the arbitrary value<br/>imputer = SimpleImputer(missing_values=np.nan, strategy='constant', fill_value=99)</span></pre><p id="0c85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">优点</strong></p><ol class=""><li id="8b94" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk nr nb nc nd bi translated">实现起来很容易。</li><li id="8ac4" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk nr nb nc nd bi translated">这是获得完整数据集的快速方法。</li><li id="d2a1" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk nr nb nc nd bi translated">它捕捉了一个值“丢失”的重要性，如果有一个值的话。</li></ol><p id="6777" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点</strong></p><ol class=""><li id="336c" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk nr nb nc nd bi translated">原始变量分布和方差的失真。</li><li id="707e" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk nr nb nc nd bi translated">剩余数据集变量的协方差失真。</li><li id="3351" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk nr nb nc nd bi translated">如果任意值位于分布的末端，它可能会屏蔽或创建<strong class="jp ir">异常值</strong>。</li><li id="e40a" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk nr nb nc nd bi translated">我们需要小心，不要选择与均值或中值(或变量分布的任何其他典型值)过于相似的任意值。</li><li id="5a23" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk nr nb nc nd bi translated">NA的百分比越高，失真就越高。</li></ol></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="cf5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mu">原载于2020年10月9日https://www.numpyninja.com</em><a class="ae nz" href="https://www.numpyninja.com/post/feature-engineering-handling-missing-data-with-python" rel="noopener ugc nofollow" target="_blank"><em class="mu"/></a><em class="mu">。</em></p></div></div>    
</body>
</html>