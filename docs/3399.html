<html>
<head>
<title>Quickly Learn How You Can Improve Your Java Coding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速了解如何改进Java编码</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/quickly-learn-how-you-can-improve-your-java-coding-c0fc02d4bcaa?source=collection_archive---------3-----------------------#2020-06-16">https://medium.datadriveninvestor.com/quickly-learn-how-you-can-improve-your-java-coding-c0fc02d4bcaa?source=collection_archive---------3-----------------------#2020-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/1c8496805383456b75eaf3d96b68bcb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*uJU1ZZqHHZJLEfZ_.jpeg"/></div></figure><p id="4069" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在《实践论》和其他新儒家著作中，伟大的中国政治家和哲学家王阳明写下了这样的话:</p><blockquote class="ku kv kw"><p id="0d66" class="ju jv ks jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated">情欲与日俱增，就像地板上的灰尘。如果你不每天打扫灰尘，它会积累。如果你努力了，你会发现人生的旅程没有尽头。你探索得越多，剩下的知识就越多。必要的是精确、清晰和完整。</p></blockquote><p id="744d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">王阳明的至理名言对我们今天的日常生活仍然非常有意义。坏代码就像欲望和灰尘一样，每天都在增加。如果你不经常清理它，它会积累。但是，如果你努力清理糟糕的代码，你可以提高你的编程能力，让你的代码精确清晰，没有怀疑的余地。本文基于一位阿里云工程师的实际编码工作，介绍了三种改进你的Java代码的方法，并提供了糟糕的代码样本。</p><div class="la lb gp gr lc ld"><a href="https://www.datadriveninvestor.com/2020/02/26/surviving-in-a-digital-age-of-instability/" rel="noopener  ugc nofollow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd ir gy z fp li fr fs lj fu fw ip bi translated">在不稳定的数字时代生存|数据驱动的投资者</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">如果你是一名计算机科学家，你可能已经注意到新的框架不断出现。编程…</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr js ld"/></div></div></a></div><h1 id="412e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">提高代码性能</h1><h1 id="8543" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">当使用映射的主键和值时，迭代<code class="fe mq mr ms mt b">entrySet()</code></h1><p id="c847" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">当使用主键和值时，应该迭代<code class="fe mq mr ms mt b">entrySet()</code>。这比迭代<code class="fe mq mr ms mt b">keySet()</code>然后获取值更有效。</p><p id="f38e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="9332" class="nh lt iq mt b gy ni nj l nk nl">Map&lt;String, String&gt; map = ...;<br/>for (String key : map.keySet()) {<br/>    String value = map.get(key);<br/>    ...<br/>}</span></pre><p id="5bd0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="adbc" class="nh lt iq mt b gy ni nj l nk nl">Map&lt;String, String&gt; map = ...;<br/>for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {<br/>    String key = entry.getKey();<br/>    String value = entry.getValue();<br/>    ...<br/>}</span></pre><h1 id="f5c6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">使用<code class="fe mq mr ms mt b">Collection.isEmpty()</code>检测空值</h1><p id="6711" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">与<code class="fe mq mr ms mt b">Collection.size()</code>相比，<code class="fe mq mr ms mt b">Collection.isEmpty()</code>可读性更强，在检测空值时提供了更好的性能。<code class="fe mq mr ms mt b">Collection.isEmpty()</code>的时间复杂度永远是<code class="fe mq mr ms mt b">O(1)</code>，但是<code class="fe mq mr ms mt b">Collection.size()</code>的时间复杂度可能是<code class="fe mq mr ms mt b">O(n)</code>。</p><p id="c6dc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="7855" class="nh lt iq mt b gy ni nj l nk nl">if (collection.size() == 0) {<br/>    ...<br/>}</span></pre><p id="9a29" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="f814" class="nh lt iq mt b gy ni nj l nk nl">if (collection.isEmpty()) {<br/>    ...<br/>}</span></pre><p id="31e7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要检测空值，可以使用<code class="fe mq mr ms mt b">CollectionUtils.isEmpty(collection)</code>和<code class="fe mq mr ms mt b">CollectionUtils.isNotEmpty(collection)</code>。</p><h1 id="e103" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">不要将集合对象传递给集合本身</h1><p id="5aa8" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">将集合作为参数传递给集合本身是一个错误或无意义的代码。</p><p id="7d8f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于在执行过程中需要不变参数的方法，当您将集合传递给其自身时，可能会发生错误。</p><p id="6219" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="cc20" class="nh lt iq mt b gy ni nj l nk nl">List&lt;String&gt; list = new ArrayList&lt;&gt;();<br/>list.add("Hello");<br/>list.add("World");<br/>if (list.containsAll(list)) { // 无意义,总是返回true<br/>    ...<br/>}<br/>list.removeAll(list); // 性能差, 直接使用clear()</span></pre><h1 id="739f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">在集合初始化期间指定集合大小</h1><p id="677c" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">Java的集合类很好用，但是在源代码中集合大小是有限制的。每次缩放操作的时间复杂度可以是<code class="fe mq mr ms mt b">O(n)</code>。您可以尽可能指定可预测的集合大小，以减少集合缩放的发生。</p><p id="455a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="4f65" class="nh lt iq mt b gy ni nj l nk nl">int[] arr = new int[]{1, 2, 3};<br/>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();<br/>for (int i : arr) {<br/>    list.add(i);<br/>}</span></pre><p id="e99f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="15b5" class="nh lt iq mt b gy ni nj l nk nl">int[] arr = new int[]{1, 2, 3};<br/>List&lt;Integer&gt; list = new ArrayList&lt;&gt;(arr.length);<br/>for (int i : arr) {<br/>    list.add(i);<br/>}</span></pre><h1 id="ce0c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">使用<code class="fe mq mr ms mt b">StringBuilder</code>连接字符串</h1><p id="81e2" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">在Java中，连接的字符串在编译期间被调优。但是，在循环中串联的字符串在编译期间不会串联。在这种情况下，使用<code class="fe mq mr ms mt b">StringBuilder</code>连接字符串。</p><p id="1003" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="f11b" class="nh lt iq mt b gy ni nj l nk nl">String s = "";<br/>for (int i = 0; i &lt; 10; i++) {<br/>    s += i;<br/>}</span></pre><p id="ab65" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="a989" class="nh lt iq mt b gy ni nj l nk nl">String a = "a";<br/>String b = "b";<br/>String c = "c";<br/>String s = a + b + c; // 没问题，java编译器会进行优化<br/>StringBuilder sb = new StringBuilder();<br/>for (int i = 0; i &lt; 10; i++) {<br/>    sb.append(i);  // 循环中，java编译器无法进行优化，所以要手动使用StringBuilder<br/>}</span></pre><h1 id="04dc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">随机访问列表</h1><p id="5c76" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">随机访问数组比访问链表更有效。当被调用的方法需要随机访问获取的<code class="fe mq mr ms mt b">List</code>中的数据，而不知道内部实现的是数组还是链表时，可以检查是否使用了<code class="fe mq mr ms mt b">RandomAccess</code>操作。</p><p id="9ee5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="3601" class="nh lt iq mt b gy ni nj l nk nl">// 调用别人的服务获取到list<br/>List&lt;Integer&gt; list = otherService.getList();<br/>if (list instanceof RandomAccess) {<br/>    // 内部数组实现，可以随机访问<br/>    System.out.println(list.get(list.size() - 1));<br/>} else {<br/>    // 内部可能是链表实现，随机访问效率低<br/>}</span></pre><h1 id="9103" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">使用Set频繁调用<code class="fe mq mr ms mt b">Collection.contains</code>方法</h1><p id="5de4" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">在Java的集合类库中，<code class="fe mq mr ms mt b">List</code>的contains方法的时间复杂度为<code class="fe mq mr ms mt b">O(n)</code>。如果需要频繁调用代码中的contains方法来搜索数据，可以将<code class="fe mq mr ms mt b">List</code>转换成<code class="fe mq mr ms mt b">HashSet</code>来降低到<code class="fe mq mr ms mt b">O(1)</code>的时间复杂度。</p><p id="d129" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="a5c5" class="nh lt iq mt b gy ni nj l nk nl">ArrayList&lt;Integer&gt; list = otherService.getList();<br/>for (int i = 0; i &lt;= Integer.MAX_VALUE; i++) {<br/>    // 时间复杂度O(n)<br/>    list.contains(i);<br/>}</span></pre><p id="8404" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="c01c" class="nh lt iq mt b gy ni nj l nk nl">ArrayList&lt;Integer&gt; list = otherService.getList();<br/>Set&lt;Integer&gt; set = new HashSet(list);<br/>for (int i = 0; i &lt;= Integer.MAX_VALUE; i++) {<br/>    // 时间复杂度O(1)<br/>    set.contains(i);<br/>}</span></pre><h1 id="5199" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">让你的代码更优雅</h1><h1 id="18fe" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">将大写字母"<code class="fe mq mr ms mt b">L</code>"附加到长整型常量上</h1><p id="300e" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">将大写字母<code class="fe mq mr ms mt b">L</code>附加到长整型常量上。不要使用小写的<code class="fe mq mr ms mt b">l</code>，因为它很容易与数字<code class="fe mq mr ms mt b">1</code>混淆。</p><p id="9d27" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="aed7" class="nh lt iq mt b gy ni nj l nk nl">long value = 1l;<br/>long max = Math.max(1L, 5);</span></pre><p id="66dc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="8a8a" class="nh lt iq mt b gy ni nj l nk nl">long value = 1L;<br/>long max = Math.max(1L, 5L);</span></pre><h1 id="df2a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">不要使用神奇的数字</h1><p id="ac83" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">幻数可能会让你的代码非常清晰，但是会很难调试。因此，幻数必须定义为可读的常数。但是，<code class="fe mq mr ms mt b">-1</code>、<code class="fe mq mr ms mt b">0,</code>、<code class="fe mq mr ms mt b">1</code>都不算幻数。</p><p id="0fc6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="2b1a" class="nh lt iq mt b gy ni nj l nk nl">for (int i = 0; i &lt; 100; i++){<br/>    ...<br/>}<br/>if (a == 100) {<br/>    ...<br/>}</span></pre><p id="8f42" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="a5c1" class="nh lt iq mt b gy ni nj l nk nl">private static final int MAX_COUNT = 100;<br/>for (int i = 0; i &lt; MAX_COUNT; i++){<br/>    ...<br/>}<br/>if (count == MAX_COUNT) {<br/>    ...<br/>}</span></pre><h1 id="eabd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">不要通过使用集合实现为静态成员变量赋值</h1><p id="e4a2" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">通过使用静态代码块而不是集合实现，为集合类型的静态成员变量赋值。</p><p id="f03a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="4124" class="nh lt iq mt b gy ni nj l nk nl">private static Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;() {<br/>    {<br/>        put("a", 1);<br/>        put("b", 2);<br/>    }<br/>};</span><span id="dd66" class="nh lt iq mt b gy nm nj l nk nl">private static List&lt;String&gt; list = new ArrayList&lt;String&gt;() {<br/>    {<br/>        add("a");<br/>        add("b");<br/>    }<br/>};</span></pre><p id="250a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="7d48" class="nh lt iq mt b gy ni nj l nk nl">private static Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();<br/>static {<br/>    map.put("a", 1);<br/>    map.put("b", 2);<br/>};</span><span id="bbda" class="nh lt iq mt b gy nm nj l nk nl">private static List&lt;String&gt; list = new ArrayList&lt;&gt;();<br/>static {<br/>    list.add("a");<br/>    list.add("b");<br/>};</span></pre><h1 id="1f29" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">使用<code class="fe mq mr ms mt b">try-with-resources</code>语句</h1><p id="fa28" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">Java 7引入了<code class="fe mq mr ms mt b">try-with-resources</code>语句，用于关闭相关资源，使程序代码更简单、更安全。比原来的<code class="fe mq mr ms mt b">try-catch-finally</code>说法要好。</p><p id="4696" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="0494" class="nh lt iq mt b gy ni nj l nk nl">private void handle(String fileName) {<br/>    BufferedReader reader = null;<br/>    try {<br/>        String line;<br/>        reader = new BufferedReader(new FileReader(fileName));<br/>        while ((line = reader.readLine()) != null) {<br/>            ...<br/>        }<br/>    } catch (Exception e) {<br/>        ...<br/>    } finally {<br/>        if (reader != null) {<br/>            try {<br/>                reader.close();<br/>            } catch (IOException e) {<br/>                ...<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="c1c4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="1ead" class="nh lt iq mt b gy ni nj l nk nl">private void handle(String fileName) {<br/>    try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {<br/>        String line;<br/>        while ((line = reader.readLine()) != null) {<br/>            ...<br/>        }<br/>    } catch (Exception e) {<br/>        ...<br/>    }<br/>}</span></pre><h1 id="73b5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">删除未使用的私有方法和字段</h1><p id="6488" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">删除未使用的私有方法和字段，使代码更简单、更易于维护。您可以从历史提交中恢复已删除的方法和字段。</p><p id="284e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="9b77" class="nh lt iq mt b gy ni nj l nk nl">public class DoubleDemo1 {<br/>    private int unusedField = 100;<br/>    private void unusedMethod() {<br/>        ...<br/>    }<br/>    public int sum(int a, int b) {<br/>        return a + b;<br/>    }<br/>}</span></pre><p id="ce39" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="800b" class="nh lt iq mt b gy ni nj l nk nl">public class DoubleDemo1 {<br/>    public int sum(int a, int b) {<br/>        return a + b;<br/>    }<br/>}</span></pre><h1 id="1dd7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">删除未使用的局部变量</h1><p id="b07d" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">删除不用的局部变量，使代码更简单，更易于维护。</p><p id="6917" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="c737" class="nh lt iq mt b gy ni nj l nk nl">public int sum(int a, int b) {<br/>    int c = 100;<br/>    return a + b;<br/>}</span></pre><p id="d6e8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="3867" class="nh lt iq mt b gy ni nj l nk nl">public int sum(int a, int b) {<br/>    return a + b;<br/>}</span></pre><h1 id="7701" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">删除未使用的方法参数</h1><p id="95cb" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">未使用的方法参数会产生误导。删除它们，使代码更简单，更易于维护。但是，对于基于父类的方法或接口方法定义的重写方法，不要删除未使用的参数。</p><p id="c93e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="1189" class="nh lt iq mt b gy ni nj l nk nl">public int sum(int a, int b, int c) {<br/>    return a + b;<br/>}</span></pre><p id="e098" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="1b92" class="nh lt iq mt b gy ni nj l nk nl">public int sum(int a, int b) {<br/>    return a + b;<br/>}</span></pre><h1 id="a4df" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">删除表达式中多余的括号</h1><p id="8af0" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">表达式的多余括号被一些编码者认为是不必要的，但是对其他编码者的代码阅读是有帮助的。对于Java专家来说，这些多余的括号只会让代码看起来复杂。</p><p id="02ac" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="106a" class="nh lt iq mt b gy ni nj l nk nl">return (x);<br/>return (x + 2);<br/>int x = (y * 3) + 1;<br/>int m = (n * 4 + 2);</span></pre><p id="7e22" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="dc53" class="nh lt iq mt b gy ni nj l nk nl">return x;<br/>return x + 2;<br/>int x = y * 3 + 1;<br/>int m = n * 4 + 2;</span></pre><h1 id="54b6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">工具类的掩码构造函数</h1><p id="1626" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">工具类是静态字段和函数的集合，不能实例化。在Java中，隐式公共构造函数被添加到每个类中，而没有构造函数定义。如果您是Java新手，我们建议您定义一个显式的私有构造函数来屏蔽隐式的公共构造函数。</p><p id="5dc8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="d5af" class="nh lt iq mt b gy ni nj l nk nl">public class MathUtils {<br/>    public static final double PI = 3.1415926D;<br/>    public static int sum(int a, int b) {<br/>        return a + b;<br/>    }<br/>}</span></pre><p id="4ec2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="1c45" class="nh lt iq mt b gy ni nj l nk nl">public class MathUtils {<br/>    public static final double PI = 3.1415926D;<br/>    private MathUtils() {}<br/>    public static int sum(int a, int b) {<br/>        return a + b;<br/>    }<br/>}</span></pre><h1 id="bbe6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">删除并抛出多余的捕获异常</h1><p id="db74" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">如果使用catch语句捕获的异常未经处理就被抛出，结果与未捕获异常相同。要解决这个问题，可以删除相关的代码块或添加另一个处理方法。</p><p id="ed12" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="2e82" class="nh lt iq mt b gy ni nj l nk nl">private static String readFile(String fileName) throws IOException {<br/>    try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {<br/>        String line;<br/>        StringBuilder builder = new StringBuilder();<br/>        while ((line = reader.readLine()) != null) {<br/>            builder.append(line);<br/>        }<br/>        return builder.toString();<br/>    } catch (Exception e) {<br/>        throw e;<br/>    }<br/>}</span></pre><p id="672a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="ac1b" class="nh lt iq mt b gy ni nj l nk nl">private static String readFile(String fileName) throws IOException {<br/>    try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {<br/>        String line;<br/>        StringBuilder builder = new StringBuilder();<br/>        while ((line = reader.readLine()) != null) {<br/>            builder.append(line);<br/>        }<br/>        return builder.toString();<br/>    }<br/>}</span></pre><h1 id="7e7c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">使用类访问公共静态常数</h1><p id="6171" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">虽然可以通过类实例访问公共静态常量，但这可能会导致误解，以为每个类的实例都有一个公共静态常量。我们建议您通过类访问公共静态常量。</p><p id="bc2d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="8c25" class="nh lt iq mt b gy ni nj l nk nl">public class User {<br/>    public static final String CONST_NAME = "name";<br/>    ...<br/>}</span><span id="d204" class="nh lt iq mt b gy nm nj l nk nl">User user = new User();<br/>String nameKey = user.CONST_NAME;</span></pre><p id="c1f1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="db58" class="nh lt iq mt b gy ni nj l nk nl">public class User {<br/>    public static final String CONST_NAME = "name";<br/>    ...<br/>}</span><span id="e258" class="nh lt iq mt b gy nm nj l nk nl">String nameKey = User.CONST_NAME;</span></pre><h1 id="6422" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">不要使用NullPointerException来确定空指针</h1><p id="c50a" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">通过编码(例如，没有检测到空值)而不是通过捕获异常来防止空指针异常</p><p id="e252" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="6046" class="nh lt iq mt b gy ni nj l nk nl">public String getUserName(User user) {<br/>    try {<br/>        return user.getName();<br/>    } catch (NullPointerException e) {<br/>        return null;<br/>    }<br/>}</span></pre><p id="0111" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="f77f" class="nh lt iq mt b gy ni nj l nk nl">public String getUserName(User user) {<br/>    if (Objects.isNull(user)) {<br/>        return null;<br/>    }<br/>    return user.getName();<br/>}</span></pre><h1 id="2224" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">将<code class="fe mq mr ms mt b">""+value</code>替换为<code class="fe mq mr ms mt b">String.valueOf(value)</code></h1><p id="1510" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">使用<code class="fe mq mr ms mt b">String.valueOf(value)</code>而不是<code class="fe mq mr ms mt b">""+value</code>更有效地将其他对象或类型转换成字符串。</p><p id="047d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="421e" class="nh lt iq mt b gy ni nj l nk nl">int i = 1;<br/>String s = "" + i;</span></pre><p id="b59c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="c113" class="nh lt iq mt b gy ni nj l nk nl">int i = 1;<br/>String s = String.valueOf(i);</span></pre><h1 id="86f7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">给过时的代码添加<code class="fe mq mr ms mt b">@Deprecated</code>注释</h1><p id="bab3" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">如果一段代码已经过时，但是由于兼容性的原因而无法删除，您可以在代码中添加<code class="fe mq mr ms mt b">@Deprecated</code>注释，这样就不会再使用它了。将<code class="fe mq mr ms mt b">@deprecated</code>添加到文档注释中，以给出解释并提供替代解决方案。</p><p id="4dbf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="b245" class="nh lt iq mt b gy ni nj l nk nl">/**<br/> * 保存<br/> *<br/> * @deprecated 此方法效率较低，请使用{@link newSave()}方法替换它<br/> */<br/>@Deprecated<br/>public void save(){<br/>    // do something<br/>}</span></pre><h1 id="66b3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">防止代码中的错误</h1><h1 id="1ad3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">不要使用构造函数方法<code class="fe mq mr ms mt b">BigDecimal(double)</code></h1><p id="0cce" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated"><code class="fe mq mr ms mt b">BigDecimal(double)</code>在精确计算或值比较过程中，可能导致准确性损失和业务逻辑异常。</p><p id="4e84" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="3db4" class="nh lt iq mt b gy ni nj l nk nl">BigDecimal value = new BigDecimal(0.1D); // 0.100000000000000005551115...</span></pre><p id="f745" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="e182" class="nh lt iq mt b gy ni nj l nk nl">BigDecimal value = BigDecimal.valueOf(0.1D);; // 0.1</span></pre><h1 id="ef37" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">返回空数组或集合，而不是空值</h1><p id="cabb" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">若要返回空值，需要调用方检测空值。否则，可能会引发空指针异常。当调用方没有检测到空值时，返回空数组或集合可以防止引发空指针异常。为了简化代码，可以删除指示调用方检测空值的语句。</p><p id="d05e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="6314" class="nh lt iq mt b gy ni nj l nk nl">public static Result[] getResults() {<br/>    return null;<br/>}</span><span id="7484" class="nh lt iq mt b gy nm nj l nk nl">public static List&lt;Result&gt; getResultList() {<br/>    return null;<br/>}</span><span id="6435" class="nh lt iq mt b gy nm nj l nk nl">public static Map&lt;String, Result&gt; getResultMap() {<br/>    return null;<br/>}</span><span id="d511" class="nh lt iq mt b gy nm nj l nk nl">public static void main(String[] args) {<br/>    Result[] results = getResults();<br/>    if (results != null) {<br/>        for (Result result : results) {<br/>            ...<br/>        }<br/>    }</span><span id="20aa" class="nh lt iq mt b gy nm nj l nk nl">    List&lt;Result&gt; resultList = getResultList();<br/>    if (resultList != null) {<br/>        for (Result result : resultList) {<br/>            ...<br/>        }<br/>    }</span><span id="c922" class="nh lt iq mt b gy nm nj l nk nl">    Map&lt;String, Result&gt; resultMap = getResultMap();<br/>    if (resultMap != null) {<br/>        for (Map.Entry&lt;String, Result&gt; resultEntry : resultMap) {<br/>            ...<br/>        }<br/>    }<br/>}</span></pre><p id="0b16" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="d149" class="nh lt iq mt b gy ni nj l nk nl">public static Result[] getResults() {<br/>    return new Result[0];<br/>}</span><span id="9492" class="nh lt iq mt b gy nm nj l nk nl">public static List&lt;Result&gt; getResultList() {<br/>    return Collections.emptyList();<br/>}</span><span id="152d" class="nh lt iq mt b gy nm nj l nk nl">public static Map&lt;String, Result&gt; getResultMap() {<br/>    return Collections.emptyMap();<br/>}</span><span id="238d" class="nh lt iq mt b gy nm nj l nk nl">public static void main(String[] args) {<br/>    Result[] results = getResults();<br/>    for (Result result : results) {<br/>        ...<br/>    }</span><span id="7262" class="nh lt iq mt b gy nm nj l nk nl">    List&lt;Result&gt; resultList = getResultList();<br/>    for (Result result : resultList) {<br/>        ...<br/>    }</span><span id="bea7" class="nh lt iq mt b gy nm nj l nk nl">    Map&lt;String, Result&gt; resultMap = getResultMap();<br/>    for (Map.Entry&lt;String, Result&gt; resultEntry : resultMap) {<br/>        ...<br/>    }<br/>}</span></pre><h1 id="7fbb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">使用常量或确定值调用<code class="fe mq mr ms mt b">equals</code>方法</h1><p id="15f6" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">对象的<code class="fe mq mr ms mt b">equals</code>方法经常抛出空指针异常。要解决这个问题，请使用常量或具有确定值的对象来调用equals方法。最好的解决方法是使用<code class="fe mq mr ms mt b">java.util.Objects.equals()</code>方法。</p><p id="bf26" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="2524" class="nh lt iq mt b gy ni nj l nk nl">public void isFinished(OrderStatus status) {<br/>    return status.equals(OrderStatus.FINISHED); // 可能抛空指针异常<br/>}</span></pre><p id="c806" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="908a" class="nh lt iq mt b gy ni nj l nk nl">public void isFinished(OrderStatus status) {<br/>    return OrderStatus.FINISHED.equals(status);<br/>}</span><span id="63a9" class="nh lt iq mt b gy nm nj l nk nl">public void isFinished(OrderStatus status) {<br/>    return Objects.equals(status, OrderStatus.FINISHED);<br/>}</span></pre><h1 id="9d5e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">仅使用私有和不可更改的枚举属性字段</h1><p id="1547" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">枚举通常以与常量相同的方式使用。如果枚举包含公共属性字段或字段设置方法，这些枚举常数的属性很容易被修改。理想情况下，枚举属性字段是私有的，并在私有构造函数中赋值。由于缺少<code class="fe mq mr ms mt b">Setter</code>方法，我们建议您添加最终修改器。</p><p id="8459" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="7590" class="nh lt iq mt b gy ni nj l nk nl">public enum UserStatus {<br/>    DISABLED(0, "禁用"),<br/>    ENABLED(1, "启用");</span><span id="f349" class="nh lt iq mt b gy nm nj l nk nl">    public int value;<br/>    private String description;</span><span id="ec58" class="nh lt iq mt b gy nm nj l nk nl">    private UserStatus(int value, String description) {<br/>        this.value = value;<br/>        this.description = description;<br/>    }</span><span id="20d9" class="nh lt iq mt b gy nm nj l nk nl">    public String getDescription() {<br/>        return description;<br/>    }</span><span id="37c1" class="nh lt iq mt b gy nm nj l nk nl">    public void setDescription(String description) {<br/>        this.description = description;<br/>    }<br/>}</span></pre><p id="ecf6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="9706" class="nh lt iq mt b gy ni nj l nk nl">public enum UserStatus {<br/>    DISABLED(0, "禁用"),<br/>    ENABLED(1, "启用");</span><span id="aa62" class="nh lt iq mt b gy nm nj l nk nl">    private final int value;<br/>    private final String description;</span><span id="128c" class="nh lt iq mt b gy nm nj l nk nl">    private UserStatus(int value, String description) {<br/>        this.value = value;<br/>        this.description = description;<br/>    }</span><span id="b931" class="nh lt iq mt b gy nm nj l nk nl">    public int getValue() {<br/>        return value;<br/>    }</span><span id="9cdb" class="nh lt iq mt b gy nm nj l nk nl">    public String getDescription() {<br/>        return description;<br/>    }<br/>}</span></pre><h1 id="88cb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">注意<code class="fe mq mr ms mt b">String.split(String regex)</code></h1><p id="ab19" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">特定于字符串的split方法传递一个分隔符字符串，它是一个正则表达式。有些关键词，比如<code class="fe mq mr ms mt b">.[]() \|</code>，必须转义。</p><p id="2575" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">错误代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="eca5" class="nh lt iq mt b gy ni nj l nk nl">"a.ab.abc".split("."); // 结果为[]<br/>"a|ab|abc".split("|"); // 结果为["a", "|", "a", "b", "|", "a", "b", "c"]</span></pre><p id="aae4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好代码:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="0f61" class="nh lt iq mt b gy ni nj l nk nl">"a.ab.abc".split("\\."); // 结果为["a", "ab", "abc"]<br/>"a|ab|abc".split("\\|"); // 结果为["a", "ab", "abc"]</span></pre><h1 id="9caf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">摘要</h1><p id="2f3a" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">仅此而已。希望你也从王阳明的至理名言中学到了一二。如果没有别的，我希望我们的Java编码指南能帮助您编写更有效、更优雅的代码。</p><p id="c047" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">你渴望了解阿里云的最新科技趋势吗？在我们新推出的系列产品</em> <a class="ae kt" href="https://resource.alibabacloud.com/webinar/topic/tech-show.html" rel="noopener ugc nofollow" target="_blank"> <em class="ks">科技展</em> </a> <em class="ks">中，听听我们的顶级专家是怎么说的吧！</em></p><h1 id="eb86" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">原始来源:</h1><div class="la lb gp gr lc ld"><a href="https://www.alibabacloud.com/blog/quickly-learn-how-you-can-improve-your-java-coding_596101" rel="noopener  ugc nofollow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd ir gy z fp li fr fs lj fu fw ip bi translated">快速了解如何改进Java编码</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">《实用生活指南及其他新儒家著作》中的299页</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">www.alibabacloud.com</p></div></div><div class="lm l"><div class="nn l lo lp lq lm lr js ld"/></div></div></a></div><p id="dba4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">访问专家视图— </strong> <a class="ae kt" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>