# 理解运行时的复杂性

> 原文：<https://medium.datadriveninvestor.com/understanding-run-time-complexities-c4f0bed0053?source=collection_archive---------4----------------------->

这篇文章的目的是用最简单的解释来涵盖常见的运行时复杂性，使初学者更容易理解代码的运行时复杂性。

代码或算法的运行时复杂性意味着决定算法的性能。最有可能的是，一个算法有多个解，运行时复杂性帮助我们确定哪个解是最好的。我们真正要问的问题是，当我们增加或加倍算法的输入时，我们还需要多少处理能力？让我们考虑以下例子:

例如 1:字符串反转(“ABC”->“CBA”)

![](img/58e65dddc842f5ffc47974462031ad8e.png)

Code for Reversing a string

上面的代码是一个字符串反转的迭代解决方案。我们将字符串中的每个字符精确地迭代**一次**。因此，可以肯定地说，当我们添加一个额外的字符时，我们必须在循环中执行一个额外的步骤。因此，我们将该算法称为具有线性运行时(表示为“N”)复杂性，因为在我们拥有的输入元素的数量和我们必须用来处理它的工作量(步骤)之间存在直接的一对一关系。

[](https://www.datadriveninvestor.com/2019/03/22/the-seductive-business-logic-of-algorithms/) [## 算法诱人的商业逻辑|数据驱动的投资者

### 某些机器行为总是让我感到惊讶。我对他们从自己的成就中学习的能力感到惊讶…

www.datadriveninvestor.com](https://www.datadriveninvestor.com/2019/03/22/the-seductive-business-logic-of-algorithms/) 

例如 2:打印楼梯(使用#字符的 N 级台阶形状。)

举个例子，

步骤(2)

// ‘# ‘

// ‘##’

![](img/f9de1d923bf1501aaf03f34694af2d10.png)

Code for printing the stairs

我们有一个输入‘n’，基于这个输入，我们有两个嵌套的 for 循环(一个循环在另一个循环里面)。这意味着当我们增加 n 的输入大小时，我们必须做更多的步骤。如果 n 是 2，我们必须做 4 步……两步用于外循环，两步用于内循环。同样，如果 n 是 3，我们要做 9 步。随着 N 的增加，我们不得不做更多的步骤，或者总共(N*N)件事。这将是 N，称为二次运行时间。

(常见)复杂类型:

1.  恒定运行时间:表示为(1)。不管输入集是什么，算法总是花费完全相同的时间。常数时间最好的例子是打印一条语句或添加两个输入值。语句的大小与算法无关，它所要做的就是打印出来。类似地，输入的值并不重要，代码只需将它们相加并返回。
2.  对数运行时间:表示为(Log(N))。如果输入集翻倍并不能使您必须做的工作量翻倍，那么您将有一个对数时间。当你使用搜索算法时，它们是最重要的。因此，搜索经过排序的数据数组可能需要对数的运行时间，这也是对数时间的一个例子。
3.  线性运行时间:表示为(N)。这是最常见的运行时，相对简单和直接。您可以通过遍历数据集合中的所有元素来识别线性运行时。如果你看到一个从' 0 '到某个' array.length '的 for 循环，你可能有' N '，或者线性运行时间。提到的弦反转的例子，是线性时间的最好例子。
4.  准线性运行时间:表示为(N*Log(N))。当输入集增加 1 时，工作量增加 1+一点点(即 log(n))，您可以注意到一个准线性运行时间。准线性运行时领域的好例子很多不同类型的排序算法。
5.  二次运行时间:表示为(N*N)或(N)。“打印楼梯”的例子有一个二次运行时间。当集合中的每个元素都必须与其他每个元素进行比较时，或者当您注意到嵌套的 for 循环时，您可以确定二次运行时。经典的例子是[‘握手问题’](http://mathworld.wolfram.com/HandshakeProblem.html)。
6.  指数运行时间:表示为(2^N).向输入集添加一个元素会显著提高处理能力，几乎是两倍。任何具有指数时间的算法都应该绝对避免。任何具有指数运行时间的解决方案都可以作为参考点，直到找到替代方案。例如:寻找一个集合的子集。

识别复杂性的技巧。

一旦你对它有了一些经验，识别复杂性就变得容易了，但是没有 100%的时间识别算法的时间复杂性的神奇公式。你需要不断的经验和实践，没有一成不变的规则。尽管如此，还是有一些建议:

1.  如果你曾经看到一个简单的 for 循环遍历一个集合，那很可能是线性运行时。请记住，遍历半个集合并不意味着，现在的运行时间是(N/2)，它仍然是(N)。即使循环在迭代中途中断，它仍然是线性运行时。
2.  遍历两个不同的集合，进入**两个独立的循环**，意味着在我们的运行时复杂性中引入了一个额外的术语。那可以写成(N+M)。“n”表示遍历第一个集合，“M”表示遍历第二个集合，因为两个集合可能不同。
3.  两个嵌套的 for 循环？运行时间可能是二次的(N)。示例:阶梯算法或金字塔算法(如下)。此外，这种解决方案是一个巨大的危险信号，应该避免。

![](img/fabbce94d967e78e988eea5f9d7f9dfd.png)

print a pyramid

两个嵌套的 for 循环，但是迭代不同的数据集合，可以表示为(N*M)。它不能再是(N)了。它与(N)没有太大的不同，因为它本质上是(N*N)。我们实际上只是在迭代另一组数据。基本上，对于 N 中的每条记录，我们都要遍历 m 中的每条记录。

简单快捷方式:

1.  排序？很有可能它的运行时间是(N*Log(N))。
2.  在一个排序的数组中搜索？(Log(N))。

回想起来，你只需要做到这一点。学习大量的算法，并练习它们，以真正擅长识别时间复杂性。没有绝对的、可以 100%使用的神奇算法、公理或定律。

参考

1.  [*编码面试训练营*](https://www.udemy.com/course/coding-interview-bootcamp-algorithms-and-data-structure/) 作者[斯蒂芬·格里德](https://medium.com/u/d058882d8cd2?source=post_page-----c4f0bed0053--------------------------------)
2.  [*每个程序员都应该知道的 8 个时间复杂性*](https://adrianmejia.com/most-popular-algorithms-time-complexity-every-programmer-should-know-free-online-tutorial-course/) 作者[艾德里安·梅希亚](https://medium.com/u/e86755444968?source=post_page-----c4f0bed0053--------------------------------)