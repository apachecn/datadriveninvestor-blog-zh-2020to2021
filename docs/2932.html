<html>
<head>
<title>Algorithms: Binary Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法:二分搜索法</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/algorithms-binary-search-5d58056cb23e?source=collection_archive---------15-----------------------#2020-05-22">https://medium.datadriveninvestor.com/algorithms-binary-search-5d58056cb23e?source=collection_archive---------15-----------------------#2020-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="839c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一周，我要讲的是<strong class="jp ir">二分搜索法</strong>算法！听起来很复杂，对吧？实际上，不是的！这种算法很常见，你可能以前遇到过。那么什么是<strong class="jp ir">二分搜索法</strong>算法呢？基本上就是顾名思义。这是一种算法，通过不断“将数组一分为二”来搜索特定元素的索引。但你会问，这意味着什么？好吧，我在下面贴了一张gif来演示这是什么意思。请记住，二分搜索法<strong class="jp ir"> <em class="kl">只适用于排序后的数组</em> </strong>！</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/81d4668a84c71df5d9faf7af8b079d74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*_H1qOF3fK8JCl8Qg.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Binary Search (gif from penjee.com)</figcaption></figure><p id="969c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上图比较了二分搜索法和顺序搜索，寻找的目标是37。我将分解每一个工作的步骤。</p><p id="f72b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">二分搜索法</strong></p><p id="7c73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.指定数组中间的索引</p><p id="5f0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.检查中间索引的值是大于还是小于我们要寻找的值</p><p id="7651" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.隔离数组中有值的部分</p><p id="6f61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.重复步骤1–3，直到找到该值</p><p id="22bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">顺序搜索</strong></p><p id="f5d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.检查索引中的每个值<strong class="jp ir">并查看其是否与目标值匹配</strong></p><p id="7542" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以现在你可能会问，为什么我们不经常使用这种算法，而不是顺序搜索？二分搜索法算法有局限性！我在开始的时候提到过一个，声明它只适用于排序的数组！如果您想使用它，请确保正在讨论的数组已经排序。如果它还没有被排序，你可以对它应用插入算法，看看我上一篇关于它的博文！</p><div class="kz la gp gr lb lc"><a href="https://www.datadriveninvestor.com/2020/02/22/algorithms-for-fairness/" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd ir gy z fp lh fr fs li fu fw ip bi translated">公平算法|数据驱动的投资者</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">许多人都有算法偏见。软件工程师关心算法偏差，因为我们关心…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq ks lc"/></div></div></a></div><p id="b340" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们进入为二分搜索法算法创建函数的过程。如果让你创建一个二分搜索法函数，你会如何处理并最终解决它？好吧，让我们来分解一些我们知道的关键事情。我们知道该算法在一个<strong class="jp ir">数组</strong>中搜索一个<strong class="jp ir">目标</strong>。这意味着我们有<strong class="jp ir">两个论点</strong>！</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/39a39d2331803f5caed794d9e16d1656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*JvpXywoqMvYtNIysGQKT2g.png"/></div></figure><p id="52dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是gif prior中使用的数组，以及图片中提供的一个空函数。所以我们知道算法会根据索引值将数组一分为二。这意味着我们需要记住一些索引值:第一个、中间的和最后一个。让我们首先创建变量来表示第一个和最后一个索引。不要担心，我们将在不久之后到达中间索引。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/83e20d4358e0e742a9089323f0becec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*lkOeVME7H1eq8aJFcMC0Zg.png"/></div></figure><p id="3007" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们进入下一步。我们知道，算法会不断前进，直到找到目标，这意味着在此之前，firstIndex将继续小于或等于lastIndex。所以我们需要创建一个条件来表示它。现在让我们创建我们的中间索引。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/c1e131dbd54c0682dac5a99acd5b6b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*Mroz-CpgsPlMiWHqAak4Eg.png"/></div></figure><p id="d13f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一下第6-9行。第6行使得该块中的代码只有在firstIndex小于或等于lastIndex时才继续运行。在第7行，我使中间的索引等于firstIndex和lastIndex相加后的舍入值除以2，从而表示数组的“中点”。然后，我将第9行作为错误消息。现在让我们来看看代码中最精彩的部分，数组的实际搜索！</p><p id="54d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但在此之前，让我们考虑几件事！我们实际上如何使用所有3个值，firstIndex、lastIndex和middleIndex，并将其与我们的目标进行比较。我们需要根据算法中已知的情况来设置条件。</p><p id="fff8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们扪心自问“我们如何为_____设定一个条件？”</p><p id="9bd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.我们真的找到目标了？</p><p id="6687" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.我们的目标大于中间指数的值？</p><p id="1a43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.我们的目标小于middleIndex的值？</p><p id="cc9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.我们的目标还没有找到吗？</p><p id="ec5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是最终解决方案！</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/b9fb6f1a5864ca57301d2bbebd9d8c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*_MzLI-whtILYMddfPL2POw.png"/></div></figure><pre class="kn ko kp kq gt lt lu lv lw aw lx bi"><span id="3e81" class="ly lz iq lu b gy ma mb l mc md">let array = [1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]</span><span id="41a0" class="ly lz iq lu b gy me mb l mc md">function binarySearch(array, target) {<br/> let firstIndex = 0<br/> let lastIndex = array.length - 1<br/> while (firstIndex &lt;= lastIndex) {<br/>  let middleIndex = Math.floor((firstIndex + lastIndex) / 2)<br/>  if (target === array[middleIndex]) {<br/>   return console.log("Target" + array[middleIndex] + "was found at index " + middleIndex);<br/>  }<br/>  if (target &gt; array[middleIndex]) {<br/>   console.log("Let's go the right side of array")<br/>   firstIndex = middleIndex + 1;<br/>  }<br/>  if (target &lt; array[middleIndex]) {<br/>   console.log("Let's go to the left side of array")<br/>   lastIndex = middleIndex - 1;<br/>  }<br/>  else {<br/>   console.log("Repeat loop iteration")<br/>  }<br/> }<br/> console.log("Target not found. Make sure the array is sorted!")<br/>};</span></pre><p id="a8e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以让我们来分解代码。让我们看看第8行。它将目标与数组中middleIndex的值进行比较。如果相等，我们将返回一条语句，说明无论目标的索引是什么，都可以找到它。让我们看看下一个条件，第11行。如果我们的目标大于middleIndex的值，类似于开始时的gif，我们将在右侧通过将firstIndex重新定义为middleIndex + 1来“将数组隔离为子数组”。第13行基本上是相同的，但是如果目标小于middleIndex的值会发生什么呢？现在我们有了第19行，这是当函数重复自己最终找到目标时打印的消息。</p><p id="4f72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们测试一下这个功能！让我们试试43作为我们的目标。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/afa58cc6e007fab87a1f7f93820120c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*hZ5VhDr9rxmL7qUG-m-fsQ.png"/></div></figure><p id="0052" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果应该是这样的。</p><p id="2c8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们尝试将5作为我们的目标。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/0db28847a5cc8d66cd15ca7d99a150c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*E3azm-2NAjvEMAQkMKiblg.png"/></div></figure><p id="386d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果应该是这样的。</p><p id="7073" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之，二分搜索法算法是寻找一个值的索引的很好的工具，特别是在大的集合中。请记住它的局限性，比如只能处理排序后的数组。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mh mi l"/></div></figure></div></div>    
</body>
</html>