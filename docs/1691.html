<html>
<head>
<title>The Complete Guide to Preprocessing in Scikit Learn with code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scikit中预处理的完整指南</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/the-complete-guide-to-preprocessing-in-scikit-learn-with-code-1bceed4befb6?source=collection_archive---------3-----------------------#2020-03-28">https://medium.datadriveninvestor.com/the-complete-guide-to-preprocessing-in-scikit-learn-with-code-1bceed4befb6?source=collection_archive---------3-----------------------#2020-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="66aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">scikit学习中所有预处理功能的实用指南</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/7848237cfc4e668e01370ab958abddc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1qku8THW1bElNsP3"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@christinhumephoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christin Hume</a> on <a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="efc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本指南的目的是解释scikit-learn提供的主要预处理功能。</p><blockquote class="lf"><p id="9334" class="lg lh it bd li lj lk ll lm ln lo kn dk translated">Scikit-learn是一个开源的机器学习库，支持监督和非监督学习。它还提供了用于模型拟合、数据预处理、模型选择和评估的各种工具，以及许多其他实用工具。</p></blockquote><p id="0e52" class="pw-post-body-paragraph jq jr it js b jt lp jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn im bi translated">Scikit-learn构建在NumPy、SciPy和matplotlib库之上。这是一个简单而有效的预测数据分析工具。</p><h1 id="8f1d" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">装置</h1><p id="ab01" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">我建议下载最新的官方版本，它将为您提供scikit-learn的稳定版本。</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="75a8" class="nc lv it my b gy nd ne l nf ng">pip install -U scikit-learn</span></pre><p id="46cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了检查您的安装，您可以使用</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="fa64" class="nc lv it my b gy nd ne l nf ng">python -m pip show scikit-learn</span></pre><p id="6264" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将显示scikit-learn的版本和安装位置</p><h1 id="7f26" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">预处理</h1><p id="0580" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">sklearn.preprocessing包提供了各种功能，帮助将原始特征转换为更适合机器学习模型的表示形式。</p><p id="cb2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是我们将在博客中关注的主要功能列表:</p><ul class=""><li id="1fc0" class="nh ni it js b jt ju jx jy kb nj kf nk kj nl kn nm nn no np bi translated">标准化</li><li id="a018" class="nh ni it js b jt nq jx nr kb ns kf nt kj nu kn nm nn no np bi translated">正常化</li><li id="bf67" class="nh ni it js b jt nq jx nr kb ns kf nt kj nu kn nm nn no np bi translated">编码分类特征</li><li id="fb70" class="nh ni it js b jt nq jx nr kb ns kf nt kj nu kn nm nn no np bi translated">[数]离散化</li><li id="40a4" class="nh ni it js b jt nq jx nr kb ns kf nt kj nu kn nm nn no np bi translated">缺失值的插补</li><li id="c38a" class="nh ni it js b jt nq jx nr kb ns kf nt kj nu kn nm nn no np bi translated">生成多项式要素</li><li id="768d" class="nh ni it js b jt nq jx nr kb ns kf nt kj nu kn nm nn no np bi translated">定制变压器</li></ul><h1 id="92ca" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">标准化</h1><p id="5809" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">标准化重新调整数据，使其平均值为0，标准差为1。当输入数据集的特征在它们的范围之间有很大的差异时，标准化就出现了。</p><div class="nv nw gp gr nx ny"><a href="https://www.datadriveninvestor.com/2020/02/19/five-data-science-and-machine-learning-trends-that-will-define-job-prospects-in-2020/" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">将定义2020年就业前景的五大数据科学和机器学习趋势|数据驱动…</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">数据科学和ML是2019年最受关注的趋势之一，毫无疑问，它们将继续发展…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om ky ny"/></div></div></a></div><p id="eaea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用一个例子来说明这一点:假设我们有一个二维数据集，它有两个特征——以米为单位的身高和以千克为单位的体重。该图将始终具有在高度上占主导地位的权重特征。因此，为了防止这一问题，解决方案是使用标准化将要素转换为可比较的比例。</p><p id="03b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">函数<em class="on"> scale </em>提供了一种快速标准化的方法</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="da0e" class="nc lv it my b gy nd ne l nf ng">from sklearn import preprocessing<br/>import numpy as np</span></pre><p id="27bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以米为单位的身高数组:[ 1，1.5，1.2 ] <br/>以公斤为单位的体重数组:[ 72。, 81., 75.]</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="df62" class="nc lv it my b gy nd ne l nf ng">x = np.array([[ 1., 72.],<br/>            [ 1.5,  81.],<br/>             [1.2, 75.]])<br/>x_scaled = preprocessing.scale(x)<br/>x_scaled</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/c97c829630985fb66f29928e39b79743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*AaJ6PMVXSfAInYBd5EYALA.png"/></div></figure><p id="faeb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="on">预处理</em>模块还提供了一个实用程序类<strong class="js iu"> StandardScalar </strong>，它实现了<em class="on"> Transformer </em> API来计算训练集的均值和标准差，以便以后能够在测试集上重新应用相同的变换。</p><p id="615d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解释这一点，我们使用相同的年龄和身高数组</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="2e14" class="nc lv it my b gy nd ne l nf ng">from sklearn.preprocessing import StandardScaler<br/>sc = StandardScaler()</span><span id="0056" class="nc lv it my b gy op ne l nf ng">x_sc = sc.fit_transform(x)<br/>x_sc</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/6796fcd4b3c8ec191e03d709661f08a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*Tt6UqxqBypIJKIGgOUbENQ.png"/></div></figure><p id="4943" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们得到相同的标准化输出。现在，如果我们需要取出原始数组，我们使用<em class="on"> inverse_transform </em>函数</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="3a04" class="nc lv it my b gy nd ne l nf ng">sc.inverse_transform(x_sc)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/75c92f651d6e9cb46f4610508baf7544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*CC_7yEoGYu_iqekpTFXOHQ.png"/></div></figure><p id="38ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们把原来的数组恢复成了原来的值。</p><p id="fa7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注:</strong>逻辑回归和基于树的算法，如决策树、随机森林和梯度推进，对变量的大小不敏感。因此在拟合这种模型之前不需要标准化。</p><p id="a770" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一种标准化是将特征缩放到给定的最小值和最大值之间，通常在0和1之间，或者将每个特征的最大绝对值缩放到单位大小。这可以通过使用<strong class="js iu"> MinMaxScaler来实现。</strong></p><p id="48b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用我们的年龄和身高例子来说明这一点:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="0570" class="nc lv it my b gy nd ne l nf ng">from sklearn.preprocessing import MinMaxScaler<br/>msc = MinMaxScaler(feature_range=(0,5))<br/>x_sc = msc.fit_transform(x)<br/>x_sc</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/ea79fd1a7b9270eee2ff13e00e1d2976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*I1wcfFnl_xmJW0OMjAXoHA.png"/></div></figure><p id="181b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">【MinMaxScaler函数中的feature_range 参数为我们的缩放功能提供了最小值和最大值。</p><h1 id="e87c" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">正常化</h1><p id="25a2" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">标准化是将单个样本缩放至单位标准的过程。这是一种经常作为机器学习的数据准备的一部分而应用的技术。规范化的目标是将数据集中数值列的值更改为使用通用的比例，而不会扭曲值范围的差异或丢失信息。</p><p id="7882" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">normalize函数提供了一种在单个类似数组的数据集上执行此操作的快速简便的方法，可以使用L1或L2规范:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="bf06" class="nc lv it my b gy nd ne l nf ng">from sklearn.preprocessing import Normalizer<br/>nm = Normalizer()<br/>x_sc = nm.fit_transform(x)<br/>x_sc</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/d9dc6ded73df66cd4dd31fa9aca04f1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*Tf8DAhOThFGbMdOdh41LOA.png"/></div></figure><p id="63f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">什么时候标准化数据集的特征？</p><blockquote class="oq or os"><p id="b9df" class="jq jr on js b jt ju jv jw jx jy jz ka ot kc kd ke ou kg kh ki ov kk kl km kn im bi translated">建议采用标准化，因为基于标准化数据建立的模型会给出更好的结果(预测)。当要素数据无法归一化或无法使其遵循高斯分布时，请使用归一化。</p></blockquote><h1 id="0732" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">编码分类特征</h1><p id="cb8e" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">通常特征并不总是连续的，它们在文本类型中表现为分类的。</p><p id="5863" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如:一个人所属的国家【印度，美国】<br/>性别【男，女】</p><p id="432f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些特征可以被编码成整数供机器处理。</p><p id="cd07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">OneHotEncoder帮助我们将分类变量转换为可用于scikit-learn估计器的特征。它将每个具有n_categories可能值的分类特征转换为n_categories二元特征，其中一个为1，所有其他为0。</p><p id="3775" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们定义我们的文本2D数组</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="f625" class="nc lv it my b gy nd ne l nf ng">x = [['Basketball','Male','USA'],['Football','Female','UK']]</span></pre><p id="3566" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">OneHotEncoder将其转换为K之一的形式</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="62e2" class="nc lv it my b gy nd ne l nf ng">from sklearn.preprocessing import OneHotEncoder<br/>enc = OneHotEncoder()<br/>enc.fit_transform(x).toarray()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/5c22b45e10aa213cba3fd61b164a0291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*jUmc59qqC-1BYW64sTkojw.png"/></div></figure><p id="08b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以进一步了解每个特性的赋值</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ow"><img src="../Images/72f790f31d1adc5f30298cab25cc3c41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qq2EgPdov7oD5g7VSLHCDQ.png"/></div></div></figure><p id="2705" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们的数据集中有6个值。对于['篮球'，'男性'，'美国']，它们出现在0，3和5索引处</p><p id="e4f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，它将“1”分配给该位置— [1，0，0，1，0，1]</p><h1 id="4efc" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">[数]离散化</h1><p id="6190" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">有时有必要将连续值的列表转换成箱。这是通过<em class="on"> KBinsDiscretizer实现的。</em>默认情况下，输出被一键编码成稀疏矩阵，这可通过编码参数进行配置。</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="2b20" class="nc lv it my b gy nd ne l nf ng">X = np.array([[ -3., 5., 15 ],<br/>              [  0., 6., 14 ],<br/>              [  6., 3., 11 ]])<br/>est = preprocessing.KBinsDiscretizer(n_bins=[3, 2, 2], encode='ordinal')<br/>est.fit_transform(X)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/c62a06cb0448060a81106698a1868b31.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*d0ToFc_UxvD2Ibr-_Txybw.png"/></div></figure><p id="cf47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">离散化类似于为连续数据构建直方图。KBinsDiscretizer实现不同的宁滨策略，可以使用策略参数进行选择。</p><h1 id="844e" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">缺失值的插补</h1><p id="c342" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">在现实世界的数据集中，我们经常会发现许多缺失值。这可能是由各种原因造成的-人为错误、传感器故障或不同的数据类型问题。人们喜欢的基本策略是丢弃所有包含缺失值的行。但这降低了数据质量，我们可能会丢失重要信息。因此，我们需要找到合适的策略来处理它们，并估算缺失的值。</p><p id="7cbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SimpleImputer类提供了输入缺失值的基本策略。缺失值可以用提供的常数值进行估算，或者使用缺失值所在的每一列的统计数据进行估算。该类还允许不同的缺失值编码。</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="306a" class="nc lv it my b gy nd ne l nf ng">import numpy as np<br/>from sklearn.impute import SimpleImputer<br/>imp = SimpleImputer(missing_values=np.nan, strategy='mean')</span><span id="2ef3" class="nc lv it my b gy op ne l nf ng">X = [[np.nan, 2], [6, np.nan], [7, 6]]<br/>imp.fit_transform(X)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/4a0e21864779cb7f1b83e6ca7d50b827.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*Zwom-U_f5Y1bLOpFV7zkAw.png"/></div></figure><p id="1597" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在SimpleImputer类中实现了“mean”策略。因此，缺少的值将通过列值来替换。</p><p id="5116" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">平均:6.5分</p><p id="c31c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此np.nan将被6.5取代</p><p id="0270" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">[np.nan，6，7] → [6.5，6，7]</p><p id="0686" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单估算器还支持“最频繁”策略，用列中出现次数最多的值替换缺失值</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="9826" class="nc lv it my b gy nd ne l nf ng">df = pd.DataFrame([["a", "x"],<br/>                   [np.nan, "y"],<br/>                   ["a", np.nan],<br/>                   ["b", "y"]], dtype="category")</span><span id="5f57" class="nc lv it my b gy op ne l nf ng">imp = SimpleImputer(strategy="most_frequent")<br/>imp.fit_transform(df)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/86e00e233260152149880c2333197d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*LIE-nlsH-YkBuV4PC1La2g.png"/></div></figure><h1 id="72c5" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">生成多项式要素</h1><p id="303a" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">大多数情况下，在进行预处理时，最好增加数据的复杂性。这可以通过使用<em class="on">多项式特征</em>函数生成多项式特征来实现</p><p id="c15a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了举例说明这一点，让我们创建一个数组</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="598c" class="nc lv it my b gy nd ne l nf ng">import numpy as np<br/>from sklearn.preprocessing import PolynomialFeatures<br/>X = np.arange(6).reshape(3, 2)<br/>X</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/4b2f95cbee4c3e4e574c892c5544c89e.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*SxlvbKGZl-oT10l6ghC7tw.png"/></div></figure><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="ca57" class="nc lv it my b gy nd ne l nf ng">poly = PolynomialFeatures(2)<br/>poly.fit_transform(X)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/da5b71b6e833347f19433e5b9f70f54f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*KnTDpbfDPUu7ResiTSILFA.png"/></div></figure><p id="ca0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是时候分析这里到底发生了什么。</p><p id="1eef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">X的特征已经从(X1，X2)变换到(1，X1，X2，X1，X1X2，X2)</p><p id="ab20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以第一列→ [1，1，1]</p><p id="af59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二列→ X1 → [0，2，4]</p><p id="dfc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第三列→ X2 → [1，3，5]</p><p id="9ca0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第四列→ X1 → [0，4，16]</p><p id="7e6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第五列→ X1X2 → [0，6，20]</p><p id="1a6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第六列→ X2 → [1，9，25]</p><h1 id="0b90" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">定制变压器</h1><p id="eb77" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">通常，我们希望通过对所有值执行某种函数来将数据转换成适当的值。这可以通过传递所需的函数，使用<em class="on">函数Transformer </em>函数来实现。</p><p id="7ff6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们用代码来看看这个</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="d6d6" class="nc lv it my b gy nd ne l nf ng">from sklearn.preprocessing import FunctionTransformer<br/>transformer = FunctionTransformer(np.log1p, validate=True)<br/>X = np.array([[0, 4], [6, 10]])<br/>transformer.transform(X)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/c28ac295cc697b393b185b8cf2012ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*W-wDVtE5iaN7iZ9ODspojw.png"/></div></figure><p id="883d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">转换后的数组包含原始数组中所有值的日志。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pd"><img src="../Images/d44984425dfe308762961be7f1fdaefb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VJ9n3eRHm0_MFSCw"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@mattbotsford?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Matt Botsford</a> on <a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ed5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们最后介绍了Scikit-learn库中所有重要的预处理函数及其在python中的实现。</p><p id="230f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">希望你喜欢！</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="pe pf l"/></div></figure></div></div>    
</body>
</html>