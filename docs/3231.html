<html>
<head>
<title>Understanding Big O Space Complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解大O空间的复杂性</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/understanding-big-o-space-complexity-6826478e5a9f?source=collection_archive---------1-----------------------#2020-06-08">https://medium.datadriveninvestor.com/understanding-big-o-space-complexity-6826478e5a9f?source=collection_archive---------1-----------------------#2020-06-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/31071c96c7d1129c4ac9d07009ed4c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dJhMqciRRMpQFRCLo0B4yA.png"/></div></div></figure><p id="1535" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">理解大O空间复杂性(不要与大O时间复杂性混淆，尽管两者都有不必要的可怕名称)需要至少基本理解最常见的大O符号类型及其含义。</p><p id="8c83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个非常简短(因此也非常简单)的大O符号的常见类型及其含义的回顾。(如果您觉得不需要复习，可以跳过这一部分)</p><p id="36bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想更深入地了解每一个问题，<a class="ae kw" href="https://www.udemy.com/course/js-algorithms-and-data-structures-masterclass/" rel="noopener ugc nofollow" target="_blank">柯尔特·斯蒂尔大学有一门关于算法和数据结构的很棒的课程</a>(我想对这篇文章中的许多例子给予一点赞扬)。</p><p id="7591" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">快速警告:</strong>这里涉及到一些数学问题，但是不要担心！我们会挺过去的。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="88e1" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">最常见的大o类型</strong></h1><h2 id="3370" class="mc lf iq bd lg md me dn lk mf mg dp lo kj mh mi ls kn mj mk lw kr ml mm ma mn bi translated">O(n)</h2><p id="36df" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated"><strong class="ka ir">如果n =某个整数，算法内的运算次数(解决给定问题的方式)大致与n成正比增加</strong>这类算法并不理想！具有O(n)的算法的一个例子可以是一个函数，它将整数“n”作为一个参数，并使用“for”循环来计算直到并包括“n”的所有数字的总和。在这种情况下，运算次数与n成比例增加，因为n越大，在“for”循环中需要完成的求和次数就越多。</p><h2 id="6b70" class="mc lf iq bd lg md me dn lk mf mg dp lo kj mh mi ls kn mj mk lw kr ml mm ma mn bi translated">O(1)</h2><p id="b1c3" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated"><strong class="ka ir">在具有O(1)的算法的情况下，无论‘n’的值如何，完成该问题所需的运算数量保持一致。</strong>这是最可取的大O类型，可产生最佳性能。例如:一个函数，它接受一个整数“n”，并简单地对n执行一些操作，而没有任何形式的“for”循环、搜索等。这是O(1)的原因是因为不管n的大小，函数内的数字运算将保持完全相同。</p><h2 id="95e1" class="mc lf iq bd lg md me dn lk mf mg dp lo kj mh mi ls kn mj mk lw kr ml mm ma mn bi translated">O(n)</h2><p id="f654" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">在这种情况下，<strong class="ka ir">函数内的运算量会随着‘n’</strong>呈指数增长。这方面的一个例子是一个包含嵌套循环的函数，它也调用n。这导致完成该问题所需的运算量呈指数级增长。O(n)是最慢和最不可取的算法类型！</p><h2 id="2f09" class="mc lf iq bd lg md me dn lk mf mg dp lo kj mh mi ls kn mj mk lw kr ml mm ma mn bi translated">o(登录号)</h2><p id="3e93" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated"><strong class="ka ir">具有O(log n)的算法开始时与‘n’成比例增加，但最终趋于平稳</strong>。这是一个高性能的算法，是仅次于O(1)的最好算法！这方面的一个例子可能涉及一个搜索算法，其中答案空间不断分裂，一遍又一遍，直到找到答案。</p><div class="mt mu gp gr mv mw"><a href="https://www.datadriveninvestor.com/2020/01/16/software-development-process-how-to-pick-the-right-process/" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd ir gy z fp nb fr fs nc fu fw ip bi translated">软件开发过程:如何选择正确的过程？数据驱动的投资者</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">软件是任何企业组织成功的生命线。没有软件的帮助，一个…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk jw mw"/></div></div></a></div><p id="136e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是与时间复杂性相关的常见大O符号类型的有用图表:</p><figure class="nm nn no np gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/d2a01748853fa5fd19aedacff8af0e30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yiyfZodqXNwMouC0-B0Wlg.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">Fig. 1: Big O Time Complexity Graph. Credit: Huang, D. (2018, January 1). Javascript — Algorithm</figcaption></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="6d80" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">好吧，我们去空间复杂性！</h1><p id="ee84" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated"><a class="ae kw" href="https://en.wikipedia.org/wiki/Space_complexity" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">维基百科的</strong> </a> <strong class="ka ir">对空间复杂度的定义如下:</strong>“算法或计算机程序的<strong class="ka ir">空间复杂度</strong>是解决一个计算问题实例所需的内存空间量，作为输入特征的函数。它是算法执行程序并产生输出所需的内存。”</p><p id="54ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更简单的说，<strong class="ka ir">空间复杂度就是一个算法需要的内存(空间)量。而我们的工作就是分析输入(‘n’)是否以及在多大程度上影响这个</strong>。</p><blockquote class="nu"><p id="b877" class="nv nw iq bd nx ny nz oa ob oc od kv dk translated">空间复杂度是算法所需的内存(空间)量。</p></blockquote><p id="9453" class="pw-post-body-paragraph jy jz iq ka b kb oe kd ke kf of kh ki kj og kl km kn oh kp kq kr oi kt ku kv ij bi translated">为了简要阐述这一点，出于我们的目的我们将谈论<strong class="ka ir">辅助</strong>空间复杂性。所有这些意味着<strong class="ka ir">我们正在严格地谈论算法内部发生的事情(换句话说，算法本身)。</strong>这是因为，以我们对大O记法的理解，我们可以假设随着‘n’的增长，n的输入也在增长。所以我们不需要考虑n本身占据了多少空间。我们只关心它如何影响执行问题所需的空间。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="ac12" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">为什么空间复杂性很重要？</strong></h1><p id="1ba7" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">像时间复杂度一样，<strong class="ka ir">空间复杂度给了我们一个具体的、一致的方法来分析我们代码的效率和性能。</strong>理解<strong class="ka ir">空间复杂性也为我们提供了一种简单有效地将这种性能传达给其他开发人员的方法。</strong></p><blockquote class="nu"><p id="7785" class="nv nw iq bd nx ny nz oa ob oc od kv dk translated">空间复杂性为我们提供了一种一致的方法来分析我们的代码，并将其性能传达给与我们合作的其他开发人员。</p></blockquote><h2 id="bef2" class="mc lf iq bd lg md oj dn lk mf ok dp lo kj ol mi ls kn om mk lw kr on mm ma mn bi translated"><strong class="ak">原语与字符串、引用类型的空间复杂度:</strong></h2><ul class=""><li id="25de" class="oo op iq ka b kb mo kf mp kj oq kn or kr os kv ot ou ov ow bi translated"><strong class="ka ir">原语—大多数原语(布尔、数字、空、未定义等。)是常数(O(1))空间。这是因为，不管是真还是假，是1还是1，000，所消耗的空间量都保持不变。</strong></li><li id="77d6" class="oo op iq ka b kb ox kf oy kj oz kn pa kr pb kv ot ou ov ow bi translated"><strong class="ka ir">字符串——另一方面，字符串需要O(n)个空间(n是字符串的长度)。这意味着如果我们有两个字符串，一个有1个字符，一个有50个字符，后者需要的空间是前者的50倍。</strong></li><li id="ff60" class="oo op iq ka b kb ox kf oy kj oz kn pa kr pb kv ot ou ov ow bi translated"><strong class="ka ir">引用类型(数组和对象)——引用类型也需要O(n)空间。“n”是数组的长度，或者在对象的情况下，“n”是键的数量。</strong>引用类型是O(n ),因为数组中的元素越多，或者对象中的键越多，它们消耗的空间就越多。</li></ul><blockquote class="nu"><p id="c310" class="nv nw iq bd nx ny pc pd pe pf pg kv dk translated">大多数原语是常量(O(1))空间，其中字符串和引用类型需要O(n)空间。</p></blockquote></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="7ba0" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">一些例子的时间</strong></h1><h2 id="c8a2" class="mc lf iq bd lg md me dn lk mf mg dp lo kj mh mi ls kn mj mk lw kr ml mm ma mn bi translated"><strong class="ak"> O(1)空间复杂度</strong></h2><p id="7bbf" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated"><strong class="ka ir">让我们创建一个名为</strong> <code class="fe ph pi pj pk b"><strong class="ka ir">sum</strong></code> <strong class="ka ir">的简单函数，它接收一个整数数组，对数组中的所有元素求和，然后返回总和。</strong>这个函数的空间复杂度是多少？(记住，我们关注的是<em class="pl">空间复杂度</em>，而不是时间复杂度！)</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="145f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">得到你的答案了吗？太好了。</p><p id="5058" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我们的</strong> <code class="fe ph pi pj pk b"><strong class="ka ir">sum</strong></code> <strong class="ka ir">函数的空间复杂度是O(1) </strong>。让我们思考一下这个问题。在我们的函数中，我们只有两个变量，“总”和“我”。不管‘arr’等于什么，我们总是只有这两个相同的变量，并且它们总是只包含一个数字。当我们<em class="pl">在</em>增加“总”变量时，我们<em class="pl">没有</em>创造或增加任何新的变量。记住，现在我们不关心数字的大小，也不关心函数中发生的运算量(在这种情况下时间复杂度为O(n))。</p><h2 id="f1ef" class="mc lf iq bd lg md me dn lk mf mg dp lo kj mh mi ls kn mj mk lw kr ml mm ma mn bi translated"><strong class="ak"> O(n)空间复杂度</strong></h2><p id="00ff" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated"><strong class="ka ir">接下来，我们将创建一个名为</strong> <code class="fe ph pi pj pk b"><strong class="ka ir">double</strong></code> <strong class="ka ir">的函数，该函数接收一个整数数组，并返回一个新数组，该数组由原始数组中的每个数字组成，但会加倍</strong>。我们在处理什么类型的空间复杂性？(提示:考虑一下创建一个长度取决于函数输入的<em class="pl">新</em>数组的空间影响)。</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="de60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我们的</strong> <code class="fe ph pi pj pk b"><strong class="ka ir">double</strong></code> <strong class="ka ir">函数的空间复杂度是O(n)。</strong>让我们在这里再次进行批判性思考。<strong class="ka ir">传入的数组越长，返回的新数组也就越长。这意味着我们的算法所需的空间将基于这个数组的长度而增加。如果<code class="fe ph pi pj pk b">arr</code>有10个数字，我们的返回数组将有10个数字，如果<code class="fe ph pi pj pk b">arr</code>有50个数字，我们的返回数组现在将有50个数字。这与我们之前的O(1)示例形成对比，在该示例中，无论传递给函数的是什么，都将返回相同数量的数字(在我们的示例中是两个)。记住，这个例子与新数组的数字大小无关！这与我们正在创建一个新数组的事实有关，这个新数组所需的空间随着‘n’(我们传入的数组<code class="fe ph pi pj pk b">arr</code>)成比例增加。</strong></p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="b1d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你知道了！<strong class="ka ir">你现在理解了大O空间复杂性的基础。给自己一个鼓励。现在，您拥有了一种能力，可以看到代码性能的主要方面，并有效地将这种性能传达给其他开发人员。</strong></p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="po pn l"/></div></figure></div></div>    
</body>
</html>