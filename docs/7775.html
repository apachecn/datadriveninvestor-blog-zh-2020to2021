<html>
<head>
<title>Biases in Artificial Intelligence (AI) — Fairness and Bias</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人工智能中的偏见——公平与偏见</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/fairness-and-bias-in-artificial-intelligence-c7fbfe880df?source=collection_archive---------12-----------------------#2020-12-22">https://medium.datadriveninvestor.com/fairness-and-bias-in-artificial-intelligence-c7fbfe880df?source=collection_archive---------12-----------------------#2020-12-22</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><figure class="iq ir gq gs is it gi gj paragraph-image"><div role="button" tabindex="0" class="iu iv di iw bf ix"><div class="gi gj ip"><img src="../Images/d642fcb42b1295ae9cbddc3c5e18e689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9x-x7sVTU1Cs6qxACfBiRw.jpeg"/></div></div></figure><div class=""/><p id="cec3" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd"> <em class="kx">艾中的偏见</em> </strong></p><h2 id="fdc0" class="ky kz jc bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated"><strong class="ak">报道偏差</strong></h2><blockquote class="lr"><p id="59f6" class="ls lt jc bd lu lv lw lx ly lz ma kw dk translated"><strong class="ak"> <em class="mb">报告偏差</em> </strong> <em class="mb">当数据集中捕获的事件、属性和/或结果的频率不能准确反映其真实频率时，就会出现报告偏差。这种偏见可能会出现，因为人们倾向于记录不寻常或特别难忘的情况，认为普通情况可以“不言而喻”。</em><a class="ae mc" href="https://developers.google.com/machine-learning/crash-course/production-ml-systems" rel="noopener ugc nofollow" target="_blank"><em class="mb">@谷歌</em> </a></p></blockquote><figure class="me mf mg mh mi it gi gj paragraph-image"><div class="gi gj md"><img src="../Images/2cada6474cbf1574c746baf856313dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*MIp0_YYhkjiDOrQDFAnr_w.png"/></div></figure><h1 id="fe90" class="mj kz jc bd la mk ml mm ld mn mo mp lg mq mr ms lj mt mu mv lm mw mx my lp mz bi translated">用统计熵解释报告偏差</h1><h2 id="ef69" class="ky kz jc bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated"><strong class="ak">案例研究1 </strong></h2><blockquote class="na nb nc"><p id="71b4" class="jz ka kx kb b kc kd ke kf kg kh ki kj nd kl km kn ne kp kq kr nf kt ku kv kw ik bi translated"><em class="jc">使用移动摄像机或数码相机作为测速枪检测器来检测车辆的速度变化。为了检测速度，首先检测车辆，然后计算图像的振幅。</em></p></blockquote><p id="073f" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd"> <em class="kx">参考文章</em> </strong></p><p id="955f" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd"> <em class="kx">【光流估计】</em></strong><a class="ae mc" href="http://www.cs.toronto.edu/~fleet/research/Papers/flowChapter05.pdf" rel="noopener ugc nofollow" target="_blank">http://www . cs . Toronto . edu/~ fleet/research/Papers/Flow chapter 05 . pdf</a></p><h2 id="fd83" class="ky kz jc bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated"><strong class="ak">案例研究2 </strong></h2><blockquote class="na nb nc"><p id="470d" class="jz ka kx kb b kc kd ke kf kg kh ki kj nd kl km kn ne kp kq kr nf kt ku kv kw ik bi translated"><em class="jc">仪表板摄像头安装在车辆内部，用于检测变道错误。为了检测运动，首先检测车辆，然后评估视频中图像的图形。</em></p></blockquote><p id="d8f6" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd"> <em class="kx">参考文章</em> </strong></p><p id="4ada" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd"> <em class="kx">【一篇关于感知压力问卷的论文参考司机用dash cam】</em></strong>【https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5981243/ T42】</p><p id="49e5" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd"> <em class="kx"> 1。问题解释:事件频率的捕获</em> </strong></p><p id="2fb0" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><em class="kx">案例研究1:(使用像素值阈值捕获事件频率)</em></p><p id="3815" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><a class="ae mc" href="https://github.com/nscalo/ai-in-business/raw/main/Courses/Production-ML-Systems/far_entrance.0.gif" rel="noopener ugc nofollow" target="_blank">使用OpenVINO的车辆检测</a></p><p id="ed9c" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><a class="ae mc" href="https://github.com/nscalo/ai-in-business/raw/main/Courses/Production-ML-Systems/output_annotated_330.gif" rel="noopener ugc nofollow" target="_blank">使用光流估计和包围盒的车辆检测</a></p><figure class="nh ni nj nk gu it gi gj paragraph-image"><div class="gi gj ng"><img src="../Images/d5eec52efa19e62e27d6a5c6365f7da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*5Z82Up_vPltVaDhomIYFqw.png"/></div></figure><blockquote class="lr"><p id="8a38" class="ls lt jc bd lu lv nl nm nn no np kw dk translated">在上面的两个示例视频中，每个边界框内的点数是在一组帧上计算的。相同的曲线图用于示出在选定频率下的帧1633。</p></blockquote><figure class="me mf mg mh mi it gi gj paragraph-image"><div role="button" tabindex="0" class="iu iv di iw bf ix"><div class="gi gj nq"><img src="../Images/b692b6f6a2cfdffc5a71c7585c82ad4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bI5td_Gh7G3A_9ZBBm6rnQ.png"/></div></div></figure><blockquote class="lr"><p id="3965" class="ls lt jc bd lu lv nl nm nn no np kw dk translated">挑战在于将颗粒计数的信息图转换成可用的统计数据，例如距离和速度，甚至显示统计熵的直接影响的参数。</p></blockquote><h2 id="61a4" class="ky kz jc bd la lb nr dn ld le ns dp lg kk nt li lj ko nu ll lm ks nv lo lp lq bi translated">—如何从指数图中提取参数</h2><p id="e773" class="pw-post-body-paragraph jz ka jc kb b kc nw ke kf kg nx ki kj kk ny km kn ko nz kq kr ks oa ku kv kw ik bi translated">下面的示例代码从边界框矩形内的点提取正值。</p><pre class="nh ni nj nk gu ob oc od oe aw of bi"><span id="bb1e" class="ky kz jc oc b gz og oh l oi oj">def get_lookback_frame(points, lookback_frames):<br/><strong class="oc jd">    # shift points by 1 frame</strong><br/>    return points.shift(1).rolling(window=lookback_frames).min()</span><span id="6446" class="ky kz jc oc b gz ok oh l oi oj">def get_long_signal(points, lookback_frame):<br/><strong class="oc jd">    # calculate the steadily increasing part of the evaluating graph</strong><br/>    long = (points &gt; lookback_frame).astype(np.int64)<br/>    return long</span><span id="96be" class="ky kz jc oc b gz ok oh l oi oj">def filter_signal(points, lookback_signal):<br/>    return points * lookback_signal</span></pre><p id="970b" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">下面的示例代码查找速度等参数中的异常值:</p><pre class="nh ni nj nk gu ob oc od oe aw of bi"><span id="078f" class="ky kz jc oc b gz og oh l oi oj"><strong class="oc jd"># Outlier Detection</strong><br/>def get_return_lookback(points, lookback_frame):<br/><strong class="oc jd">    # evaluate log returns of lookback and current ones</strong><br/>    return np.log(points) - np.log(lookback_frame)</span><span id="594b" class="ky kz jc oc b gz ok oh l oi oj">def get_signal_returns(signal, lookback_returns):<br/>    <strong class="oc jd"># multiply the signal to lookback_returns</strong><br/>    return signal * lookback_returns</span></pre><h2 id="796f" class="ky kz jc bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">记录从跟踪器中找到的每个阈值点的返回</h2><figure class="nh ni nj nk gu it gi gj paragraph-image"><div role="button" tabindex="0" class="iu iv di iw bf ix"><div class="gi gj ol"><img src="../Images/e84a5ee2030b46694029384a9a12edd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X44zIamg0mP5QszE33VIyw.png"/></div></div></figure><p id="8fe2" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><em class="kx">日志返回与本问题中统计熵相匹配的结果。</em></p><p id="4ac7" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><em class="kx">从线性回归拟合计算残差将为我们提供速度异常值。</em></p><p id="0905" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><em class="kx">要估计距离，log returns是一个足够好的指标，因为它在稳步下降。</em></p><p id="742c" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><em class="kx">案例研究2:(使用PSQs捕获事件频率)</em></p><figure class="nh ni nj nk gu it gi gj paragraph-image"><div role="button" tabindex="0" class="iu iv di iw bf ix"><div class="gi gj om"><img src="../Images/d88e4c3f4162e2c3704480260a08699b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xeXJ1yLsG9RvOq9iiKu54A.png"/></div></div></figure><p id="b597" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><em class="kx">在PSQs评估中，应用了相同的技术。在这种情况下，计数在整个间隔内或多或少是相同的，这意味着该表必须被转换成类似PCA的转换。</em></p><h2 id="9ec4" class="ky kz jc bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated"><strong class="ak">自动化偏置</strong></h2><p id="eb4c" class="pw-post-body-paragraph jz ka jc kb b kc nw ke kf kg nx ki kj kk ny km kn ko nz kq kr ks oa ku kv kw ik bi translated"><strong class="kb jd">自动化偏差</strong>是一种倾向，倾向于由自动化系统生成的结果，而不是由非自动化系统生成的结果，而不考虑每个系统的错误率。<a class="ae mc" href="https://developers.google.com/machine-learning/crash-course/production-ml-systems" rel="noopener ugc nofollow" target="_blank">@谷歌</a></p><p id="2faa" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd">②<em class="kx">。问题解释:视频推断</em> </strong></p><p id="d315" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd">案例分析1 </strong> <strong class="kb jd">(测速枪探测器)</strong></p><p id="f7bb" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><a class="ae mc" href="https://github.com/nscalo/ai-in-business/raw/main/Courses/Production-ML-Systems/far_entrance.0.gif" rel="noopener ugc nofollow" target="_blank">使用OpenVINO进行车辆检测</a></p><p id="1f6e" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><a class="ae mc" href="https://github.com/nscalo/ai-in-business/raw/main/Courses/Production-ML-Systems/output_annotated_330.gif" rel="noopener ugc nofollow" target="_blank">使用光流估计和包围盒的车辆检测</a></p><p id="7c11" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">如你所见，上面的视频演示了边界框图像中的光流检测。检测到的点在阈值上被过滤，该阈值发出要通过分析管道发送的数据。所分析的数据用于确定视频的统计参数。</p><p id="a53e" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">那么为什么会存在自动化偏差呢？当具有单个原始模型的一个软件可以用于确定有助于优化视频特征的统计属性时，存在自动化偏差。</p><h2 id="cc0b" class="ky kz jc bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated"><strong class="ak">选择偏差</strong></h2><p id="7f67" class="pw-post-body-paragraph jz ka jc kb b kc nw ke kf kg nx ki kj kk ny km kn ko nz kq kr ks oa ku kv kw ik bi translated"><strong class="kb jd">选择偏差</strong>发生在数据集的样本选择方式不能反映其真实分布的情况下。选择偏差可以有许多不同的形式:<a class="ae mc" href="https://developers.google.com/machine-learning/crash-course/production-ml-systems" rel="noopener ugc nofollow" target="_blank">@谷歌</a></p><p id="7671" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd"> <em class="kx"> 3。问题解释:评估一个图形</em> </strong></p><p id="f6bc" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd">覆盖偏差</strong>:数据不是以有代表性的方式选取的。<a class="ae mc" href="https://developers.google.com/machine-learning/crash-course/production-ml-systems" rel="noopener ugc nofollow" target="_blank">@谷歌</a></p><p id="fcaa" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd">案例研究1:(测速枪探测器)</strong></p><ul class=""><li id="6624" class="on oo jc kb b kc kd kg kh kk op ko oq ks or kw os ot ou ov bi translated"><strong class="kb jd"> <em class="kx">【正确】:</em> </strong>按置信区间收集测速仪内部节点出现的顺序</li><li id="d799" class="on oo jc kb b kc ow kg ox kk oy ko oz ks pa kw os ot ou ov bi translated"><strong class="kb jd"> <em class="kx">【错误】:</em> </strong>在不形成包围盒出现顺序的情况下，从n帧的检测到的盒子中进行粒子计数</li><li id="f138" class="on oo jc kb b kc ow kg ox kk oy ko oz ks pa kw os ot ou ov bi translated"><strong class="kb jd"> <em class="kx">【正确】:</em> </strong>使用正确阈值收集的外观顺序连接两个相邻帧</li><li id="d117" class="on oo jc kb b kc ow kg ox kk oy ko oz ks pa kw os ot ou ov bi translated"><strong class="kb jd"> <em class="kx">【错误】:</em> </strong>通过选择错误的像素阈值对帧进行粒子计数</li></ul><p id="32b9" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd">根据基于光流相位的方法测量这些边界框内的粒子数。</strong></p><p id="0360" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd">收集的数据并不具有代表性，但它们会转化为可用的统计数据。</strong></p><pre class="nh ni nj nk gu ob oc od oe aw of bi"><span id="7b37" class="ky kz jc oc b gz og oh l oi oj">viz = pd.DataFrame(columns=['vehicle', 'count', 'frame', 'nodes']) frame = 0 <br/>for n, t in zip(nodes, threshold):     <br/>frame += 1     <br/>map_n = list(map(lambda k: str(k), n))     <br/>for i, j in zip(n, t):         <br/>    viz = viz.append({'vehicle': i, 'count': j, 'frame': frame, 'nodes': "-".join(map_n)}, ignore_index=True)</span></pre><p id="b4c5" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd">无响应偏差</strong>:(或参与偏差):由于数据收集过程中的参与差距，数据最终不具有代表性。<a class="ae mc" href="https://developers.google.com/machine-learning/crash-course/production-ml-systems" rel="noopener ugc nofollow" target="_blank">@谷歌</a></p><p id="a659" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd">案例研究1:(测速枪探测器)</strong></p><blockquote class="lr"><p id="ef86" class="ls lt jc bd lu lv lw lx ly lz ma kw dk translated">车辆检测中可能出现参与差距，因为一些边界框可能由于深度学习错误而未被检测到，这种情况不太可能发生。另一个原因是当车辆顺序移动时，边界框切换置信区间或置信阈值，这意味着它们改变了它们在检测中出现的顺序。这在从一组车辆中检测特定车辆时引入了参与偏差。</p></blockquote><p id="3c7c" class="pw-post-body-paragraph jz ka jc kb b kc pb ke kf kg pc ki kj kk pd km kn ko pe kq kr ks pf ku kv kw ik bi translated"><strong class="kb jd">解释包围盒检测的代码:</strong></p><pre class="nh ni nj nk gu ob oc od oe aw of bi"><span id="df22" class="ky kz jc oc b gz og oh l oi oj">def draw_boxes(out_write_npy, zone, frame, result, args, width, height):     <br/>    for box in result[0][0]: <br/>        # Output shape is 1x1x100x7         <br/>        conf = box[2]         # comparison of confidence threshold    <br/>        if conf &gt;= args.pt:             <br/>            xmin = int(box[3] * width)             <br/>            ymin = int(box[4] * height)             <br/>            xmax = int(box[5] * width)             <br/>            ymax = int(box[6] * height)             <br/>            # draw bounding box rectangles             <br/>            cv2.rectangle(frame, (xmin, ymin), (xmax, ymax), args.c, args.th)                  <br/>return frame</span></pre><p id="4d38" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd">显示包围盒参与偏差的代码:</strong></p><figure class="nh ni nj nk gu it gi gj paragraph-image"><div role="button" tabindex="0" class="iu iv di iw bf ix"><div class="gi gj pg"><img src="../Images/dd4ebf0e8eddfbd5edce55e3d40fb2c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ihalnPT25_LNIzm77UCEbQ.png"/></div></div></figure><pre class="nh ni nj nk gu ob oc od oe aw of bi"><span id="361c" class="ky kz jc oc b gz og oh l oi oj"><strong class="oc jd"># distance arrays to collect distances </strong><br/>dist = [] <br/>node_length = len(_input[0]) # initial node length referring to frame 0 <br/>nodes = [list(range(node_length))] # collected nodes, starts from node_length of first frame <br/># iterate up frame (n - 1) <br/>for i in range(len(_input)-1):     <br/>    d = []    <strong class="oc jd"> # loop through a cycle of next frame and the current frame     </strong><br/>    for k in range(len(_input[i+1])):         <br/>        for j in range(len(_input[i])):             <br/>        <strong class="oc jd"># norm of distances between each bounding box rectangles                               </strong></span><span id="cb50" class="ky kz jc oc b gz ok oh l oi oj">        d.append(np.sqrt(np.sum(np.square(np.array(_input[i][j]) - np.array(_input[i+1][k])))/4))     <br/>        dist.append(d)     <br/>        n = np.zeros(len(_input[i+1])).astype(np.int64) # initialising the nodes to zeros to explore findability     <br/>    for k,x in enumerate(d):         <br/>   <strong class="oc jd"> # a comparison of distance to its threshold which is assumed to be PI  </strong>       <br/>    if (x &lt;= np.pi):             <br/>        n[int(k/len(_input[i]))] = int(nodes[i][k%len(_input[i])])           </span><span id="67d1" class="ky kz jc oc b gz ok oh l oi oj">else:             <br/>        if (int(k/len(_input[i])) &gt;= len(_input[i])):                 <br/>            <strong class="oc jd"># increment the node_length to enable detection    </strong><br/>            node_length += 1                         <br/>            n[int(k/len(_input[i]))] = node_length - 1          <br/>    nodes.append(n.tolist())</span></pre><blockquote class="lr"><p id="1337" class="ls lt jc bd lu lv nl nm nn no np kw dk translated">上述代码导致在流量中收集节点。这种偏差可以通过向深度学习模型引入定制层来避免，这导致SoftMax检测。模型的训练必须通过不断的验证，因为SoftMax层可能需要至少二维向量。</p></blockquote><p id="ea49" class="pw-post-body-paragraph jz ka jc kb b kc pb ke kf kg pc ki kj kk pd km kn ko pe kq kr ks pf ku kv kw ik bi translated"><strong class="kb jd">固定了参与偏差的代码:</strong></p><p id="90d7" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd">解决方案1:自定义图层</strong></p><figure class="nh ni nj nk gu it"><div class="bz fq l di"><div class="ph pi l"/></div></figure><p id="7c5e" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd">解决方案2:通过将节点连接到边界框来消除参与偏差</strong></p><div class="iq ir gq gs is pj"><a href="https://www.datadriveninvestor.com/2020/11/19/how-machine-learning-and-artificial-intelligence-changing-the-face-of-ecommerce/" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab fp"><div class="pl ab pm cl cj pn"><h2 class="bd jd gz z fq po fs ft pp fv fx jb bi translated">机器学习和人工智能如何改变电子商务的面貌？|数据驱动…</h2><div class="pq l"><h3 class="bd b gz z fq po fs ft pp fv fx dk translated">电子商务开发公司，现在，整合先进的客户体验到一个新的水平…</h3></div><div class="pr l"><p class="bd b dl z fq po fs ft pp fv fx dk translated">www.datadriveninvestor.com</p></div></div><div class="ps l"><div class="pt l pu pv pw ps px iy pj"/></div></div></a></div><p id="b3ec" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">用与边界框匹配的节点重画边界框</p><figure class="nh ni nj nk gu it gi gj paragraph-image"><div role="button" tabindex="0" class="iu iv di iw bf ix"><div class="gi gj py"><img src="../Images/446cf550ae3caa9f53d15bda1a7b5593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qWHrqqxQAFocBNM1NThleA.png"/></div></div></figure><p id="4940" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd">采样偏差</strong>:数据采集期间未使用适当的随机化。</p><blockquote class="lr"><p id="0432" class="ls lt jc bd lu lv lw lx ly lz ma kw dk translated">在上面显示的这个实验中，我们考虑来自边界框的数据样本，而不是整个数据，这使得我们对数据应用统计测试</p></blockquote><p id="f0b2" class="pw-post-body-paragraph jz ka jc kb b kc pb ke kf kg pc ki kj kk pd km kn ko pe kq kr ks pf ku kv kw ik bi translated">当您通过光流估计方法从包围盒中收集点的数量时，包围盒的样本被考虑，而不是整个学习数据，这使得我们将训练集引入到收集的点中。</p><figure class="nh ni nj nk gu it gi gj paragraph-image"><div class="gi gj pz"><img src="../Images/88ebde64b004fd0e5d70c5443544c1b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*ys2j__D3sPNr5JDWTYFMCQ.png"/></div></figure><h2 id="9814" class="ky kz jc bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated"><strong class="ak">群体归因偏差</strong></h2><p id="ab08" class="pw-post-body-paragraph jz ka jc kb b kc nw ke kf kg nx ki kj kk ny km kn ko nz kq kr ks oa ku kv kw ik bi translated"><strong class="kb jd">群体归因偏差</strong>是一种将个体的真实情况推广到他们所属的整个群体的倾向。这种偏见的两个主要表现是:<a class="ae mc" href="https://developers.google.com/machine-learning/crash-course/production-ml-systems" rel="noopener ugc nofollow" target="_blank"> @Google </a></p><p id="b1c7" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd"> <em class="kx"> 4。问题说明:称量组件</em> </strong></p><ul class=""><li id="75d2" class="on oo jc kb b kc kd kg kh kk op ko oq ks or kw os ot ou ov bi translated"><strong class="kb jd">群体内偏好</strong>:对你也属于<em class="kx">的群体成员</em>的偏好，或者对你们也共有的特征的偏好。</li></ul><figure class="nh ni nj nk gu it gi gj paragraph-image"><div role="button" tabindex="0" class="iu iv di iw bf ix"><div class="gi gj qa"><img src="../Images/170c05fcd7f6797c5affbc3292d83796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pg0j9cSzyPY8ODObVEMwSA.png"/></div></div></figure><h2 id="144b" class="ky kz jc bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated"><strong class="ak">用静态DEA解释问题</strong></h2><figure class="nh ni nj nk gu it gi gj paragraph-image"><div class="gi gj qb"><img src="../Images/b2d0c73dad265606564e76ca28fbdf24.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*JZ9PkiG8o3ou0yIWJUQ4tA.png"/></div></figure><pre class="nh ni nj nk gu ob oc od oe aw of bi"><span id="3709" class="ky kz jc oc b gz og oh l oi oj">s = cvx.Variable(service_data.values.shape[0]) <br/>p = cvx.Variable(privilege_data.values.shape[0])  </span><span id="6789" class="ky kz jc oc b gz ok oh l oi oj">service = cvx.matmul(s, service_data.values[:,0]) <br/>privilege = cvx.matmul(p, privilege_data.values[:,0])  </span><span id="9841" class="ky kz jc oc b gz ok oh l oi oj"><strong class="oc jd"># SPECTRUM </strong><br/>GAMMA_SHAPE=5e1 <br/>GAMMA_SCALE=1e25 <br/>NORMAL_CENTER=1e20 <br/>NORMAL_STD=5e19  <br/>dmu_s = np.random.gamma(GAMMA_SHAPE, GAMMA_SCALE, service_data.values.shape[0]) <br/>dmu_p = np.random.normal(NORMAL_CENTER, NORMAL_STD, privilege_data.values.shape[0]) </span><span id="9497" class="ky kz jc oc b gz ok oh l oi oj"><strong class="oc jd"># objective function </strong><br/>objective = cvx.Maximize(service)  </span><span id="6143" class="ky kz jc oc b gz ok oh l oi oj"><strong class="oc jd"># constraints </strong><br/>constraints = [cvx.matmul(s, dmu_s) - cvx.matmul(p, dmu_p) &lt;= 0, privilege == 1, s &gt;= 0, p &gt;= 0]  </span><span id="3514" class="ky kz jc oc b gz ok oh l oi oj"><strong class="oc jd"># use cvxpy to solve the objective </strong><br/>problem = cvx.Problem(objective, constraints).solve(verbose=False, solver=cvx.SCS, max_iters=500)</span></pre><blockquote class="lr"><p id="d668" class="ls lt jc bd lu lv nl nm nn no np kw dk translated">DEA问题是一个高度静态的模型，这意味着无论你给它提供什么样的决策单元，它都会产生相同的输出，但会随着所提供的数据而变化。</p></blockquote><p id="7d22" class="pw-post-body-paragraph jz ka jc kb b kc pb ke kf kg pc ki kj kk pd km kn ko pe kq kr ks pf ku kv kw ik bi translated">解决方案是:</p><ul class=""><li id="c11c" class="on oo jc kb b kc kd kg kh kk op ko oq ks or kw os ot ou ov bi translated"><strong class="kb jd"/></li><li id="f609" class="on oo jc kb b kc ow kg ox kk oy ko oz ks pa kw os ot ou ov bi translated"><strong class="kb jd"> <em class="kx">【你的归属】</em> </strong>:或者，你将不得不全部改变数据。</li></ul><p id="7faa" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd">群体外同质偏见</strong>:对你不属于的<em class="kx">群体中的个体成员抱有刻板印象的倾向</em>，或者认为他们的特征更加一致。</p><ul class=""><li id="fe5a" class="on oo jc kb b kc kd kg kh kk op ko oq ks or kw os ot ou ov bi translated"><em class="kx">这是一个类似的问题，当您均衡DMU(输入和输出)时，效率会降低到一个总和。</em></li></ul><h2 id="e12e" class="ky kz jc bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated"><strong class="ak">隐性偏见</strong></h2><p id="024c" class="pw-post-body-paragraph jz ka jc kb b kc nw ke kf kg nx ki kj kk ny km kn ko nz kq kr ks oa ku kv kw ik bi translated">当基于自己的心智模型和个人经验做出不一定更普遍适用的假设时，就会出现隐性偏见。<a class="ae mc" href="https://developers.google.com/machine-learning/crash-course/production-ml-systems" rel="noopener ugc nofollow" target="_blank">@谷歌</a></p><p id="a81c" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><strong class="kb jd"> <em class="kx"> 5。问题解释:信念与观察的比较</em> </strong></p><ul class=""><li id="e2d0" class="on oo jc kb b kc kd kg kh kk op ko oq ks or kw os ot ou ov bi translated"><strong class="kb jd"> <em class="kx">确认偏差</em> </strong> <em class="kx">:模型构建者无意识地以肯定预先存在的信念和假设的方式处理数据</em></li><li id="c778" class="on oo jc kb b kc ow kg ox kk oy ko oz ks pa kw os ot ou ov bi translated"><strong class="kb jd"> <em class="kx">实验者的偏见</em> </strong> <em class="kx">:模型构建者可能实际上一直在训练一个模型，直到它产生一个与他们最初的假设一致的结果</em></li></ul><figure class="nh ni nj nk gu it gi gj paragraph-image"><div class="gi gj qc"><img src="../Images/fce9414e630f3c3939b0853748085029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*XzPgDk-xJfcwBbyJMrquWg.png"/></div></figure><h1 id="9e67" class="mj kz jc bd la mk ml mm ld mn mo mp lg mq mr ms lj mt mu mv lm mw mx my lp mz bi translated">参考</h1><div class="iq ir gq gs is pj"><a href="https://developers.google.com/machine-learning/crash-course/fairness/types-of-bias" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab fp"><div class="pl ab pm cl cj pn"><h2 class="bd jd gz z fq po fs ft pp fv fx jb bi translated">公平:偏见的类型|机器学习速成班</h2><div class="pr l"><p class="bd b dl z fq po fs ft pp fv fx dk translated">developers.google.com</p></div></div><div class="ps l"><div class="qd l pu pv pw ps px iy pj"/></div></div></a></div><h2 id="bd6b" class="ky kz jc bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">获得专家观点— <a class="ae mc" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank">订阅DDI英特尔</a></h2></div></div>    
</body>
</html>