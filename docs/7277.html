<html>
<head>
<title>Complete guide to Clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">集群完全指南</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/complete-guide-to-clustering-9f0296596b75?source=collection_archive---------14-----------------------#2020-12-02">https://medium.datadriveninvestor.com/complete-guide-to-clustering-9f0296596b75?source=collection_archive---------14-----------------------#2020-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/e2ed0278edaeafc041f6dafaec1b687f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aFA8EvIl08_0AEvv03XEUw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@providence" rel="noopener ugc nofollow" target="_blank">Providence Doucet</a> on <a class="ae jd" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="def4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">聚类是一种无监督的机器学习算法，其任务是将数据点分成若干组，使得同一组中的数据点比其他组中的数据点更类似于同一组中的其他数据点。简而言之，它旨在隔离具有相似特征的群体，并将其分配到不同的群中。例如，假设你有很多关于你的博客访问者的数据。您可能想要建立一个聚类模型来尝试检测相似访问者的组。在任何时候，你都不需要告诉模型一个访问者属于哪个群体:它不需要你的帮助就能找到这些联系。例如，它可能会注意到40%的访问者是热爱科幻的男性，通常在晚上阅读你的博客，而20%是年轻的漫画爱好者，他们在周末访问，等等。聚类又分为两种:K-means聚类和层次聚类。</p><h1 id="79ef" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">k均值聚类</h1><p id="9b19" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这是一个迭代过程，目的是在每次迭代中找到局部最大值。该算法分以下五个步骤工作:<br/>步骤1:决定聚类数(k) <br/>步骤2:随机选择k个点，质心(不一定来自你的数据集)<br/>步骤3:将每个数据点分配到最近的质心(最后，它将形成k个聚类)<br/>步骤4:计算并放置每个聚类的新质心<br/>步骤5:将每个数据点重新分配到新的最近质心。如果发生了任何重新分配，请转到步骤4，否则，结束。</p><div class="ip iq gp gr ir me"><a href="https://www.datadriveninvestor.com/2020/11/19/how-machine-learning-and-artificial-intelligence-changing-the-face-of-ecommerce/" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd jh gy z fp mj fr fs mk fu fw jf bi translated">机器学习和人工智能如何改变电子商务的面貌？|数据驱动…</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">电子商务开发公司，现在，整合先进的客户体验到一个新的水平…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms ix me"/></div></div></a></div><h2 id="d5f9" class="mt lc jg bd ld mu mv dn lh mw mx dp ll ko my mz lp ks na nb lt kw nc nd lx ne bi translated">如何选择合适的集群数？</h2><p id="cc7c" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不能为我们的集群数量选择任何随机值。通过计算然后比较聚类内的数据点到其质心的距离来形成每个聚类。计算簇内平方和(WCSS)是确定簇正确数量的一种方法，也称为惯性。它是所有聚类中每个数据点到各自质心的距离的平方和。<br/>目的是降低WCSS。假设在给定的数据集中有“n”个观察值，我们指定“n”个聚类(k=n ),那么平方和将变为零，理想情况下，这形成了完美的聚类，但这没有任何意义。因此，存在一个k的阈值，我们将使用肘点图找到它。</p><p id="939a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">剪影得分</strong>也是一种评估度量或标准，用于测量聚类技术的好坏。范围在[-1，1]之间。分数+1表示采样点远离其相邻的聚类，并且可清楚地区分，分数0表示采样点位于或非常接近分隔聚类的判定边界，分数-1表示采样点被分配到错误的聚类中。根据scikit-learn官方文档，使用每个样本的平均簇内距离(<code class="fe nf ng nh ni b">a</code>)和平均最近簇距离(<code class="fe nf ng nh ni b">b</code>)来计算轮廓系数。样本的轮廓系数是<code class="fe nf ng nh ni b">(b - a) / max(a, b)</code>。澄清一下，<code class="fe nf ng nh ni b">b</code>是样本和样本不属于的最近聚类之间的距离。</p><h2 id="4539" class="mt lc jg bd ld mu mv dn lh mw mx dp ll ko my mz lp ks na nb lt kw nc nd lx ne bi translated">肘点图</h2><p id="775c" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们针对一系列k值随机初始化k均值算法，并针对每个k值绘制WCSS/惯性曲线。我们根据WCSS的下降率来选择k的值。</p><figure class="nj nk nl nm gt is"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">K-means clustering python code file by Author</figcaption></figure></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="3383" class="lb lc jg bd ld le nw lg lh li nx lk ll lm ny lo lp lq nz ls lt lu oa lw lx ly bi translated">分层聚类</h1><p id="6225" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">顾名思义，这是一种构建集群层次结构的算法。该算法从分配给它们自己的聚类的所有数据点开始。然后将两个最近的聚类合并成一个相同的聚类。最后，当只剩下一个集群时，该算法终止。</p><p id="68f2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">层次聚类的结果可以用树形图来表示。为了得到层次聚类的聚类数，我们使用了一个叫做树状图的概念。</p><blockquote class="ob oc od"><p id="195a" class="kd ke oe kf b kg kh ki kj kk kl km kn of kp kq kr og kt ku kv oh kx ky kz la ij bi translated">树状图是一个树状图表，记录了合并或拆分的顺序。</p></blockquote><figure class="nj nk nl nm gt is gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/7e196acecbdbe5574b80a9109f253589.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*AzN_s8RmHQRbXUqOGJzq3g.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">A Dendogram representing nested Clusters. Photo by Author</figcaption></figure><p id="b4f6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以通过观察树突图来选择能够最好地描述不同组的聚类数目的决定。聚类数目的最佳选择是由水平线切割的树状图中的垂直线的数目，该水平线可以垂直穿过最大距离而不与聚类相交。</p><h2 id="bc23" class="mt lc jg bd ld mu mv dn lh mw mx dp ll ko my mz lp ks na nb lt kw nc nd lx ne bi translated">凝聚层次聚类</h2><p id="28aa" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在这项技术中，我们将把每个数据点分配给一个单独的聚类。然后，在每次迭代中，我们合并最近的一对聚类，并重复这个步骤，直到只剩下一个聚类。</p><h2 id="88fb" class="mt lc jg bd ld mu mv dn lh mw mx dp ll ko my mz lp ks na nb lt kw nc nd lx ne bi translated">分裂层次聚类</h2><p id="83b1" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">它的工作方式正好与上面提到的凝聚层次聚类相反。我们从单个聚类开始，并将所有数据点分配给该聚类。因此，所有的点在开始时将属于同一个聚类。现在，在每次迭代中，我们将分割聚类中最远的点，并重复这个过程，直到每个聚类只包含一个点。</p><figure class="nj nk nl nm gt is"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Hierarchical clustrering Python code file by Author</figcaption></figure></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h2 id="9d74" class="mt lc jg bd ld mu mv dn lh mw mx dp ll ko my mz lp ks na nb lt kw nc nd lx ne bi translated">K均值和层次聚类有什么区别？</h2><p id="b957" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">I)层次聚类不能很好地处理大数据集，但是K均值可以，这是使用K均值优于层次聚类的优点。这是因为k均值聚类的时间复杂度是线性的，而层次聚类的时间复杂度是二次的。</p><p id="6ae5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ii)k表示聚类，因为我们从随机选择的聚类开始，所以多次运行产生的结果可能不同。而分级聚类的结果是可再现的。</p><p id="3558" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">iii)当簇的形状是超球面的(像2-D中的圆形或3-D中的球形)时，发现K均值工作良好。</p><h2 id="6547" class="mt lc jg bd ld mu mv dn lh mw mx dp ll ko my mz lp ks na nb lt kw nc nd lx ne bi translated">访问专家视图— <a class="ae jd" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank">订阅DDI英特尔</a></h2></div></div>    
</body>
</html>