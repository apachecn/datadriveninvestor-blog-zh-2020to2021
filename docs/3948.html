<html>
<head>
<title>C Programming Hacks 3: Diving Deep into Memory Alignment and Bit-Fields</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">c编程技巧3:深入研究内存对齐和位字段</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/c-programming-hacks-3-diving-deep-into-memory-alignment-and-bit-fields-457b31dbd3e1?source=collection_archive---------1-----------------------#2020-07-16">https://medium.datadriveninvestor.com/c-programming-hacks-3-diving-deep-into-memory-alignment-and-bit-fields-457b31dbd3e1?source=collection_archive---------1-----------------------#2020-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1809" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更高级的结构设计概念和位域介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1427c66237a60d4afb948d082f30be86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IyXq0N4N--FpTgIU"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@grohsfabian?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fabian Grohs</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2241" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我用一个例子来演示一些高级的内存对齐概念，并介绍位字段及其用途。假设你被一个组织雇佣来编写一个软件，其中第一步是存储雇员的详细信息。要求是存储雇员ID、性别、年龄和工资。</p><p id="d7c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第一步:</strong>你决定创建一个<code class="fe lv lw lx ly b">struct</code></p><p id="050d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设employeeId只有5个字符长，2个字节足以保存工资值。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="2ca2" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">typedef struct </strong>employee {<br/>    <strong class="ly iu">char </strong>employeeId[5];<br/>    <strong class="ly iu">bool </strong>isMale;<br/>    uint8_t age;<br/>    uint16_t salary;<br/>} Employee;</span></pre><p id="29df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果使用打印该结构的大小，</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5c81" class="md me it ly b gy mf mg l mh mi">Employee employee1;<br/>printf("Size of struct employee is %zu \n", <strong class="ly iu">sizeof</strong>(employee1));</span></pre><p id="a7af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该结构的大小将是10个字节。</p><blockquote class="mj mk ml"><p id="fc37" class="kz la mm lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated">employeeId -&gt; 5字节，isMale -&gt; 1字节，age -&gt; 1字节，salary -&gt; 2字节。</p></blockquote><p id="ec76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总共9个字节(5 + 1 + 1 + 2)。<em class="mm">等等，什么！！！！</em></p><p id="4578" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第二步:</strong>检查内存对齐情况</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/1fea715b8f137a10ff836bf79fed95e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*Z2s2g7hcTX_rWeYYhtvW8Q.png"/></div></figure><p id="77f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于salary是2字节长，所以它的内存地址应该是2的倍数<a class="ae ky" href="https://medium.com/dev-genius/c-programming-hacks-01-memory-efficient-struct-design-8e7252c2b986" rel="noopener">这个概念的详细解释</a>。因此，您修改您的<code class="fe lv lw lx ly b">struct</code>如下</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="88f7" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">typedef struct </strong>employee {<br/>    <strong class="ly iu">char </strong>employeeId[5];<br/>    <strong class="ly iu">bool </strong>isMale;<br/>    uint16_t salary;<br/>    uint8_t age;<br/>} Employee;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/487de7bc2ba33e33b8812ffdb3bc8cc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*tkQlds1RjDS9JLzvjLggjg.png"/></div></figure><p id="0a67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您再次打印该尺寸，您会惊叹不已，因为尺寸仍然是10。<em class="mm">为什么会这样？</em></p><p id="e934" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三步:你深入挖掘</p><p id="54c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据海湾合作委员会的文件，</p><blockquote class="mj mk ml"><p id="4250" class="kz la mm lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated">请注意，ISO C标准要求任何给定结构或联合类型的对齐至少是该结构或联合的所有成员的对齐的最低公倍数的完美倍数。</p></blockquote><p id="c81b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在out <code class="fe lv lw lx ly b">struct</code>设计中，最低公倍数为</p><blockquote class="mj mk ml"><p id="1335" class="kz la mm lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated">[sizeof(char)，sizeof(bool)，sizeof(uint16_t)，sizeof(uint8_t)]</p></blockquote><p id="f994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是2(由于uint16_t占用2个字节)，这就迫使我们的<code class="fe lv lw lx ly b">struct</code>的大小为10。</p><p id="f6cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际情况是，在末尾添加了1字节的填充，如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/b9be4733f66129e414fe70b02f4453b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*pLniaFx6jaRgkob6fjvgzg.png"/></div></figure><h1 id="7e9d" class="mt me it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">位字段</h1><p id="cf67" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我们能做进一步的修改来减少内存消耗吗？是的，我们可以！！！</p><p id="6757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了表示性别，我们只需要一位(1 =男性，0 =女性)(只考虑男性和女性，只是为了举例)。你不需要8位来表示年龄。没有人活过256 (2⁸)岁:-)。这就是位域有用的地方。看看下面的结构设计。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="6ed1" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">typedef struct </strong>employee {<br/>    <strong class="ly iu">char </strong>employeeId[5];<br/>    <strong class="ly iu">bool </strong>isMale : 1;<br/>    uint8_t age : 7;<br/>    uint16_t salary;<br/>} Employee;</span></pre><p id="ede1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用位域，你可以让编译器知道你想为每个变量使用多少位。在我们的例子中，isMale将只占用1位，而age将占用7位。现在内存对齐看起来像这样，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/99d050c239beb7961d37b3416f5b0fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*y5CVF7iRaS429oNPNgokzQ.png"/></div></figure><p id="38f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你打印我们的<code class="fe lv lw lx ly b">struct</code>的大小，它将只有8个字节。</p><h2 id="840f" class="md me it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">位字段的其他应用</h2><p id="b304" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">假设您必须创建一个包含10个整数变量的结构，其中每个变量只需要40位。但是，40位整数没有标准的C数据类型。因此，剩下的唯一选择就是使用64位整数。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5ffb" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">struct </strong>sample {<br/>    <strong class="ly iu">long </strong>integer1;<br/>    <strong class="ly iu">long </strong>integer2;<br/>    //....<br/>    <strong class="ly iu">long </strong>integer10;<br/>};</span></pre><p id="0fc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用640位(10 x 64 ),而只需要400位。使用位域可以解决这个问题。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a138" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">struct </strong>sample2 {<br/>    <strong class="ly iu">long </strong>integer1 : 40;<br/>    <strong class="ly iu">long </strong>integer2 : 40;<br/>    //....<br/>    <strong class="ly iu">long </strong>integer10 : 40;<br/>};</span></pre><p id="80e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，<code class="fe lv lw lx ly b">struct</code>的大小只有400比特。</p><h2 id="6f78" class="md me it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">使用位域的限制</h2><p id="41de" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">主要的限制是您不能使用位域创建数组。例如，不能创建每个元素为40位的数组。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><div class="kj kk kl km gt oi"><a href="https://www.datadriveninvestor.com/2019/04/22/strategic-or-tactical-programming-the-road-ahead-for-software-engineers/" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">战略或战术规划？软件工程师的未来之路|数据驱动的投资者</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">outer hout(2018)在他的书《软件设计哲学》中提到了一些原则，以便更深入地挖掘…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div><p id="3559" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你喜欢这篇文章！！！</p><p id="1c65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">进入专家视图— </strong> <a class="ae ky" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>