<html>
<head>
<title>TensorFlow 2.0 — From Preprocessing to Serving (Part 4)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TensorFlow 2.0 —从预处理到服务(第4部分)</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/tensorflow-2-0-from-preprocessing-to-serving-part-4-96a6ba1dcd39?source=collection_archive---------2-----------------------#2020-05-19">https://medium.datadriveninvestor.com/tensorflow-2-0-from-preprocessing-to-serving-part-4-96a6ba1dcd39?source=collection_archive---------2-----------------------#2020-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/08e53a62d8dd93eb93a9d412418620b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jH_fVUGTZ6z-XGdXMHe4lg.png"/></div></div></figure><p id="9d94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">欢迎来到TensorFlow及其Keras API教程的第四部分，也是最后一部分。我们将讨论深度学习的一切——从如何预处理输入数据开始，然后建模你的神经网络来编码你的数据和处理输出，优化训练，并将模型作为REST API。</p><p id="3c41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您从标题中看到的，我们已经有了3个关于这个主题的故事，在这个故事中，我们将快速浏览所有这些步骤，并使用创建的模型来满足请求。</p><p id="826e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在开始阅读本文及其前辈之前，您应该了解以下主题的基础知识，以便在阅读时不会感到慌张:</p><ol class=""><li id="c1df" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">结石</li><li id="8d12" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">线性代数</li><li id="fd16" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">神经网络</li><li id="821f" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">熊猫，熊猫</li></ol><p id="361a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您可能已经从主题中推断出的那样，这是一篇编程文章，因此它可能有助于了解python的一些现有经验。</p><p id="dccd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于这篇文章涉及到服务模型，最好在Google Colab上完成——Colaboratory是一个免费的Jupyter笔记本环境，不需要设置，完全在云中运行。</p><p id="7d7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">借助Colaboratory，您可以编写和执行代码、保存和共享您的分析，以及访问强大的计算资源，所有这些都可以从浏览器中免费获得。</p><p id="6a6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在这里使用的数据集是<code class="fe lk ll lm ln b">Fashion-MNIST</code>。<code class="fe lk ll lm ln b">Fashion-MNIST</code>是一个由<a class="ae lo" href="https://jobs.zalando.com/tech/" rel="noopener ugc nofollow" target="_blank">扎兰多</a>的文章图像组成的数据集——由60，000个样本的训练集和10，000个样本的测试集组成。每个示例都是28x28灰度图像，与10个类别的标签相关联。我们打算将<code class="fe lk ll lm ln b">Fashion-MNIST</code>作为原始<a class="ae lo" href="http://yann.lecun.com/exdb/mnist/" rel="noopener ugc nofollow" target="_blank"> MNIST数据集</a>的直接替代，用于机器学习算法的基准测试。它共享训练和测试分割的相同图像大小和结构。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lp"><img src="../Images/180251f9d360381269f2b2d24d2daa27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OvuEcP3S79Mfxoip.png"/></div></div></figure><p id="aa85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来自时尚MNIST数据集的样本(每个类占三行)</p><p id="d151" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能以前使用过MNIST的手写数字数据集，但我们不会在这里使用它，原因有两个:</p><ol class=""><li id="9ad8" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">MNIST的网络设计太简单了，即使是简单的密集网络，你也能达到98%的准确率。</li><li id="c3ad" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">它被过度使用了，我们想要学习新的东西，而不是重复旧的内容。</li></ol><p id="1165" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但首先我们应该了解什么是API:应用程序接口(API)是一组用于构建软件应用程序的例程、协议和工具。API规定了软件组件应该如何交互。</p><p id="2b45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们来看一个小例子:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/7e35bf477c9a18ba446068308d61ba73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/0*DAsZ7LkpfO4T6nLv.png"/></div></figure><p id="e59b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的TensorFlow模型服务器将是相同的，除了它从ML模型返回预测。现在，让我们像在本教程的第一部分中一样加载并规范化数据:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/2ea239e53abe601aebfebee86f77261d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*byScSWR3BGHsbOBA.png"/></div></div></figure><p id="c34c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们将扩展维度，重塑并获得唯一类的数量。现在我们继续构建卷积模型，就像第二个教程一样。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/bbf07ada17c37c7a4cfb7607dbf563c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/0*YMJdRE9TFRLRrMz9.png"/></div></figure><p id="e487" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们开始训练:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lx"><img src="../Images/565d6f4e47e6ee0e0fc8f02a75a4d1d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OZvXTmzvk9q-zzId.png"/></div></div></figure><p id="7e42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们已经训练了模型，我们需要把它保存在一个临时文件中，这样它就可以被服务了，如果已经有一个保存的模型，我们就把它从系统中删除。SavedModel是包含序列化签名和运行它们所需的状态的目录，包括变量值和词汇表。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/39ef5e9b7a06b082ff51cfa9e0caa3f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/0*M6um03ngrHf2e5MW.png"/></div></figure><p id="8db7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意版本的使用。</p><p id="be1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lk ll lm ln b">saved_model.pb</code>文件存储实际的TensorFlow程序或模型，以及一组命名的签名，每个签名标识一个接受张量输入并产生张量输出的函数。</p><p id="13fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SavedModels可能包含模型的多个变体(多个<code class="fe lk ll lm ln b">v1.MetaGraphDefs</code>，用<code class="fe lk ll lm ln b">--tag_set</code>标志到<code class="fe lk ll lm ln b">saved_model_cli</code>来标识)。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/212a12393cac185f13902cae71d7b928.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/0*aPoy1WBRmbKqxGsY.png"/></div></figure><p id="8f63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lk ll lm ln b">saved_model_cli</code>在其输出中包含了更多的类信息，如果您能看到这个命令的完整输出就太好了。</p><p id="d8eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在使用“！”在您的colab终端上安装<code class="fe lk ll lm ln b">tensorflow-model-server</code>包(砰)符号。(在整个代码中还包含了在本地设置软件包的说明)</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/bf24690fa0ca6cb21a6b575ac5a4ca5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-nr6C2Pb2YWi7iPG.png"/></div></div></figure><p id="94a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将继续并开始将模型作为服务来提供。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/fe2c5cb4a6f3169163ac5d43da9aed09.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/0*lP-g4QSeCIj6vOaI.png"/></div></figure><p id="5701" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们开始运行TensorFlow服务和加载模型的地方。加载之后，我们可以开始使用REST进行推理请求。有一些重要的参数:</p><ul class=""><li id="b686" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv mc lc ld le bi translated"><code class="fe lk ll lm ln b">rest_api_port</code>:我们将用于REST请求的端口。</li><li id="dec6" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv mc lc ld le bi translated"><code class="fe lk ll lm ln b">model_name</code>:我们将在REST请求的URL中使用它。它可以是任何东西。</li><li id="47dc" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv mc lc ld le bi translated"><code class="fe lk ll lm ln b">model_base_path</code>:这是我们保存模型的目录路径。</li></ul><p id="b2ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">nohup参数是必需的，以便服务不间断地运行。让我们检查一下我们的日志，看看一切运行正常:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi md"><img src="../Images/4d366421a844436cd6aed306539a63c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/0*tdKOgdR5fPyZDKKH.png"/></div></figure><p id="dab8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果没有记录错误，这意味着我们的模型已经开始服务，我们可以向它发送请求以获得预测。</p><p id="7204" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们看一个来自我们数据集的随机例子:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/f5d3aa8e81ea7509b68cde4738d93003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/0*yvAuy1A0PXR94s-9.png"/></div></figure><p id="dfbd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们将创建一个请求，以JSON格式传递，它应该包含正确格式化的输入，就像我们传递用于训练的数据一样，因为我们的模型被训练为只识别预处理的数据。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/56eed928e99060d495a5e400807c4da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XLWiRNWyyb87bzA5.png"/></div></div></figure><p id="fe3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您可以清楚地看到的，我们传入了3个实例来获得推论。</p><p id="968c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将它打包在一个请求中，并将其发送给我们的预测模型，我们得到一个ping返回，即预测，采用相同的JSON格式。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/f2e829b18a57f55f2976044499adb106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lfoLF4COlF04GkQr.png"/></div></div></figure><p id="8b35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">预测采用SoftMax格式，这是与实例所属的每个类相对应的概率。因此，我们可以做的是通过获取每个预测的argmax并将它们映射回字符串标签来找到每个实例所属的索引。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/46e1c8ba262a4debc6693b9ccfa3a222.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/0*EQsFaZTGqUjrv9F4.png"/></div></div></figure><p id="fcfc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看它们是如何与实际预测相匹配的:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/4c312c1417063c3a71dfa9178635ce4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/0*c0fYADgdiYp_4oNm.png"/></div></figure><p id="5a9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相当不错的成绩！</p><p id="0aec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们来看一下模型的版本化，让我们看看如何根据版本来制作和选择模型:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/8f1643bc5342ba79a239f5e54492ea70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*q8T5B-kxIJwzRrBH.png"/></div></div></figure><p id="3b3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">额外注意URL的最后几个部分，我们向其发出post请求，特别是versions/1:predict，默认情况下，如果只有一个模型，那就是v1，这是唯一被服务的模型。</p><p id="01e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将继续制作模型的另一个版本，再次编译并将其放入我们的数据集。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/61b99891d8943ae09aad10a9d2787ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/0*YNSmMkUBxYxWqV8H.png"/></div></figure><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/ab057788aceac951b8dd1ee7a96ab209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*seSFYD0EnPLfj2i3.png"/></div></div></figure><p id="49dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在适当地保存我们模型的第二个版本:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/6fb828c04a70600f5e1957ed99150d92.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/0*3BNLG1atWfCPtJkV.png"/></div></figure><p id="df70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最酷的是，您不需要重新启动服务器来让模型识别第二个版本，它已经被保存为资产并准备好提供服务。我们再次发出post请求，但是这次是针对模型的第二个版本</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/659a91b25cedc987b8fd9faea6623cae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_j8-XGdkcaLRWaIc.png"/></div></div></figure><p id="339b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看到了吗？URL现在已更改为<code class="fe lk ll lm ln b">2:predict</code>。使用<code class="fe lk ll lm ln b">tensorflow-server</code>进行版本控制很容易。</p><p id="d945" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是此时要问的一个有效问题是，“如果我们使用一个不存在的版本号会怎么样？”让我们来测试一下！</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/e8af49222be0f05f58c2d70b650d78a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Nlzk3Vz2wwgT9zXy.png"/></div></div></figure><p id="baa0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们遇到了一个我们预料到的错误。</p><p id="a77a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">至此，我们完成了从预处理到上菜的整个过程。</p><p id="e399" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要查看完整的代码，请查看:</p><div class="mp mq gp gr mr ms"><a href="https://github.com/lordtt13/Medium-Articles" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">Lord TT 13/中等-物品</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">我的Medium Articles-Lord tt13/Medium-Articles中引用的所有代码的配套报告</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng jw ms"/></div></div></a></div><p id="095d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请继续关注我的下一个系列。</p><p id="6bc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在那之前，再见！</p></div></div>    
</body>
</html>