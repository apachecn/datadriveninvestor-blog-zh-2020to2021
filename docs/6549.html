<html>
<head>
<title>Dealing with Large Datasets in Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在熊猫中处理大数据集</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/dealing-with-large-datasets-in-pandas-ad47100a9424?source=collection_archive---------3-----------------------#2020-10-30">https://medium.datadriveninvestor.com/dealing-with-large-datasets-in-pandas-ad47100a9424?source=collection_archive---------3-----------------------#2020-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/227a349dd718120910f92faf5a100896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tcx4RbqNRbAbTiCJVDJ9tQ.jpeg"/></div></div></figure><p id="fae6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">andas可能是执行探索性数据分析和各种其他任务(如数据清理和转换)的首选库。通常，我们可能希望在大型数据集上利用熊猫的力量，而用传统的方法这样做通常很麻烦。在这篇博文中，我将展示我对此类问题的处理方法，以及它如何使分析过程变得更加可行。</p><h1 id="6b58" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">分块加载数据集</h1><p id="8ae0" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">当我得到一个8GB内存不足以加载CSV文件的错误时，我真的很惊讶。我的spyder IDE决定粉碎我的梦想，刚刚崩溃。</p><p id="d4d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，pandas有办法将数据加载到你的内存可以处理的数据块中。没有你应该使用的固定块大小。这一切都是通过反复试验才知道什么最适合你的机器。一旦以块的形式加载了数据，就可以循环遍历这些块并单独处理它们。最后，将处理过的块连接成一个数据帧。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="4bda" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">删除不必要的列</h1><p id="4523" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">尽可能缩小你的数据帧总是更可取的，如果可能的话，最好在把它加载到pandas之前，因为这将极大地改善处理时间。</p><p id="2a9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以删除不必要的列，或者只选择您需要的列。老实说，我更喜欢使用drop函数来删除它们，因为它清楚地显示了被忽略的内容。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="3286" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">更改数据类型</h1><p id="10b8" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">当使用高效的数据类型时，您可以存储和处理更大的数据集。一些值可以存储在内存要求较低的数据类型中。例如，具有相对较少唯一值的文本数据列可以存储为<strong class="ka ir">分类</strong>数据，因为它将每个唯一值存储一次，并使用有效的整数来表示什么属于什么。您可以使用astype()函数来更改列的数据类型，如下所示。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f53d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，您可以使用pandas to_numeric()函数将整数值向下转换为尽可能小的数据类型。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="8a93" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">矢量化而不是循环</h1><p id="c200" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">使用iterrows()或itertuples()在数据帧中循环只能在pandas矢量化无法应用时作为最后的选择。例如，如果您需要创建一个新列，该列是两个现有列相乘的结果，而不是遍历整个数据帧并一次更新一个单元格，您可以通过矢量化在一行代码中执行此操作。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="3a4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，如果需要从dataframe中筛选出在特定列中具有特定值的行，可以使用isin()函数，而不是像下面这样遍历dataframe。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="1675" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">分块保存数据集</h1><p id="1e0b" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">就像我们以块的形式加载CSV文件一样，我们也可以使用to_csv()函数中的chunksize参数以块的形式保存数据。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure></div></div>    
</body>
</html>