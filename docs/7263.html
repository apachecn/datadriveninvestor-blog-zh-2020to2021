<html>
<head>
<title>The Node.js Architecture!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js架构！</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/the-node-js-architecture-f86e2337bcd2?source=collection_archive---------0-----------------------#2020-12-02">https://medium.datadriveninvestor.com/the-node-js-architecture-f86e2337bcd2?source=collection_archive---------0-----------------------#2020-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1b4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大家好。我希望你过得好！今天，在本文中，我将讨论awesome node.js的工作方式，深入探讨代码在node运行时会发生什么。它是node.js的核心库、依赖项和大脑。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/1fc382b04bebe46c1e0db6eae0e90281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ODU5V_oAmYmzvZ1wIw3rDw.png"/></div></div></figure><p id="1118" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Node.js单独用Javascript写，用c++和Javascript写才能正确运行。node依赖于许多库。然而，V8和LIBUV是处理大多数node.js操作的两个最重要的依赖项。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/719cdaad7218d8df7189df61fcdbbe22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lsXeMZwetEg1M4mQok0-Sw.png"/></div></div></figure><p id="a16b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两个依赖项提供了一个非常好的抽象层，允许我们编写在Node.js中运行的纯JavaScript代码，并且仍然允许我们访问在LIBUV和其他C++库中实现的文件读取功能。这一切的美妙之处在于Node.js将所有这些库绑定在一起，不管它们是用C++还是JavaScript编写的，让我们可以用纯JavaScript访问它们的功能。这使得我们更容易专注于应用程序代码，而无需处理C++代码。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/e3afa9eedd1805333f678117555e76b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V5cXdAh9I9eH6iwLev1rjA.png"/></div></div></figure><p id="da60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们一次探索一个。</p><h1 id="47b5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">V8</h1><p id="a1ee" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">Node.js建立在谷歌的V8引擎之上。它是最快的javascript引擎。V8引擎将javascript代码转换成计算机能够理解的机器代码。然后生成结果并返回给node.js，Node.js无法理解我们在没有V8的情况下编写的javascript代码。除了javascript，V8还使用C++。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ma"><img src="../Images/4b436d8f5b64544bda443448b70db3ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QwIQS5MA1dwEQ2XiW5Hncg.png"/></div></div></figure><h2 id="d29c" class="mb ky iq bd kz mc md dn ld me mf dp lh jy mg mh ll kc mi mj lp kg mk ml lt mm bi translated">* *在开始使用LIBUV之前，您应该对异步I/O有一个基本的了解。</h2><h1 id="f9cc" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">异步输入输出</h1><p id="a2e5" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">异步I/O允许应用程序将处理与I/O操作重叠。简单地说，目标是程序永远不要阻塞。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/9d1b4d2f99eef35348cbd68e0b15b080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T3638zoZng8e5D-j-tpP8w.png"/></div></div></figure><p id="add4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在同步I/O中，线程(一个线程就是一系列指令)会一直等到整个操作完成。另一方面，在异步I/O中，行在操作期间不等待。该操作将在后台运行，完成后将被调用。异步I/O特性使应用程序能够在I/O发生时有更多的CPU时间来执行其他处理。</p><div class="mn mo gp gr mp mq"><a href="https://www.datadriveninvestor.com/2020/11/27/what-separates-a-great-web-developer-from-others/" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">是什么让一个伟大的Web开发者与众不同？数据驱动的投资者</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">你知道吗，2019年，一个网页开发者的平均工资是每年73760美元？更令人震惊的是…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne kv mq"/></div></div></a></div><h1 id="2e57" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">LIBUV</h1><p id="d352" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">LIBUV是node.js的另一个重要依赖项，它让node.js可以访问机器操作系统、网络、文件系统等等。LIBUV是一个开源库，主要关注异步I/O(输入输出)。LIBUV是用C++写的。除了关注异步I/O，LIBUV还实现了两个基本特性:事件循环和线程池。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/a0afff41eec429544f16387e7d1c9541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tvTtKsPc6TvU5NHuV4f-ew.png"/></div></div></figure><p id="2841" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事件循环处理更简单的任务，线程池管理繁重的任务。让我们一个一个的去探索。</p><h1 id="2382" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">事件循环</h1><p id="2465" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">当我们在一台计算机上使用Node.js时，有一个节点进程在那台计算机上运行。流程只是一个执行中的程序。在这个过程中，Node.js在一个线程中运行。线程只是一系列的指令，深入理解什么是线程或进程并不重要。把线程想象成一个盒子，在那里我们的代码在计算机的处理器中执行。现在，需要理解的是，节点只在一个线程中运行。例如，如果我们有四个不同的任务，那么这四个任务都将发生在一个线程中。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/55c434ef234141569b819ea292c705c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hk7dVPNfNMyStwH5mkCciA.png"/></div></div></figure><p id="32e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们为PHP等语言中的每个任务创建了一个新线程。同样，如果您运行节点应用程序，它将只在一个线程中运行。不管你有一个用户还是100个用户，或者可能有1亿个用户同时访问你的应用程序。事件循环被称为node.js的心脏。它在单个线程中执行所有的回调函数(一些工作一完成就调用的函数)，并且它还卸载繁重或昂贵的任务，如将文件压缩到线程池。Eventloop使node.js中的异步编程成为可能，我将在下一篇文章中讨论异步编程。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/9946aa77fcf4fcb6b2f240441deb284e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4YPVS6HOdQgRypcCxCIqKw.png"/></div></div></figure><p id="1e1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它负责处理所有传入的事件，并通过将较重的任务卸载到线程池中并自己完成较简单的任务来执行平衡部分。我将在接下来的几篇文章中再次讨论事件循环，因为还有更多内容，它是node.js中的基本特性。你应该记住，事件循环是node js的核心，这使Node完全不同于其他后端语言。</p><h1 id="b9dd" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">线程池</h1><p id="4fff" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">线程池从事件循环中的单个主线程中为我们提供了四个独立的线程。我们最多可以配置128行，但是通常，这四行就够了。所以这四个线程一起形成了一个线程池。事件循环会将繁重的任务卸载到线程池，这在后台自动发生。不是我们开发人员决定什么进入线程池，什么不进入线程池。被卸载的一些昂贵的任务都是处理文件的操作，所有与加密相关的事情，如缓存密码，所有与压缩相关的功能，DNS查找(将web域与其对应的真实IP地址匹配)，等等。这是最容易阻塞主线程的东西。因此，节点通过自动将它们卸载到线程池中来处理它。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/efe83a14a8cc0a103a07d6c34dae1fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2yFI2vc6Cn7SW1eqo2YEoQ.png"/></div></div></figure><p id="58e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，当请求到达节点服务器时，它将通过事件队列进入事件循环。事件循环现在将检查任务是否繁重，如处理文件的操作或与网络相关的操作。如果任务很重，它将把任务卸载到线程池，线程池将单独执行任务。它不会阻塞我们的事件循环，事件循环可以执行所有不太复杂的任务</p><h1 id="ef50" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">其他重要的图书馆</h1><p id="de7b" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">Node.js最重要的库是LIBUV和V8。然而，该节点不仅基于V8和LIBUV，还基于其他一些库，如用于解析HTTP的HTTP parser、用于DNS查询的C-ARES、用于加密的OpenSSL和用于文件压缩的Zlib。当所有这些组件完美地结合在一起时，我们就有了Node。JS可以在服务器端用于我们所有的应用程序。</p><h1 id="6186" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">事件驱动架构</h1><p id="34f8" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">该节点的大多数核心模块，如HTTP文件系统，都是围绕事件驱动的架构构建的。这个概念很简单。在node中，有一些称为事件发射器的特定对象，一旦应用程序中发生重要的事情，如请求到达服务器或文件完成读取，它们就会发出命名的事件。事件监听器然后拾取我们开发人员设置的这些事件，这些事件将触发附加到每个监听器的函数(回调函数)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/b2fc5bd527d742f0fb84a69f4422e5b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gkZMUn_7StVUm8HnC9w-MA.png"/></div></div></figure><p id="1c44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一方面，我们有将发出命名事件的事件发射器，另一方面，我们有通过调用回调函数对发出的事件做出反应的事件侦听器。事件驱动的架构使得多次响应同一事件变得更加简单。我们所要做的就是设置多个监听器。</p><p id="03b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，简而言之，这就是节点的事件驱动架构。不要担心这似乎有点太理论化。我将在下一篇文章中解释更多关于事件和回调函数的内容，我们也将看到这种逻辑在许多情况下被使用。所以在我的下一篇文章中再见。祝您愉快！</p><h2 id="7d66" class="mb ky iq bd kz mc md dn ld me mf dp lh jy mg mh ll kc mi mj lp kg mk ml lt mm bi translated">访问专家视图— <a class="ae nf" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank">订阅DDI英特尔</a></h2></div></div>    
</body>
</html>