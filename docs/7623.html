<html>
<head>
<title>10 Must-Have Continuous Integration Steps for JavaScript and NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript和NodeJS的10个必备持续集成步骤</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/10-must-have-continuous-integration-steps-for-javascript-and-nodejs-31ee17bdf8d8?source=collection_archive---------3-----------------------#2020-12-16">https://medium.datadriveninvestor.com/10-must-have-continuous-integration-steps-for-javascript-and-nodejs-31ee17bdf8d8?source=collection_archive---------3-----------------------#2020-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/30a2a34beefc297e9a49ed3affa62218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UnGrivimft-QCpuq7pAkiQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@xavier_von_erlach?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Xavier von Erlach</a> on <a class="ae kf" href="https://unsplash.com/s/photos/cog?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="312e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论你有一个小的前端服务，一个大的整体，正在构建一个MVP或者一个生产级的应用——拥有一个持续的集成服务运行提交将会极大地帮助你的开发速度和质量。</p><p id="5ce1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在的持续集成服务非常容易建立，支持Dockerfiles，而且非常便宜。它们支持拾取每个代码变更或特定分支，并运行您的脚本，以便您可以对提交的每个代码进行检查，并且永远不会忘记运行您的单元测试。尤其是如果你经常犯错误，这是一个很好的方法来看看哪个改变破坏了什么。</p><p id="f131" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是你的线人应该做什么样的检查呢？以下脚本面向JavaScript(和/或NodeJS)开发人员，尽管最佳实践几乎适用于任何语言和服务。</p><h2 id="e042" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">1 |检查第三方包的安全问题</h2><p id="5cb0" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">为了确保您意识到潜在的安全问题并能够缓解它们，您可以运行NPM的<code class="fe mc md me mf b">audit</code>命令。它会搜索发布您正在使用的第三方软件包(甚至是您的第三方软件包正在使用的那些)，这些软件包已经在他们的数据库中存档，您可以在https://www.npmjs.com/advisories的<a class="ae kf" href="https://www.npmjs.com/advisories" rel="noopener ugc nofollow" target="_blank">看到。这意味着它只包括用户报告的问题。</a></p><p id="0278" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">安全级别遵循https://www.first.org/cvss/specification-document的CVSS(<a class="ae kf" href="https://www.first.org/cvss/specification-document" rel="noopener ugc nofollow" target="_blank"/>)，这意味着对所有重要或关键问题运行您的审计并使用代码<code class="fe mc md me mf b">1</code>退出，您可以在您的配置项中实现以下步骤:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="62d1" class="le lf it mf b gy mo mp l mq mr">npm audit --audit-level=high</span></pre><p id="1a0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将扫描您的软件包并输出所有发现的问题。根据您的依赖项的数量，发现的问题列表可能会很长；如果您只想查看重要和关键问题，可以使用以下命令:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="3214" class="le lf it mf b gy mo mp l mq mr">npm audit --audit-level=high | grep -E "(High | Critical)" -B3 -A10</span></pre><p id="ebf8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(在<a class="ae kf" href="https://github.com/npm/npm/issues/20596" rel="noopener ugc nofollow" target="_blank">https://github.com/npm/npm/issues/20596</a>发现)</p><p id="cb68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了NPM(或纱)审计，有更多的方法来搜索安全问题。一般来说，你应该尽可能多地覆盖你的基础设施:从你自己的代码到你的代码正在处理的整个堆栈。</p><p id="07bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果你在生产中使用Docker，你可以运行像Clair(<a class="ae kf" href="https://github.com/quay/clair" rel="noopener ugc nofollow" target="_blank">https://github.com/quay/clair</a>)这样的工具来静态分析你的Docker图像。</p><p id="931e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">特别是如果你有B2B客户，安全检查对通过他们的审计是很重要的。你可以在https://medium.com/@Markus.<a class="ae kf" href="https://medium.com/@Markus.Hanslik/what-a-customers-it-security-audit-for-web-apps-is-and-how-to-pass-it-b637c9df67a1" rel="noopener">了解更多关于B2B安全审计的信息Hans lik/what-a-customers-it-security-audit-for-web-apps-is-and-how-to-pass it-b 637 c 9 df 67 a 1</a>。</p><h2 id="e117" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">2 |检查法律问题</h2><p id="cad7" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">你正在开发不想开源的专有软件吗？那么你一定要确保你遵守你正在使用的第三方软件包的许可。毕竟，如果你是在构建封闭源代码，你是不允许使用一些像GPL-2这样的许可证的。</p><p id="82a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">NPM包<code class="fe mc md me mf b">license-checker</code>遍历您正在使用的所有NPM包，可能会因为无效的许可证而失败，这使它成为您的CI的完美步骤。</p><h2 id="4638" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">3 |检查过期的依赖项</h2><p id="966d" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">尤其是在短暂的JavaScript世界中，包更新非常频繁，有时甚至一天更新多次。</p><p id="44c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有多种方法可以让您的配置项报告过期的软件包，以便您可以更新它们；最简单的方法是使用NPM软件包。</p><p id="9275" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mc md me mf b">npm-check-updates</code>顾名思义，它会检查您的任何第三方NPM依赖项是否过期，然后抛出退出代码，以便您的配置项可以提醒您需要更新:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="bfe5" class="le lf it mf b gy mo mp l mq mr">ncu --errorLevel 2</span></pre><p id="5c1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(如果您计划手动更新软件包，您可能希望将CI步骤设置为将来自NCU的错误视为警告，这样您的管道不会被阻塞，但您仍然知道需要进行更新。)</p><p id="9274" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了这种非常手动的方法，还有一些工具可以自动检查更新，甚至支持检查Dockerfiles中过时的库等等。查看renew(<a class="ae kf" href="https://www.whitesourcesoftware.com/free-developer-tools/renovate/" rel="noopener ugc nofollow" target="_blank">https://www . white source software . com/free-developer-tools/renew/</a>)或Snyk ( <a class="ae kf" href="https://snyk.io" rel="noopener ugc nofollow" target="_blank"> https://snyk.io </a>)，它们也支持安全审计。</p><h2 id="ce2c" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">4 | Lint您的代码以查找编码风格和质量问题</h2><p id="2cdb" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">如果你在一个团队中工作，或者即使你只是在一个较长时间跨度的项目中工作，编码风格有可能会偏离，使你的代码难以阅读。手动检查需要时间，并且会降低代码审查的速度。</p><p id="d29a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，你可以使用<code class="fe mc md me mf b">prettier</code>(<a class="ae kf" href="https://prettier.io" rel="noopener ugc nofollow" target="_blank">https://prettle . io</a>)来确保你所有的文件总是以相同的方式自动格式化。</p><p id="fa19" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想在代码格式不正确的情况下使CI管道失败，只需使用以下命令(通过NPM安装了prettier之后):</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="44d1" class="le lf it mf b gy mo mp l mq mr">prettier --check “src/**/*.*“ --ignore-unknown</span></pre><p id="83cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ignore-unknown标志将确保prettier只检查它实际上可以格式化的文件，比如JavaScript、TypeScript、HTML甚至YaML。</p><p id="d2cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您的CI支持在一个步骤中提交代码，您也可以直接修复所有错误:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="6d17" class="le lf it mf b gy mo mp l mq mr">prettier "**/*" --write --ignore-unknown</span></pre><p id="89d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，你可以使用<code class="fe mc md me mf b">eslint</code>(【https://eslint.org】)来lint你的代码。它现在还支持TypeScript，所以不再需要安装TSLint使用推荐的ESLint规则将帮助您发现代码中的潜在问题(例如，getter函数不返回任何内容)，并遵循最佳实践(例如，不要在条件表达式中赋值以增加可读性)。</p><p id="5c96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦通过NPM安装并设置了ESLint，就可以在CI步骤中使用以下脚本:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="6413" class="le lf it mf b gy mo mp l mq mr">npx eslint src --ext .js --format junit &gt; eslint.xml</span></pre><p id="3494" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将对您的带有<code class="fe mc md me mf b">js</code>扩展名的<code class="fe mc md me mf b">src</code>文件夹中的文件运行ESLint，并以JUnit格式输出其结果，这可以被大多数CI系统解析。</p><p id="7f27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">顺便说一下，如果您想在一个CI作业中运行多个脚本，但不希望立即失败，您可以像这样组合退出代码:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="3c76" class="le lf it mf b gy mo mp l mq mr">- RESULT=0<br/>- npx prettier -c ‘src/**/*.*‘ — Ignore-unknown || RESULT=$((RESULT + $?)) || true<br/>- npx eslint src — ext .js — format junit &gt; eslint.xml || RESULT=$((RESULT + $?)) || true<br/>- if [ $RESULT -gt 0 ]; then exit 1; fi</span></pre><h2 id="b97f" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">5 |在您的容器中构建和测试！</h2><p id="7398" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">您的CI渠道支持运行Docker容器吗？如果是这样，为了减少出错的空间，并减少代码重复，不要直接在CI的标准runner映像中运行测试，而是在您的应用程序中使用的实际Docker映像中运行测试。</p><div class="ms mt gp gr mu mv"><a href="https://www.datadriveninvestor.com/2020/12/07/name-matching-techniques-with-python/" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">使用Python |数据驱动投资者的名称匹配技术</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">我们确实面临很多情况，我们必须匹配一个有很多变体的单词。这可能是因为错别字…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj jz mv"/></div></div></a></div><p id="ddf6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果您使用Bitbucket Pipelines CI系统，默认情况下，测试步骤可能如下所示(摘自<a class="ae kf" href="https://support.atlassian.com/bitbucket-cloud/docs/javascript-nodejs-with-bitbucket-pipelines/" rel="noopener ugc nofollow" target="_blank">https://support . atlassian . com/bit bucket-cloud/docs/JavaScript-nodejs-with-bit bucket-Pipelines/</a>):</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="6106" class="le lf it mf b gy mo mp l mq mr">image: node:10.15.0<br/>pipelines:<br/>  default:<br/>    - step:<br/>      script:<br/>        - npm install<br/>        - npm test</span></pre><p id="8c45" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，这将在普通NodeJS映像中测试您的代码。如果你正在开发一个做一些图像操作的后端应用程序，你的代码可能使用ImageMagick，并且在这里失败；即使您的实际生产Docker映像可能正确安装了ImageMagick。</p><p id="2c4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种可能导致失败的情况是，您正在更新生产映像的节点版本，但忘记在配置项中执行此操作；您可以在CI中通过测试，但是您的代码在生产中可能会失败。</p><p id="dea6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在您的实际容器中运行测试可能如下所示:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="3e28" class="le lf it mf b gy mo mp l mq mr"># First, build the container<br/>- docker build -t $IMAGE_NAME:$IMAGE_TAG .<br/># Then, run the tests inside your container<br/>- docker run — name $IMAGE_NAME-tester-$IMAGE_TAG $IMAGE_NAME:$IMAGE_TAG sh -c “npm run test“<br/># Finally, copy the test results from inside your container to the CI, so that you may use it as an artifact<br/>- mkdir -p artifacts<br/>- docker cp $IMAGE_NAME-tester-$IMAGE_TAG:/usr/app/src/test-reports ./artifacts/<br/>- docker rm -f $IMAGE_NAME-tester-$IMAGE_TAG</span></pre><h2 id="caaf" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">6 |正确标记您的容器</h2><p id="ada1" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">如果您在CI管道中构建容器，请确保不要仅仅将它们标记为<code class="fe mc md me mf b">latest</code>。这将有助于部署它们；但这也将确保你可以重新运行管道，而不会破坏东西。</p><p id="555e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你只使用<code class="fe mc md me mf b">latest</code>标签，然后重新运行一个更老的管道，你会不小心替换掉你实际的<code class="fe mc md me mf b">latest</code>镜像；因此，您应该尽可能地使用语义版本控制(例如，在您的发布标签上),否则使用您的分支名称和管道ID进行标记。</p><p id="ddfd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，您可以随时重新运行任何管道，而不会覆盖任何标记，并且可以轻松地引用任何图像。</p><h2 id="7752" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">7 |添加集成测试</h2><p id="476b" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">您的服务可能不是完全独立的，并且会使用其他服务。为了确保这些都一起工作，您可以在您的CI管道中编写和运行集成测试。</p><p id="fc27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用Docker，您甚至可以旋转多个容器——您的关键依赖项——而无需模仿一切，然后运行Jest或更复杂的堆栈，如Puppeteer或Cypress测试(针对web应用程序)。</p><h2 id="3d53" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">8 |以“快速失败”的方式运行测试</h2><p id="be7a" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">添加到CI中的步骤和测试越多，单次运行所需的时间就越长。这几乎总是会导致开发人员提交的频率降低，从而导致CI运行的频率降低，从而导致由于大量提交而导致的失败难以确定。</p><p id="eb3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这不应该阻止您添加许多测试来尽可能高效地自动化；但是它应该意味着你以最有效的方式分组和运行你的测试。</p><p id="0bf2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您能指定在其他测试失败之前失败的关键测试，或者必须通过的测试吗？如果是这样的话，你应该首先运行它们，这样开发者就能得到快速的反馈。如果这些测试通过了，其他的就可以在之后运行了。</p><p id="dcd7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您有许多测试，您需要在任何分支、任何提交上运行所有检查和测试吗？或者只在夜间运行其中一些就足够了吗？如果你的代码结构足够好，你能先测试你修改过的模块/服务，然后再测试剩下的吗？</p><h2 id="7c66" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">9 |将工件导出为JUnit文件</h2><p id="91ff" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">尝试使用支持解析测试结果的JUnit格式的CI。直接打开一个合并请求并获得所有测试错误和警告的解析概述要容易得多，而不必打开每个失败的CI步骤并滚动控制台输出。好的开发者体验意味着更高的产出！</p><p id="40b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如今，JUnit如此普及，以至于大多数工具都可以开箱即用地生成它们，或者只需很少的设置。ESLint、Jest、Cypress和许多其他工具可以输出Junit XML文件；GitLab等CI管道可以解析它们，并自动在CI管道分支的合并请求中显示它们。</p><p id="ae3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，如果您有额外的KPI，请尝试将其导出，以便您可以看到它们随时间的变化。例如，如果您重视代码覆盖率，将它传递给您的CI；或者，如果您关心特性覆盖率，请为您的CI计算并传递它。</p><p id="705b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于GitLab，解析Jest Junit文件以及代码覆盖率在CI步骤中会是这样的:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="d374" class="le lf it mf b gy mo mp l mq mr">Test:<br/>  script:<br/>    - npm run test # ...<br/>  artifacts:<br/>    name: Test results<br/>    paths:<br/>      - artifacts/<br/>    expire_in: 4 weeks<br/>    reports:<br/>      junit:<br/>        - artifacts/*.xml<br/>  coverage: /All files[^|]*\|[^|]*\s+([\d\.]+)/</span></pre><h2 id="9b46" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">10 |使用您的CI进行部署</h2><p id="879b" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">通过您的CI进行部署，以进一步减少出错的空间。它将使您能够重新播放部署以恢复更改(即使您最初没有蓝/绿部署)，它将消除容易出错的手动部署列表，并且一旦设置好，它将大大增加发布信心。</p><p id="c609" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，您可以更容易地更新您的文档，而不会忘记任何东西。</p><p id="7af0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设您使用Bugsnag之类的错误报告工具，那么您可以在每次部署后将发布信息推送到Bugsnag，这样您的错误指示板就可以保持最新。</p><p id="40a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你有一个<code class="fe mc md me mf b">CHANGELOG.md</code>文件吗？你可以grep推送的版本的变化，并在你的团队频道中公布。</p><p id="710c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">进入专家视图— </strong> <a class="ae kf" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>