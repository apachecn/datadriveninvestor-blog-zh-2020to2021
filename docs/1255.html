<html>
<head>
<title>Create Singly Linked Lists using Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Javascript创建单链表</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/create-singly-linked-lists-using-javascript-29c77b0557ad?source=collection_archive---------8-----------------------#2020-03-10">https://medium.datadriveninvestor.com/create-singly-linked-lists-using-javascript-29c77b0557ad?source=collection_archive---------8-----------------------#2020-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c2deb2e815b3c23fd82723c74be096f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9-5wIeqzqBwGjEUI"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@iam_anih?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Anika Huizinga</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1b5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">链表是一种数据结构，包含一个<strong class="ki iu">头</strong>、<strong class="ki iu">尾</strong>和<strong class="ki iu">长度</strong>属性。链表由节点组成，每个节点都有一个值和一个指向另一个节点或null的指针。</p><p id="20e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们比较链表和数组时，最大的区别就是链表没有索引。链表通过带有下一个<strong class="ki iu">指针</strong>的节点连接，这意味着不允许随机访问。为了做到这一点，我们必须遍历链接。链表擅长<strong class="ki iu">插入</strong>和<strong class="ki iu">删除</strong>。与数组不同，链表在插入或删除元素时不需要重新分配索引。</p><p id="280e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这一课中，我将向你展示如何使用Javascript编写链表的插入和删除方法。</p><h1 id="3675" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">推</h1><p id="93aa" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">记住，链表是链接节点的集合，所以我们可以通过在链表的末尾添加一个新节点来将一个元素推送到链表中！</p><p id="380c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以让我们从为每个节点定义一个类开始。一个节点很简单。它需要一段数据(<strong class="ki iu">值</strong>)和对下一个节点的引用(<strong class="ki iu"> next </strong>)。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1f09" class="mq lf it mm b gy mr ms l mt mu">Class Node {<br/>      constructor (val) {<br/>          this.val = val;<br/>          this.next = null;<br/>//at the beginning nothing comes after val</span><span id="595d" class="mq lf it mm b gy mv ms l mt mu">      }</span><span id="13d3" class="mq lf it mm b gy mv ms l mt mu">}</span></pre><p id="dac8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们定义自己的sinlyLinkedList类来利用node类。我们初始化新创建的链表的头、尾和长度。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6449" class="mq lf it mm b gy mr ms l mt mu">Class singlyLinkedList {<br/>      constructor () {<br/>          this.head = null;<br/>          this.tail = null;<br/>          this.length = 0;</span><span id="f091" class="mq lf it mm b gy mv ms l mt mu">      }<br/>//here, we are going to define the push method</span><span id="7a64" class="mq lf it mm b gy mv ms l mt mu">}</span></pre><h2 id="8658" class="mq lf it bd lg mw mx dn lk my mz dp lo kr na nb ls kv nc nd lw kz ne nf ma ng bi translated">推送伪代码</h2><ul class=""><li id="5a70" class="nh ni it ki b kj mc kn md kr nj kv nk kz nl ld nm nn no np bi translated">这个函数应该接受一个值</li><li id="9d1f" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">使用传递给函数的值创建一个新节点</li><li id="ba59" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">如果列表中没有head属性，则将head和tail设置为新创建的节点</li><li id="445c" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">否则，将尾部的下一个属性设置为新节点，并将列表的尾部属性设置为新创建的节点</li><li id="13fd" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">将长度增加一</li><li id="ede0" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">返回链表</li></ul><p id="4ad3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是代码！</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fa7d" class="mq lf it mm b gy mr ms l mt mu">Class singlyLinkedList {<br/>      constructor () {<br/>          this.head = null;<br/>          this.tail = null;<br/>          this.length = 0;</span><span id="ce9d" class="mq lf it mm b gy mv ms l mt mu">}<br/>      push(val) {</span><span id="e193" class="mq lf it mm b gy mv ms l mt mu">           var newNode =new Node(val); //implementing the node class we created before<br/>           if(!this.head) {<br/>             this.head = new Node;<br/>             this.tail = this.head;</span><span id="6bba" class="mq lf it mm b gy mv ms l mt mu">           } else {<br/>             this.tail.next = newNode;<br/>             this.tail = newNode;</span><span id="e51c" class="mq lf it mm b gy mv ms l mt mu">           }<br/>           this.length++;<br/>           return this;</span><span id="505d" class="mq lf it mm b gy mv ms l mt mu">      }</span><span id="8356" class="mq lf it mm b gy mv ms l mt mu">}</span></pre><h1 id="8283" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">间歇的</h1><p id="e3b8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们从链表的末尾移除一个<strong class="ki iu">节点</strong>！这比pushing方法稍微复杂一点，因为单链表没有向后指针。我们必须遍历列表。</p><h2 id="c9eb" class="mq lf it bd lg mw mx dn lk my mz dp lo kr na nb ls kv nc nd lw kz ne nf ma ng bi translated">弹出伪代码</h2><ul class=""><li id="2c1a" class="nh ni it ki b kj mc kn md kr nj kv nk kz nl ld nm nn no np bi translated">如果列表中没有节点，返回undefined</li><li id="684d" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">循环遍历列表，直到到达末尾</li><li id="2776" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">将第二个到最后一个节点的next属性设置为null</li><li id="7f0f" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">将尾部设置为倒数第二个节点</li><li id="55e8" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">将列表长度减1</li><li id="3293" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">返回被删除节点的值</li></ul><p id="678e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将在singlyLinkedList类中编写pop方法。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c2f3" class="mq lf it mm b gy mr ms l mt mu">pop(val) {</span><span id="6096" class="mq lf it mm b gy mv ms l mt mu">   if(!this.head) return undefined;<br/>   var current = this.head;<br/>   var newTail = current;<br/>   while(current.next){<br/>        newTail = current;<br/>        current = current.next;</span><span id="427e" class="mq lf it mm b gy mv ms l mt mu">   }<br/>   this.tail = newTail;<br/>   thils.tail.next = null;<br/>   this.length--;</span><span id="4e17" class="mq lf it mm b gy mv ms l mt mu">//when there is one item left in the link, we have to set the head and tail to be null after popping</span><span id="950a" class="mq lf it mm b gy mv ms l mt mu">   if(this.length === 0) {<br/>     this.head = null;<br/>     this.tail = null;</span><span id="c1a0" class="mq lf it mm b gy mv ms l mt mu">   }</span><span id="48bd" class="mq lf it mm b gy mv ms l mt mu">   return current;</span><span id="ebb6" class="mq lf it mm b gy mv ms l mt mu">}</span></pre></div></div>    
</body>
</html>