<html>
<head>
<title>Algorithm Solving Strategies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法求解策略</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/algorithm-solving-strategies-89ce5248cb03?source=collection_archive---------12-----------------------#2020-12-07">https://medium.datadriveninvestor.com/algorithm-solving-strategies-89ce5248cb03?source=collection_archive---------12-----------------------#2020-12-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/045fd360c9a0d2a2c2dda5e6beed32e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zk95CvUgW6GjcEcn"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@wocintechchat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christina @ wocintechchat.com</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5724" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你读过我之前关于<a class="ae kc" href="https://medium.com/swlh/big-o-notation-128b7b8051c9" rel="noopener"> Big O Notation </a>的博客，你可能记得算法被定义为“一个定义明确的、计算机可实现的指令的有限序列，通常是为了解决一类问题或执行一种计算”(<a class="ae kc" href="https://en.wikipedia.org/wiki/Algorithm" rel="noopener ugc nofollow" target="_blank">维基百科</a>)。算法对所有软件工程师来说都很重要，因为它们可以帮助我们解决工作中可能遇到的问题。</p><p id="f321" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能正在读这篇博文，因为你目前正在找工作。如果是这样的话，<a class="ae kc" href="https://leetcode.com/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>和<a class="ae kc" href="https://www.hackerrank.com/" rel="noopener ugc nofollow" target="_blank"> HackerRank </a>都有数百个练习算法的问题供求职者利用。这篇博客的目的是用一些策略来武装你，帮助你解决这些类型的问题，以及你在面试和工作中可能遇到的问题。</p><p id="9050" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本博客将要讨论的三个策略包括:</p><ol class=""><li id="b9ed" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kf ir">频率计数器</strong></li><li id="2b93" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">多指针</strong></li><li id="c036" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">推拉窗</strong></li></ol><p id="9bcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lp">这些策略来自柯尔特·斯蒂尔的JavaScript算法和数据结构大师班Udemy课程，我强烈推荐。这些例子主要来自LeetCode。</em></p><h2 id="8baf" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">计数式频率计</h2><p id="9d3c" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">频率计数器方法可以应用于需要收集值或检查某个值出现的次数的算法。这种策略利用了对象或集合，避免了对嵌套循环的需要(Steele)。此外，频率计数器将我们的解决方案的时间复杂度从O(n )(如果使用嵌套循环)提高到O(n)。</p><p id="5b16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，为了在实践中展示频率计数器策略，让我们看一个来自Leetcode的例子。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6b10" class="lq lr iq mt b gy mx my l mz na"><strong class="mt ir">Source</strong>: <a class="ae kc" href="https://leetcode.com/problems/valid-anagram/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/valid-anagram/</a></span><span id="f475" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">Problem</strong>:</span><span id="64eb" class="lq lr iq mt b gy nb my l mz na">Given two strings <em class="lp">s</em> and <em class="lp">t </em>, write a function to determine if <em class="lp">t</em> is an anagram of <em class="lp">s</em>.</span><span id="725a" class="lq lr iq mt b gy nb my l mz na">  Test Case #1</span><span id="99ff" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">     Input:</strong> <em class="lp">s</em> = "tennis", <em class="lp">t</em> = "entsno"<br/>     <strong class="mt ir">Output: </strong>false</span><span id="67e7" class="lq lr iq mt b gy nb my l mz na">  Test Case #2</span><span id="5e6e" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">     Input:</strong> <em class="lp">s</em> = "tan", <em class="lp">t</em> = "nat"<br/>     <strong class="mt ir">Output: </strong>true</span></pre><p id="9f8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个示例中，我们将使用频率计数器方法来检查每个字符串是否都有相同的字母，以及这些字母出现的次数是否相同。如果这两个检查都为真，我们知道s和t是变位词。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="d37b" class="lq lr iq mt b gy mx my l mz na"><strong class="mt ir">Solution:</strong></span><span id="598d" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">var</strong> isAnagram = function(s, t) {<br/>  // if string lengths are different, it's impossible for string t <br/>    // to be an anagram<br/>  <strong class="mt ir">if</strong> (s.length !== t.length) {<br/>    <strong class="mt ir">return</strong> false;<br/>  }</span><span id="db3a" class="lq lr iq mt b gy nb my l mz na">  <strong class="mt ir">const</strong> lookup = {};</span><span id="078d" class="lq lr iq mt b gy nb my l mz na">  <strong class="mt ir">for</strong> (let i = 0; i &lt; s.length; i++) {<br/>    <strong class="mt ir">let</strong> letter = s[i];<br/>    // if letter exists, increment by 1, otherwise set to 1<br/>    lookup[letter] ? lookup[letter] += 1 : lookup[letter] = 1;<br/>  }<br/>  <br/>  <strong class="mt ir">console.log</strong>(lookup)</span><span id="74d3" class="lq lr iq mt b gy nb my l mz na">   <strong class="mt ir">for</strong> (let i = 0; i &lt; t.length; i++) {<br/>    <strong class="mt ir">let</strong> letter = t[i];<br/>    // if letter not found or letter value is zero then string t is<br/>      // not an anagram of string s<br/>    <strong class="mt ir">if</strong> (!lookup[letter]) {<br/>      <strong class="mt ir">return</strong> false;<br/>    } <strong class="mt ir">else</strong> {<br/>      lookup[letter] -= 1;<br/>    }<br/>    <strong class="mt ir">console.log</strong>(lookup)<br/>   }</span><span id="1fbe" class="lq lr iq mt b gy nb my l mz na">   <strong class="mt ir">return</strong> true;<br/>};</span><span id="5431" class="lq lr iq mt b gy nb my l mz na">isAnagram("tennis", "entsno")<br/>isAnagram("tan", "nat")</span><span id="67ba" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">Test Case #1 Output</strong>: </span><span id="8f4c" class="lq lr iq mt b gy nb my l mz na">// lookup object after looping over s string<br/>{ t: 1, e: 1, n: 2, i: 1, s: 1 }</span><span id="1777" class="lq lr iq mt b gy nb my l mz na">// lookup object decrementing by matching letters in t string <br/>  //  after each loop<br/>{ t: 1, e: 0, n: 2, i: 1, s: 1 }<br/>{ t: 1, e: 0, n: 1, i: 1, s: 1 }<br/>{ t: 0, e: 0, n: 1, i: 1, s: 1 }<br/>{ t: 0, e: 0, n: 1, i: 1, s: 0 }<br/>{ t: 0, e: 0, n: 0, i: 1, s: 0 }</span><span id="5b1d" class="lq lr iq mt b gy nb my l mz na">false</span><span id="d0f9" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">Test Case #2 Output</strong>:</span><span id="98e0" class="lq lr iq mt b gy nb my l mz na">// lookup object after looping over s string<br/>{ t: 1, a: 1, n: 1 }</span><span id="d53d" class="lq lr iq mt b gy nb my l mz na">// lookup object decrementing by matching letters in t string <br/>  //  after each loop<br/>{ t: 1, a: 1, n: 0 }<br/>{ t: 1, a: 0, n: 0 }<br/>{ t: 0, a: 0, n: 0 }</span><span id="b52e" class="lq lr iq mt b gy nb my l mz na">true</span></pre><p id="3649" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的解决方案中，我们首先检查字符串是否长度相同。我们进行这种检查是因为如果字符串长度不同，我们知道它们不可能是变位词，因此不需要通过任何额外的代码。解决方案中的第一个循环将字符串s中所有字母及其频率的汇总创建到一个名为lookup的对象中。第二个循环检查字符串t中的字母是否出现在lookup中，并且值是否大于0。如果这些条件都为真，则字母在查找中的频率递减1；如果不是，我们知道字符串t不是字符串s的变位词。如果第二个循环遍历字符串t中的最后一个字母，那么我们返回true作为频率，lookup中的所有字母都将是0。</p><h2 id="1ea8" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">多个指针</h2><p id="4806" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">多指针策略通常用于线性结构(即数组、字符串和链表)。当您需要搜索满足特定条件的一个值或一对值时，多指针非常有用。柯尔特·斯蒂尔对其工作过程描述如下，“创建对应于索引或位置的指针或值，并根据特定条件向开始、结束或中间移动”(斯蒂尔)。Steele还提到，多指针解决方案具有高效的时间复杂度O(n)和最小的空间复杂度O(1)。</p><p id="08b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，为了在实践中展示多指针策略，让我们看一个例子。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="b60a" class="lq lr iq mt b gy mx my l mz na"><strong class="mt ir">Source</strong>: <a class="ae kc" href="https://leetcode.com/problems/valid-anagram/" rel="noopener ugc nofollow" target="_blank">C</a>olt Steele's JavaScript Algorithms and Data Structures Masterclass Course on Udemy</span><span id="87e9" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">Problem</strong>:</span><span id="9e4b" class="lq lr iq mt b gy nb my l mz na">Write a function called sumZero which accepts a <strong class="mt ir">sorted array</strong> of integers.The function should find the first pair where the sum is 0. Return an array that includes both values that sum to zero or undefined if a pair does not exist.</span><span id="7e04" class="lq lr iq mt b gy nb my l mz na">Test Case #1<br/>     <br/>     <strong class="mt ir">Input</strong> = [-3, -2, -1, 0, 1, 2, 3]<br/>     <strong class="mt ir">Output</strong> = [-3, 3]</span><span id="eee1" class="lq lr iq mt b gy nb my l mz na">Test Case #2<br/>     <br/>     <strong class="mt ir">Input</strong> = [-2, 0, 1, 3]<br/>     <strong class="mt ir">Output</strong> = undefined</span><span id="0a5d" class="lq lr iq mt b gy nb my l mz na">Test Case #3<br/>     <br/>     <strong class="mt ir">Input</strong> = [1, 2, 3]<br/>     <strong class="mt ir">Output</strong> = undefined</span></pre><p id="9e84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我们将使用多指针策略来查看一个数组是否包含两个相加后等于0的值。因为我们的数组是排序的，所以我们可以在数组的开头和结尾各放一个指针。然后返回两个指针的值，如果它们的和为0。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="bc2e" class="lq lr iq mt b gy mx my l mz na"><strong class="mt ir">Solution:</strong></span><span id="beb0" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">var</strong> sumZero = function(arr) {<br/>     <strong class="mt ir">let</strong> pointer1 = 0<br/>     <strong class="mt ir">let</strong> pointer2 = arr.length - 1;<br/>     // Needs to be less than instead of less than or equal to<br/>        // to prevent a single 0 creating a false positive.<br/>      <strong class="mt ir">while</strong>(pointer1 &lt; pointer2) {<br/>         <strong class="mt ir">let</strong> sum = arr[pointer1] + arr[pointer2];<br/>         <strong class="mt ir">console.log</strong>(sum, arr[pointer1], arr[pointer2])     <br/>         <strong class="mt ir">if</strong>(sum === 0) {<br/>              return [arr[pointer1], arr[pointer2]];<br/>         } <strong class="mt ir">else if</strong>(sum &gt; 0) {<br/>              pointer2--;<br/>         } <strong class="mt ir">else</strong> {<br/>              pointer1++;<br/>         }<br/>      }<br/>};</span><span id="d584" class="lq lr iq mt b gy nb my l mz na">sumZero([-3, -2, -1, 0, 1, 2, 3])<br/>sumZero([-2, 0, 1, 3])<br/>sumZero([1, 2, 3])</span><span id="edc7" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">Test Case #1 Output</strong>:</span><span id="7425" class="lq lr iq mt b gy nb my l mz na">// console.log of sum, value at pointer1, and value at pointer2<br/>0 -3 3</span><span id="e9f0" class="lq lr iq mt b gy nb my l mz na">// result<br/>[ -3, 3 ]</span><span id="b39b" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">Test Case #2 Output</strong>:</span><span id="d00d" class="lq lr iq mt b gy nb my l mz na">// console.log of sum, value at pointer1, and value at pointer2<br/>1 -2 3<br/>-1 -2 1<br/>1 0 1</span><span id="90f2" class="lq lr iq mt b gy nb my l mz na">// result<br/>undefined</span><span id="2756" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">Test Case #3 Output</strong>:</span><span id="d78c" class="lq lr iq mt b gy nb my l mz na">// console.log of sum, value at pointer1, and value at pointer2<br/>4 1 3<br/>3 1 2</span><span id="7196" class="lq lr iq mt b gy nb my l mz na">// result<br/>undefined</span></pre><p id="3192" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的解决方案中，我们首先将指针1的位置设置为数组的开头，将指针2的位置设置为数组的结尾。然后我们看看指针1和指针2的值之和等于多少。如果总和为负，我们需要将指针1向右移动一个值。如果和为正，我们需要将指针2向左移动一个值。如果总和为0，那么我们已经找到了我们要寻找的对，并返回这些值。我们继续这种模式，直到找到一个和为0的对，或者到达while循环的最后一次迭代，其中指针1的位置小于指针2的位置并返回undefined。</p><p id="7e22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">附加示例:</strong></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="938d" class="lq lr iq mt b gy mx my l mz na"><strong class="mt ir">Source</strong>: <a class="ae kc" href="https://leetcode.com/explore/interview/card/top-interview-questions-easy/92/array/727/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/explore/interview/card/top-interview-questions-easy/92/array/727/</a></span><span id="7e2b" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">Problem</strong>: </span><span id="560b" class="lq lr iq mt b gy nb my l mz na">Given a sorted array nums, remove the duplicates <a class="ae kc" href="https://en.wikipedia.org/wiki/In-place_algorithm" rel="noopener ugc nofollow" target="_blank">in-place</a> such that each element appears only once and returns the new length.</span><span id="e4d1" class="lq lr iq mt b gy nb my l mz na">Do not allocate extra space for another array, you must do this by modifying the input array <a class="ae kc" href="https://en.wikipedia.org/wiki/In-place_algorithm" rel="noopener ugc nofollow" target="_blank">in-place</a> with O(1) extra memory.</span><span id="c623" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">     Input:</strong> nums = [0,0,1,1,1,2,2,3,3,4]<br/>     <strong class="mt ir">Output:</strong> 5, nums = [0,1,2,3,4]</span><span id="a163" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir"><br/>Solution:</strong></span><span id="53fb" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">var</strong> removeDuplicates = function(nums) {<br/>    <strong class="mt ir">if</strong> (nums.length === 0) {<br/>        <strong class="mt ir">return</strong> 0<br/>    }<br/>    <br/>    <strong class="mt ir">let</strong> pointer1 = 0</span><span id="f9bf" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">for</strong> (let pointer2 = 1; pointer2 &lt; nums.length; pointer2++) {<br/>        <strong class="mt ir">if</strong> (nums[pointer1] !== nums[pointer2]) {<br/>            pointer1++;<br/>            nums[pointer1] = nums[pointer2]<br/>        }<br/>    }<br/>    <br/>    <strong class="mt ir">return</strong> pointer1 + 1<br/>    <br/>    <br/>};</span><span id="1858" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">Source</strong>: <a class="ae kc" href="https://leetcode.com/explore/interview/card/top-interview-questions-easy/92/array/567/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/explore/interview/card/top-interview-questions-easy/92/array/567/</a></span><span id="134d" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">Problem</strong>: </span><span id="cfe4" class="lq lr iq mt b gy nb my l mz na">Given an array <!-- -->nums<!-- -->, write a function to move all <!-- -->0<!-- -->'s to the end of it while maintaining the relative order of the non-zero elements.</span><span id="a6e3" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">     Input:</strong> <!-- -->[0,1,0,3,12]<br/>     <strong class="mt ir">Output:</strong> <!-- -->[1,3,12,0,0]</span><span id="c086" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">Solution</strong>:</span><span id="f443" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">var</strong> moveZeroes = <strong class="mt ir">function</strong>(nums) {</span><span id="f114" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">   let</strong> pointer1 = 0<br/>    <br/>       <strong class="mt ir">for</strong>(<strong class="mt ir">let</strong> pointer2 = 0; pointer2 &lt; nums.length; pointer2++) {<br/>           <strong class="mt ir">if</strong>(nums[pointer2] !== 0) {<br/>               <strong class="mt ir">let</strong> temp = nums[pointer1]<br/>               nums[pointer1] = nums[pointer2]<br/>               nums[pointer2] = temp<br/>               pointer1++<br/>           }<br/>       }<br/>       <strong class="mt ir">return</strong> nums<br/>};</span><span id="dc66" class="lq lr iq mt b gy nb my l mz na">moveZeroes([0,1,0,3,12])</span><span id="1c1c" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">Video Explanation: </strong><a class="ae kc" href="https://www.youtube.com/watch?v=0rPuILjoVsg" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=0rPuILjoVsg</a></span></pre><h2 id="d0a7" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">推拉窗</h2><p id="8203" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">我们将在博客中讨论的最后一个策略是滑动窗口。类似于多指针策略，滑动窗口通常用于线性结构(即数组和字符串)。当您需要查找/跟踪遵循某种模式的输入子集时，滑动窗口非常有用。柯尔特·斯蒂尔这样描述它的工作过程:“这个模式包括创建一个窗口，它可以是一个数组，也可以是从一个位置到另一个位置的数字。根据特定条件，窗口要么增大，要么关闭(并创建一个新窗口)”(Steele)。此外，使用滑动窗口是优选的，因为它具有O(n)时间复杂度。</p><p id="c45c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，为了在实践中展示滑动窗口策略，让我们看一个例子。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3647" class="lq lr iq mt b gy mx my l mz na"><strong class="mt ir">Source</strong>: <a class="ae kc" href="https://leetcode.com/problems/valid-anagram/" rel="noopener ugc nofollow" target="_blank">C</a>olt Steele's JavaScript Algorithms and Data Structures Masterclass Course on Udemy</span><span id="2464" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">Problem</strong>:</span><span id="4a4b" class="lq lr iq mt b gy nb my l mz na">Write a function called maxSubarraySum which accepts an array of integers and a number called n. the function should calculate the maximum sum of n consecutive elements in the array.</span><span id="fcf5" class="lq lr iq mt b gy nb my l mz na">Test Case #1<br/>     <br/>     <strong class="mt ir">Input</strong> = [1,2,5,2,8,1,5], n = 2<br/>     <strong class="mt ir">Output</strong> = 10</span><span id="f95e" class="lq lr iq mt b gy nb my l mz na">Test Case #2<br/>     <br/>     <strong class="mt ir">Input</strong> = [1,2,5,2,8,1,5], n = 4<br/>     <strong class="mt ir">Output</strong> = 17</span></pre><p id="2c1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本例中，我们将使用滑动窗口策略从数据子集中找出最大和。为此，我们将创建一个窗口，其大小由n决定。接下来，我们将窗口1的位置向右滑动，并确定该总和是否大于前面的总和。一旦最后的窗口被求和，我们将返回最大的和。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="dd62" class="lq lr iq mt b gy mx my l mz na"><strong class="mt ir">Solution:</strong></span><span id="d438" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">function</strong> maxSubarraySum(arr, n){<br/>  <strong class="mt ir">let</strong> maxSum = 0;<br/>  <strong class="mt ir">let</strong> tempSum = 0;<br/>  <strong class="mt ir">if</strong> (arr.length &lt; n) return null;<br/>  <strong class="mt ir">for</strong> (let i = 0; i &lt; n; i++) {<br/>    maxSum += arr[i];<br/>  }<br/>  tempSum = maxSum;<br/>  <strong class="mt ir">for</strong> (let i = n; i &lt; arr.length; i++) {<br/>    tempSum = tempSum - arr[i - n] + arr[i];<br/>    maxSum = Math.max(maxSum, tempSum);<br/>  }<br/>  <strong class="mt ir">return</strong> maxSum;<br/>}</span><span id="ecfc" class="lq lr iq mt b gy nb my l mz na">maxSubarraySum([1,2,5,2,8,1,5],2)<br/>maxSubarraySum([1,2,5,2,8,1,5],4)</span><span id="0aa2" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">Test Case #1 Output</strong>:</span><span id="38d2" class="lq lr iq mt b gy nb my l mz na">// the initial maxSum<br/>3</span><span id="b4ca" class="lq lr iq mt b gy nb my l mz na">// sliding window, tempSum on left and previous maxSum on right<br/>7 3<br/>7 7<br/>10 7<br/>9 10<br/>6 10</span><span id="ed55" class="lq lr iq mt b gy nb my l mz na">// result<br/>10</span><span id="ec94" class="lq lr iq mt b gy nb my l mz na"><strong class="mt ir">Test Case #2 Output</strong>:</span><span id="ea63" class="lq lr iq mt b gy nb my l mz na">// the initial maxSum<br/>10</span><span id="ec68" class="lq lr iq mt b gy nb my l mz na">// sliding window, tempSum on left and previous maxSum on right<br/>17 10<br/>16 17<br/>16 17</span><span id="b069" class="lq lr iq mt b gy nb my l mz na">// result<br/>17</span></pre><p id="ef17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的解决方案中，我们首先声明两个变量maxSum和tempSum，并将它们设置为0。然后，我们设置一个边界条件，如果窗口的大小n大于数组，则返回null。接下来，我们通过仅循环指定数量的n个数字并将每个数字添加到maxSum变量来找到第一个窗口的总和。然后，我们将tempSum变量设置为maxSum的值；临时sum将是我们的滑动窗口。然后在我们的第二个循环中，我们通过从我们的初始窗口(arr[0])中减去第一个值，并添加数组中不在我们的初始窗口中的下一个值(即，如果第一个窗口包含arr[0]，arr[1]，arr[2])，来找到下一个窗口的值，并将该值设置为tempSum的值。然后，我们将maxSum的值设置为tempSum和先前的maxSum中的较大值。我们继续这个过程，直到到达数组的末尾并返回maxSum</p><p id="ce0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您花时间了解更多算法求解策略。我希望这篇博客能为你提供一些策略，帮助你寻找工作和/或工作场所。</p><p id="3485" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">资源</strong></p><p id="0ca6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">斯蒂尔，加州(未注明)。<em class="lp"> JavaScript算法和数据结构大师班</em>。在线课程。</p><p id="a683" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">算法。(2020年07年10月)。检索于2020年10月10日，发自https://en.wikipedia.org/wiki/Algorithm<a class="ae kc" href="https://en.wikipedia.org/wiki/Algorithm" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>