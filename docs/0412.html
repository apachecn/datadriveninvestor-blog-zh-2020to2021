<html>
<head>
<title>How to build an object detection app for sketches?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何搭建一个针对草图的物体检测app？</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/how-to-build-an-object-detection-app-for-sketches-7671ffde4989?source=collection_archive---------2-----------------------#2020-01-29">https://medium.datadriveninvestor.com/how-to-build-an-object-detection-app-for-sketches-7671ffde4989?source=collection_archive---------2-----------------------#2020-01-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/68c7ce957b3d222257c2ee83df79206f.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*BjekxfDSQ_A5xFumVtWcHQ.png"/></div></figure><p id="fe43" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">几周前，我读到了微软的新工具(sketch2code ),它可以将草图转换成HTML代码。所以我决定挑战自己，做同样的转换，但对斯威夫特来说。不到20天后，该应用程序已经准备好进行测试，结果很好。</p><figure class="ks kt ku kv gt jr"><div class="bz fp l di"><div class="kw kx l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">How app work from image selection to conversion to code</figcaption></figure><h2 id="aa77" class="lc ld iq bd le lf lg dn lh li lj dp lk kf ll lm ln kj lo lp lq kn lr ls lt lu bi translated">要制作这样的移动应用程序，我们需要遵循以下步骤:</h2><p id="2477" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">1-收集数据集</p><p id="3204" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">2-图像分割和数据标记</p><p id="f3aa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">三目标检测模型</p><p id="4332" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">4- OCR</p><p id="2865" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">5-部署模型</p><p id="d87f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">6-创建转换算法</p><p id="12e1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这些过程是构建您想要的任何对象检测器应用程序的基础，您可以只替换数据集。在本教程的最后，你会找到完整的代码和重要的资源。</p><h1 id="82ef" class="ma ld iq bd le mb mc md lh me mf mg lk mh mi mj ln mk ml mm lq mn mo mp lt mq bi translated">1-数据收集</h1><p id="22de" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">我们建立任何深度学习模型首先需要的是数据集。所以我做了一些快速搜索准备使用数据集，但我没有找到一个。于是10点左右开始画一些草图，从google images下载其他草图。</p><figure class="ks kt ku kv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/76b1e42eab748123348bfdd5cdd23d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DRVWSUmH5RIMldClJ3dZFQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Sample of Dataset</figcaption></figure><p id="fd95" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，我们需要调整图像的大小，以降低分辨率，使训练模型更快，我发现这个python代码是由Tanner Gilber编写的。</p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="0f64" class="lc ld iq my b gy nc nd l ne nf">from PIL import Image <br/>import os import argparse  </span><span id="b69d" class="lc ld iq my b gy ng nd l ne nf">def rescale_images(directory, size):<br/>     for img in os.listdir(directory):         <br/>         im = Image.open(directory+img)<br/>         im_resized = im.resize(size, Image.ANTIALIAS) <br/>         im_resized.save(directory+img)</span><span id="a971" class="lc ld iq my b gy ng nd l ne nf">if __name__ == '__main__':<br/>     parser = argparse.ArgumentParser(description="Rescale images")<br/>     parser.add_argument('-d', '--directory', type=str,<br/>     required=True, help='Directory containing the images')<br/>     parser.add_argument('-s', '--size', type=int, nargs=2,<br/>     required=True, metavar=('width', 'height'), help='Image size')<br/>     args = parser.parse_args()<br/>     rescale_images(args.directory, args.size)</span></pre><p id="ac24" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在图片的父目录中保存这个脚本为<em class="nh"> reseize_images.py </em>，然后在同一个文件夹中打开一个终端，输入以下命令:</p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="1d20" class="lc ld iq my b gy nc nd l ne nf">&gt; python <!-- -->reseize_images.py<!-- --> -d images/ -s 400 600</span></pre><p id="2b48" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在开始标记之前，我们需要随机拆分文件夹中的图片。一个用于训练，需要80%的图像，另外20%的图像用于测试文件夹。如果你有一个小的数据集，你可以手动分割图像，否则，你需要使用像<a class="ae mw" href="https://pypi.org/project/split-folders/" rel="noopener ugc nofollow" target="_blank"> split-folders 0.3.1 </a>这样的库。</p><h1 id="8424" class="ma ld iq bd le mb mc md lh me mf mg lk mh mi mj ln mk ml mm lq mn mo mp lt mq bi translated">2-图像分割和标记</h1><p id="bc7c" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">对于标注，我们将使用<a class="ae mw" href="https://github.com/tzutalin/labelImg" rel="noopener ugc nofollow" target="_blank"> LabelImg </a>，它是一个图形图像注释工具，通过在图像中的对象周围绘制边界框。我们需要从GitHub下载它，并按照安装说明进行操作。</p><div class="ni nj gp gr nk nl"><a href="https://www.datadriveninvestor.com/2019/01/23/deep-learning-explained-in-7-steps/" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">深度学习用7个步骤解释-更新|数据驱动的投资者</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">在深度学习的帮助下，自动驾驶汽车、Alexa、医学成像-小工具正在我们周围变得超级智能…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz js nl"/></div></div></a></div><p id="892b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在LabelImg界面出现后，您可以使用“打开目录”按钮打开培训目录，并通过“创建矩形框”按钮绘制边界框，并写入标签名称，然后单击保存。需要对训练和测试目录中的所有映像重复这个过程。</p><figure class="ks kt ku kv gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/4888212f33bdb56c52583f41e4a982ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*CNAAPVXewPefvSV4nBbNTg.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">LabelImg interface</figcaption></figure><p id="fb0f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，我们需要生成一个TFRecord，这是一个将数据存储为二进制记录序列的文件。这可以帮助我们减少存储空间和培训时间。为了创建TFRecords，我们需要在将数据写入文件之前指定数据的结构。所以我们会从<a class="ae mw" href="https://github.com/datitran/raccoon_dataset" rel="noopener ugc nofollow" target="_blank"> Dat Tran的浣熊探测器</a> ( <em class="nh"> xml_to_csv.py </em>和<em class="nh"> generate_tfrecord.py </em>)下载两个脚本。如果您打开培训目录，您可以看到每个图像都有一个相应的xml文件，现在将通过对main函数进行一些更改，使用<em class="nh"> xml_to_csv.py将这些xml文件转换为csv。</em></p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="b568" class="lc ld iq my b gy nc nd l ne nf">def main():<br/>     for folder in ['train', 'test']:<br/>         image_path = os.path.join(os.getcwd(), ('images/' +<br/>         folder))<br/>         xml_df = xml_to_csv(image_path)<br/>         xml_df.to_csv(('images/'+folder+'_labels.csv'), index=None)<br/>     print('Successfully converted xml to csv.')</span></pre><p id="2763" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在终端窗口中，在项目文件夹中键入以下命令:</p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="3182" class="lc ld iq my b gy nc nd l ne nf">&gt; python xml_to_csv.py</span></pre><p id="c794" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">稍后，我们要进行转换，我们将打开<em class="nh"> generate_tfrecord.py，更新class_text_to_int函数中的标签名称:</em></p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="a254" class="lc ld iq my b gy nc nd l ne nf"><br/>def class_text_to_int(row_label):<br/> if row_label == ‘CheckBox’:<br/> return 1<br/> elif row_label == ‘TextField’:<br/> return 2<br/> elif row_label == ‘Label’:<br/> return 3<br/> elif row_label == ‘Button’:<br/> return 4<br/> elif row_label == ‘TextView’:<br/> return 5<br/> elif row_label == ‘ImageView’:<br/> return 6<br/> else:<br/> return None</span></pre><p id="37f5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，可以通过键入以下命令来生成TFRecords:</p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="6a56" class="lc ld iq my b gy nc nd l ne nf">&gt; python generate_tfrecord.py — csv_input=images/train_labels.csv — image_dir=images/train — output_path=train.record </span><span id="fa27" class="lc ld iq my b gy ng nd l ne nf">&gt; python generate_tfrecord.py — csv_input=images/test_labels.csv — image_dir=images/test — output_path=test.record</span></pre><p id="55c9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们将创建一个标签映射，保存每个标签的ID。id应该与<em class="nh"> generate_tfrecord.py中的一个数字相匹配。S </em>另存为<em class="nh"> labelmap.pbtxt </em></p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="0251" class="lc ld iq my b gy nc nd l ne nf">item {<br/> id: 1<br/> name: ‘CheckBox’<br/> }<br/> item {<br/> id: 2<br/> name: ‘TextField’<br/> }<br/> item {<br/> id: 3<br/> name: ‘Label’<br/> }<br/> item {<br/> id: 4<br/> name: ‘Button’<br/> }<br/> item {<br/> id: 5<br/> name: ‘TextView’<br/> }<br/> item {<br/> id: 6<br/> name: ‘ImageView’<br/> }</span></pre><h1 id="ee90" class="ma ld iq bd le mb mc md lh me mf mg lk mh mi mj ln mk ml mm lq mn mo mp lt mq bi translated">三目标检测模型</h1><p id="4788" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">我们需要一个模型来训练我们的分类器。基于掩蔽区域的卷积神经网络或掩蔽R-CNN模型是用于对象识别任务的最先进方法之一。例如，更快的R-CNN生成提议(区域),其假设是这些区域很可能包含对象，然后通过对每个区域包含的类别进行分类来进行额外的步骤。此外，Tensorflow的对象检测API是一个强大的工具，使每个人都能创建自己的强大图像分类器。</p><p id="1668" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在终端中键入以下命令:</p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="964b" class="lc ld iq my b gy nc nd l ne nf">&gt; git clone <a class="ae mw" href="https://github.com/tensorflow/models" rel="noopener ugc nofollow" target="_blank">https://github.com/tensorflow/models</a></span></pre><p id="551c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，我们将把之前创建的<em class="nh"> train.record </em>和<em class="nh"> test.record </em>移动到<em class="nh">model/research/object _ detection</em>中，然后创建一个名为<em class="nh"> training </em>的新目录，并将<em class="nh"> labelmap.pbtxt放入其中。</em> Tensorflow的物体检测API自带了很多预训练的模型，我们会下载<a class="ae mw" href="http://download.tensorflow.org/models/object_detection/faster_rcnn_inception_v2_coco_2018_01_28.tar.gz" rel="noopener ugc nofollow" target="_blank">faster _ rcnn _ inception _ v2 _ coco</a>你提取物体检测文件夹中的文件夹。然后我们需要配置文件，因为我们在这个项目中使用了一个<em class="nh"> faster_rcnn_inception </em>模型，从object _ detection \ samples \ configs中复制<em class="nh">faster _ rcnn _ inception _ v2 _ pets . config</em>文件并粘贴到之前创建的培训目录中。然后，我将使用文本编辑器打开它，以便更改配置中的几行内容。</p><p id="aa6e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第9行:将类的数量更改为您想要检测的对象的数量</p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="eb10" class="lc ld iq my b gy nc nd l ne nf">num_classes: 6</span></pre><p id="6dcf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第106行:将<em class="nh">微调检查点</em>改为<em class="nh"> model.ckpt </em>文件的路径:</p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="bbaa" class="lc ld iq my b gy nc nd l ne nf">fine_tune_checkpoint:"/Users/bdour/Documents/Python/Sketch2Swift/models/research/object_detection/faster_rcnn_inception_v2_coco_2018_01_28/model.ckpt"</span></pre><p id="c235" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第123行:将<em class="nh">输入_路径</em>改为<em class="nh"> train.records </em>文件的路径:</p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="4f00" class="lc ld iq my b gy nc nd l ne nf">input_path: "/Users/bdour/Documents/Python/Sketch2Swift/models/research/object_detection/train.record"</span></pre><p id="6db6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第135行:将<em class="nh">输入路径</em>改为<em class="nh">测试记录</em>文件的路径:</p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="7f40" class="lc ld iq my b gy nc nd l ne nf">input_path: "/Users/bdour/Documents/Python/Sketch2Swift/models/research/object_detection/test.record"</span></pre><p id="2111" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第125行和第137行:将<em class="nh"> label_map_path </em>改为标签地图的路径:</p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="c9f5" class="lc ld iq my b gy nc nd l ne nf">label_map_path:  "/Users/bdour/Documents/Python/Sketch2Swift/models/research/object_detection/training/labelmap.pbtxt"</span></pre><p id="e3a8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第130行:将num_examples参数设置为测试目录中图像的数量。</p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="526b" class="lc ld iq my b gy nc nd l ne nf">num_examples: 7</span></pre><h2 id="f2a9" class="lc ld iq bd le lf lg dn lh li lj dp lk kf ll lm ln kj lo lp lq kn lr ls lt lu bi translated">让我们训练我们的模型，</h2><p id="7506" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">您可以在object_detection/legacy/位置找到一个名为<em class="nh"> train.py </em>的文件。复制并粘贴到object_detection目录中。</p><p id="f2a6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">运行以下命令开始训练。</p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="172e" class="lc ld iq my b gy nc nd l ne nf">&gt; python model_main.py --logtostderr --model_dir=training/ --pipeline_config_path=training/faster_rcnn_inception_v2_pets.config</span></pre><p id="5c40" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Tensorflow每5分钟创建一个检查点并存储。所有检查点都保存在培训目录中。培训过程可能需要大约4个小时。如果我们迷路小于或等于0.1，我们可以终止训练。</p><p id="915d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在进入下一步之前，我们需要保存我们训练好的模型。我们将使用模型配置和经过训练的检查点，通过将变量和图形的所有值保存在我们称为冻结图的单个文件中，来准备用于推断的对象检测张量流图。冻结图意味着将模型的结构与其权重(检查点)结合起来。我们需要导航到培训目录，并寻找具有最大索引的<em class="nh"> model.ckpt </em>文件。然后，我们可以通过在命令行中键入以下命令来创建推理图。</p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="c344" class="lc ld iq my b gy nc nd l ne nf">&gt; python export_inference_graph.py <br/>--input_type image_tensor <br/>--pipeline_config_path training/faster_rcnn_inception_v2_pets.config --trained_checkpoint_prefix training/model.ckpt-XXXX <br/>--output_directory inference_graph</span></pre><p id="790b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">XXXX应该由最高的检查点编号填充。</p><p id="776b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">就这样，如果我们转到\ object _ detection \ inference _ graph文件夹，我们会看到我们的对象检测分类器:<em class="nh">frozen _ inference _ graph . Pb</em>文件。</p><h2 id="7816" class="lc ld iq bd le lf lg dn lh li lj dp lk kf ll lm ln kj lo lp lq kn lr ls lt lu bi translated">测试时间到了，</h2><p id="a6ea" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">在object_detection文件夹中打开新的Jupiter笔记本，复制并粘贴一些代码来下载我们的模型，并从<a class="ae mw" href="https://github.com/TannerGilbert/Tutorials/blob/master/Tensorflow%20Object%20Detection/object_detection_with_own_model.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>中绘制检测结果框。结果应该是这样的:</p><figure class="ks kt ku kv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi ob"><img src="../Images/cff9935a2ee6aaaed2b28f76271b5e21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hW6aSy3zGDY-ABOHIx65-w.jpeg"/></div></div></figure><h1 id="5373" class="ma ld iq bd le mb mc md lh me mf mg lk mh mi mj ln mk ml mm lq mn mo mp lt mq bi translated">3- <strong class="ak">光学字符识别</strong> ( <strong class="ak"> OCR </strong></h1><p id="bb64" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">要检测按钮或标签内的文本，我们需要使用Tesseract对图像应用(OCR)。首先，我们需要安装库:</p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="6112" class="lc ld iq my b gy nc nd l ne nf">$ pip install pytesseract</span></pre><p id="2253" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，在<em class="nh">visualize _ boxes _ and _ labels _ on _ image _ array</em>函数中添加下一行，这样我们就可以从图像中获取文本:</p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="3437" class="lc ld iq my b gy nc nd l ne nf">text = pytesseract.image_to_string(Image.open(filename))</span></pre><h1 id="d3f8" class="ma ld iq bd le mb mc md lh me mf mg lk mh mi mj ln mk ml mm lq mn mo mp lt mq bi translated">4-部署模型</h1><p id="9b28" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">在移动应用中部署深度学习模型有很多好的方法，我在这里列举了:</p><div class="ni nj gp gr nk nl"><a href="https://medium.com/@BdourEbrahim/how-to-integrate-machine-learning-models-into-your-app-b77717e2702" rel="noopener follow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">如何将机器学习模型集成到你的app中？</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">。近来，对…的需求</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">medium.com</p></div></div><div class="nu l"><div class="oc l nw nx ny nu nz js nl"/></div></div></a></div><p id="30db" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但在这里，我们将使用一种快速简单的方法，通过使用Flask API将训练好的模型投入生产，在移动应用程序中测试我们的模型。在object_detection文件夹中，创建2个脚本来建立连接。第一个，<em class="nh"> app.py : </em></p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="cf44" class="lc ld iq my b gy nc nd l ne nf">import flask<br/>from flask import Flask, jsonify, request<br/>import json<br/>import videoAndImageDetection<br/>app = Flask(__name__)<br/><a class="ae mw" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route(‘/predict’, methods=[‘POST’])<br/>def predict():</span><span id="b275" class="lc ld iq my b gy ng nd l ne nf">response = “failure”</span><span id="c850" class="lc ld iq my b gy ng nd l ne nf">request_json = request.get_json(force=True)</span><span id="0e19" class="lc ld iq my b gy ng nd l ne nf">image_data = request_json[‘input’]<br/> <br/>responseList = videoAndImageDetection.getjson(image_data)</span><span id="0609" class="lc ld iq my b gy ng nd l ne nf">if responseList :<br/> response = json.dumps({‘response’: responseList[0],’response2': responseList[1]})<br/> <br/> return response, 200</span><span id="37dc" class="lc ld iq my b gy ng nd l ne nf">if __name__ == ‘__main__’:<br/> application.run(debug=True)</span></pre><p id="701b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第二个，wsgi.py:</p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="3e69" class="lc ld iq my b gy nc nd l ne nf">from app import app as application<br/>if __name__ == “__main__”:<br/> application.run()</span></pre><p id="e6a3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要通过在命令行中键入来启动连接:</p><pre class="ks kt ku kv gt mx my mz na aw nb bi"><span id="9176" class="lc ld iq my b gy nc nd l ne nf">&gt; gunicorn — bind 0.0.0.0:8080 wsgi:application -w 1</span></pre><h1 id="da27" class="ma ld iq bd le mb mc md lh me mf mg lk mh mi mj ln mk ml mm lq mn mo mp lt mq bi translated">5-创建转换算法</h1><p id="b5d2" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">在Xcode中，我们创建了一个算法来获取所有坐标及其位置、大小和文本的字典。然后，我们可以使用这些信息轻松地以编程方式创建任何UIKit元素。</p><div class="ks kt ku kv gt ab cb"><figure class="od jr oe of og oh oi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><img src="../Images/39daf165c4220408026443ea74734668.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*F2FgVw3yB06ol-3lCxcjbw.png"/></div></figure><figure class="od jr oj of og oh oi paragraph-image"><img src="../Images/20d95c918a8ee97745bf7c407139e144.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*sNCfqgwOVjU2FNKJ9YDd6A.png"/></figure></div><h1 id="0901" class="ma ld iq bd le mb mc md lh me mf mg lk mh mi mj ln mk ml mm lq mn mo mp lt mq bi translated">就这些，谢谢你的阅读。</h1><p id="d775" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated"><strong class="jw ir">资源:</strong><a class="ae mw" href="https://www.youtube.com/channel/UCBOKpYBjPe2kD8FSvGRhJwA" rel="noopener ugc nofollow" target="_blank">YouTube上的吉尔伯特·坦纳</a>频道。</p><figure class="ks kt ku kv gt jr"><div class="bz fp l di"><div class="ok kx l"/></div></figure></div></div>    
</body>
</html>