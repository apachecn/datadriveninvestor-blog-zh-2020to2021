# 用于有效检索大量 SimHash 数据的 smlar 插件

> 原文：<https://medium.datadriveninvestor.com/the-smlar-plug-in-for-effective-retrieval-of-massive-volumes-of-simhash-data-e429c19da1a3?source=collection_archive---------8----------------------->

![](img/a573f84f018202a3d3b9fa6348355179.png)

# 背景

SimHash 是一种确定数据集之间相似性的算法。Google Crawler 使用 SimHash 查找相似的页面，避免内容重复。

参考上面提到的文章，SimHash 算法有助于为每个网页生成向量指纹。因此，如果您想知道我们如何使用 SimHash 来确定文档之间的相似性，那么让我们快速查看以下步骤，以获得使用汉明距离的应用程序的概述:

什么是海明距离？
码字间的汉明距离是不同值的比特数。有效码集中码字之间的最小汉明距离是该码集的汉明距离。例如，10101 和 00110 在第一、第四和第五位具有不同的值，因此汉明距离为 3。

汉明距离的几何意义
一个 n 比特的码字可以用 n 维空间中的一个超立方体顶点来表示。码字之间的汉明距离是超立方体顶点之间最短距离的边。

汉明距离应用场景
汉明距离应用于代码错误检查和纠正。

一旦通过使用 SimHash 算法提取了指纹，就使用汉明距离来计算相似性。SimHash 算法更适合于超过 500 个单词的长文档。对于短文档，差别可能很大，这取决于应用场景。根据谷歌论文中发表的数据，如果签名是 64 位，汉明距离是 3，则两个文档被认为是相似或重复的。在这个例子中，汉明距离 3 仅作为参考；在不同的应用场景中可以提供不同的测试值。

[](https://www.datadriveninvestor.com/2018/09/22/infographic-journey-to-the-clouds/) [## 信息图:云之旅|数据驱动的投资者

### 聪明的企业领导者了解利用云的价值。随着数据存储需求的增长，他们已经…

www.datadriveninvestor.com](https://www.datadriveninvestor.com/2018/09/22/infographic-journey-to-the-clouds/) 

上面解释的技术有助于获得相似性。但是，当有数百亿条数据记录时，就存在一个效率问题。当不断添加数据时，效率会随着每个新数据记录与数据库中所有现有数据的比较而下降。

为了提高海量数据的重复数据消除效率，我们可以将 64 位指纹划分为四个 16 位数据块。基于抽屉原理，如果当汉明距离为 3 时两个文档相似，则它们在一个块中一定具有相同的数据。

这里出现的下一个问题是，是否有任何数据库能够有效地支持这种海量数据的检索。

多亏了 smlar 插件， [PostgreSQL](https://www.alibabacloud.com/product/apsaradb-for-rds-postgresql?spm=a2c41.13977169.0.0) 数据库支持如此高效的检索。

# 1.要求

首先，从海量 SimHash 数据池中快速搜索与特定 SimHash 数据记录相似的 SimHash 数据记录。

# 2.建筑设计

PostgreSQL 支持多种设计方法在海量数据池中搜索汉明距离小于 N 的数据。每种设计方法都有不同的能效比(EER)。您可以根据自己的需求选择以下任何一种方法。

# a.强力计算

暴力扫描的单节点多核并行计算
阿里云 ApsaraDB RDS for PostgreSQL 10 提供的多核并行计算用于暴力扫描。

蛮力扫描多节点多核并行计算
阿里云 HybridDB 为 PostgreSQL 提供的多级并发计算用于蛮力扫描。

用于强力计算加速的 GPU 和 FPGA 功能
PostgreSQL 提供了扩展接口，允许您使用 GPU 和 FPGA 功能进行数据计算。

蛮力计算的 CPU 向量计算命令
PostgreSQL 提供了扩展接口，允许你使用 CPU 向量计算命令来加速计算。

# b.索引

索引是一种有效的检索方法。比如 PostgreSQL smlar 插件，利用阿里巴巴导购平台上的索引，及时从海量导购文章池中查询相似的导购文章。

为了使 smlar 插件能够加速基于汉明距离的数据搜索，需要采用更科学的方法，比如切片。

直接使用位置会产生问题，因为 smlar 插件的第一个过程是块级收敛。然而，汉明码是 64 位的。一个数据块包含若干条记录，0 和 1 可能同时出现在任何位置。因为所有数据块都包含 0 和 1，所以在第一个过程中过滤失败。

我们可以使用切片来降低过滤失败的可能性。例如，每两个、四个或更多比特被分类为一个片。

通常，如果记录之间的汉明距离大于 3，则两个记录彼此不相关。

# 3.演示和性能

# a.强力计算

为了说明全扫描和并行扫描，首先，创建一个测试表。

```
create table hm (  
  id int,        -- id  
  hmval bit(64)  -- 海明 HASH  
);
```

现在，向表中写入 1000 万条测试数据记录。

```
postgres=# insert into hm select id, val::int8::bit(64) from (select id, sqrt(random())::numeric*9223372036854775807*2-9223372036854775807::numeric as val from generate_series(1,10000000) t(id)) t;  
INSERT 0 10000000  

postgres=# select * from hm limit 10;  
 id |                              hmval                                 
----+------------------------------------------------------------------  
  1 | 0000101001110110110101010111101011100110101010000111100011110111  
  2 | 0110011100110101101000001010101111010001011101100111111011001110  
  3 | 1010110111001011011110110000111111101101101111010111111100101110  
  4 | 0110011110110000001011000010010000101011100101010100111000101001  
  5 | 0101110100101111010110010110000000101110000010001011010110110000  
  6 | 0011010000100000101011011100000101111110010110111101100001100001  
  7 | 1011110011101101101000011101011101010111011001011010110111101000  
  8 | 1110010011000101001101110010001111110100001101010101111101110010  
  9 | 0110111111110011101001001000101101011011111100010010111010001111  
 10 | 0011100011000010101011010001111000000110100011100100111011011001  
(10 rows)
```

设置蛮力计算的并行度。

```
postgres=# set force_parallel_mode = on;  
postgres=# set min_parallel_table_scan_size = 0;  
postgres=# set parallel_setup_cost = 0;  
postgres=# set parallel_tuple_cost = 0;  
postgres=# alter table hm set (parallel_workers = 128);  
postgres=# set max_parallel_workers_per_gather = 64;
```

并发查询汉明距离小于 4 的记录。这需要 463 毫秒才能完成。

```
postgres=# select * from hm where length(replace(bitxor(bit'0011110001011010110010001011010101001000111110000111110010010110', hmval)::text,'0','')) < 4;  
 id |                              hmval                                 
----+------------------------------------------------------------------  
 16 | 0011110001011010110010001011010101001000111110000111110010010110  
(1 row)  

Time: 463.314 ms
```

非并发查询汉明距离小于 4 的记录。这需要 16 秒来完成。

```
postgres=# select * from hm where length(replace(bitxor(bit'0011110001011010110010001011010101001000111110000111110010010110', hmval)::text,'0','')) < 4;  
 id |                              hmval                                 
----+------------------------------------------------------------------  
 16 | 0011110001011010110010001011010101001000111110000111110010010110  
(1 row)  

Time: 16791.215 ms (00:16.791)
```

有更有效的方法来查询字符串之间不同值的位数。理论上，这需要不到 100 毫秒来完成。

```
[https://www.postgresql.org/message-id/flat/ab1ea6540903121110l2a3021d4h6632b206e2419898%40mail.gmail.com#ab1ea6540903121110l2a3021d4h6632b206e2419898@mail.gmail.com](https://www.postgresql.org/message-id/flat/ab1ea6540903121110l2a3021d4h6632b206e2419898%40mail.gmail.com#ab1ea6540903121110l2a3021d4h6632b206e2419898@mail.gmail.com)
```

# b.索引

阿里云 RDS PostgreSQL 提供了一个 smlar 插件，高效查询数组间的相似度。因此，我们需要将 SimHash 数据记录转换成数组。

根据前面的设计，将八位分类到一个数组中，以搜索汉明距离小于或等于 8 的值。

切片前，在数据切片后验证过滤。

```
postgres=# select relpages from pg_class where relname='hm';  
 relpages   
----------  
    63695  
(1 row)  

1、单个片为 1 时，不用说，每个块都包含。  

postgres=# select count(*) from (select substring(ctid::text,'(\d+),') from hm where substring(hmval,1,1)='0' group by 1)t;  
 count   
-------  
 63695  
(1 row)  

2、单个片为 8 时，有接近一半的块包含。  

postgres=# select count(*) from (select substring(ctid::text,'(\d+),') from hm where substring(hmval,1,8)='00000000' group by 1)t;  
 count   
-------  
 29100  
(1 row)  

3、单个片为 16 时，只有 100 多个块包含了。  

postgres=# select count(*) from (select substring(ctid::text,'(\d+),') from hm where substring(hmval,1,16)='0000000000000000' group by 1)t;  
 count   
-------  
   160  
(1 row)
```

## 8 数组切片方法的性能验证

按照下列步骤测试性能:

第一步。创建 smlar 插件。

```
create extension smlar;
```

第二步。创建一个测试表。

```
create table hm1 (id int, hmval bit(64), hmarr text[]);
```

第三步。现在，生成 1000 万条测试数据记录。基于 8 数组切片方法对这些数据记录进行切片，并将切片后的记录记录为文本数组。

```
insert into hm1   
select   
  id,   
  val::bit(64),   
  regexp_split_to_array('1_'||substring(val,1,8)||',2_'||substring(val,9,8)||',3_'||substring(val,17,8)||',4_'||substring(val,25,8)||',5_'||substring(val,33,8)||',6_'||substring(val,41,8)||',7_'||substring(val,49,8)||',8_'||substring(val,57,8), ',')    
from   
(select id, (sqrt(random())::numeric*9223372036854775807*2-9223372036854775807::numeric)::int8::bit(64)::text as val from generate_series(1,10000000) t(id)) t;  

postgres=# select * from hm1 limit 10;  
 id |                              hmval                               |                                           hmarr                                             
----+------------------------------------------------------------------+-------------------------------------------------------------------------------------------  
  1 | 0000001110101101100110011000100111100100001100100101101010010011 | {1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}  
  2 | 0001001000010101001100100010101010111001001000000110101101100100 | {1_00010010,2_00010101,3_00110010,4_00101010,5_10111001,6_00100000,7_01101011,8_01100100}  
  3 | 0011111111010100011001001010110110100010101110101001101111010000 | {1_00111111,2_11010100,3_01100100,4_10101101,5_10100010,6_10111010,7_10011011,8_11010000}  
  4 | 1100110010011001001110101110111111111111010000100000010011000010 | {1_11001100,2_10011001,3_00111010,4_11101111,5_11111111,6_01000010,7_00000100,8_11000010}  
  5 | 0011000011010001011111010101010111100110000110000011101100000101 | {1_00110000,2_11010001,3_01111101,4_01010101,5_11100110,6_00011000,7_00111011,8_00000101}  
  6 | 0111101101111110101000010110101101110011011110100100010111011001 | {1_01111011,2_01111110,3_10100001,4_01101011,5_01110011,6_01111010,7_01000101,8_11011001}  
  7 | 0010001011111111100010101011110001001101001011100100011000010000 | {1_00100010,2_11111111,3_10001010,4_10111100,5_01001101,6_00101110,7_01000110,8_00010000}  
  8 | 1110001111100011011110110111101111010101000111000100111111111101 | {1_11100011,2_11100011,3_01111011,4_01111011,5_11010101,6_00011100,7_01001111,8_11111101}  
  9 | 0111110010111000010111001000000101111000000110110110000011101110 | {1_01111100,2_10111000,3_01011100,4_10000001,5_01111000,6_00011011,7_01100000,8_11101110}  
 10 | 0111001101100010001101101111000000100100000000010001010011100101 | {1_01110011,2_01100010,3_00110110,4_11110000,5_00100100,6_00000001,7_00010100,8_11100101}  
(10 rows)
```

第四步。创建 smlar 索引。

```
postgres=# create index idx_hm1 on hm1 using gin(hmarr _text_sml_ops );
```

第五步。现在，使用 smlar 索引搜索汉明距离小于或等于 1 的值。使用 smlar 索引后，完成查询需要 63 毫秒。

```
postgres=# set smlar.type = overlap;  
postgres=# set smlar.threshold = 7;  

select    
    *,    
    smlar( hmarr, '{1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}')    
  from    
    hm1    
  where    
    hmarr % '{1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}'      
    and length(replace(bitxor(bit'0000001110101101100110011000100111100100001100100101101010010011', hmval)::text,'0','')) < 2  
  limit 100;  

postgres=# explain (analyze,verbose,timing,costs,buffers) select    
    *,    
    smlar( hmarr, '{1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}')    
  from    
    hm1    
  where    
    hmarr % '{1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}'      
    and length(replace(bitxor(bit'0000001110101101100110011000100111100100001100100101101010010011', hmval)::text,'0','')) < 2  
  limit 100;  
                                                                            QUERY PLAN                                                                               
-------------------------------------------------------------------------------------------------------------------------------------------------------------------  
 Limit  (cost=117.83..420.48 rows=100 width=169) (actual time=62.928..62.929 rows=1 loops=1)  
   Output: id, hmval, hmarr, (smlar(hmarr, '{1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}'::text[]))  
   Buffers: shared hit=166  
   ->  Bitmap Heap Scan on public.hm1  (cost=117.83..10205.17 rows=3333 width=169) (actual time=62.927..62.927 rows=1 loops=1)  
         Output: id, hmval, hmarr, smlar(hmarr, '{1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}'::text[])  
         Recheck Cond: (hm1.hmarr % '{1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}'::text[])  
         Filter: (length(replace((bitxor(B'0000001110101101100110011000100111100100001100100101101010010011'::"bit", hm1.hmval))::text, '0'::text, ''::text)) < 2)  
         Heap Blocks: exact=1  
         Buffers: shared hit=166  
         ->  Bitmap Index Scan on idx_hm1  (cost=0.00..117.00 rows=10000 width=0) (actual time=62.898..62.898 rows=1 loops=1)  
               Index Cond: (hm1.hmarr % '{1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}'::text[])  
               Buffers: shared hit=165  
 Planning time: 0.147 ms  
 Execution time: 62.975 ms  
(14 rows)  

postgres=# select                  
    *,    
    smlar( hmarr, '{1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}')    
  from    
    hm1    
  where    
    hmarr % '{1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}'      
    and length(replace(bitxor(bit'0000001110101101100110011000100111100100001100100101101010010011', hmval)::text,'0','')) < 2  
  limit 100;  
 id |                              hmval                               |                                           hmarr                                           | smlar   
----+------------------------------------------------------------------+-------------------------------------------------------------------------------------------+-------  
  1 | 0000001110101101100110011000100111100100001100100101101010010011 | {1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011} |     8  
(1 row)  
Time: 61.227 ms
```

要查询汉明距离小于或等于 4 的值，我们可以使用 16 数组切片方法或不同切片方法的组合。

## 混合 6 阵列切片方法的性能验证

6 阵列切片方法的配置为 8 位、16 位、8 位、8 位、16 位和 8 位。这种切片方法可以查询汉明距离小于或等于 6 的值。

```
create table hm2 (id int, hmval bit(64), hmarr text[]);  

insert into hm2   
select   
  id,   
  val::bit(64),   
  regexp_split_to_array('1_'||substring(val,1,8)||',2_'||substring(val,9,16)||',3_'||substring(val,25,8)||',4_'||substring(val,33,8)||',5_'||substring(val,41,16)||',6_'||substring(val,57,8), ',')    
from   
(select id, (sqrt(random())::numeric*9223372036854775807*2-9223372036854775807::numeric)::int8::bit(64)::text as val from generate_series(1,10000000) t(id)) t;  

postgres=# select * from hm2 limit 10;  
 id |                              hmval                               |                                        hmarr                                          
----+------------------------------------------------------------------+-------------------------------------------------------------------------------------  
  1 | 1100111011000001100100100111111110100011100111111101101001101010 | {1_11001110,2_1100000110010010,3_01111111,4_10100011,5_1001111111011010,6_01101010}  
  2 | 0111111000101011000111010011011000000010010001111001000111011101 | {1_01111110,2_0010101100011101,3_00110110,4_00000010,5_0100011110010001,6_11011101}  
  3 | 0111111000101111000101011100100000001111011101101100110100000101 | {1_01111110,2_0010111100010101,3_11001000,4_00001111,5_0111011011001101,6_00000101}  
  4 | 0111010101010010100000110001100011110010111000001011000010010010 | {1_01110101,2_0101001010000011,3_00011000,4_11110010,5_1110000010110000,6_10010010}  
  5 | 1111101100110100101111000011001011111110111000100110101001100001 | {1_11111011,2_0011010010111100,3_00110010,4_11111110,5_1110001001101010,6_01100001}  
  6 | 0011110000100010101001000001100010000010111011100010011001000110 | {1_00111100,2_0010001010100100,3_00011000,4_10000010,5_1110111000100110,6_01000110}  
  7 | 0000111111001110100110011110000110001101110111111111111010111001 | {1_00001111,2_1100111010011001,3_11100001,4_10001101,5_1101111111111110,6_10111001}  
  8 | 0110100010010100111100110110000011101110101001001111010101011111 | {1_01101000,2_1001010011110011,3_01100000,4_11101110,5_1010010011110101,6_01011111}  
  9 | 0111001111001100101011001001100100000000111100000110110001000011 | {1_01110011,2_1100110010101100,3_10011001,4_00000000,5_1111000001101100,6_01000011}  
 10 | 1101111101011000111100101010101000100001101100101110100001111000 | {1_11011111,2_0101100011110010,3_10101010,4_00100001,5_1011001011101000,6_01111000}  
(10 rows)  

create index idx_hm2 on hm2 using gin(hmarr _text_sml_ops );
```

当查询汉明距离小于或等于 1 的值时，查询时间减少到 2 ms。

```
postgres=# set smlar.type = overlap;  
postgres=# set smlar.threshold = 5;  

postgres=# select    
    *,    
    smlar( hmarr, '{1_11001110,2_1100000110010010,3_01111111,4_10100011,5_1001111111011010,6_01101010}')    
  from    
    hm2   
  where    
    hmarr % '{1_11001110,2_1100000110010010,3_01111111,4_10100011,5_1001111111011010,6_01101010}'      
    and length(replace(bitxor(bit'1100111011000001100100100111111110100011100111111101101001101010', hmval)::text,'0','')) < 2  
  limit 100;  
 id |                              hmval                               |                                        hmarr                                        | smlar   
----+------------------------------------------------------------------+-------------------------------------------------------------------------------------+-------  
  1 | 1100111011000001100100100111111110100011100111111101101001101010 | {1_11001110,2_1100000110010010,3_01111111,4_10100011,5_1001111111011010,6_01101010} |     6  
(1 row)  
Time: 1.954 ms  

postgres=# explain (analyze,verbose,timing,costs,buffers) select    
    *,    
    smlar( hmarr, '{1_11001110,2_1100000110010010,3_01111111,4_10100011,5_1001111111011010,6_01101010}')    
  from    
    hm2   
  where    
    hmarr % '{1_11001110,2_1100000110010010,3_01111111,4_10100011,5_1001111111011010,6_01101010}'      
    and length(replace(bitxor(bit'1100111011000001100100100111111110100011100111111101101001101010', hmval)::text,'0','')) < 2  
  limit 100;  
                                                                            QUERY PLAN                                                                               
-------------------------------------------------------------------------------------------------------------------------------------------------------------------  
 Limit  (cost=103.83..406.06 rows=100 width=153) (actual time=2.414..2.416 rows=1 loops=1)  
   Output: id, hmval, hmarr, (smlar(hmarr, '{1_11001110,2_1100000110010010,3_01111111,4_10100011,5_1001111111011010,6_01101010}'::text[]))  
   Buffers: shared hit=102  
   ->  Bitmap Heap Scan on public.hm2  (cost=103.83..10177.17 rows=3333 width=153) (actual time=2.414..2.415 rows=1 loops=1)  
         Output: id, hmval, hmarr, smlar(hmarr, '{1_11001110,2_1100000110010010,3_01111111,4_10100011,5_1001111111011010,6_01101010}'::text[])  
         Recheck Cond: (hm2.hmarr % '{1_11001110,2_1100000110010010,3_01111111,4_10100011,5_1001111111011010,6_01101010}'::text[])  
         Filter: (length(replace((bitxor(B'1100111011000001100100100111111110100011100111111101101001101010'::"bit", hm2.hmval))::text, '0'::text, ''::text)) < 2)  
         Heap Blocks: exact=1  
         Buffers: shared hit=102  
         ->  Bitmap Index Scan on idx_hm2  (cost=0.00..103.00 rows=10000 width=0) (actual time=2.374..2.374 rows=1 loops=1)  
               Index Cond: (hm2.hmarr % '{1_11001110,2_1100000110010010,3_01111111,4_10100011,5_1001111111011010,6_01101010}'::text[])  
               Buffers: shared hit=101  
 Planning time: 0.149 ms  
 Execution time: 2.463 ms  
(14 rows)
```

## 4 阵列切片方法的性能验证

```
create table hm3 (id int, hmval bit(64), hmarr text[]);  

insert into hm3   
select   
  id,   
  val::bit(64),   
  regexp_split_to_array('1_'||substring(val,1,16)||',2_'||substring(val,17,16)||',3_'||substring(val,33,16)||',4_'||substring(val,41,16), ',')    
from   
(select id, (sqrt(random())::numeric*9223372036854775807*2-9223372036854775807::numeric)::int8::bit(64)::text as val from generate_series(1,10000000) t(id)) t;  

postgres=# select * from hm3 limit 10;  
 id |                              hmval                               |                                     hmarr                                       
----+------------------------------------------------------------------+-------------------------------------------------------------------------------  
  1 | 0101011111111010000001001011101101100011111101111101101100000011 | {1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}  
  2 | 1101011000010000000000000000111011011111011101110100000010101011 | {1_1101011000010000,2_0000000000001110,3_1101111101110111,4_0111011101000000}  
  3 | 0101000010110110110010001010100010101001001010111111011000110011 | {1_0101000010110110,2_1100100010101000,3_1010100100101011,4_0010101111110110}  
  4 | 0111000111100011111000100111000011101111110000011110101101000100 | {1_0111000111100011,2_1110001001110000,3_1110111111000001,4_1100000111101011}  
  5 | 0010111010101011111010011110110010011110111111110011101110010011 | {1_0010111010101011,2_1110100111101100,3_1001111011111111,4_1111111100111011}  
  6 | 0110111110011100100110010111010000000011100011000011110001010110 | {1_0110111110011100,2_1001100101110100,3_0000001110001100,4_1000110000111100}  
  7 | 0100110100111001110011011110100111101110101001000101010110110110 | {1_0100110100111001,2_1100110111101001,3_1110111010100100,4_1010010001010101}  
  8 | 0110010111001100111000011011011100001100111111101111011010100010 | {1_0110010111001100,2_1110000110110111,3_0000110011111110,4_1111111011110110}  
  9 | 0110111010110000001010101111000101110000010011100011100101000100 | {1_0110111010110000,2_0010101011110001,3_0111000001001110,4_0100111000111001}  
 10 | 0101101000000110100101100011111111000101110001010011100110101011 | {1_0101101000000110,2_1001011000111111,3_1100010111000101,4_1100010100111001}  
(10 rows)  

create index idx_hm3 on hm3 using gin(hmarr _text_sml_ops );
```

当查询汉明距离小于或等于 1 的值时，查询时间减少到 0.2 ms。

```
postgres=# set smlar.type = overlap;  
postgres=# set smlar.threshold = 3;  

postgres=# select    
    *,    
    smlar( hmarr, '{1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}')    
  from    
    hm3  
  where    
    hmarr % '{1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}'      
    and length(replace(bitxor(bit'0101011111111010000001001011101101100011111101111101101100000011', hmval)::text,'0','')) < 2  
  limit 100;  
 id |                              hmval                               |                                     hmarr                                     | smlar   
----+------------------------------------------------------------------+-------------------------------------------------------------------------------+-------  
  1 | 0101011111111010000001001011101101100011111101111101101100000011 | {1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011} |     4  
(1 row)  

postgres=# explain (analyze,verbose,timing,costs,buffers) select    
    *,    
    smlar( hmarr, '{1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}')    
  from    
    hm3  
  where    
    hmarr % '{1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}'      
    and length(replace(bitxor(bit'0101011111111010000001001011101101100011111101111101101100000011', hmval)::text,'0','')) < 2  
  limit 100;  
                                                                            QUERY PLAN                                                                               
-------------------------------------------------------------------------------------------------------------------------------------------------------------------  
 Limit  (cost=99.83..401.19 rows=100 width=134) (actual time=0.169..0.170 rows=1 loops=1)  
   Output: id, hmval, hmarr, (smlar(hmarr, '{1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}'::text[]))  
   Buffers: shared hit=14  
   ->  Bitmap Heap Scan on public.hm3  (cost=99.83..10144.17 rows=3333 width=134) (actual time=0.168..0.169 rows=1 loops=1)  
         Output: id, hmval, hmarr, smlar(hmarr, '{1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}'::text[])  
         Recheck Cond: (hm3.hmarr % '{1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}'::text[])  
         Filter: (length(replace((bitxor(B'0101011111111010000001001011101101100011111101111101101100000011'::"bit", hm3.hmval))::text, '0'::text, ''::text)) < 2)  
         Heap Blocks: exact=1  
         Buffers: shared hit=14  
         ->  Bitmap Index Scan on idx_hm3  (cost=0.00..99.00 rows=10000 width=0) (actual time=0.145..0.145 rows=1 loops=1)  
               Index Cond: (hm3.hmarr % '{1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}'::text[])  
               Buffers: shared hit=13  
 Planning time: 0.101 ms  
 Execution time: 0.200 ms  
(14 rows)
```

当查询汉明距离小于或等于 4 的值时，查询时间保持几毫秒。

```
postgres=# set smlar.type = overlap;  
postgres=# set smlar.threshold = 0;  

postgres=# select    
    *,    
    smlar( hmarr, '{1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}')    
  from    
    hm3  
  where    
    hmarr % '{1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}'      
    and length(replace(bitxor(bit'0101011111111010000001001011101101100011111101111101101100000011', hmval)::text,'0','')) < 5  
  limit 100;  
 id |                              hmval                               |                                     hmarr                                     | smlar   
----+------------------------------------------------------------------+-------------------------------------------------------------------------------+-------  
  1 | 0101011111111010000001001011101101100011111101111101101100000011 | {1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011} |     4  
(1 row)  
Time: 6.983 ms
```

如果没有使用索引，查询需要 23 秒才能完成。

```
postgres=# select * from hm3 where length(replace(bitxor(bit'0101011111111010000001001011101101100011111101111101101100000011', hmval)::text,'0','')) < 5;  
 id |                              hmval                               |                                     hmarr                                       
----+------------------------------------------------------------------+-------------------------------------------------------------------------------  
  1 | 0101011111111010000001001011101101100011111101111101101100000011 | {1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}  
(1 row)  

Time: 22954.686 ms
```

与不使用索引的场景相比，性能提高了 114，800 倍，从 23 秒提高到 0.2 毫秒。

# 自动切片

如果您想知道如何在对 SimHash 数据进行切片后生成数组，那么不要担心。PostgreSQL 提供了强大的用户定义函数(UDF)来生成数组。

您可以创建 UDF 和触发器，一旦写入数据，切片时就会自动生成数组。以下示例说明了自动切片的工作原理:

```
create table hm4 (id int, hmval bit(64), hmarr text[]); create or replace function sp(val bit(64)) returns text[] as $$
select regexp_split_to_array('1_'||substring(val::text,1,10)||',2_'||substring(val::text,11,10)||',3_'||substring(val::text,21,10)||',4_'||substring(val::text,31,10)||',5_'||substring(val::text,41,10)||',6_'||substring(val::text,51,14), ',') ;            
$$ language sql strict;postgres=# select sp(123::bit(64));
                                         sp                                          
-------------------------------------------------------------------------------------
 {1_0000000000,2_0000000000,3_0000000000,4_0000000000,5_0000000000,6_00000001111011}
(1 row)-- 写入 1 亿记录insert into hm4  
select   
  id,   
  val::bit(64),   
  sp(val::bit(64))    
from   
(select id, (sqrt(random())::numeric*9223372036854775807*2-9223372036854775807::numeric)::int8::bit(64)::text as val from generate_series(1,100000000) t(id)) t; -- 索引create index idx_hm4 on hm4 using gin(hmarr _text_sml_ops ); -- 查询海明距离小于等于 1 的记录，性能杠杠的postgres=# set smlar.type = overlap;  
postgres=# set smlar.threshold = 5; select    
    *,    
    smlar( hmarr, sp(123::bit(64)))     -- 查询与 123::bit(64)海明距离小于 2 的记录
  from    
    hm3  
  where    
    hmarr % sp(123::bit(64))      -- 查询与 123::bit(64)海明距离小于 2 的记录
    and length(replace(bitxor(123::bit(64), hmval)::text,'0','')) < 2      -- 查询与 123::bit(64)海明距离小于 2 的记录
  limit 100;  

postgres=# explain (analyze,verbose,timing,costs,buffers) select
    *,
    smlar( hmarr, sp(123::bit(64)))     -- 查询与 123::bit(64)海明距离小于 2 的记录
  from
    hm3
  where
    hmarr % sp(123::bit(64))      -- 查询与 123::bit(64)海明距离小于 2 的记录
    and length(replace(bitxor(123::bit(64), hmval)::text,'0','')) < 2      -- 查询与 123::bit(64)海明距离小于 2 的记录
  limit 100;
                                                                             QUERY PLAN                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=109.83..411.19 rows=100 width=134) (actual time=0.078..0.078 rows=0 loops=1)
   Output: id, hmval, hmarr, (smlar(hmarr, '{1_0000000000,2_0000000000,3_0000000000,4_0000000000,5_0000000000,6_00000001111011}'::text[]))
   Buffers: shared hit=19
   ->  Bitmap Heap Scan on public.hm3  (cost=109.83..10154.17 rows=3333 width=134) (actual time=0.076..0.076 rows=0 loops=1)
         Output: id, hmval, hmarr, smlar(hmarr, '{1_0000000000,2_0000000000,3_0000000000,4_0000000000,5_0000000000,6_00000001111011}'::text[])
         Recheck Cond: (hm3.hmarr % '{1_0000000000,2_0000000000,3_0000000000,4_0000000000,5_0000000000,6_00000001111011}'::text[])
         Filter: (length(replace((bitxor(B'0000000000000000000000000000000000000000000000000000000001111011'::bit(64), hm3.hmval))::text, '0'::text, ''::text)) < 2)
         Buffers: shared hit=19
         ->  Bitmap Index Scan on idx_hm3  (cost=0.00..109.00 rows=10000 width=0) (actual time=0.074..0.074 rows=0 loops=1)
               Index Cond: (hm3.hmarr % '{1_0000000000,2_0000000000,3_0000000000,4_0000000000,5_0000000000,6_00000001111011}'::text[])
               Buffers: shared hit=19
 Planning time: 0.592 ms
 Execution time: 0.117 ms
(13 rows)
```

接下来，您需要创建一个触发器。当写入 SimHash 数据时，切片产生的数组被自动写入。

```
create or replace function tg() returns trigger as $$
declare
begin
  NEW.hmarr := sp(NEW.hmval);
  return NEW;
end;
$$ language plpgsql strict;postgres=# create trigger tg before insert or update on hm4 for each row execute procedure tg();
CREATE TRIGGER-- 效果很赞postgres=# truncate hm4;
TRUNCATE TABLE
postgres=# insert into hm4 values (1,1::bit(64));
INSERT 0 1
postgres=# select * from hm4;
 id |                              hmval                               |                                        hmarr                                        
----+------------------------------------------------------------------+-------------------------------------------------------------------------------------
  1 | 0000000000000000000000000000000000000000000000000000000000000001 | {1_0000000000,2_0000000000,3_0000000000,4_0000000000,5_0000000000,6_00000000000001}
(1 row)postgres=# update hm4 set hmval=123456::bit(64);
UPDATE 1
postgres=# select * from hm4;
 id |                              hmval                               |                                        hmarr                                        
----+------------------------------------------------------------------+-------------------------------------------------------------------------------------
  1 | 0000000000000000000000000000000000000000000000011110001001000000 | {1_0000000000,2_0000000000,3_0000000000,4_0000000000,5_0000000111,6_10001001000000}
(1 row)
```

# 基于 GIN 索引的相似性算法简介

让我们来看看各种基于 GIN 指数的相似性算法:

1.余弦

```
相似值算法
                case ST_COSINE:
                        {
                                int                             cnt;
                                double                  power; power = ((double)(sa->nelems)) * ((double)(sb->nelems));
                                cnt = numOfIntersect(sa, sb); PG_RETURN_FLOAT4(  ((double)cnt) / sqrt( power ) );
                        }
GIN 一重过滤算法
                                case ST_COSINE:
                                                {
                                                        double                  power; power = sqrt( ((double)(sa->nelems)) * ((double)(cnt)) ); if (  ((double)cnt) / power >= GetSmlarLimit()  )
                                                                res = true;
                                                }
```

2.重叠

```
相似值算法
                case ST_OVERLAP:
                        {
                                float4 res = (float4)numOfIntersect(sa, sb); PG_RETURN_FLOAT4(res);
                        }
GIN 一重过滤算法
                                case ST_OVERLAP:
                                                if (cnt >= GetSmlarLimit())
                                                        res = true;
```

3.TF-IDF

目前，只有当 TF 值等于 IDF 值时，才支持基于 GIN 索引的数据检索。此外，IDF 值被写入表中。这意味着指数支持 IDF 值，但不支持 TF 值。算法本身同时支持 TF 和 IDF。

要使 GIN 索引支持 TF，您需要修改 smlar 代码。但是，由于 GiST 索引已经支持 TF，所以您可以使用 GiST 索引来代替。可以参考博客-
[PostgreSQL 结合余弦和线性相关算法在文本、图像、数组相似性领域的应用(2)——smlar 插件介绍](https://github.com/digoal/blog/blob/master/201701/20170116_03.md?spm=a2c41.13977169.0.0&file=20170116_03.md)了解更多信息。

smlar 插件可用于确定短文档之间的相似性。

```
相似值算法
考虑了 IDF 的权重(一张 IDF TABLE 来记录权重)。相比 cosine 算法，更适合短文本相似判断。 但是请注意不考虑 TF。
例如一个短文的关键词向量为 (我 1, 爱 1, 中国 5),这里的 tf 115 全部不计。 static double
TFIDFSml(SimpleArray *a, SimpleArray *b)
{
        int                             cmp;
        Datum                   *aptr = a->elems,
                                        *bptr = b->elems;
        ProcTypeInfo    info = a->info;
        double                  res = 0.0;
        double                  suma = 0.0, sumb = 0.0; Assert( a->info->typid == b->info->typid );
        Assert( a->df );
        Assert( b->df ); getFmgrInfoCmp(info); while( aptr - a->elems < a->nelems && bptr - b->elems < b->nelems )
        {
                cmp = cmpArrayElem(aptr, bptr, info);
                if ( cmp < 0 )
                {
                        suma += a->df[ aptr - a->elems ] * a->df[ aptr - a->elems ];
                        aptr++;
                }
                else if ( cmp > 0 )
                {
                        sumb += b->df[ bptr - b->elems ] * b->df[ bptr - b->elems ];
                        bptr++;
                }
                else
                {
                        res += a->df[ aptr - a->elems ] * b->df[ bptr - b->elems ];
                        suma += a->df[ aptr - a->elems ] * a->df[ aptr - a->elems ];
                        sumb += b->df[ bptr - b->elems ] * b->df[ bptr - b->elems ];
                        aptr++;
                        bptr++;
                }
        } /*
         * Compute last elements
         */
        while( aptr - a->elems < a->nelems )
        {
                suma += a->df[ aptr - a->elems ] * a->df[ aptr - a->elems ];
                aptr++;
        } while( bptr - b->elems < b->nelems )
        {
                sumb += b->df[ bptr - b->elems ] * b->df[ bptr - b->elems ];
                bptr++;
        } if ( suma > 0.0 && sumb > 0.0 )
                res = res / sqrt( suma * sumb );
        else
                res = 0.0; return res;
}
GIN 一重过滤算法
                                case ST_TFIDF:
                                                {
                                                        double  weight = 0.0, /* exact weight of union */
                                                                        saSum = 0.0,  /* exact length of query */
                                                                        siSum = 0.0;  /* lower limit of length of indexed value */                                                        if ( getTFMethod() != TF_CONST )
                                                                elog(ERROR,"GIN supports only smlar.tf_method = \"const\"" ); Assert(sa->df); for(i=0; i<sa->nelems; i++)
                                                        {
                                                                /*
                                                                 * With smlar.tf_method = "const"   sa->df[i] is 
                                                                 * equal to its idf, so lookup of StatElem is not needed
                                                                 */
                                                                if ( check[i] )
                                                                {
                                                                        weight += sa->df[i] * sa->df[i];
                                                                        siSum += sa->df[i] * sa->df[i];
                                                                }
                                                                saSum += sa->df[i] * sa->df[i];
                                                        } if ( saSum > 0.0 && siSum > 0.0 && weight / sqrt(saSum * siSum ) > GetSmlarLimit() )
                                                                res = true;
                                                }
```

基于 TF-IDF 查询相似文档。

# 4.技术要点

1.  阿里云 ApsaraDB RDS for PostgreSQL 的 smlar 插件使用了 GIN 索引、块级收敛和双重过滤。从 1000 万条数据记录中检索汉明距离小于或等于 2 的记录只需不到 0.2 ms。
2.  阿里云 ApsaraDB RDS for PostgreSQL 10 采用多核并行计算和蛮力扫描。从 1000 万条数据记录中检索汉明距离小于或等于 N 的记录需要不到 450 ms。
3.  阿里云 HybridDB for PostgreSQL 采用多主机并行计算，横向扩展计算能力，进行蛮力扫描。查询效率取决于节点的数量。

# 5.结论

可以将 smlar 插件与阿里云 ApsaraDB RDS for PostgreSQL 配合使用，从数千万条 SimHash 数据记录中检索相似数据。稍后将提供关于更大数据量的测试的信息，响应速度应该是几毫秒。与不使用索引的场景相比，性能提高了 114，800 倍，从 23 秒提高到 0.2 毫秒。

*在阿里云上用*[*ApsaraDB for RDS PostgreSQL*](https://www.alibabacloud.com/product/apsaradb-for-rds-postgresql?spm=a2c41.13977169.0.0)*构建自己的 PostgreSQL 解决方案。*

# 原始来源:

[](https://www.alibabacloud.com/blog/the-smlar-plug-in-for-effective-retrieval-of-massive-volumes-of-simhash-data_595786?spm=a2c41.13977169.0.0) [## 用于有效检索大量 SimHash 数据的 smlar 插件

### 本文解释了 PostgreSQL 数据库和 smlar 插件如何帮助高效地检索大量的…

www.alibabacloud.com](https://www.alibabacloud.com/blog/the-smlar-plug-in-for-effective-retrieval-of-massive-volumes-of-simhash-data_595786?spm=a2c41.13977169.0.0)