<html>
<head>
<title>Redis Data Structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis数据结构</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/redis-data-structures-495baef3d486?source=collection_archive---------4-----------------------#2021-01-08">https://medium.datadriveninvestor.com/redis-data-structures-495baef3d486?source=collection_archive---------4-----------------------#2021-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="1aba" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">Redis第六集</h2><div class=""/><div class=""><h2 id="d493" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">Redis中数据结构的解释和使用</h2></div><p id="b552" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">大家好，今天我们将讨论Redis内存数据存储可用的数据结构。在深入主题之前，我们首先讨论一些子概念。这将使文章的流动很好。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lk"><img src="../Images/8f2c4a4fc83380c72f96495a76dd0112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*99v8pR4nRoMnxr9z"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk">Photo by <a class="ae ma" href="https://unsplash.com/@jessedo81?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">jesse orrico</a> on <a class="ae ma" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="1ff5" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">雷迪斯</h1><p id="6990" class="pw-post-body-paragraph ko kp iq kq b kr mt ka kt ku mu kd kw kx mv kz la lb mw ld le lf mx lh li lj ij bi my translated">edis是一个用C语言编写的开源(<a class="ae ma" href="https://en.wikipedia.org/wiki/BSD_licenses#:~:text=BSD%20licenses%20are%20a%20family,and%20distribution%20of%20covered%20software.&amp;text=The%20original%20BSD%20license%20was,a%20Unix%2Dlike%20operating%20system." rel="noopener ugc nofollow" target="_blank"> BSD许可</a>)内存数据结构存储，主要支持Linux及相关操作系统。Redis可以用作NoSQL数据库和高速缓存存储。它是一个键值数据存储，不同于以表格格式存储数据的关系数据库。内存中的<a class="ae ma" href="https://en.wikipedia.org/wiki/In-memory_database" rel="noopener ugc nofollow" target="_blank">让Redis变得难以置信的快和高性能。这是许多开发者对Redis感兴趣的主要原因。Redis允许持久化，即使它在内存中，高可伸缩性和简单性。Redis处理像Twitter的timeline这样的超级大数据集的速度非常快。它是在Redis中实现的。除了堆栈溢出之外，Github还在实现中使用Redis作为缓存存储。你可以在这里找到我的Redis介绍文章</a><a class="ae ma" href="https://sthenusan.medium.com/introduction-to-redis-3e6c3a0083a7" rel="noopener"/>。</p><h1 id="7418" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">数据结构</h1><p id="b9de" class="pw-post-body-paragraph ko kp iq kq b kr mt ka kt ku mu kd kw kx mv kz la lb mw ld le lf mx lh li lj ij bi translated">当我们的东西在工作场所、卧室甚至是工作桌上都没有摆放整齐时，我们可能会觉得很困难。任何类型的工作场所都需要被很好地组织起来，以便于进入，快速地在那里放入新的东西或者从那里移走一些东西，而不会打扰到那里的其他人。编程中的这种概念叫做数据结构。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nh"><img src="../Images/4235a180e5df00dc87747dec11db1cb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8dODocDuQHDq5uFZ"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk">Photo by <a class="ae ma" href="https://unsplash.com/@brett_jordan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brett Jordan</a> on <a class="ae ma" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dc53" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">数据结构是用于组织、处理、检索和存储数据的专用格式。有许多数据结构的例子，如列表、集合、哈希表、树、堆栈、队列、链表等。所有的数据结构都被设计来安排数据以适应特定的目的。一种数据结构对于一个用例可能非常有用，而对于另一个用例可能毫无用处。</p><h1 id="41ca" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">Redis数据结构</h1><p id="09a4" class="pw-post-body-paragraph ko kp iq kq b kr mt ka kt ku mu kd kw kx mv kz la lb mw ld le lf mx lh li lj ij bi translated">尽管Redis是一个键值对存储，但它直接支持几种数据结构。它们是列表、集合、散列、排序集合、位图和超级日志。下面更多细节一个一个来看。</p><h1 id="c9e3" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">列表</h1><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ni"><img src="../Images/dcb167cfae46a2f52777f90f4204f078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BGefoYxKEY8vFJQQ"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk">Photo by <a class="ae ma" href="https://unsplash.com/@martinsanchez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Martin Sanchez</a> on <a class="ae ma" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9810" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">列表是许多编程语言中常见的数据结构之一。从一个非常普通的角度来看，列表仅仅意味着有序元素的序列。列表可以使用一些不同的数据结构来实现，如数组或链表等。根据实现类型的不同，列表的功能可能会有所不同。通过数组实现的列表的属性与通过链表实现的列表的属性非常不同。</p><p id="0556" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">Redis列表是通过链表实现的。这意味着即使你在一个列表中有数百万个元素，在列表的头部或尾部添加一个新元素的操作也是在常量<em class="nj">时间</em>中执行的。将一个新元素添加到只有五个元素的列表的开头所花费的时间与将一个元素添加到有五百万个元素的列表的开头所花费的时间相同。如果Redis列表是使用数组数据结构实现的，那么通过索引访问时间将是常数。</p><h2 id="33bd" class="nk mc iq bd md nl nm dn mh nn no dp ml kx np nq mn lb nr ns mp lf nt nu mr iw bi translated">列表的一些重要命令</h2><ol class=""><li id="8130" class="nv nw iq kq b kr mt ku mu kx nx lb ny lf nz lj oa ob oc od bi translated"><code class="fe oe of og oh b">LPUSH</code>和<code class="fe oe of og oh b">RPUSH</code>分别是将元素推到列表右侧和左侧的命令。</li><li id="f557" class="nv nw iq kq b kr oi ku oj kx ok lb ol lf om lj oa ob oc od bi translated">弹出元素是同时从列表中检索元素和从列表中删除元素的操作。我们可以使用<code class="fe oe of og oh b">LPOP</code>和<code class="fe oe of og oh b">RPOP</code>从左侧和右侧弹出元素，类似于我们如何在列表的两侧推送元素。</li></ol><p id="d32f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">3.<code class="fe oe of og oh b">LRANGE </code>从Redis的列表中提取元素范围。</p><p id="0c57" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">4.命令<code class="fe oe of og oh b">LTRIM</code>类似于<code class="fe oe of og oh b">LRANGE</code>，但是它不是显示指定范围的元素，而是将这个范围设置为新的列表值。移除给定范围之外的所有元素。</p><h1 id="8b79" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">设置</h1><p id="cfbd" class="pw-post-body-paragraph ko kp iq kq b kr mt ka kt ku mu kd kw kx mv kz la lb mw ld le lf mx lh li lj ij bi translated">Redis集是唯一字符串的无序集合。唯一均值集不允许关键字中的数据重复。还可以对集合进行一些操作，比如向集合追加一个值，检查给定元素是否已经存在，产生多个集合之间的交集、并集或差集，等等。无论集合中包含多少个元素，集合添加、移除和测试成员的存在都将在一个固定的时间内发生。</p><h2 id="2978" class="nk mc iq bd md nl nm dn mh nn no dp ml kx np nq mn lb nr ns mp lf nt nu mr iw bi translated">器械包的一些重要命令</h2><ol class=""><li id="b393" class="nv nw iq kq b kr mt ku mu kx nx lb ny lf nz lj oa ob oc od bi translated">命令<code class="fe oe of og oh b">SADD </code>向集合中添加新元素。</li><li id="5640" class="nv nw iq kq b kr oi ku oj kx ok lb ol lf om lj oa ob oc od bi translated">命令<code class="fe oe of og oh b">SDIFF</code>用于减去多组</li><li id="0f62" class="nv nw iq kq b kr oi ku oj kx ok lb ol lf om lj oa ob oc od bi translated">为了相交多个集合，我们使用<code class="fe oe of og oh b">SINTER</code>。</li><li id="2951" class="nv nw iq kq b kr oi ku oj kx ok lb ol lf om lj oa ob oc od bi translated">为了确定一个给定值是否是一个集合的成员，我们可以使用<code class="fe oe of og oh b">SISMEMBER</code>命令。</li></ol><p id="aad4" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">还有许多其他的集合命令。你可以在这里找到它们。</p><h1 id="d23e" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">散列表</h1><p id="0b70" class="pw-post-body-paragraph ko kp iq kq b kr mt ka kt ku mu kd kw kx mv kz la lb mw ld le lf mx lh li lj ij bi translated">HashMap与HashTable相同，但是它是不同步的。它也允许放置空键，但是应该只有一个空键对象，并且可以有任意数量的空值。HashMap允许我们存储键和值对，其中键应该是惟一的。值可以是特定键的任何类型的对象。如果您尝试插入复制键，它将替换相应键的元素。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi on"><img src="../Images/4b637390cc5c09a4c48f2493c4f4e1d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Gs_Zeb5EdpiS4h2k"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk">Photo by <a class="ae ma" href="https://unsplash.com/@miracleday?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Elena Mozhvilo</a> on <a class="ae ma" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="38c7" class="nk mc iq bd md nl nm dn mh nn no dp ml kx np nq mn lb nr ns mp lf nt nu mr iw bi translated">Redis散列</h2><p id="3ec6" class="pw-post-body-paragraph ko kp iq kq b kr mt ka kt ku mu kd kw kx mv kz la lb mw ld le lf mx lh li lj ij bi translated">Redis散列是字符串字段和字符串值之间的映射。它们是表示对象的绝对数据类型。你可以在这里找到如何在Redis <a class="ae ma" href="https://sthenusan.medium.com/redis-as-object-storage-e6a084b46f8b" rel="noopener">中存储对象。密钥是唯一的。二进制键和值可以通过编程语言客户端存储在Redis中。例如Jedis。BinaryJedis在这里</a><a class="ae ma" href="https://github.com/redis/jedis" rel="noopener ugc nofollow" target="_blank">可用</a>。</p><h2 id="e3b2" class="nk mc iq bd md nl nm dn mh nn no dp ml kx np nq mn lb nr ns mp lf nt nu mr iw bi translated">Redis hash的一些重要命令</h2><ol class=""><li id="8f74" class="nv nw iq kq b kr mt ku mu kx nx lb ny lf nz lj oa ob oc od bi translated"><code class="fe oe of og oh b">HSET</code>用于设置哈希字段的字符串值。</li><li id="ae25" class="nv nw iq kq b kr oi ku oj kx ok lb ol lf om lj oa ob oc od bi translated"><code class="fe oe of og oh b">HGET</code>用于获取存储在指定键的散列字段的值。</li><li id="5701" class="nv nw iq kq b kr oi ku oj kx ok lb ol lf om lj oa ob oc od bi translated"><code class="fe oe of og oh b">HGETALL</code>将给所有的字段和值存储在一个hash中的特定键上。</li><li id="738d" class="nv nw iq kq b kr oi ku oj kx ok lb ol lf om lj oa ob oc od bi translated"><code class="fe oe of og oh b">HEXISTS</code>将允许我们检查一个关键字段的存在。</li></ol><p id="bcb4" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">Redis Hash还有更多可用的命令。你可以在这里找到它们。</p><h1 id="1886" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">排序集合</h1><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nh"><img src="../Images/a3983521216c37d41351599e42549eaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bvD-P_Uu0RBkMzcg"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk">Photo by <a class="ae ma" href="https://unsplash.com/@paulbrgmr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Paul Bergmeir</a> on <a class="ae ma" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b74e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">有序集合是一种数据类型，类似于集合和散列的混合。排序集由唯一的且不重复的字符串元素组成。有序集合中的每个元素都与一个称为分数的浮点值相关联。这就是为什么排序集被称为类似于哈希，因为每个元素都映射到一个名为score的值。有序集合中的元素按顺序排列。它们在已排序的集合中没有排序。顺序是用于描述有序集合的数据结构的特征。它们根据以下规则排序:</p><ul class=""><li id="85aa" class="nv nw iq kq b kr ks ku kv kx oo lb op lf oq lj or ob oc od bi translated">如果A和B是两个得分不同的元素，那么A &gt; B，如果A . score &gt; B . score。</li><li id="29e0" class="nv nw iq kq b kr oi ku oj kx ok lb ol lf om lj or ob oc od bi translated">如果A和B的得分完全相同，那么A &gt; B，如果A字符串在字典上大于B字符串。a和B字符串不能相等，因为排序后的集合只有唯一的元素。</li></ul><p id="41fb" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们从一个简单的例子开始。添加一些选定的板球运动员的名字作为排序的集合元素，以他们在最后一场比赛中得分作为分数。</p><pre class="ll lm ln lo gt os oh ot ou aw ov bi"><span id="30e6" class="nk mc iq oh b gy ow ox l oy oz">&gt; zadd wcwinners 0 "<!-- -->Virender Sehwag<!-- -->"<br/>(integer) 1<br/>&gt; zadd wcwinners 18 "<!-- -->Sachin Tendulkar<!-- -->"<br/>(integer) 1<br/>&gt; zadd wcwinners 97 "<!-- -->Gautam Gambhir<!-- -->"<br/>(integer) 1<br/>&gt; zadd wcwinners 35 "Virat Kholi"<br/>(integer) 1<br/>&gt; zadd wcwinners 91 "<!-- -->MS Dhoni<!-- -->"<br/>(integer) 1<br/>&gt; zadd wcwinners 21 "<!-- -->Yuvraj Singh<!-- -->"<br/>(integer) 1</span></pre><ul class=""><li id="9f32" class="nv nw iq kq b kr ks ku kv kx oo lb op lf oq lj or ob oc od bi translated"><code class="fe oe of og oh b">zadd</code>更可能是普通集合中的<code class="fe oe of og oh b">sadd</code>，用于在有序集合中添加元素。</li><li id="d548" class="nv nw iq kq b kr oi ku oj kx ok lb ol lf om lj or ob oc od bi translated">排序集是通过包含一个跳过列表和一个哈希表的双端口数据结构来执行的，所以每次我们添加一个元素Redis都会执行一个O(log(N))操作。这很好，但是当我们请求排序的元素时，Redis根本不需要做任何工作，它已经处于排序状态了。</li><li id="bd4e" class="nv nw iq kq b kr oi ku oj kx ok lb ol lf om lj or ob oc od bi translated">当我们从0到-1调用<code class="fe oe of og oh b">zrange</code>时，它将列表中的所有元素按顺序排序。我们可以调用<code class="fe oe of og oh b">zrevrange</code>从排序后的列表中获取反向排序的元素。</li></ul><pre class="ll lm ln lo gt os oh ot ou aw ov bi"><span id="a531" class="nk mc iq oh b gy ow ox l oy oz">&gt; zrange wcwinners 0 -1<br/>1) "<!-- -->Gautam Gambhir<!-- -->"<br/>2) "<!-- -->MS Dhoni<!-- -->"<br/>3) "Virat Kholi"<br/>4) "<!-- -->Yuvraj Singh<!-- -->"<br/>5) "<!-- -->Sachin Tendulkar<!-- -->"<br/>6) "<!-- -->Virender Sehwag<!-- -->"</span></pre><ul class=""><li id="6a07" class="nv nw iq kq b kr ks ku kv kx oo lb op lf oq lj or ob oc od bi translated">我们可以通过<code class="fe oe of og oh b">zrangebyscore</code>命令得到一个范围内的排序元素。</li><li id="72dc" class="nv nw iq kq b kr oi ku oj kx ok lb ol lf om lj or ob oc od bi translated">我们还可以通过<code class="fe oe of og oh b">zrank</code>命令以有序的方式获得特定元素的等级。</li></ul><pre class="ll lm ln lo gt os oh ot ou aw ov bi"><span id="4914" class="nk mc iq oh b gy ow ox l oy oz">&gt; zrank wcwinners "<!-- -->MS Dhoni<!-- -->"<br/>(integer) 2</span></pre><p id="0e64" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">此处有更多适用于可用排序集合的命令<a class="ae ma" href="https://redis.io/commands" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="9378" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">位图</h1><p id="317a" class="pw-post-body-paragraph ko kp iq kq b kr mt ka kt ku mu kd kw kx mv kz la lb mw ld le lf mx lh li lj ij bi translated">位图不是实际的数据类型。Redis中没有专门的位图数据结构。相反，位级操作是在主要Redis数据结构字符串上进行的。</p><p id="589e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">按位运算主要分为两组</p><ol class=""><li id="aa5a" class="nv nw iq kq b kr ks ku kv kx oo lb op lf oq lj oa ob oc od bi translated">操作单比特:像设置一个比特，获得它的值</li><li id="2768" class="nv nw iq kq b kr oi ku oj kx ok lb ol lf om lj oa ob oc od bi translated">在位组上的操作:计算给定位范围内设置位的数量</li></ol><p id="2231" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">位图最有影响力的好处之一是，在存储信息时，它们通常能最大限度地节省空间。</p><p id="ee6b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">*例如，在一个通过递增的用户id来描述不同用户的系统中，仅使用512 MB的内存就可以记住40亿用户的一位信息(例如，知道一名员工是否想要免费午餐)。</p><p id="dec4" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">使用位图中的<code class="fe oe of og oh b">setbit</code>和<code class="fe oe of og oh b">getbit</code>命令设置和检索位。</p><pre class="ll lm ln lo gt os oh ot ou aw ov bi"><span id="4892" class="nk mc iq oh b gy ow ox l oy oz">&gt; setbit lunch 11 1<br/>(integer) 1<br/>&gt; getbit lunch 11<br/>(integer) 1</span></pre><p id="4ade" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe oe of og oh b">setbit</code>命令接受位数作为其第一个参数，接受将该位设置为1或0的值作为其第二个参数。<code class="fe oe of og oh b">getbit</code>只返回指定索引处的位的值。超出范围的位会被判断为零。</p><ul class=""><li id="7d93" class="nv nw iq kq b kr ks ku kv kx oo lb op lf oq lj or ob oc od bi translated"><code class="fe oe of og oh b">bitpos</code>-获取具有指定值0或1的第一位。</li><li id="2649" class="nv nw iq kq b kr oi ku oj kx ok lb ol lf om lj or ob oc od bi translated"><code class="fe oe of og oh b">bitop</code>-在不同字符串之间执行逐位逻辑运算。</li><li id="97c5" class="nv nw iq kq b kr oi ku oj kx ok lb ol lf om lj or ob oc od bi translated"><code class="fe oe of og oh b">bitcount</code>-执行群体计数，报告设置为1的位数</li></ul><p id="7359" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">你可以在这里找到位图<a class="ae ma" href="https://redis.io/commands" rel="noopener ugc nofollow" target="_blank">的附加命令。</a></p><h1 id="d73b" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">超对数</h1><p id="6a55" class="pw-post-body-paragraph ko kp iq kq b kr mt ka kt ku mu kd kw kx mv kz la lb mw ld le lf mx lh li lj ij bi translated">超对数是一种用于计算唯一值的概率数据结构。在数学中，我们可以用计算一个集合的基数来匹配它。通常计数单个项目需要使用与您需要计数的项目数量成比例的内存量。</p><p id="bf4d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这个算法的神奇之处在于，我们不需要使用与计算的项目数量成比例的内存量，而是可以使用固定的内存量。在最坏的情况下，它使用12k字节。Redis中的HLL编码为Redis字符串，因此您可以调用get来序列化HLL，并设置将其反序列化回服务器。超级日志中使用了<code class="fe oe of og oh b">pfadd</code>、<code class="fe oe of og oh b">pfcount</code>和<code class="fe oe of og oh b">pfmerge</code>命令。这些命令在超对数算法的发明者Philippe Flajolet的内存中以pf为前缀。</p><p id="383c" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">下面给出了上述命令的用法示例。</p><pre class="ll lm ln lo gt os oh ot ou aw ov bi"><span id="9c6f" class="nk mc iq oh b gy ow ox l oy oz">&gt; pfadd teachers raj kamal vimal<br/>(integer) 1<br/>&gt; pfcount teachers<br/>(integer) 3<br/>&gt; pfadd students kholi dhoni<br/>(integer) 1<br/>&gt; pfmerge members teachers students<br/>OK<br/>&gt; pfcount members<br/>(integer) 5</span></pre><p id="ed39" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我相信你已经理解了我们今天讨论的话题。如果您有任何问题或任何澄清，不要犹豫，通过回复部分与我联系。感谢您花费宝贵的时间阅读本文。</p><p id="3bfc" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">干杯…</p><p id="8510" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">访问专家视图— </strong> <a class="ae ma" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="kq ja">订阅DDI英特尔</strong> </a></p><h1 id="739f" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">参考</h1><div class="pa pb gp gr pc pd"><a href="https://redislabs.com/" rel="noopener  ugc nofollow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd ja gy z fp pi fr fs pj fu fw iz bi translated">Redis实验室|最佳Redis体验</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">如果简单的缓存是你使用Redis的全部目的，那你就错过了。利用实时数据库Redis Enterprise</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">redislabs.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr lu pd"/></div></div></a></div><div class="pa pb gp gr pc pd"><a href="https://redis.io/" rel="noopener  ugc nofollow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd ja gy z fp pi fr fs pj fu fw iz bi translated">雷迪斯</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">Redis是一个开源的(BSD许可的)、内存中的数据结构存储，用作数据库、缓存和消息代理…</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">redis.io</p></div></div><div class="pm l"><div class="ps l po pp pq pm pr lu pd"/></div></div></a></div></div></div>    
</body>
</html>