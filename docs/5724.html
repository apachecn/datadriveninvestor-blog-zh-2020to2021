<html>
<head>
<title>Chem: Molecular Graph-Based Similarity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">化学:基于分子图的相似性</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/chem-molecular-graph-based-similarity-fc37572fc81?source=collection_archive---------7-----------------------#2020-09-29">https://medium.datadriveninvestor.com/chem-molecular-graph-based-similarity-fc37572fc81?source=collection_archive---------7-----------------------#2020-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="eae6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章将解释如何计算基于分子图的相似性来寻找子图/子结构。有许多算法可以达到这个目的，但我们将通过3个算法。</p><h1 id="f95c" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">子图/子结构搜索</h1><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/19f31fe534a406276090121cb0a8a2d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WXvBkc_-jnjLR-bN.png"/></div></div></figure><p id="f85f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要定义什么是子图，什么是子图搜索。首先，子图是化学结构的一部分。可以用上图查一下。我们想寻找每一种具有完全相同结构的化学物质。我们有一个复合数据库和一个小的查询片段(子结构)。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ly"><img src="../Images/d07b7535ac70e7a06bcc0a92de0172df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3qSL8ezgbKlUn2r5d8hJvQ.png"/></div></div></figure><p id="1776" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个查询示例。我们对算法进行查询，算法通过数据库找到具有完全相同子结构的化学物质。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lz"><img src="../Images/ed136f532448306bdd5251d434a8ee27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fuAxV42LhFEb1e5jF1su4A.png"/></div></div></figure><p id="a50c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个子图的例子。如果子图有不同的边，它就不再是子图了。每个节点和边都必须在图中。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ma"><img src="../Images/210179010dbc802586d0e12265fba865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9nFnkxl7NJTYbb6CIp95eg.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Brute Force Approach</figcaption></figure><p id="2e95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不幸的是，子图搜索是一个NP完全问题，因为它随着图节点数的增加而导致时间呈指数增长。因此，我们应该使用效率更高的启发式方法。</p><div class="mf mg gp gr mh mi"><a href="https://www.datadriveninvestor.com/2020/05/18/how-could-algorithms-put-individuals-and-communities-in-harms-way/" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd iu gy z fp mn fr fs mo fu fw is bi translated">算法是如何将个人和社区置于危险之中的？数据驱动的投资者</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">尽管数学方程看起来遥远而冷漠，但它们通常也与可靠的硬科学联系在一起…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw lw mi"/></div></div></a></div><h2 id="2310" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">回溯法</h2><p id="c3f8" class="pw-post-body-paragraph jq jr it js b jt nj jv jw jx nk jz ka kb nl kd ke kf nm kh ki kj nn kl km kn im bi translated">它基于一个连接表，我们需要为一个查询结构和数据库分子准备好每个连接表。启发式算法是回溯法，它缩小了子图同构问题的搜索空间。</p><ol class=""><li id="6d18" class="no np it js b jt ju jx jy kb nq kf nr kj ns kn nt nu nv nw bi translated"><strong class="js iu">初始化</strong></li></ol><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nx"><img src="../Images/299f74c8353ba33dce6521523d4a81a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*02dlRW7s6Bk40fgeSQUM9g.png"/></div></div></figure><p id="a116" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在查询中任意选择起始原子，通常选择杂原子，因为它出现的频率比碳低。然后，我们将选择的原子与数据库化合物进行匹配。</p><p id="d401" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 2。递归/回溯</strong></p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ny"><img src="../Images/f215338a20425cec2ab126ba8bcf616f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gZ6O9x2RlvcZZtCxVDMWJA.png"/></div></div></figure><p id="f4cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们通过连接表搜索邻近的原子。如果我们在搜索过程中遇到不同的原子，它使用回溯试探法，返回到上一步并搜索其他分支。如果没有选择，那么我们改变起点。综上所述，原子A和原子b被认为是匹配的，当且仅当对于分子A中的每个元素，在分子b中存在匹配，如果条件不匹配，那么它使用回溯。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nz"><img src="../Images/7e80602d774e2c2e40c5123322a24d40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cTxIRLzc6qagjRbOVTbQGg.png"/></div></div></figure><p id="3d1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个完整的算法。</p><p id="795d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3。终止</strong></p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi oa"><img src="../Images/d5aa5259447df1d9a533778d5d5d27ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rzUZBdzIi-wohJBb2A3qtQ.png"/></div></div></figure><p id="ee36" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它以完全匹配或失败报告终止算法。</p><h2 id="7558" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">乌尔曼算法</h2><p id="43fe" class="pw-post-body-paragraph jq jr it js b jt nj jv jw jx nk jz ka kb nl kd ke kf nm kh ki kj nn kl km kn im bi translated">这种算法是基于邻接矩阵的，我们需要每个化合物都有邻接矩阵。该算法通过构造匹配矩阵来搜索子结构。它从匹配矩阵中识别查询结构到数据库复合的映射。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ob"><img src="../Images/3e9c13dc48f60d24dd0c061d826ba416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xne91CG9B39VcSFpSS-mxA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Adjacency Matrix</figcaption></figure><p id="2302" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是邻接矩阵。行和列对应于原子。如果它们彼此相连，那么矩阵中的相应位置被设置为1否则为0。因此，邻接矩阵总是对称的。</p><p id="cc9a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它建立匹配矩阵，这是邻接矩阵。它的行和列将分别是查询复合节点和数据库复合节点。因此，我们可以搜索子结构。目标匹配矩阵是每行恰好有一个“1”，每列最多有一个“1”。当满足此条件时，数据库组合完全包含查询组合。</p><p id="9cd9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它也使用试探法。它考虑本地信息。查询中的原子不允许与数据库复合中的原子匹配，除非每个邻居也匹配。这是邻接矩阵中回溯的新版本。</p><ol class=""><li id="1058" class="no np it js b jt ju jx jy kb nq kf nr kj ns kn nt nu nv nw bi translated"><strong class="js iu">初始化</strong></li></ol><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi oc"><img src="../Images/ed419b8f545e9f25efe7ea28e885307e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qLlEOjw4b-rPvgXMxKHDOw.png"/></div></div></figure><p id="4911" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个原子对应于查询复合中的第一行。它在数据库化合物中找到第一个可能的匹配。我们将相应的匹配矩阵位置更改为1。</p><p id="3dfb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 2。启发式/细化</strong></p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi od"><img src="../Images/c62163c921e0c658764c9fc0b2992731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HSCbtmZ_LLj9UyAXGSXgZg.png"/></div></div></figure><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi oe"><img src="../Images/930c58f008c1dda75a621213fa594f01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hVfb_BgxDO2YfU8b9bGF7w.png"/></div></div></figure><p id="b758" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它显示了过程和回溯。查询组合中的3个位置与数据库组合中的3个位置不匹配。因此，它回到另一个分支。但是，我们不能匹配这个，因为S中3的邻居是2，M中4的邻居是3。因此，我们需要匹配S中的2和M中的3，但事实并非如此。我们进一步追溯。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi oc"><img src="../Images/071de0d84322f3869b3511452b52cee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mqIwCia6Jc7jCy9pWrPjNw.png"/></div></div></figure><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi of"><img src="../Images/feae706348877235a9c0166e1aa82046.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GE_lpXDLlU8wP4E73LHhoA.png"/></div></div></figure><p id="11e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在S中选择2，在M中选择1，然后我们返回，在S中选择2，在M中选择3，我们可以用新路径完成算法。</p><p id="e870" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3。终止</strong></p><p id="be75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它循环进行，直到找到完全匹配或者所有可能的匹配矩阵都被测试失败。</p><h2 id="ed8f" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">计算机科学硕士</h2><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi og"><img src="../Images/54b64b94b644d7de8e201bb7588be66b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mETKxcZ8kA0QjAlrxGpGFQ.png"/></div></div></figure><p id="a9a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们要做的是找到包含查询复合的复合。现在，我们将查询改为查找两个化合物之间的MCS。MCS是由两种结构共享的最大的一组原子。</p><p id="6659" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这也是一个NP完全问题。因此，我们需要启发式来解决这个问题。</p><h2 id="84e6" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">麦格雷戈算法</h2><ol class=""><li id="d9e3" class="no np it js b jt nj jx nk kb oh kf oi kj oj kn nt nu nv nw bi translated"><strong class="js iu">初始化</strong></li></ol><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ok"><img src="../Images/9f646e2239de57b69af0eb1689ef9505.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hfyaAHaIQeYsENU03Vm8Hg.png"/></div></div></figure><p id="cc61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们构建MCS图，如果它找到比前一个更大的，我们就更新MCS图。起点可以在任何地方。</p><p id="d2ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 2。递归/回溯</strong></p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ol"><img src="../Images/a17b06ba592375eb073a18515e9d232c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZEnk4jtNTGjl_EU_FPH0mw.png"/></div></div></figure><p id="2161" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">递归部分与回溯方法相同。</p><p id="4b3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3。终止</strong></p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi om"><img src="../Images/a6c5d1ce03d8845d843094d87e01af1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FpkF7GTksxogkH95fyPbYQ.png"/></div></div></figure><p id="69e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当一个给定的结构完全包含在另一个结构中，并且探索了所有回溯路径时，它终止。它返回当前存储的MCS。</p><p id="db26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">这篇文章发表于2020年9月29日</strong></p><h2 id="319d" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">访问专家视图— <a class="ae on" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank">订阅DDI英特尔</a></h2></div></div>    
</body>
</html>