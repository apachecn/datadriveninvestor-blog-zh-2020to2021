<html>
<head>
<title>Basic Mistakes of Writing Getters/Setters in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Java编写getter/setter的基本错误</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/basic-mistakes-of-writing-getters-setters-in-java-d5b0d1ce71b2?source=collection_archive---------2-----------------------#2020-04-14">https://medium.datadriveninvestor.com/basic-mistakes-of-writing-getters-setters-in-java-d5b0d1ce71b2?source=collection_archive---------2-----------------------#2020-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5482" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇博客最初发表在我的博客@linqz.io <a class="ae kl" href="https://www.linqz.io/2019/04/basic-mistakes-of-writing-getters-setters-in-java.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/d3fe083a39a9be7bed2c9da68d34254a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u4Xnb6ugB1sMMmDzHJH4Tg.jpeg"/></div></div></figure><p id="9bac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，看完标题，首先想到的是“<strong class="jp ir">Java中有Getter/Setter的指导方针吗？</strong>”。</p><p id="c2ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">答案是“<strong class="jp ir">不，没有</strong>，这个博客条目是我在过去10年的编码过程中犯下的错误(或者很多时候人们称之为“体验”:D)”。</p><p id="7178" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以让我们开始吧，我不会深入到面向对象编程的什么、为什么、如何等等的细节，以及getter/setter适合在哪里，但是如果你谷歌一下，你会找到关于这些主题的详细解释。</p><h2 id="b277" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">错误1:是<strong class="ak">将对象引用直接</strong>分配到业务对象的S <strong class="ak">信中。</strong></h2><p id="95ca" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">例如:考虑一个Employee类，它有一个包含employeeIds的int[]数组，并为其编码了一个默认的setter。假设下面的代码是用某种方法编写的:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="e20d" class="ky kz iq lx b gy mb mc l md me">.....Some business code...<br/>.....Some business code...</span><span id="e174" class="ky kz iq lx b gy mf mc l md me">int[] employeeIds= {5001, 5002, 4002, 3002, 2004, 9874};</span><span id="fc23" class="ky kz iq lx b gy mf mc l md me">employeeObj.setEmployeeIds(employeeIds);<br/>.....<br/><strong class="lx ir">employeeIds[1] = 1; // setting the value 1 resets the value of employeeObj</strong> <strong class="lx ir">employeeIds array index 1’s value from 5002 to 1.</strong><br/>.....</span></pre><p id="43fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我总是建议像下面这样编写setter:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="c07a" class="ky kz iq lx b gy mb mc l md me">public void setEmployeeIds(int[] ids) <br/>{<br/>  <strong class="lx ir">this.employeeIds = new int[ids.length];<br/>  System.arraycopy(ids, 0, this.employeeIds, 0, ids.length);</strong><br/>}</span></pre><h2 id="4c37" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">错误2:对于业务对象，直接从G <strong class="ak">返回对象引用</strong>更好。</h2><p id="79f4" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">假设在业务逻辑的某个地方，代码如下:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="003e" class="ky kz iq lx b gy mb mc l md me">.....Some business code...<br/>// lets say employee Obj has these Ids= {5001, 6002, 4002, 3002};<br/>.....Some business code...</span><span id="31b4" class="ky kz iq lx b gy mf mc l md me"><strong class="lx ir">int[] employeeIds= employeeObj.getEmployeeIds();</strong><br/>.....<br/><strong class="lx ir">employeeIds[1] = 891; // setting the value 1 resets the value of employeeIds array index 1’s value from 6002 to 891.</strong><br/>.....</span></pre><p id="16df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，要解决上述问题，我建议编写如下的getter:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="98cb" class="ky kz iq lx b gy mb mc l md me">public int[] getEmployeeIds() <br/>{<br/>  <strong class="lx ir">int len = this.employeeIds.length;<br/></strong>  <strong class="lx ir">int[] copyIds = new int[len];<br/>  System.arraycopy(this.employeeIds, 0, copyIds, 0, len);<br/>  return copyIds;</strong> <br/>}</span></pre><h2 id="992e" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">第三个错误。为可变Java数据类型编写<strong class="ak"> Getter/Setter，例如java.util. <strong class="ak"> Date。</strong>或<strong class="ak">日历等。</strong></strong></h2><p id="8b11" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">Java有一些<strong class="jp ir">可变的</strong>数据类型，如日期、日历等，如果任何一个使用get方法或使用reference方法重置该值，这在调试时会成为一个巨大的可维护性问题(使用方法引用进行搜索可能会变成一个非常棘手的任务)。</p><div class="mg mh gp gr mi mj"><a href="https://www.datadriveninvestor.com/2020/01/16/software-development-process-how-to-pick-the-right-process/" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd ir gy z fp mo fr fs mp fu fw ip bi translated">软件开发过程:如何选择正确的过程？数据驱动的投资者</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">软件是任何企业组织成功的生命线。没有软件的帮助，一个…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx kw mj"/></div></div></a></div><p id="82ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我总是建议总是使用防御性副本(即深度克隆)来编写getter和setter。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="ecfc" class="ky kz iq lx b gy mb mc l md me">public void <strong class="lx ir">setDateOfJoining</strong>(Date date) <br/>{<br/>  <strong class="lx ir">this.dateOfJoining = (Date) date.clone();</strong><br/>}</span><span id="6ab9" class="ky kz iq lx b gy mf mc l md me">public Date <strong class="lx ir">getDateOfJoining</strong>() <br/>{<br/>  <strong class="lx ir">return (Date) this.dateOfJoining.clone();</strong><br/>}</span></pre><h2 id="1043" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">错误4: <strong class="ak">业务对象集合的Getter/Setter。</strong></h2><p id="4e81" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">第三个错误指出了java可变数据类型的克隆，这也适用于可变业务对象或可变对象集合。</p><p id="bf6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设每个雇员都参与多个项目，那么在每个employee对象中，我们保存一个项目列表，记住上面的内容，总是返回一个副本，我们编写getter/setter如下:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="4c21" class="ky kz iq lx b gy mb mc l md me">private List&lt;Project&gt; projectList;</span><span id="3950" class="ky kz iq lx b gy mf mc l md me">public void setProjectList(List&lt;Project&gt; list)<br/>{<br/>  this.projectList = new ArrayList&lt;Project&gt;(list);<br/>}</span><span id="272f" class="ky kz iq lx b gy mf mc l md me">public List&lt;Project&gt; getProjectList()<br/>{<br/>  return new ArrayList&lt;Project&gt;(this.projectList);<br/>}</span></pre><p id="5955" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是有一个缺陷可以暴露如下:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="0321" class="ky kz iq lx b gy mb mc l md me">...In some business method...<br/>...some business Code ...</span><span id="8b7e" class="ky kz iq lx b gy mf mc l md me"><strong class="lx ir">List&lt;Project&gt; list1 = new ArrayList&lt;&gt;();<br/>list1.add(new Project("Government Project 1"));<br/>list1.add(new Project("Internal Project #20"));<br/>list1.add(new Project("Self Project #12"));</strong></span><span id="5663" class="ky kz iq lx b gy mf mc l md me">employeeObj.setProjectList(list1);<br/><br/><strong class="lx ir">list1.get(2).setProjectName("Dummy Wrong Project"); // This line sets wrong project name since new collection is pointing to same Project object.</strong></span></pre><p id="3697" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，为了避免上述错误，请始终使用深度克隆来实现克隆方法，如下所示:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="533a" class="ky kz iq lx b gy mb mc l md me">public Object clone() <br/>{<br/>  <strong class="lx ir">Project cloneProject = new Project(this.projectName);<br/>  ....<br/>  ....</strong></span><span id="fb82" class="ky kz iq lx b gy mf mc l md me"><strong class="lx ir">  return cloneProject;</strong><br/>}</span></pre><p id="61ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在员工课堂上</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="be61" class="ky kz iq lx b gy mb mc l md me">public void setProjectList(List&lt;Project&gt; list) <br/>{<br/>  for (Project project: list) <br/>  {<br/>    this.projectList.add(<strong class="lx ir">(Project) project.clone()</strong>);<br/>  }<br/>}</span><span id="15a7" class="ky kz iq lx b gy mf mc l md me">public List&lt;Project&gt; getProjectList() <br/>{<br/>  List&lt;Project&gt; listReturn = new ArrayList&lt;&gt;();<br/>  for (Project project: this.projectList) <br/>  {<br/>    listReturn.add(<strong class="lx ir">(Project) project.clone()</strong>);<br/>  }<br/>  return listReturn;<br/>}</span></pre><h2 id="d804" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">错误5 : Getter/Setter是私有作用域所必需的，如果是为公共作用域变量提供的话，它们几乎是无用的。</h2><p id="77de" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">这是不言自明的，这种错误很少发生，但需要小心。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="1de3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你喜欢这个博客内容，请考虑买一杯咖啡。谢谢大家的支持！</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><a href="http://buymeacoff.ee/cyby0109"><div class="gh gi nf"><img src="../Images/7b3b86e7b1337900b3557fda835b6ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/0*YncPlO1V7GfQmErB.png"/></div></a></figure><p id="ef0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有问题吗？建议？评论？</p><p id="e60e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是什么？<a class="ae kl" href="https://medium.com/@vaibhav0109" rel="noopener"> <strong class="jp ir">在Medium上关注我</strong> </a>成为第一个阅读我的故事的人。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div></div>    
</body>
</html>