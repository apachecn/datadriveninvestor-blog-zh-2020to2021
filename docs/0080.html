<html>
<head>
<title>The Median of two sorted arrays — Fundamental Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">两个排序数组的中间值—基本算法</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/the-median-of-two-sorted-arrays-fundamental-algorithms-e4f50ef0c097?source=collection_archive---------3-----------------------#2020-01-08">https://medium.datadriveninvestor.com/the-median-of-two-sorted-arrays-fundamental-algorithms-e4f50ef0c097?source=collection_archive---------3-----------------------#2020-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ced9d839adb57f12f062522ddfd840e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NOgxL38BRuzVLglB"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@danielkcheung?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Daniel Cheung</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8289" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一名算法爱好者，我遇到了这个问题，并认为写下这个问题背后的直觉可能会很有趣。我认为，在解决问题时，培养直觉比仅仅练习一大堆问题更重要。所以我真的希望这对像我一样的人们有所帮助。</p><div class="lb lc gp gr ld le"><a href="https://www.datadriveninvestor.com/2019/03/22/the-seductive-business-logic-of-algorithms/" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">算法诱人的商业逻辑|数据驱动的投资者</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">某些机器行为总是让我感到惊讶。我对他们从自己的成就中学习的能力感到惊讶…</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls jw le"/></div></div></a></div><p id="ee6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个问题有<strong class="kf ir"> <em class="lt">两个不变量</em> </strong>来求中位数:</p><ol class=""><li id="009c" class="lu lv iq kf b kg kh kk kl ko lw ks lx kw ly la lz ma mb mc bi translated">排序后的<strong class="kf ir">数组大小相同</strong></li><li id="ac27" class="lu lv iq kf b kg md kk me ko mf ks mg kw mh la lz ma mb mc bi translated">不同大小的<strong class="kf ir">排序数组</strong></li></ol><p id="f135" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将试图涵盖这两个问题的直觉。尽管两者的方法不同，但直觉是相同的。</p><h1 id="a64a" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">基本知识:</h1><p id="f2c8" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">我们先来了解一下<strong class="kf ir"> <em class="lt">中位数</em> </strong>的概念。</p><blockquote class="nl"><p id="b7f5" class="nm nn iq bd no np nq nr ns nt nu la dk translated">中位只是一种花哨的说法，<strong class="ak"> <em class="nv">中间元素</em> </strong> <em class="nv">。</em></p></blockquote><p id="aacf" class="pw-post-body-paragraph kd ke iq kf b kg nw ki kj kk nx km kn ko ny kq kr ks nz ku kv kw oa ky kz la ij bi translated">因此，给定数组中的一组数字，你的工作是找出哪个数字位于中间。例如，假设给我们一个奇数长度的数组:</p><p id="7eba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lt">奇数长度排列</em> = [ 1，2，5，7，8 ]</p><p id="d841" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种情况下的中间元素很简单！现在是5点。两个元素在它的左边，两个在它的右边。完美！</p><p id="32d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是在偶数长度数组的情况下。</p><p id="1244" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">偶数长度排列 = [1，2，5，7，8，10]</p><p id="7971" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们取中间的两个元素，5和7，取它们的平均值。</p><p id="829d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以中间元素是(5 + 7 )/ 2 = 6</p><p id="3729" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">够简单吗？好了，现在是起飞的时候了！</p><h1 id="08e1" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">两个排序数组的中间值——一种简单的方法</h1><p id="7141" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">我们可以将两个数组合并成一个大数组，然后像上面一样计算中值。</p><p id="99c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">arr1 = [2，4，6]</p><p id="f714" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">arr2 = [3，5，10]</p><p id="7c82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lt">合并_数组</em> </strong> = [2，3，4，5，6，10]</p><p id="0241" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，中间值= 4.5</p><blockquote class="ob oc od"><p id="9d53" class="kd ke lt kf b kg kh ki kj kk kl km kn oe kp kq kr of kt ku kv og kx ky kz la ij bi translated">从现在开始，每当我提到merged_array，这就是我要说的</p></blockquote><p id="8f03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，在合并排序中使用merge合并两个数组所花费的时间:<strong class="kf ir"><em class="lt">【O(m+n)】</em></strong>其中m和n是数组的长度。有点线性时间。</p><p id="16f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这还不错，但是我们没有利用两个数组都排序的事实。</p><blockquote class="ob oc od"><p id="d14d" class="kd ke lt kf b kg kh ki kj kk kl km kn oe kp kq kr of kt ku kv og kx ky kz la ij bi translated">如果有<strong class="kf ir">排序</strong>，那就一定会有<strong class="kf ir">二分搜索法</strong>。</p><p id="0041" class="kd ke lt kf b kg kh ki kj kk kl km kn oe kp kq kr of kt ku kv og kx ky kz la ij bi translated">-不要引用</p></blockquote><p id="f153" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们使用二分搜索法，看看我们能否将时间复杂度降低到对数。真正的交易！</p><h1 id="b8a8" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">两个大小相同的排序数组的中值:</h1><figure class="oh oi oj ok gt jr"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="bf0b" class="on mj iq bd mk oo op dn mo oq or dp ms ko os ot mw ks ou ov na kw ow ox ne oy bi translated">算法:</h2><ol class=""><li id="7bde" class="lu lv iq kf b kg ng kk nh ko oz ks pa kw pb la lz ma mb mc bi translated">求两个数组a1和a2的中间值。让我们称它们为m1和m2。</li><li id="4ea9" class="lu lv iq kf b kg md kk me ko mf ks mg kw mh la lz ma mb mc bi translated">现在比较这两个中间值</li><li id="dc25" class="lu lv iq kf b kg md kk me ko mf ks mg kw mh la lz ma mb mc bi translated">如果m1 == m2，意味着我们正好在合并数组的中间。</li><li id="693a" class="lu lv iq kf b kg md kk me ko mf ks mg kw mh la lz ma mb mc bi translated">否则，如果m1 &gt; m2:</li></ol><p id="12a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lt">现在想到的是merged_array。中位数不可能在m1(更大的范围)之后。由于m1大于m2，因此中位数也不可能位于m2之前(较小的范围)。</em>T3】</strong></p><h2 id="a17f" class="on mj iq bd mk oo op dn mo oq or dp ms ko os ot mw ks ou ov na kw ow ox ne oy bi translated"><strong class="ak"> <em class="nv">消除这些不必要的范围，并使用递归方法继续寻找剩余数字中的中值。</em> </strong></h2><p id="88c0" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">5.否则:(m2 &gt; m1)</p><p id="ee9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与上一点的逻辑正好相反</p><p id="0126" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">6.继续步骤1-5，直到每个数组中只剩下两个元素或一个元素。</p><p id="0282" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">7.然后使用以下公式找到这些元素的中值:(基本情况)</p><p id="9cd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果每个数组中还有2个元素，那么median= <strong class="kf ir"> <em class="lt"> avg(max(两个数组的前两个)+ min(数组的后两个))</em> </strong></p><p id="c525" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果每个数组中有1个元素，那么median =<strong class="kf ir"><em class="lt">(arr 1 _ num+arr 2 _ num)/2</em></strong></p><p id="1a2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lt">这个公式的直觉同样来自对偶数长度的合并数组的中值的思考。</em>T19】</strong></p><figure class="oh oi oj ok gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pc"><img src="../Images/a86f11fe01a672d721762a1110d8c716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3F7Q2sj3QQw13TEGijmB-w.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Example with two sorted arrays of odd lengths</figcaption></figure><p id="f890" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些可供参考的代码:</p><figure class="oh oi oj ok gt jr"><div class="bz fp l di"><div class="pd om l"/></div></figure><h2 id="a825" class="on mj iq bd mk oo op dn mo oq or dp ms ko os ot mw ks ou ov na kw ow ox ne oy bi translated">要记住的注意事项(最好在自己编码后阅读):</h2><ol class=""><li id="64c6" class="lu lv iq kf b kg ng kk nh ko oz ks pa kw pb la lz ma mb mc bi translated">递归时，记住<strong class="kf ir"> <em class="lt">在数组长度为偶数</em> </strong>时包括每个数组的中间元素，在数组长度为奇数时包括单个中间元素。(<em class="lt">因此代码中的数组切片为+1)</em></li><li id="83d7" class="lu lv iq kf b kg md kk me ko mf ks mg kw mh la lz ma mb mc bi translated">递归时数组长度将始终保持不变，因为实质上我们从每个数组中移除了一半的元素</li><li id="2e40" class="lu lv iq kf b kg md kk me ko mf ks mg kw mh la lz ma mb mc bi translated">由于长度相同，因此时间复杂度为O(log n + log m)或O(log n)。</li><li id="89fd" class="lu lv iq kf b kg md kk me ko mf ks mg kw mh la lz ma mb mc bi translated">这种方法不适用于不同的长度:为什么？因为假设一个数组是奇数，一个是偶数，那么在递归中就没有基本情况。(在基本情况下，不能保证两个数组最终具有相同数量的元素)</li></ol><h2 id="deb6" class="on mj iq bd mk oo op dn mo oq or dp ms ko os ot mw ks ou ov na kw ow ox ne oy bi translated">脚注:</h2><ol class=""><li id="8090" class="lu lv iq kf b kg ng kk nh ko oz ks pa kw pb la lz ma mb mc bi translated">我将在另一篇文章中介绍的<strong class="kf ir">下一种方法</strong>稍微复杂一些，但是<strong class="kf ir">可以用于解决长度相同和长度不同的数组大小</strong>。</li><li id="3e75" class="lu lv iq kf b kg md kk me ko mf ks mg kw mh la lz ma mb mc bi translated">我介绍这种方法的原因是为了深入了解<strong class="kf ir">分而治之</strong>概念的消除过程。</li><li id="74b5" class="lu lv iq kf b kg md kk me ko mf ks mg kw mh la lz ma mb mc bi translated">对这种方法的深入了解将为您带来另一个著名问题:<a class="ae kc" href="https://stackoverflow.com/questions/4607945/how-to-find-the-kth-smallest-element-in-the-union-of-two-sorted-arrays" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">如何在两个有序数组的并集中找到第k个最小元素？</strong> </a></li><li id="242e" class="lu lv iq kf b kg md kk me ko mf ks mg kw mh la lz ma mb mc bi translated">此外，这将为下一步寻找任意大小的排序数组的中值奠定基础。</li></ol><p id="ea24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">暂时就这样了。下一个方法即将到来。我希望写更多关于有趣问题的直觉，并希望这能帮助一些人。感谢阅读伙计们！^_^</p><figure class="oh oi oj ok gt jr"><div class="bz fp l di"><div class="pe om l"/></div></figure></div></div>    
</body>
</html>