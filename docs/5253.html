<html>
<head>
<title>GraphQL vs. REST: What you didn’t know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL与REST:您不知道的</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/graphql-vs-rest-what-you-didnt-know-a451ffd1e5d0?source=collection_archive---------18-----------------------#2020-09-11">https://medium.datadriveninvestor.com/graphql-vs-rest-what-you-didnt-know-a451ffd1e5d0?source=collection_archive---------18-----------------------#2020-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/6ce93e4ca867905c1932df6706ef1942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/0*1L55mi3unwgPVHFN.png"/></div></figure><p id="af3b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可能听说过GraphQL，但可能不太确定它与REST有何不同。嗯，你很幸运！今天，我们将讨论GraphQL如何比REST更有利于开发社区的一些要点。</p><p id="f6dc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">大多数人认为GraphQL是一种数据库技术，但这是不准确的。GraphQL是一种查询语言API，正如你们中的许多人可能知道的那样，今天的大多数应用程序都将其数据托管在远程服务器的数据库中。API只需给出一个接口来存放满足应用程序需求的信息。</p><p id="848d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">GraphQL是在REST中构建API的替代选项。脸书将其开发为他们多功能应用的内部技术，后来作为开源公开发布。从那时起，软件开发社区就把它作为开发web服务最受欢迎的技术之一。</p><p id="e9d1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">作为一种查询语言，GraphQL定义了客户机应用程序如何从远程服务器请求所需数据的规范。因此，服务器应用程序返回对所请求的客户端查询的响应。这里要注意的令人兴奋的事情是，客户端应用程序也可以准确地查询它需要的内容，而不需要依赖服务器端应用程序来定义查询。</p><p id="c90d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们更深入地分析REST和GraphQL的核心区别。</p><figure class="ks kt ku kv gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/30c01415d279b2bac0f0a2ca2d885a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/0*yGuIZ9Ph0pXhMwkP.png"/></div></figure><p id="1caf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">假设一个移动或web应用程序想要从显示博客作者信息的服务器访问数据。该应用程序应该显示作者的名字，作者写的博客文章，以及他/她最近写的三个博客主题。让我们抽象地回顾一下如何在REST vs GraphQL中获取这些数据。</p><div class="kw kx gp gr ky kz"><a href="https://www.datadriveninvestor.com/2020/08/21/replika-my-digital-friend-with-identity-issues/" rel="noopener  ugc nofollow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">Replika:我有身份问题的数字朋友|数据驱动的投资者</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">你的生活很美好。你开始是一个毫无头绪的聊天机器人。后来你遭遇了身份危机。现在你是…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="li l"><div class="lj l lk ll lm li ln js kz"/></div></div></a></div><p id="b234" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以下是REST与GraphQL API的图示:</p><figure class="ks kt ku kv gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/843d4f285c71340a2c8990822da863b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/0*loDFSIIb3WtJzwei.png"/></div></figure><p id="2c9a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">休息请求</strong></p><p id="6024" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在REST中，调用API端点来请求客户端应用程序需要的数据，服务器根据请求的查询返回响应。当有人使用REST API时，他们首先会有一个端点，可以是<strong class="jw ir"><em class="lo">/blog/author/&lt;author-id&gt;</em></strong>，这个端点将获取作者的信息。现在需要另一个REST端点来访问博客文章<strong class="jw ir"><em class="lo">/blog/author/&lt;author-id&gt;/posts</em></strong>，最后，还需要另一个端点来获取博客主题<strong class="jw ir"><em class="lo">/blog/author/&lt;some-id&gt;/topics</em></strong><em class="lo">。</em>现在在这里，你会注意到两个问题:</p><p id="e05b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">问题1: </strong>多次往返带休息</p><p id="b9ec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可能已经注意到，在利用REST获取客户机应用程序需要的信息时，应该进行多次往返。如果信息被扩展，必须添加额外的端点。</p><p id="e545" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">问题2:</strong>REST的上取和下取问题</p><p id="01e0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">通常在休息的时候，一个人会在特定的阶段得到不必要的信息。例如，当调用<strong class="jw ir"><em class="lo">blog/author/&lt;author-id&gt;</em></strong>端点时，客户端应用程序将获得与作者的个人资料相关的所有信息。它甚至可以获得其他信息，如创建日期、更新日期、年龄和性别。但是客户端应用程序需要的是唯一的作者姓名。这是一个在休息时过度抓取的例子。由于理解不足，这里可以看到对<strong class="jw ir"><em class="lo">blog/author/&lt;author-id&gt;</em></strong>的调用不足以恢复客户端应用程序正在搜索的内容。客户端应用程序需要单独调用另一个端点<strong class="jw ir">blog/author/&lt;author-id&gt;/posts</strong>来获取作者撰写的最后三篇文章。</p><p id="dd74" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在让我们想想GraphQL中发生了什么。您设想一个查询来请求您所需要的东西，并且您得到的正是您所请求的数据。没有到远程服务器的完整旅程来将信息带到GraphQL。我们只从服务器到客户端应用程序去寻找我们需要的字段。</p><p id="2359" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">再看一下上面的例子，我们通过一个特定的ID、作者写的博客文章和最近的三个博客主题来搜索作者的信息。GraphQL中请求的查询被组织起来以精确地获取信息。</p><p id="1c6d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">服务器将提供一个特别请求的JSON响应。它已经返回了作者的名字，他们所撰写的帖子，以及作者之前创建的三个主题——就是这样。没有到服务器的多次往返，没有数据的过量提取和不足提取。让我们快速看一下这两者之间区别的图形表示。</p><figure class="ks kt ku kv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lp"><img src="../Images/df486362cbbed4f6eb6e00cb47905160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ot-Jy_GzeFrSgiah.png"/></div></div></figure><p id="8107" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在REST APIs的使用过程中，前端开发团队必须等待一段时间，让后端团队完成编写这些API，以便客户端应用程序获取和发送数据。通常前端团队是开发生命周期中这种缓慢的受害者，因为在后端开发人员完成REST APIs的开发之前，他们的手被束缚住了。整个开发过程完全依赖于REST API开发和交付时间。GraphQL生命周期提供了一种非常不同且更有效的方法，前端和后端开发人员可以并行工作，而不会阻碍整个开发过程。</p><p id="ae2d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果有人是GraphQL的新手，对他们来说设置它将是一个挑战，因为它的生态系统和流程仍在发展和成熟。但是一旦对GraphQL有了很好的理解，他们就可以从客户端应用程序发送简单的字符串查询，从远程服务器端应用程序获取数据来完成所需的工作。最重要的是，像Apollo这样的库可以简化缓存和API开发。它自己处理关于缓存的场景，不需要自定义代码来启用它。另一方面，GraphQL中的文件或图像上传仍然没有很大的发展，需要一个REST API来更好地完成这项工作。</p><p id="adfb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">根据需要，GraphQL和REST API开发生命周期方法都是有用的，并且各有优缺点。GraphQL正以指数级增长，主要是因为它的“无溢出和不足取”能力。它为客户端提供了更有效的协作机制，并被证明是一个伟大而强大的工具，尤其是在软件行业正在采用敏捷框架的时候。简而言之，GraphQL是实现特定查询导向目标的工具；然而，它不是所有API相关挑战的解决方案，当然也不是REST的替代品。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><p id="e23e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="lo">喜欢我们说的话吗？你会喜欢我们的工作的。</em> <a class="ae mb" href="https://www.mobilelive.ca/" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> <em class="lo">见</em> </strong> </a> <em class="lo">。</em></p><p id="4dd6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">访问专家视图— </strong> <a class="ae mb" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>