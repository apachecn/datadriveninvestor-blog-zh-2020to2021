<html>
<head>
<title>Coding Specifications | Elegant Java Functions (Part Two)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码规范|优雅的Java函数(第二部分)</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/coding-specifications-elegant-java-functions-part-two-3a1e6e240707?source=collection_archive---------19-----------------------#2020-06-30">https://medium.datadriveninvestor.com/coding-specifications-elegant-java-functions-part-two-3a1e6e240707?source=collection_archive---------19-----------------------#2020-06-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/9ddfcaecc404e7a4f2a8134dbc094db7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*4jDoIrsKjkmhcZmh.jpeg"/></div></figure><p id="99a3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">由</em> <a class="ae kt" href="https://community.alibabacloud.com/users/5241164025409916" rel="noopener ugc nofollow" target="_blank"> <em class="ks"> Amap_tech团队</em> </a> <em class="ks">。</em></p><h1 id="d1f0" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">背景</h1><p id="63b4" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">本文描述了一组与Java函数相关的编码规则，旨在为Java程序员提供一些编码建议，帮助他们编写出更优雅、更高质量、更高效的代码。</p><p id="3c14" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">参考此<a class="ae kt" href="https://www.alibabacloud.com/blog/coding-specifications-%7C-elegant-java-functions-part-one_596181" rel="noopener ugc nofollow" target="_blank">链接</a>查看本文的第一部分。</p><h1 id="3842" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">使用内部函数参数的基本类型</h1><h2 id="2c92" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">案例1)尽可能使用内部函数参数的基本类型</h2><p id="9f35" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">以下代码片段显示了症状描述。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="8901" class="lx kv iq mo b gy ms mt l mu mv">// 调用代码<br/>double price = 5.1D;<br/>int number = 9;<br/>double total = calculate(price, number);</span><span id="124b" class="lx kv iq mo b gy mw mt l mu mv">// 计算金额函数<br/>private double calculate(Double price, Integer number) {<br/>    return price * number;<br/>}</span></pre><p id="541c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请参考以下推荐的解决方案。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="7706" class="lx kv iq mo b gy ms mt l mu mv">// 调用代码<br/>double price = 5.1D;<br/>int number = 9;<br/>double total = calculate(price, number);</span><span id="d77f" class="lx kv iq mo b gy mw mt l mu mv">// 计算金额函数<br/>private double calculate(double price, int number) {<br/>    return price * number;<br/>}</span></pre><h2 id="f822" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">情况2)尽可能对内部函数的返回值使用基本类型</h2><p id="bdc9" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">以下代码片段显示了症状描述。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="d9d1" class="lx kv iq mo b gy ms mt l mu mv">// 获取订单总额函数<br/>public double getOrderAmount(List&lt;Product&gt; productList) {<br/>    double amount = 0.0D;<br/>    for (Product product : productList) {<br/>        if (Objects.isNull(product) || Objects.isNull(product.getPrice())<br/>            || Objects.isNull(product.getNumber())) {<br/>            continue;<br/>        }<br/>        amount += calculate(product.getPrice(), product.getNumber());<br/>    }<br/>    return amount;<br/>}</span><span id="135c" class="lx kv iq mo b gy mw mt l mu mv">// 计算金额函数<br/>private Double calculate(double price, double number) {<br/>    return price * number;<br/>}</span></pre><p id="48fa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请参考以下推荐的解决方案。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="f34b" class="lx kv iq mo b gy ms mt l mu mv">// 获取订单总额函数<br/>public double getOrderAmount(List&lt;Product&gt; productList) {<br/>    double amount = 0.0D;<br/>    for (Product product : productList) {<br/>        if (Objects.isNull(product) || Objects.isNull(product.getPrice())<br/>            || Objects.isNull(product.getNumber())) {<br/>            continue;<br/>        }<br/>        amount += calculate(product.getPrice(), product.getNumber());<br/>    }<br/>    return amount;<br/>}</span><span id="ac89" class="lx kv iq mo b gy mw mt l mu mv">// 计算金额函数<br/>private double calculate(double price, double number) {<br/>    return price * number;<br/>}</span></pre><p id="5e82" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该示例仅用于说明目的。在这种情况下，最好使用流编程。</p><div class="mx my gp gr mz na"><a href="https://www.datadriveninvestor.com/2019/01/15/the-path-of-mobile-app-development-in-2019/" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd ir gy z fp nf fr fs ng fu fw ip bi translated">2019年移动应用开发之路|数据驱动的投资者</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">任何在移动应用程序开发行业工作的人，无论他们是专注于在伦敦开发iOS应用程序还是…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no js na"/></div></div></a></div><h2 id="1888" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">利益</h2><ul class=""><li id="c3ae" class="np nq iq jw b jx ls kb lt kf nr kj ns kn nt kr nu nv nw nx bi translated">尽可能使用内部函数的基本类型，以避免打包和解包隐式封装类型。</li><li id="9576" class="np nq iq jw b jx ny kb nz kf oa kj ob kn oc kr nu nv nw nx bi translated">当基本类型用于内部函数参数时，这在语法上避免了对这些参数的空指针判断。</li><li id="973a" class="np nq iq jw b jx ny kb nz kf oa kj ob kn oc kr nu nv nw nx bi translated">当基本类型用于内部函数的返回值时，这在语法上避免了调用函数时对返回值的空指针判断。</li></ul><h1 id="068e" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">避免返回空数组和列表</h1><h2 id="a284" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">情况1)尽可能避免空数组的返回，以避免不必要的空指针判断</h2><p id="10ce" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">以下代码片段显示了症状描述。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="e6b8" class="lx kv iq mo b gy ms mt l mu mv">// 调用代码<br/>UserVO[] users = queryUser();<br/>if (Objects.nonNull(users)) {<br/>    for (UserVO user : users) {<br/>        // 处理用户信息<br/>    }<br/>}</span><span id="d8a9" class="lx kv iq mo b gy mw mt l mu mv">// 查询用户函数<br/>private UserVO[] queryUser() {<br/>    // 查询用户列表<br/>    List&lt;UserDO&gt; userList = userDAO.queryAll();<br/>    if (CollectionUtils.isEmpty(userList)) {<br/>        return null;<br/>    }</span><span id="80c2" class="lx kv iq mo b gy mw mt l mu mv">    // 转化用户数组<br/>    UserVO[] users = new UserVO[userList.size()];<br/>    for (int i = 0; i &lt; userList.size(); i++) {<br/>        UserDO user = userList.get(i);<br/>        users[i] = new UserVO();<br/>        users[i].setId(user.getId());<br/>        users[i].setName(user.getName());<br/>    }</span><span id="3c70" class="lx kv iq mo b gy mw mt l mu mv">    // 返回用户数组<br/>    return users;<br/>}</span></pre><p id="51c4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请参考以下推荐的解决方案。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="b54c" class="lx kv iq mo b gy ms mt l mu mv">// 调用代码<br/>UserVO[] users = queryUser();<br/>for (UserVO user : users) {<br/>    // 处理用户信息<br/>}</span><span id="4793" class="lx kv iq mo b gy mw mt l mu mv">// 查询用户函数<br/>private UserVO[] queryUser() {<br/>    // 查询用户列表<br/>    List&lt;UserDO&gt; userList = userDAO.queryAll();<br/>    if (CollectionUtils.isEmpty(userList)) {<br/>        return new UserVO[0];<br/>    }</span><span id="1f45" class="lx kv iq mo b gy mw mt l mu mv">    // 转化用户数组<br/>    UserVO[] users = new UserVO[userList.size()];<br/>    for (int i = 0; i &lt; userList.size(); i++) {<br/>        UserDO user = userList.get(i);<br/>        users[i] = new UserVO();<br/>        users[i].setId(user.getId());<br/>        users[i].setName(user.getName());<br/>    }</span><span id="6a95" class="lx kv iq mo b gy mw mt l mu mv">    // 返回用户数组<br/>    return users;<br/>}</span></pre><h2 id="0b58" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">情况2)尽可能避免空列表的返回，以避免不必要的空指针判断</h2><p id="ad68" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">以下代码片段显示了症状描述。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="2ec8" class="lx kv iq mo b gy ms mt l mu mv">// 调用代码<br/>List&lt;UserVO&gt; userList = queryUser();<br/>if (Objects.nonNull(userList)) {<br/>    for (UserVO user : userList) {<br/>        // 处理用户信息<br/>    }<br/>}</span><span id="c29e" class="lx kv iq mo b gy mw mt l mu mv">// 查询用户函数<br/>private List&lt;UserVO&gt; queryUser(){<br/>    // 查询用户列表<br/>    List&lt;UserDO&gt; userList = userDAO.queryAll();<br/>    if(CollectionUtils.isEmpty(userList)) {<br/>        return null;<br/>    }</span><span id="5265" class="lx kv iq mo b gy mw mt l mu mv">    // 转化用户列表<br/>    List&lt;UserVO&gt; userVoList = new ArrayList&lt;&gt;(userList.size());<br/>    for(UserDO user : userList) {<br/>        UserVO userVo = new UserVO();<br/>        userVo.setId(user.getId());<br/>        userVo.setName(user.getName());<br/>        userVoList.add(userVo);<br/>    }</span><span id="70a2" class="lx kv iq mo b gy mw mt l mu mv">    // 返回用户列表<br/>    return userVoList;<br/>}</span></pre><p id="8171" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请参考以下推荐的解决方案。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="b6e0" class="lx kv iq mo b gy ms mt l mu mv">// 调用代码<br/>List&lt;UserVO&gt; userList = queryUser();<br/>for (UserVO user : userList) {<br/>   // 处理用户信息<br/> }</span><span id="9476" class="lx kv iq mo b gy mw mt l mu mv">// 查询用户函数<br/>private List&lt;UserVO&gt; queryUser(){<br/>    // 查询用户列表<br/>    List&lt;UserDO&gt; userList = userDAO.queryAll();<br/>    if(CollectionUtils.isEmpty(userList)) {<br/>        return Collections.emptyList();<br/>    }</span><span id="3fde" class="lx kv iq mo b gy mw mt l mu mv">    // 转化用户列表<br/>    List&lt;UserVO&gt; userVoList = new ArrayList&lt;&gt;(userList.size());<br/>    for(UserDO user : userList) {<br/>        UserVO userVo = new UserVO();<br/>        userVo.setId(user.getId());<br/>        userVo.setName(user.getName());<br/>        userVoList.add(userVo);<br/>    }</span><span id="82fc" class="lx kv iq mo b gy mw mt l mu mv">    // 返回用户列表<br/>    return userVoList;<br/>}</span></pre><h2 id="a941" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">利益</h2><ul class=""><li id="d5c2" class="np nq iq jw b jx ls kb lt kf nr kj ns kn nt kr nu nv nw nx bi translated">确保返回的数组和列表不为空，以避免空指针判断。</li></ul><h1 id="273b" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">封装函数输入参数</h1><h2 id="1941" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">情况1)当输入太多参数时，应该将它们封装成参数类</h2><p id="53ba" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">Java规范不允许太多的函数参数，这使得函数的维护和扩展变得很困难。</p><p id="1a04" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以下代码片段显示了症状描述。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="e81e" class="lx kv iq mo b gy ms mt l mu mv">// 修改用户函数<br/>public void modifyUser(Long id, String name, String phone, Integer age, <br/>    Integer sex, String address, String description) {<br/>    // 具体实现逻辑<br/>}</span></pre><p id="383a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请参考以下推荐的解决方案。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="dca0" class="lx kv iq mo b gy ms mt l mu mv">// 修改用户函数<br/>public void modifyUser(User user) {<br/>    // 具体实现内容<br/>}</span><span id="1d3f" class="lx kv iq mo b gy mw mt l mu mv">// 用户类<br/>@Getter<br/>@Setter<br/>@ToString<br/>private class User{<br/>    private Long id;<br/>    private String name;<br/>    private String phone;<br/>    private Integer age;<br/>    private Integer sex;<br/>    private String address;<br/>    private String description;<br/>}</span></pre><h1 id="9882" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">将组参数封装为参数类</h1><p id="8415" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">由于参数是成组出现的，所以有必要封装一个类来描述这种情况。</p><p id="d055" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以下代码片段显示了症状描述。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="9253" class="lx kv iq mo b gy ms mt l mu mv">// 获取距离函数<br/>public double getDistance(double x1, double y1, double x2, double y2) {<br/>    // 具体实现逻辑<br/>}</span></pre><p id="6cba" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请参考以下推荐的解决方案。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="ae02" class="lx kv iq mo b gy ms mt l mu mv">// 获取距离函数<br/>public double getDistance(Point point1, Point point2) {<br/>    // 具体实现逻辑<br/>}</span><span id="eb89" class="lx kv iq mo b gy mw mt l mu mv">// 点类<br/>@Getter<br/>@Setter<br/>@ToString<br/>private class Point{<br/>    private double x;<br/>    private double y;<br/>}</span></pre><h2 id="22f5" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">利益</h2><ul class=""><li id="607e" class="np nq iq jw b jx ls kb lt kf nr kj ns kn nt kr nu nv nw nx bi translated">将多个函数参数封装成类，使函数更容易扩展和维护。</li><li id="80a2" class="np nq iq jw b jx ny kb nz kf oa kj ob kn oc kr nu nv nw nx bi translated">将组功能参数封装为类，以阐明业务。</li></ul><h2 id="9981" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">尽可能使用函数实现匿名内部类</h2><p id="def9" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">Java中匿名内部类的优缺点:在匿名内部类(包括Lambda表达式)中，你可能直接访问外部类的成员，包括类的成员变量和函数的内部变量。在这种情况下，由于你随意访问外部变量，代码的边界就不清楚了。</p><p id="5418" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们建议使用Lambda表达式来简化匿名内部类，然后使用函数来实现复杂的Lambda表达式。</p><h2 id="4a0e" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">案例1)尽可能使用函数实现匿名内部类(包括Lambda表达式)</h2><p id="06b1" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">以下代码片段显示了症状描述。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="49f6" class="lx kv iq mo b gy ms mt l mu mv">// 发送结算数据<br/>sendWorkerSettleData(WorkerPushDataType.CHECKER, () -&gt; {<br/>    Date beginDate = DateUtils.addDays(currDate, -aheadDays);<br/>    Date endDate = DateUtils.addDays(currDate, 1);<br/>    return auditTaskDAO.statCheckerSettleData(beginDate, endDate);<br/>});</span></pre><p id="5ba0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请参考以下推荐的解决方案。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="af80" class="lx kv iq mo b gy ms mt l mu mv">// 发送结算数据<br/>sendWorkerSettleData(WorkerPushDataType.CHECKER, () -&gt; statCheckerSettleData(currDate, aheadDays));</span><span id="325f" class="lx kv iq mo b gy mw mt l mu mv">// 统计验收员结算数据函数<br/>private List&lt;WorkerSettleData&gt; statCheckerSettleData(Date currDate, int aheadDays) {<br/>    Date beginDate = DateUtils.addDays(currDate, -aheadDays);<br/>    Date endDate = DateUtils.addDays(currDate, 1);<br/>    return auditTaskDAO.statCheckerSettleData(beginDate, endDate);<br/>}</span></pre><p id="25ac" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">其实还有一个更简单的方法。要在调用<code class="fe od oe of mo b">sendWorkerSettleData</code>函数(将数据发送给操作员进行结算)之前计算开始日期和结束日期，请使用函数<code class="fe od oe of mo b">auditTaskDAO.statCheckerSettleData</code> (beginDate，end date)而不是匿名内部类。</p><h2 id="a703" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">情况2)将复杂的匿名内部类实现API拆分成多个函数类API</h2><p id="007b" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">如果由匿名内部类实现的API的函数相互之间的相关性较低，则将API拆分成几个函数API，以便于使用Lambda表达式。</p><p id="e2c5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以下代码片段显示了症状描述。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="e85e" class="lx kv iq mo b gy ms mt l mu mv">// 清除过期数据<br/>cleanExpiredData("用户日志表", new CleanExpiredDataOperator() {<br/>    @Override<br/>    public List&lt;Date&gt; queryExpiredDate(Integer remainDays) {<br/>        return userDAO.queryExpiredDate(remainDays);<br/>    }<br/>    @Override<br/>    public void cleanExpiredData(Date expiredDate) {<br/>        userDAO.cleanExpiredData(expiredDate);<br/>    }<br/>});</span><span id="7bfe" class="lx kv iq mo b gy mw mt l mu mv">// 清除过期数据函数<br/>private void cleanExpiredData(String tableName, CleanExpiredDataOperator ,<br/>cleanExpiredDataOperator) {<br/>    // 功能实现代码<br/>}</span><span id="b698" class="lx kv iq mo b gy mw mt l mu mv">// 清除过期操作接口<br/>interface CleanExpiredDataOperator {<br/>    // 查询过期日期<br/>    public List&lt;Date&gt; queryExpiredDate(Integer remainDays);<br/>    // 清除过期数据<br/>    public void cleanExpiredData(Date expiredDate);<br/>}</span></pre><p id="51c5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请参考以下推荐的解决方案。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="bf39" class="lx kv iq mo b gy ms mt l mu mv">// 清除过期数据<br/>cleanExpiredData("用户日志表", userDAO::queryExpiredDate,userDAO::cleanExpiredData);</span><span id="d527" class="lx kv iq mo b gy mw mt l mu mv">// 清除过期数据函数<br/>private void cleanExpiredData(String tableName, QueryExpiredDateOperator queryExpiredDateOperator, CleanExpiredDataOperator cleanExpiredDataOperator) {<br/>    // 功能实现代码<br/>}</span><span id="79f6" class="lx kv iq mo b gy mw mt l mu mv">// 查询过期日期接口<br/>interface QueryExpiredDateOperator {<br/>    // 查询过期日期<br/>    public List&lt;Date&gt; queryExpiredDate(Integer remainDays);<br/>}</span><span id="fcbe" class="lx kv iq mo b gy mw mt l mu mv">// 清除过期操作接口<br/>interface CleanExpiredDataOperator {<br/>    // 清除过期数据<br/>    public void cleanExpiredData(Date expiredDate);<br/>}</span></pre><h2 id="be74" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">利益</h2><ul class=""><li id="8b69" class="np nq iq jw b jx ls kb lt kf nr kj ns kn nt kr nu nv nw nx bi translated">定义函数并指定参数，以明确匿名内部类的代码边界。</li><li id="7053" class="np nq iq jw b jx ny kb nz kf oa kj ob kn oc kr nu nv nw nx bi translated">使用Lambda表达式来简化匿名内部类的实现并简化代码。</li></ul><h1 id="3c5b" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">使用return移除不必要的代码</h1><h2 id="9cac" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">案例1)删除不必要的“如果”</h2><p id="3c23" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">以下代码片段显示了症状描述。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="a7a5" class="lx kv iq mo b gy ms mt l mu mv">// 是否通过函数<br/>public boolean isPassed(Double passRate) {<br/>    if (Objects.nonNull(passRate) &amp;&amp; passRate.compareTo(PASS_THRESHOLD) &gt;= 0) {<br/>        return true;<br/>    }<br/>    return false;<br/>}</span></pre><p id="d804" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请参考以下推荐的解决方案。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="9651" class="lx kv iq mo b gy ms mt l mu mv">// 是否通过函数<br/>public boolean isPassed(Double passRate) {<br/>    return Objects.nonNull(passRate) &amp;&amp; passRate.compareTo(PASS_THRESHOLD) &gt;= 0;<br/>}</span></pre><h2 id="3643" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">情况2)删除不必要的“别人的”</h2><p id="b7f4" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">以下代码片段显示了症状描述。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="8618" class="lx kv iq mo b gy ms mt l mu mv">// 结算工资函数<br/>public double settleSalary(Long workId, int workDays) {<br/>    // 根据是否合格处理<br/>    if (isQualified(workId)) {<br/>        return settleQualifiedSalary(workDays);<br/>    } else {<br/>        return settleUnqualifiedSalary(workDays);<br/>    }<br/>}</span></pre><p id="6a11" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请参考以下推荐的解决方案。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="3e69" class="lx kv iq mo b gy ms mt l mu mv">// 结算工资函数<br/>public double settleSalary(Long workId, int workDays) {<br/>    // 根据是否合格处理<br/>    if (isQualified(workId)) {<br/>        return settleQualifiedSalary(workDays);<br/>    }<br/>    return settleUnqualifiedSalary(workDays);<br/>}</span></pre><h2 id="e370" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">情况3)删除不必要的变量</h2><p id="55e0" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">以下代码片段显示了症状描述。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="6c84" class="lx kv iq mo b gy ms mt l mu mv">// 查询用户函数<br/>public List&lt;UserDO&gt; queryUser(Long id, String name) {<br/>    UserQuery userQuery = new UserQuery();<br/>    userQuery.setId(id);<br/>    userQuery.setName(name);<br/>    List&lt;UserDO&gt; userList = userDAO.query(userQuery);<br/>    return userList;<br/>}</span></pre><p id="8858" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请参考以下推荐的解决方案。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="6894" class="lx kv iq mo b gy ms mt l mu mv">// 查询用户函数<br/>public List&lt;UserDO&gt; queryUser(Long id, String name) {<br/>    UserQuery userQuery = new UserQuery();<br/>    userQuery.setId(id);<br/>    userQuery.setName(name);<br/>    return userDAO.query(userQuery);<br/>}</span></pre><h2 id="3bb5" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">利益</h2><ul class=""><li id="a248" class="np nq iq jw b jx ls kb lt kf nr kj ns kn nt kr nu nv nw nx bi translated">删除不必要的代码行，以获得更精简、更方便的代码。</li></ul><h1 id="96e7" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">使用临时变量来优化代码</h1><p id="44e9" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">在一些代码段中，你经常会看到<code class="fe od oe of mo b">a.getB().getC()...getN()</code>语法。这被称为级联函数调用，会导致代码健壮性和可读性较差。我们建议您不要执行级联函数调用。相反，使用临时变量来拆分调用并对对象执行空指针检查。</p><h2 id="a083" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">案例1)使用临时变量来阐明逻辑</h2><p id="24e4" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">以下代码片段显示了症状描述。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="b24d" class="lx kv iq mo b gy ms mt l mu mv">// 是否土豪用户函数<br/>private boolean isRichUser(User user) {<br/>    return Objects.nonNull(user.getAccount())<br/>        &amp;&amp; Objects.nonNull(user.getAccount().getBalance())<br/>        &amp;&amp; user.getAccount().getBalance().compareTo(RICH_THRESHOLD) &gt;= 0;<br/>}</span></pre><p id="d457" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是一种简化代码控制的简单方法，但是可读性很差。</p><p id="8117" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请参考以下推荐的解决方案。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="5e1c" class="lx kv iq mo b gy ms mt l mu mv">// 是否土豪用户函数<br/>private boolean isRichUser(User user) {<br/>    // 获取用户账户<br/>    UserAccount account = user.getAccount();<br/>    if (Objects.isNull(account)) {<br/>        return false;<br/>    }</span><span id="6627" class="lx kv iq mo b gy mw mt l mu mv">    // 获取用户余额<br/>    Double balance = account.getBalance();<br/>    if (Objects.isNull(balance)) {<br/>        return false;<br/>    }</span><span id="8c55" class="lx kv iq mo b gy mw mt l mu mv">    // 比较用户余额<br/>    return balance.compareTo(RICH_THRESHOLD) &gt;= 0;<br/>}</span></pre><p id="9c2c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个解决方案增加了代码行，但是澄清了逻辑。当你发现很难平衡简单性和可读性时，我们建议更多地权衡可读性。</p><h2 id="b7f5" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">情况2)使用临时变量来简化代码</h2><p id="c2c0" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">以下代码片段显示了症状描述。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="87bc" class="lx kv iq mo b gy ms mt l mu mv">// 构建用户函数<br/>public UserVO buildUser(UserDO user) {<br/>    UserVO vo = new UserVO();<br/>    vo.setId(user.getId());<br/>    vo.setName(user.getName());<br/>    if (Objects.nonNull(user.getAccount())) {<br/>        vo.setBalance(user.getAccount().getBalance());<br/>        vo.setDebt(user.getAccount().getDebt());<br/>    }<br/>    return vo;<br/>}</span></pre><p id="bde6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这样写代码是为了减少临时变量。</p><p id="9833" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请参考以下推荐的解决方案。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="6549" class="lx kv iq mo b gy ms mt l mu mv">// 构建用户函数<br/>public UserVO buildUser1(UserDO user) {<br/>    UserVO vo = new UserVO();<br/>    vo.setId(user.getId());<br/>    vo.setName(user.getName());<br/>    UserAccount account = user.getAccount();<br/>    if (Objects.nonNull(account)) {<br/>        vo.setBalance(account.getBalance());<br/>        vo.setDebt(account.getDebt());<br/>    }<br/>    return vo;<br/>}</span></pre><h2 id="8f58" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">利益</h2><ul class=""><li id="1719" class="np nq iq jw b jx ls kb lt kf nr kj ns kn nt kr nu nv nw nx bi translated">使用临时变量来阐明业务逻辑。</li><li id="4d82" class="np nq iq jw b jx ny kb nz kf oa kj ob kn oc kr nu nv nw nx bi translated">使用临时变量来简化代码。变量名表明了它的用途，避免了大量无用的代码。</li><li id="83f9" class="np nq iq jw b jx ny kb nz kf oa kj ob kn oc kr nu nv nw nx bi translated">如果检索函数很复杂很耗时，使用临时变量来提高运行效率。</li><li id="3e7a" class="np nq iq jw b jx ny kb nz kf oa kj ob kn oc kr nu nv nw nx bi translated">使用临时变量来避免级联函数调用，并防止空指针异常。</li></ul><h1 id="f59f" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">仅保留函数所需的参数</h1><p id="8a88" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">在一些代码段中，你经常会看到<code class="fe od oe of mo b">a.getB().getC()...getN()</code>语法。这被称为级联函数调用，会导致代码健壮性和可读性较差。我们建议您不要执行级联函数调用。相反，使用临时变量来拆分调用并对对象执行空指针检查。</p><h2 id="9018" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">情况1)删除冗余参数</h2><p id="aae7" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">以下代码片段显示了症状描述。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="4594" class="lx kv iq mo b gy ms mt l mu mv">// 修改用户状态函数<br/>private void modifyUserStatus(Long userId, Integer status, String unused) {<br/>    userCache.modifyStatus(userId, status);<br/>    userDAO.modifyStatus(userId, status);<br/>}<br/>其中，unused参数是无用参数。</span><span id="b392" class="lx kv iq mo b gy mw mt l mu mv">建议方案：</span><span id="837d" class="lx kv iq mo b gy mw mt l mu mv">// 修改用户状态函数<br/>private void modifyUserStatus(Long userId, Integer status) {<br/>    userCache.modifyStatus(userId, status);<br/>    userDAO.modifyStatus(userId, status);<br/>}</span></pre><h2 id="745a" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">情况2)用属性替换对象</h2><p id="b600" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">以下代码片段显示了症状描述。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="6572" class="lx kv iq mo b gy ms mt l mu mv">// 删除用户函数<br/>private void deleteUser(User user) {<br/>    userCache.delete(user.getId());<br/>    userDAO.delete(user.getId());<br/>}</span></pre><p id="4fd6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请参考以下推荐的解决方案。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="fdb5" class="lx kv iq mo b gy ms mt l mu mv">// 删除用户函数<br/>private void deleteUser(Long userId) {<br/>    userCache.delete(userId);<br/>    userDAO.delete(userId);<br/>}</span></pre><p id="a3b7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当调用一个函数时，不需要构建一个专用的参数对象。当一个函数使用三个以上的属性时，您不需要应用这个规则。</p><h2 id="8421" class="lx kv iq bd kw ly lz dn la ma mb dp le kf mc md li kj me mf lm kn mg mh lq mi bi translated">利益</h2><p id="0688" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">只保留函数需要的参数，以明确在调用过程中需要赋值的参数，避免在调用过程中构造无用的参数。</p><h1 id="2723" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">附言</h1><p id="ba43" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">如果你有更好的建议或者更好的代码案例，我们欢迎你的输入。我们希望这篇文章可以作为参考，有助于形成一套完整的Java编码规范。</p><h1 id="d8eb" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">原始来源:</h1><div class="mx my gp gr mz na"><a href="https://www.alibabacloud.com/blog/coding-specifications-%7C-elegant-java-functions-part-two_596182" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd ir gy z fp nf fr fs ng fu fw ip bi translated">编码规范|优雅的Java函数(第二部分)</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">本文描述了一组与Java函数相关的编码规则，旨在…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">www.alibabacloud.com</p></div></div><div class="nj l"><div class="og l nl nm nn nj no js na"/></div></div></a></div><p id="2bf3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">进入专家视图— </strong> <a class="ae kt" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>