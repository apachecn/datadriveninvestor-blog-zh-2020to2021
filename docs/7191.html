<html>
<head>
<title>The Most Simple Explanation of Threads and Queues in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中线程和队列的最简单解释</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/the-most-simple-explanation-of-threads-and-queues-in-python-cbc206025dd1?source=collection_archive---------0-----------------------#2020-11-29">https://medium.datadriveninvestor.com/the-most-simple-explanation-of-threads-and-queues-in-python-cbc206025dd1?source=collection_archive---------0-----------------------#2020-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5511" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">编程；编排</h2><div class=""/><figure class="gl gn ka kb kc kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi jz"><img src="../Images/867ab41b08127e7f2930b8512ee971e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*teywwUNmEb8sjC8K.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Photo Credit: <a class="ae ko" href="https://learntalk.org/en/blog/travel-english-at-the-airport-check-in-counter" rel="noopener ugc nofollow" target="_blank">https://learntalk.org/en/blog/travel-english-at-the-airport-check-in-counter</a></figcaption></figure><p id="90f0" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">并行处理和线程吓到了初级程序员。像队列和线程这样的术语看起来非常奇怪和复杂。在这里，我试图展开这些术语，并展示多线程是如何工作的。本文是专门为对并行化感兴趣的Python初学者编写的。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="222d" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">长队</h1><p id="6f9d" class="pw-post-body-paragraph kp kq it kr b ks ms ku kv kw mt ky kz la mu lc ld le mv lg lh li mw lk ll lm im bi translated">你到达机场，去办理登机手续。航空公司的工作人员会看着你的机票，让你排队。简单吧？基本上，机场中的队列是有序旅客的集合。先来的人将被优先招待。在计算机编程领域，我们称之为FIFO(先进先出)队列。它从来没有发生在机场，但有时在编程世界中，我们首先服务于最后的任务或项目。我们称之为后进先出队列。另一种类型的队列是优先级队列。在机场，那些有头等舱或商务舱机票的人通常会首先得到服务。这正是优先级队列的工作方式。它给排队的每个人一个优先权。</p><figure class="my mz na nb gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi mx"><img src="../Images/c49c3de1864ac77aac47805ed3695b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pfD67JrcCNXmEZQ3.jpg"/></div></div></figure><p id="c198" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">虽然我们有三种队列，但FIFO是编程中最常见的类型。让我们用Python创建这三种队列。</p><figure class="my mz na nb gt kd"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="5d76" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">您可以使用<code class="fe ne nf ng nh b">put()</code>方法在队列中放置或插入项目，或者使用<code class="fe ne nf ng nh b">get()</code>方法从队列中调用一个对象。下面的例子显示了一个简单的FIFO队列加载和卸载。首先，创建一个FIFO队列对象，并将其命名为<code class="fe ne nf ng nh b">q</code>。然后使用<code class="fe ne nf ng nh b">put()</code>方法将1到5的数字放入队列。最后，在另一个循环中，您从队列中一个接一个地获取项目并打印它们。</p><figure class="my mz na nb gt kd"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="55e3" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">上面提到的例子有什么问题？问题是，在这个例子中，我们知道队列中的项目数(5)。因此，我们用<code class="fe ne nf ng nh b">get()</code>和一个固定的循环来称呼它们。在现实世界的应用程序中，我们通常不知道队列中的项目数量。因此，我们必须遍历队列中的所有项，直到队列变空。</p><p id="3cba" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们如何检查队列是否为空？使用名为<code class="fe ne nf ng nh b">empty()</code>的方法或名为<code class="fe ne nf ng nh b">empty</code>的属性。当<code class="fe ne nf ng nh b">empty()</code>方法或<code class="fe ne nf ng nh b">empty</code>属性返回True时，队列为空。</p><figure class="my mz na nb gt kd"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="951a" class="lu lv it bd lw lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr bi translated">穿线</h1><figure class="my mz na nb gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi nn"><img src="../Images/1002723be63b6cc62f85901d8a4139d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CXjIGaMRdM4SxmS9.jpg"/></div></div></figure><p id="8861" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们回到我们的机场例子。通常，对于一家航空公司来说，我们为所有旅客提供一条线路，但有多个值机柜台。所有的柜台都在做同样的工作，为乘客办理登机手续。每个柜台的工作人员呼叫排队的第一个人，在完成登记手续后，他们呼叫排队的下一个人。在编程中，线程是一个独立的执行流。在本例中，每个计数器都是一个线程。如您所见，这些计数器(即线程)相互不依赖，这使得并行执行成为可能。</p><p id="ff4f" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在Python中，线程可以用不同的方式完成。这里，我们实现了最基本的线程类型。</p><figure class="my mz na nb gt kd"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7b24" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这个例子中，我们有两个工作者(线程)执行相同的任务(在这个例子中运行函数<code class="fe ne nf ng nh b">func</code>)。如你所见，整个穿线过程只需3个步骤:</p><p id="d7a9" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">步骤1:将任务定义为一个函数。</p><p id="d8df" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">步骤2:创建线程。</p><p id="fd61" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">步骤3:启动线程(使用start方法)。</p><h1 id="4e31" class="lu lv it bd lw lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr bi translated">结合线程和队列</h1><p id="2b5b" class="pw-post-body-paragraph kp kq it kr b ks ms ku kv kw mt ky kz la mu lc ld le mv lg lh li mw lk ll lm im bi translated">现在是时候将两个强大的工具结合在一起了。假设我们有一个任务队列，我们希望使用4个线程来完成。为了简单起见，我使用了一个不做任何特定事情的虚拟函数，但是它模拟了耗时的任务。</p><figure class="my mz na nb gt kd"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b565" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们来看一下代码，逐行分析。第1–3行调用了这个示例代码的三个必需的包。第5–10行是一个简单的函数，模拟一个耗时的任务(这里使用<code class="fe ne nf ng nh b">time.sleep(2)</code>)。该函数接受两个任意参数。这里，参数是q，它是一个任务队列(在这种情况下是一个整数队列)和一个作为线程号的整数(为了打印一个有用的消息)。第6行是一个无限循环，它保证我们得到队列中的所有任务。在循环内部，我们从队列中获取第一个任务(第7行)。然后，我们等待2秒钟(模拟一个耗时的任务)。一旦任务完成，使用<code class="fe ne nf ng nh b">tase_done()</code>(第9行)，我们让系统知道这个任务已经完成。第10行只是打印一条消息，显示哪个线程完成了哪个任务。</p><p id="3da4" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在主程序中(第12到21行)，我们首先声明一个队列对象(第12行)。第14–16行生成四个线程并启动它们。注意，对于每个线程，负责任务的函数是<code class="fe ne nf ng nh b">func</code>函数，我们将队列和线程号参数传递给它们(第15行)。</p><p id="0694" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">到目前为止，我们已经准备好了任务函数(即<code class="fe ne nf ng nh b">func</code>)和4个线程。因为队列是空的，所以所有四个线程都在等待。一旦任务被插入到队列中，线程就开始处理该任务。第18行和第19行只是用0到9之间的整数填充我们的队列。第21行很重要，因为当队列中的所有作业都完成并且队列变空时，它就结束程序。</p><p id="b9c4" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">运行此示例代码后，您将看到类似这样的内容:</p><pre class="my mz na nb gt no nh np nq aw nr bi"><span id="f000" class="ns lv it nh b gy nt nu l nv nw">Thread #2 is doing task #2 in the queue.<br/>Thread #0 is doing task #0 in the queue.<br/>Thread #1 is doing task #1 in the queue.<br/>Thread #3 is doing task #3 in the queue.<br/>Thread #3 is doing task #7 in the queue.<br/>Thread #2 is doing task #5 in the queue.<br/>Thread #1 is doing task #6 in the queue.<br/>Thread #0 is doing task #4 in the queue.<br/>Thread #3 is doing task #9 in the queue.<br/>Thread #2 is doing task #8 in the queue.</span></pre><p id="f4af" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">您可能会看到不同顺序的结果，这取决于哪个任务先完成。例如，在我的例子中(没有特别的原因),处理任务2的线程2提前完成，然后线程0完成任务0，依此类推。如果您仔细观察，您会发现这4个线程中的每一个都是在它们的前一个任务完成后立即从队列中挑选一个新任务。这就像4个柜台正在为10个人的队伍中的乘客办理登机手续。</p><h1 id="fc88" class="lu lv it bd lw lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr bi translated">摘要</h1><p id="ed34" class="pw-post-body-paragraph kp kq it kr b ks ms ku kv kw mt ky kz la mu lc ld le mv lg lh li mw lk ll lm im bi translated">通过使用Python中的队列库，可以创建任务或对象的队列或行。简单地说，您可以将一个任务添加到队列中(使用<code class="fe ne nf ng nh b">put()</code>方法)，或者将一个任务从队列中取出并处理它(使用<code class="fe ne nf ng nh b">get()</code>方法)。</p><p id="09a8" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">Python中的线程包允许您同时运行多个任务。您可以将线程与队列对象结合起来，以获得稳定的任务流，并将它们分布在多个线程之间。</p><p id="2664" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最后，我们在这里没有讨论它，但是多线程与并行计算和处理有一点不同。为了更好地理解，请关注我即将发表的关于这个主题的文章。</p></div></div>    
</body>
</html>