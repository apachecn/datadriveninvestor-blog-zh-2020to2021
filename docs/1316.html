<html>
<head>
<title>Best Practices: Advanced Deep Learning with Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最佳实践:使用Keras进行高级深度学习</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/best-practices-advanced-deep-learning-with-keras-a183985a0a07?source=collection_archive---------15-----------------------#2020-03-12">https://medium.datadriveninvestor.com/best-practices-advanced-deep-learning-with-keras-a183985a0a07?source=collection_archive---------15-----------------------#2020-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d5d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个博客将帮助我们探索各种工具，这些工具将使我们更接近解决难题的最新发展水平。使用Keras functional API，我们可以构建一个类似图形的模型，跨不同的输入共享各层。Keras回调和Tensorboard可视化工具允许我们在训练期间监控模型。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi ks"><img src="../Images/24a7c722b646a7df888bf9ff3453d4e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*uokXCDa_O7jzfbUC9qS6cg.png"/></div></figure><p id="b2e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Keras功能API:超越顺序模型</strong></p><p id="f47a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们谈论训练神经网络时，序列模型是非常常见的。它只有一个输入和一个输出，由线性层叠组成。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi la"><img src="../Images/a6c464f24e5467a84ed694443427caef.png" data-original-src="https://miro.medium.com/v2/resize:fit:96/0*WvcEIMEr3T2_J6Nc"/></div></figure><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/4a6cc15d899ea8c02906a0952b8a1dac.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/0*lKyGE8dxANrIqcd_.png"/></div></figure><p id="cb19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顺序模型</p><p id="a981" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些场景需要多模态输入，我们将来自不同来源的数据合并，并在神经网络中进行处理。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/f6c48b0da3318a7a03644f4d9bb59b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/0*NJBBGXx53eVt7ZsE"/></div></figure><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/bc2f5f4379bfd532dea85baae06a01cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/0*eAKR4jkAElzqKujm.png"/></div></figure><p id="fd4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，在神经网络结构中有许多发展需要非线性拓扑。有三种类型的用例——多输入模型、多输出模型和类似图形的模型。</p><p id="5af3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">简介:</strong></p><p id="e521" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在函数API中，我们直接处理张量，使用层作为取张量和返回张量的函数。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/15730227c327f40bb0ec288bbd86b484.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/0*ljdPo6KBXaAxUcmQ"/></div></figure><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi le"><img src="../Images/db80b03af65578385f75c831f708c2fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TQQJumARXczn6TdO.png"/></div></div></figure><p id="8d52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码中唯一令人惊讶的部分是“模型”对象的使用。这里，<strong class="jp ir">模型</strong>由输入张量和输出张量实例化。在图片背后，Keras检索了从输入张量到输出张量所涉及的所有层，将它们整合到一个类似图形的数据结构中。</p><div class="lj lk gp gr ll lm"><a href="https://www.datadriveninvestor.com/2019/01/23/deep-learning-explained-in-7-steps/" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab fo"><div class="lo ab lp cl cj lq"><h2 class="bd ir gy z fp lr fr fs ls fu fw ip bi translated">深度学习用7个步骤解释-更新|数据驱动的投资者</h2><div class="lt l"><h3 class="bd b gy z fp lr fr fs ls fu fw dk translated">在深度学习的帮助下，自动驾驶汽车、Alexa、医学成像-小工具正在我们周围变得超级智能…</h3></div><div class="lu l"><p class="bd b dl z fp lr fr fs ls fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="lv l"><div class="lw l lx ly lz lv ma ky lm"/></div></div></a></div><p id="088b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">多输入型号:</strong></p><p id="198a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">函数式API可用于构建具有多个输入的模型。这种类型的模型总是有一个我们可以组合它们不同输入的点:通过添加它们或者连接它们。</p><p id="7e4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这通常通过Keras合并操作完成，例如<strong class="jp ir"> keras.layers.add </strong>，<strong class="jp ir">Keras . layers . concatenate</strong>。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/c086aeb39e87d68a90975eea377643cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/0*ikCp-xNzMRkt7iwF"/></div></figure><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/7538ac877c3813014ada1a8c10d5e58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*4wP2BXYkCGZmrMfC.png"/></div></figure><p id="7e75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">多输出型号:</strong></p><p id="cf20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以同样的方式，函数式API可以用于构建具有多个输出的模型。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/5767a4029d4b6120a03c30a546731cde.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/0*1B9FJM6riwxCE5yw"/></div></figure><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/3f65c5a7e287a59818601ab89210f94c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/0*pzyKzheEOD25BSqb.png"/></div></figure><p id="338a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重要的是，训练这样的模型需要为网络的不同头部指定不同损失函数的能力。一种情况可能是回归，另一种情况可能是需要不同训练过程的二元分类。但是因为梯度下降要求我们最小化一个标量，所以我们必须将这些损失组合成单个值，以便训练模型。组合不同损失的最简单方法是将它们相加。在Keras中，对于不同的输出，我们可以在编译到不同的对象时使用一个损失列表或字典:得到的损失值被加到一个全局损失中，该损失在训练期间被最小化。</p><p id="1e0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，非常不平衡的损失贡献将导致模型表示优先针对具有最大个体损失的任务进行优化，而以另一个任务为代价。为了补救这一点，我们可以根据损失价值对最终损失的贡献程度来分配不同的重要性级别。</p><p id="b2e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">层的有向无环图:</strong></p><p id="f902" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在functional API中，我们还可以实现具有复杂内部拓扑的网络。Keras中的神经网络可以是任意层的有向无环图。限定词“非循环的”很重要:这些图不能有循环。张量x t不可能成为生成x的另一层的输入。唯一允许的处理循环(即循环连接)是循环层内部的处理循环。</p><p id="0cc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几个常见的神经网络组件以图形形式实现:</p><p id="fb75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.初始模块</p><p id="b4b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.残留连接。</p><p id="72a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">初始模块:</p><p id="b445" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">盗梦空间模型是由Christian Szegedy在2013-14年开发的。它包含分成并行分支的小独立模块。初始模块的最基本形式具有三个或四个分支，以1x1卷积开始，随后是3x3卷积，并以结果特征的连接结束。</p><p id="37b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种设置有助于网络分别学习空间特征和通道特征，这比联合学习它们更有效。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/65c3acb79a332aa09fb7055a8724f94c.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/0*X9XCRgzsejGUv4Lg"/></div></figure><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi md"><img src="../Images/71032731defb7f78baa042b602222bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*niDe32jcp4NAmjMj.png"/></div></div></figure><p id="31b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">剩余连接:</strong></p><p id="0ac9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是微软在2015年开发的。它处理深度学习模型中的两个主要问题:消失梯度和表示瓶颈。一般来说，向任何超过10层的模型添加剩余连接是有益的。</p><p id="aeef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">剩余连接有效地将前一层的输出作为后一层的输入，有效地在q序列网络中创建了捷径。不是连接到后面的激活，而是将前面的激活与后面的激活相加，这假定两者的大小相同。如果它们是不同的形状，我们可以使用线性变换将其调整为目标形状。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/0e5f8728aa34260e35975964b3101406.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/0*aN5z9Zc_pwWdyQbX"/></div></figure><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi me"><img src="../Images/661a6e06e27a7720a5f548855a1a4a39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/0*JkVYh2Ir8n1Cb3i7.png"/></div></figure><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mf mg l"/></div></figure></div></div>    
</body>
</html>