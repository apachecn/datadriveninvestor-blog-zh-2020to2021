<html>
<head>
<title>Processing Beauty: Cellular Automata</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理美:细胞自动机</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/processing-beauty-cellar-automata-ebab985177c9?source=collection_archive---------8-----------------------#2020-12-18">https://medium.datadriveninvestor.com/processing-beauty-cellar-automata-ebab985177c9?source=collection_archive---------8-----------------------#2020-12-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="49d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">加工简介</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/d61569c4abc9c6a5c054a2bfa5ff7aa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dt9gv5Sgu7LMBgQ4vp6FsQ.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Simple patterns can produce pleasing results. unsplash: <a class="ae lb" href="https://unsplash.com/@mitchel3uo" rel="noopener ugc nofollow" target="_blank">Mitchell Luo</a></figcaption></figure><blockquote class="lc ld le"><p id="d668" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">“每样东西都有它的美，但不是每个人都看得到。”——孔子</p></blockquote><p id="e731" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码能创造美吗？</p><p id="74d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多艺术品包含图案和设计。例如，马赛克艺术和硬边抽象。设计中固有的规则令人愉悦。</p><p id="9273" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用代码通过处理创建类似的模式。<a class="ae lb" href="https://processing.org/" rel="noopener ugc nofollow" target="_blank"> Processing </a>是一款为艺术家、设计师、教师和初学计算机图形的学生开发的工具。使用Processing，很容易制作简单的可视化程序。</p><p id="4ea1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">细胞自动机</strong></p><p id="ec1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">细胞自动机(CA)是这种编程的良好基础。CA是一种使用“单元”网格显示复杂信息的方式在我们的例子中，我们将创建一个版本的<a class="ae lb" href="http://pi.math.cornell.edu/~lipa/mec/lesson6.html" rel="noopener ugc nofollow" target="_blank">康威的生命游戏</a>，一个非常著名的细胞自动机练习。</p><p id="2997" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要创建这个游戏，我们首先需要画一个包含列和行的网格。网格上的每个细胞要么是“活的”，要么是“死的”跟踪每个细胞的状态将允许我们从一组简单的规则中生成复杂的动画图案。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/ff9239aae2f1de42e60a081310815615.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/1*pHDCnPbIi4IMxgiDG2H1RQ.gif"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">An example of Conway’s Game of Life.</figcaption></figure><p id="3052" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个细胞都有邻居，这些邻居要么活着，要么死了。</p><p id="b48c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CA最早是由数学家约翰·冯·诺依曼在20世纪40年代发现的。游戏从随机确定网格中每个细胞的状态(活的或死的)开始。然后，游戏进行一步，并根据以下条件进入新的状态:</p><p id="0bc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.如果一个细胞是活的，如果它的邻居超过3个，或者少于2个，它就会死亡。</p><p id="6286" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.如果一个细胞死了，如果正好有3个邻居，它就会活过来。</p><p id="a792" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.在所有其他情况下，单元格保持不变。</p><p id="f2d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">利用这些规则，我们将创造生活的游戏，也许在这个过程中还会有一点美。最后提供了完整的代码。可以将其复制并粘贴到新的加工草图中。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lk"><img src="../Images/a117fbaeab1abf3d551a2555a2f92030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/1*tDCNt0ZtL5KCYpNRTz1S4A.gif"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">An example of the Processing sketch we will build.</figcaption></figure><p id="91f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">入门</strong></p><p id="0735" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要完成这个练习，你只需要一份加工的拷贝。你可以从processing.org免费下载if。一旦你打开处理，你会看到一个包含你的草图的文本编辑器。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/a441d0bcc17a8243e7945a894bae21c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*TwcTDlFnp0iU8fYmKSv0fw.png"/></div></figure><p id="0c0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们准备写一些代码。让我们从构建游戏板开始。棋盘是一个格子，很像棋盘。为了存储这些数据，使用2D数组是有意义的。</p><pre class="km kn ko kp gt lm ln lo lp aw lq bi"><span id="e15c" class="lr ls iq ln b gy lt lu l lv lw">int[][] board = new int[columns][rows];</span></pre><p id="08d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">阵列中的每个单元将有一个状态，或者开或者关(0或1)。游戏开始时循环遍历每个单元格，并将它们设置为随机开始状态。</p><pre class="km kn ko kp gt lm ln lo lp aw lq bi"><span id="39dd" class="lr ls iq ln b gy lt lu l lv lw">// Initialize the game board<br/>  for (int x = 0; x &lt; columns; x++){<br/>    for (int y =0; y &lt; rows; y++){<br/>      gameboard[x][y] = int(random(2));<br/>    }<br/>  }</span></pre><p id="6b7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然游戏板已经初始化，我们可以把它画到屏幕上了。我们可以使用Processing提供的rect()函数来绘制每个单元格。我们将创建一个DrawBoard()函数，该函数循环遍历每个单元格，并在指定位置绘制一个白色或黑色的矩形。</p><p id="764a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们将使用一个int来存储平铺图形的大小。将这个值乘以每个单元格的x和y坐标，我们就可以画出单元格。</p><p id="d8a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">处理提供了一个初始化草图的函数:setup()。从setup()函数中调用DrawBoard()会给我们一个板子的图像。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/ea2fcbbb2fb539c9389569b6266fcb33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*QwVZjrZdeYQwTZ2dIYU9zQ.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">The first steps in the game of life.</figcaption></figure><p id="fefd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的草图中还需要两个函数:CheckNeighbors()和TakeStep()。CheckNeighbors将有两个参数(x和y)。我们将使用这个函数来计算一个单元中活着的邻居的数量。</p><p id="54bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个函数TakeStep()将遍历游戏棋盘中的每个单元格，计算其邻居，然后检查生命游戏的规则以确定该单元格是生是死。</p><p id="da97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用第二个2D数组(称为next)来存储每个单元格的状态。在函数结束时，旧数据被新数据替换。</p><pre class="km kn ko kp gt lm ln lo lp aw lq bi"><span id="7a0a" class="lr ls iq ln b gy lt lu l lv lw">gameboard = next;</span></pre><p id="9c35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CheckNeighbors()函数使用双for循环(也称为嵌套循环)来检查单元格的邻居。首先，进行检查以确保邻居在游戏板内。接下来，我们确保不对当前单元格进行计数。在所有其他情况下，如果细胞是活的，我们将其视为邻居。</p><p id="f8f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用邻居计数和生命游戏的规则，我们可以根据游戏棋盘的当前状态来计算游戏中的下一个状态。</p><p id="59ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TakeStep()函数使用嵌套循环来抓取游戏棋盘中的每个单元格。然后它将需要确定该细胞当前是否存活。</p><p id="f84b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果细胞是活的，另一个检查确定它是否被杀死。请记住，在生命的游戏中，如果一个细胞的邻居超过3个(超过种群数量)，或少于2个(低于种群数量)，这个细胞就会死亡。</p><div class="ly lz gp gr ma mb"><a href="https://www.datadriveninvestor.com/2020/09/29/5-robotic-process-automation-traps-to-avoid/" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd ir gy z fp mg fr fs mh fu fw ip bi translated">要避免的5个机器人流程自动化陷阱|数据驱动型投资者</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">在一些大公司的机器人流程自动化(RPA)之旅中，我从一开始就在这些公司工作…</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp kv mb"/></div></div></a></div><p id="173d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果细胞死了，如果它正好有3个邻居，它可以复活。</p><p id="9d5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在所有其他情况下，单元格保持不变。</p><p id="5454" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了运行模拟，我们还需要一个函数:draw()。这个函数是在setup()函数之后直接调用的，重复执行。使用名为“tick”的变量，我们可以计算在进行下一步并重新绘制棋盘之前我们想要等待多少个循环。</p><p id="d0d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这种方法，我们可以控制细胞存活和死亡的速度。</p><p id="693c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是完整的加工草图:</p><pre class="km kn ko kp gt lm ln lo lp aw lq bi"><span id="763b" class="lr ls iq ln b gy lt lu l lv lw">// GAME OF LIFE</span><span id="9e10" class="lr ls iq ln b gy mq lu l lv lw">int columns = 16; // width of the gameboard<br/>int rows = 12; //height of the gameboard<br/>int tile_size = 40; // size of the tiles<br/>int tick = 1;<br/>int tick_time = 10;</span><span id="d4a8" class="lr ls iq ln b gy mq lu l lv lw">int[][] gameboard = new int[columns][rows];</span><span id="c232" class="lr ls iq ln b gy mq lu l lv lw">int[][] next = new int[columns][rows];</span><span id="a2f5" class="lr ls iq ln b gy mq lu l lv lw">void setup(){<br/>  size(640,480);<br/>  <br/>  // Initialize the game board<br/>  for (int x = 0; x &lt; columns; x++){<br/>    for (int y =0; y &lt; rows; y++){<br/>      gameboard[x][y] = int(random(2));<br/>      next[x][y] = gameboard[x][y];<br/>    }<br/>  }<br/>  DrawBoard();<br/>}</span><span id="6130" class="lr ls iq ln b gy mq lu l lv lw">void draw(){<br/>  tick++;<br/>  if (tick &gt; tick_time){<br/>    tick = 0;<br/>    TakeStep();<br/>    DrawBoard();<br/>  }<br/>}</span><span id="558a" class="lr ls iq ln b gy mq lu l lv lw">void TakeStep(){<br/>  // loop through the board in it's current state<br/>  for (int y = 0; y &lt; rows; y++){<br/>    for (int x = 0; x &lt; columns; x++){<br/>      <br/>      int n = CheckNeighbors(x,y);<br/>      //print(n, " ");<br/>      // if cell is alive<br/>      if (gameboard[x][y] == 1){<br/>        // if over or under populated, kill it<br/>        if (n &gt; 3 || n &lt; 2){<br/>          next[x][y] = 0;<br/>        }<br/>      }<br/>      else if(gameboard[x][y] == 0){<br/>        if (n == 3){<br/>          next[x][y] = 1;<br/>        }<br/>      }<br/>      else{<br/>        next[x][y] = gameboard[x][y];<br/>      }<br/>    }<br/>  }<br/>  <br/>  gameboard = next;<br/>}</span><span id="95c6" class="lr ls iq ln b gy mq lu l lv lw">int CheckNeighbors(int x, int y) {<br/>  int neighbors = 0;<br/>  // loop through the 9possible neighbors <br/>  for (int i = -1; i &lt; 2; i++){<br/>    for (int j = -1; j &lt; 2; j++){<br/>      if (x + i &lt; 0 || x + i &gt; columns-1 || y + j &lt; 0 || y + j &gt; rows-1){<br/>       // outside the bounds of the map. do nothing <br/>      }<br/>      else if (i == 0 &amp;&amp; j == 0){<br/>        // don't count ourselves<br/>      }<br/>          <br/>      else if (gameboard[x+i][y+j] == 1){<br/>        neighbors++;<br/>      }<br/>    }<br/>  }<br/>    <br/>  return neighbors;<br/>}</span><span id="6d80" class="lr ls iq ln b gy mq lu l lv lw">void DrawBoard(){<br/>  for (int i = 0; i &lt; columns; i++){<br/>    for (int j = 0; j &lt; rows; j++){<br/>      if (gameboard[i][j] == 1) fill(0);<br/>      else fill(255);<br/>      stroke(0);<br/>      rect(i*tile_size, j*tile_size, tile_size, tile_size);<br/>    }<br/>  }<br/>}</span></pre><p id="3ef3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦你有了完整的代码，运行草图就会产生一个随机的生命游戏。每部新戏都是独一无二的。尝试行数和列数将得到更小或更大的地图，更改切片大小将产生有趣的结果。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/00ce4eec985850c7415dfceb745429bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*GeXu2Uqxpg8xUisQwmmIQg.png"/></div></figure><p id="849c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而且你可以挑选更讨人喜欢的颜色。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/ae4825afae103f08eafd833a6339e01a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*Tzmgh82ft0-4NHLBE1MHog.png"/></div></figure><p id="2967" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">细胞自动机的美妙之处在于它的简单。简单的规则可以带来无限的变化。这本身就有一种美感，和自然的亲密关系。</p><p id="5aca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用处理，任何人都可以学习并利用代码的力量来创造美。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="2b57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你喜欢我的作品，并愿意支持我和Medium上的其他作者，请使用<a class="ae lb" href="https://harold-j-petty.medium.com/membership" rel="noopener">这个链接</a>成为会员。你的会员费直接支持我和你看的其他作家。你也可以在媒体上看到所有的故事。</p><h2 id="3453" class="lr ls iq bd na nb nc dn nd ne nf dp ng jy nh ni nj kc nk nl nm kg nn no np nq bi translated">获得专家视图— <a class="ae lb" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank">订阅DDI英特尔</a></h2></div></div>    
</body>
</html>