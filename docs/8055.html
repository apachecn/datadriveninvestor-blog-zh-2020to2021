<html>
<head>
<title>Easy to Learn React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单易学的反应钩</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/easy-to-learn-react-hooks-7db7763608f5?source=collection_archive---------4-----------------------#2020-12-31">https://medium.datadriveninvestor.com/easy-to-learn-react-hooks-7db7763608f5?source=collection_archive---------4-----------------------#2020-12-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="0c1a" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">前端</h2><div class=""/><div class=""><h2 id="d59c" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">以useEffect()为例</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/52cc07b899f34cc5208c6d72f09c4b6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fbPkB4GcfdqPbQ9k3Wv6MQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@blizzard88?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Grant Durr</a> on <a class="ae le" href="https://unsplash.com/s/photos/hook?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7c47" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我已经写了关于<a class="ae le" href="https://towardsdatascience.com/react-best-practices-804def6d5215" rel="noopener" target="_blank">反应最佳实践</a>的文章。我提到过，React钩子编写有状态的功能组件。现在大部分react框架比如react-i18next，Material-UI等等都是鼓励使用React钩子的。但是，最近我开始意识到React钩子非常有用。React钩子是在React v16.08之后引入的，这里我将非常简单容易地描述React钩子。这是我的第34篇中型文章。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="02c8" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">两套React API</h1><p id="7a22" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">以前只有一套React API，现在有两套:类API和基于函数的钩子API。任何组件都可以由一个类或一个钩子来编写。下面是如何编写这个类。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="fa30" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们来看看钩子的编写方式，也就是函数。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="56b3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这两种写法效果完全一样。新手自然会问:“我该用哪个API？”</p><p id="8710" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><a class="ae le" href="https://reactjs.org/docs/hooks-faq.html#should-i-use-hooks-classes-or-a-mix-of-both" rel="noopener ugc nofollow" target="_blank">官方推荐</a>使用钩子(函数)代替类。因为钩子更简洁，代码更少，所以用起来“更轻”，而类则“更重”。而且钩子是函数，更符合React的函数性质。</p><p id="87c2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">下面是类组件(左)和功能组件(右)的代码量对比。对于复杂的组件，差别就更大了。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nh"><img src="../Images/abf0760a38b15a5620db4579745bea93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fyHQ5LZieX8UbpZU4zMhgQ.jpeg"/></div></div></figure><p id="f299" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但是钩子的灵活性太大，新手理解不了。很多人一知半解，很容易写出乱七八糟、不可维护的代码。最好使用类。因为类有很多强制性的语法约束，所以不容易搞砸。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="ced3" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">类和函数的区别</h1><p id="2923" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">严格来说，类组件和功能组件是有区别的。不同的编写方法代表不同的编程方法。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/ab61b85c7dc6949d4e0a85ff10001445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*TVhzFkIjNtmpOYt7xiR-DQ.jpeg"/></div></figure><p id="733b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">类是数据和逻辑的封装。</strong>换句话说，组件的状态和操作方法封装在一起。如果选择了编写的类型，就应该在同一个类中编写相关的数据和操作。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nj"><img src="../Images/125f1cf7d7af2e3bd2b9b0a8283b1b13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yBmNd02dBwKNbGIcwKgYgg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk"><a class="ae le" href="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3b/Function_machine2.svg/1200px-Function_machine2.svg.png" rel="noopener ugc nofollow" target="_blank">https://upload.wikimedia.org/wikipedia/commons/thumb/3/3b/Function_machine2.svg/1200px-Function_machine2.svg.png</a></figcaption></figure><p id="616e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">一般来说，函数应该只做一件事，就是返回值。</strong>如果你有多个操作，每个操作都应该写成一个单独的函数。而且，数据的状态要和操作方法分开。按照这个理念，React的功能组件应该只做一件事:返回组件的HTML代码，没有其他功能。</p><p id="bdd2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">以下面的功能组件为例。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="176c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这个函数只做一件事，就是根据输入参数返回组件的HTML代码。这种只进行简单数据计算(转换)的函数在函数式编程中称为<strong class="lh ja">“纯函数”</strong>。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="1a9a" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">有什么副作用？</h1><p id="39d3" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">看到这里，你可能会有一个疑问:如果纯函数只能进行数据计算，那些不涉及计算的操作(比如生成日志、存储数据、改变应用状态等)应该放在哪里？)被写？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/ac52df77d78d0591eb18680a8cc4dd5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*-YvOvw7xuTF5oA30YEwQUw.jpeg"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk"><a class="ae le" href="https://functionalprogrammingcsharp.com/images/posts/pure-functions.jpg" rel="noopener ugc nofollow" target="_blank">https://functionalprogrammingcsharp.com/images/posts/pure-functions.jpg</a></figcaption></figure><p id="090a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">计算那些与数据无关的运算的函数式编程叫做“次生效应”<strong class="lh ja">(副作用)</strong>。如果一个函数直接包含产生副作用的运算，那么它就不再是一个纯函数，我们称之为不纯函数。</p><p id="2642" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">只有通过纯函数内部的间接手段(即通过其他函数调用)，才能包含副作用。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="cd92" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">钩子的作用</h1><p id="e7c2" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">说了半天，到底什么是钩子？总之，<strong class="lh ja">钩子就是React功能组件的副作用解决方案，用来给功能组件引入副作用。</strong>函数组件的体应该只用于返回组件的HTML代码，其他所有操作(副作用)都必须通过钩子引入。</p><p id="cf9d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">既然有这么多副作用，那就有很多种挂钩。React为许多常见操作(副作用)提供了特殊的挂钩。</p><ul class=""><li id="65d7" class="nl nm iq lh b li lj ll lm lo nn ls no lw np ma nq nr ns nt bi translated"><code class="fe nu nv nw nx b">useState()</code>:保存状态</li><li id="9f4b" class="nl nm iq lh b li ny ll nz lo oa ls ob lw oc ma nq nr ns nt bi translated"><code class="fe nu nv nw nx b">useContext()</code>:保存上下文</li><li id="4487" class="nl nm iq lh b li ny ll nz lo oa ls ob lw oc ma nq nr ns nt bi translated"><code class="fe nu nv nw nx b">useRef()</code>:保存参考</li><li id="1ec2" class="nl nm iq lh b li ny ll nz lo oa ls ob lw oc ma nq nr ns nt bi">…</li></ul><p id="ae4e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">以上这些钩子，都是特定副作用的介绍而<code class="fe nu nv nw nx b">useEffect()</code> <strong class="lh ja">是钩子</strong>的常见副作用。找不到对应挂钩的时候可以用。其实从名字就能看出来，和副作用有直接关系。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi od"><img src="../Images/f65e914e7958c51b76358de420674299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lXbyzFjWcBEmiCEzdZ9DDQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk"><a class="ae le" href="https://dev.to/swapnadeepmohapatra/useeffect-react-hooks-25fb" rel="noopener ugc nofollow" target="_blank">https://dev.to/swapnadeepmohapatra/useeffect-react-hooks-25fb</a></figcaption></figure></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="f891" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated"><code class="fe nu nv nw nx b">useEffect()</code>的用法</h1><p id="4f4f" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated"><code class="fe nu nv nw nx b">useEffect()</code>本身就是一个函数，由React框架提供，可以在功能组件内部调用。</p><p id="c922" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">例如，我们希望组件加载后，页面标题(<code class="fe nu nv nw nx b">document.title</code>)会随之改变。然后，改变网页标题的操作是组件的副作用，是<code class="fe nu nv nw nx b">useEffect()</code>实现的。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="4151" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">上例中，<code class="fe nu nv nw nx b">useEffect()</code>参数是一个函数，是要完成的副作用(改变页面标题)。组件加载后，React将执行这个函数。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oe ng l"/></div></figure><p id="b852" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><code class="fe nu nv nw nx b">useEffect()</code>的作用是指定一个副作用函数，每次渲染组件时自动执行。组件首次加载到网页DOM后，副作用函数也会被执行。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="1034" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">useEffect()的第二个参数</h1><p id="270e" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">有时候，我们不希望<code class="fe nu nv nw nx b">useEffect()</code>执行每一次渲染。这时，我们可以用它的第二个参数用一个数组来指定副作用函数的依赖关系。只有当依赖关系改变时，才会再次执行渲染。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="8687" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在上面的例子中，<code class="fe nu nv nw nx b">useEffect()</code>第二个参数是一个数组，它指定了第一个参数(副作用函数)的依赖关系(<code class="fe nu nv nw nx b">props.name</code>)。只有当变量改变时，副作用功能才会被执行。</p><p id="3520" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果第二个参数是一个空数组，这意味着副作用参数没有任何依赖关系。所以组件加载到DOM后副作用函数只会执行一次，后续组件会重新渲染，不会再执行。这是合理的，因为副作用不依赖于任何变量，所以无论那些变量如何变化，副作用函数的执行结果都不会改变，所以运行一次就够了。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="cad0" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">useEffect()的目的</h1><p id="af84" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">只要是副作用，都可以用<code class="fe nu nv nw nx b">useEffect()</code>介绍。其常见用途如下。</p><ul class=""><li id="d0e5" class="nl nm iq lh b li lj ll lm lo nn ls no lw np ma nq nr ns nt bi translated">数据提取</li><li id="7605" class="nl nm iq lh b li ny ll nz lo oa ls ob lw oc ma nq nr ns nt bi translated">事件监控或订阅(设置订阅)</li><li id="a5b2" class="nl nm iq lh b li ny ll nz lo oa ls ob lw oc ma nq nr ns nt bi translated">改变DOM(改变DOM)</li><li id="818a" class="nl nm iq lh b li ny ll nz lo oa ls ob lw oc ma nq nr ns nt bi translated">输出日志(记录)</li></ul><p id="d4d6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">下面是一个从远程服务器获取数据的例子。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oe ng l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="1639" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在上面的例子中，<code class="fe nu nv nw nx b">useState()</code>用于生成一个状态变量(<code class="fe nu nv nw nx b">data</code>)来保存采集到的数据；<code class="fe nu nv nw nx b">useEffect()</code>在副作用函数内部，有一个异步函数从服务器异步获取数据。得到数据后，使用<code class="fe nu nv nw nx b">setData()</code>触发器组件重新渲染。</p><p id="db36" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">由于数据采集只需要执行一次，<code class="fe nu nv nw nx b">useEffect()</code>上面例子的第二个参数是一个空数组。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="d7af" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">useEffect()的返回值</h1><p id="d11a" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">加载组件时会产生副作用，因此当卸载组件时，可能需要清除这些副作用。</p><p id="7f86" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><code class="fe nu nv nw nx b">useEffect()</code>允许返回一个函数，该函数在组件卸载时执行，以清除副作用。如果你不需要清理<code class="fe nu nv nw nx b">useEffect()</code>的副作用，你不需要返回任何值。</p><pre class="kp kq kr ks gt of nx og oh aw oi bi"><span id="79ec" class="oj mj iq nx b gy ok ol l om on">useEffect(() =&gt; {<br/>  const subscription = props.source.subscribe();<br/>  <em class="oo">return</em> () =&gt; {<br/>    subscription.unsubscribe();<br/>  };<br/>}, [props.source]);</span></pre><p id="0568" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在上面的例子中，<code class="fe nu nv nw nx b">useEffect()</code>加载组件时订阅一个事件，并返回一个清理函数，卸载组件时取消订阅。</p><p id="99ca" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在实际使用中，由于副作用函数默认执行每一次渲染，因此清理函数不仅会在组件卸载时执行一次，还会在副作用函数重新执行之前执行一次，以清理上一次渲染效果的副作用。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="fd76" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">useEffect()注意点</h1><p id="30bf" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">使用<code class="fe nu nv nw nx b">useEffect()</code>有一点需要注意。如果有多个副作用，应该调用多个<code class="fe nu nv nw nx b">useEffect()</code>,而不是组合在一起写。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="eeef" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">上面的例子是错误的。副作用功能中有两个定时器。他们没有血缘关系。其实是两个不相关的副作用，不应该写在一起。正确的做法是把它们分别写成两个<code class="fe nu nv nw nx b">useEffect()</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="b65a" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">结论</h1><p id="d799" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">我的大多数社交媒体朋友都建议我写React hooks，因为他们想轻松理解它们。在这里，我用基本的Javascript概念写了一些钩子，并以<code class="fe nu nv nw nx b">useEffect()</code>为例。</p><p id="7d0c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">新年快乐🎉</p><p id="1ea4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">快乐编码😎</p><p id="bb60" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">访问专家视图— </strong> <a class="ae le" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>