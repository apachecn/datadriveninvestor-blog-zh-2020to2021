<html>
<head>
<title>Javascript Algorithm 2 — “Sliding Window”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript算法2——“滑动窗口”</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/javascript-algorithm-2-sliding-window-66622c7cb4f8?source=collection_archive---------1-----------------------#2020-02-11">https://medium.datadriveninvestor.com/javascript-algorithm-2-sliding-window-66622c7cb4f8?source=collection_archive---------1-----------------------#2020-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b22d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">嗨，我带来了另一种常见的Javascript算法类型！这就是所谓的“滑动窗口”。它在跟踪数组或字符串中的数据子集时非常有用，并且在降低时间复杂度方面非常有用。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e31790d3ea9d1dbdc406e76cf4c0eb4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZL8sXtLR5kH5x7lKQTXeQ.jpeg"/></div></div></figure><p id="3480" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们看一个例子，就更容易理解了。</p><p id="7b86" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们定义一个返回num大小的子数组的最大和的函数。我们将添加数组中的前三个元素，从索引0开始，连续移动到下一个元素。当我们添加下一个子集时，我们将通过减去起始索引元素并添加新的索引元素来移动窗口。</p><div class="ln lo gp gr lp lq"><a href="https://www.datadriveninvestor.com/2019/03/22/the-seductive-business-logic-of-algorithms/" rel="noopener  ugc nofollow" target="_blank"><div class="lr ab fo"><div class="ls ab lt cl cj lu"><h2 class="bd ir gy z fp lv fr fs lw fu fw ip bi translated">算法诱人的商业逻辑|数据驱动的投资者</h2><div class="lx l"><h3 class="bd b gy z fp lv fr fs lw fu fw dk translated">某些机器行为总是让我感到惊讶。我对他们从自己的成就中学习的能力感到惊讶…</h3></div><div class="ly l"><p class="bd b dl z fp lv fr fs lw fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="lz l"><div class="ma l mb mc md lz me kp lq"/></div></div></a></div><p id="7c0c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有一个例子。</p><p id="b4fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">输入数组</strong> : [2，6，9，2，1，8，5，6，3]</p><p id="0bc7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">数字</strong> : 3</p><ol class=""><li id="07a9" class="mf mg iq kt b ku kv kx ky la mh le mi li mj lm mk ml mm mn bi translated">让我们定义两个变量来跟踪结果子集的总和以及与临时总和相比的最大总和。</li></ol><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="0e21" class="mt mu iq mp b gy mv mw l mx my">function maxSumArr(arr, num) {<br/>    let maxSum = 0;<br/>    let tempSum = 0;</span><span id="1164" class="mt mu iq mp b gy mz mw l mx my">}</span></pre><p id="89f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.如果一个数组的长度小于num，我们应该在开始循环数组之前返回<strong class="kt ir"> null </strong>。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="755b" class="mt mu iq mp b gy mv mw l mx my">function maxSumArr(arr, num) {<br/>    let maxSum = 0;<br/>    let tempSum = 0;<br/>    if(arr.length &lt; num) return null;</span><span id="d040" class="mt mu iq mp b gy mz mw l mx my">}</span></pre><p id="be87" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.开始从索引0到num大小的数组循环，并将每个元素添加到tempSum中</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="3153" class="mt mu iq mp b gy mv mw l mx my">function maxSumArr(arr, num) {<br/>    let maxSum = 0;<br/>    let tempSum = 0;<br/>    if(arr.length &lt; num) return null;<br/>    for(let i = 0; i &lt; num; i++) {<br/>       tempSum += arr[i];</span><span id="4dd0" class="mt mu iq mp b gy mz mw l mx my">    }</span><span id="c00f" class="mt mu iq mp b gy mz mw l mx my">}</span></pre><p id="e922" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">4.将tempSum设置为maxSum变量，并从num开始再次遍历数组以获得新的tempSum。新的tempSum是通过滑动数组的窗口获得的，因此我们可以减去新子集的前一个元素并添加新元素</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="ccf9" class="mt mu iq mp b gy mv mw l mx my">function maxSumArr(arr, num) {<br/>    let maxSum = 0;<br/>    let tempSum = 0;<br/>    if(arr.length &lt; num) return null;<br/>    for(let i = 0; i &lt; num; i++) {<br/>       tempSum += arr[i];</span><span id="26ac" class="mt mu iq mp b gy mz mw l mx my">    }<br/>    tempSum = maxSum;<br/>    for(let i = num; i &lt; arr.length; i++) {<br/>       tempSum = tempSum - arr[i - num] + arr[i];</span><span id="5224" class="mt mu iq mp b gy mz mw l mx my">    }</span><span id="ae32" class="mt mu iq mp b gy mz mw l mx my">}</span></pre><p id="ec36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">5.现在，是时候比较maxSum和tempSum，并将较大的和设置为maxSum，我们将在最后返回。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="c624" class="mt mu iq mp b gy mv mw l mx my">function maxSumArr(arr, num) {<br/>    let maxSum = 0;<br/>    let tempSum = 0;<br/>    if(arr.length &lt; num) return null;<br/>    for(let i = 0; i &lt; num; i++) {<br/>       tempSum += arr[i];</span><span id="32f9" class="mt mu iq mp b gy mz mw l mx my">    }<br/>    tempSum = maxSum;<br/>    for(let i = num; i &lt; arr.length; i++) {<br/>       tempSum = tempSum - arr[i - num] + arr[i];<br/>       maxSum = Math.max(tempSum, maxSum);</span><span id="5f70" class="mt mu iq mp b gy mz mw l mx my">       }      <br/>       return maxSum;</span><span id="5993" class="mt mu iq mp b gy mz mw l mx my">}</span></pre><p id="88db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Yayyy！！！我们得到了最大子阵列的和！利用滑动窗口算法，将运算时间减少到O(n)。干得好。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div></div>    
</body>
</html>