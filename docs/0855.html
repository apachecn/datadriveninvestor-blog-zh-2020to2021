<html>
<head>
<title>Change your Codes Behavior with Bitwise Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用按位运算符更改代码行为</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/change-your-codes-behavior-with-bitwise-operators-3055233d0d18?source=collection_archive---------13-----------------------#2020-02-19">https://medium.datadriveninvestor.com/change-your-codes-behavior-with-bitwise-operators-3055233d0d18?source=collection_archive---------13-----------------------#2020-02-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8c15311cd68e944640e03bf05fc66b73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GpM1HNZdtDbLGQJ4.jpg"/></div></div></figure><p id="d483" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们剖析一个奇怪的位标志程序，它花了我一秒钟的时间来理解。这样做，我们将有望更好地理解位掩码和按位OR逻辑如何有效地操作值。</p><p id="1fc4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">具体来说，我们要看的程序打印了open()函数(包含在<fcntl.h>库中)中使用的不同访问模式标志的二进制表示。访问模式标志的功能是指定要打开或创建的文件的权限。这些标志具有“对应于单个比特的值”，(<em class="kw">黑客:利用的艺术，</em>乔恩·埃里克森)，因此，这些标志可以被加在一起(使用OR运算符)以创建新的行为。让我们来看看下面的程序:</fcntl.h></p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kx"><img src="../Images/337cd6d2d2f6d9f3cbf0c0d282183d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yxlk7rBSipn-txkzmZ1ZQw.png"/></div></div></figure><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lc"><img src="../Images/305da24342cd604ae35e2817045e4c98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HGljoLiKsi3RXpkrJNeYrw.png"/></div></div></figure><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ld"><img src="../Images/986d5d217356a154eb47536ba2ebc93b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5RwVwyedZIb1JYFP5tg24w.png"/></div></div></figure><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi le"><img src="../Images/67062a666a68232b7ff4acafe0c7f650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q0BcOqCI61WezbxJFgpfNw.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">Courtesy of “Hacking: The Art of Exploitation, Jon Erickson”</figcaption></figure><p id="a6eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我第一次看到这个程序时，我不明白它在做什么——所以让我们浏览一下。首先，main()函数将访问模式标志的值发送给display_flags()函数。</p><p id="4026" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">display_flags函数打印访问模式标志的字符串和十进制值。Display_flags()然后将访问模式标志的十进制值发送到binary_print()。</p><div class="lj lk gp gr ll lm"><a href="https://www.datadriveninvestor.com/2019/02/21/best-coding-languages-to-learn-in-2019/" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab fo"><div class="lo ab lp cl cj lq"><h2 class="bd ir gy z fp lr fr fs ls fu fw ip bi translated">2019年最值得学习的编码语言|数据驱动的投资者</h2><div class="lt l"><h3 class="bd b gy z fp lr fr fs ls fu fw dk translated">在我读大学的那几年，我跳过了很多次夜游去学习Java，希望有一天它能帮助我在…</h3></div><div class="lu l"><p class="bd b dl z fp lr fr fs ls fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="lv l"><div class="lw l lx ly lz lv ma jw lm"/></div></div></a></div><p id="cdc4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Binary_print()有一个内外循环结构。我们使用一个值为4278190080的位掩码(“掩码”变量)(这个数字需要4个字节)。在二进制中，这个掩码看起来像八个1后面跟着二十四个0:</p><p id="2179" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">11111111000000000000000000000000</p><p id="1ca5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们有一个值为16777216的变量“shift ”,它看起来像一个二进制的1后面跟着24个0:</p><p id="b23f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">1000000000000000000000000</p><p id="607b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">外层循环运行四次，负责隔离每个字节。外部循环中的第一行代码:</p><p id="4774" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">byte =(值&amp;掩码)/shift；</p><p id="d48b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用访问模式标志的值和掩码的值执行按位AND运算。然后将结果运算的乘积除以移位，从而只保存最左边的八位。这里有一个例子:</p><p id="9a15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">值= 10000000000</p><p id="2534" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">mask = 1111111100000000</p><p id="f011" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">shift = 100000000</p><p id="8b6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">价值</p><p id="b78c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">&amp;遮罩</p><p id="f764" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">_ _ _ _ _ _ _ _ _ _ _ _ _ _ = 1000000000/shift = 00000100</p><p id="1844" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，字节变量将保存值4。</p><p id="98d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们分离出每个字节，我们就进入内部循环。内部循环遍历字节中的每个位，并检查msb(最高有效位(最左边的位))是否已设置。如果是，我们打印一个“1”。如果不是，我们打印一个“0”。打印该位后，我们通过将字节乘以2，将字节向左移位(获得新的msb ):</p><p id="80a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">字节*= 2</p><p id="47d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">《出埃及记》四变成八:</p><p id="f2f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">A = 00000100</p><p id="037e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">A *= 2</p><p id="42f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">A = 00001000</p><p id="c321" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按照内部循环，我们将掩码和移位变量除以8，以便将位向右移动8位。我们这样做是为了检查我们的值中的低位是否被设置。我们重复这个过程:隔离下一个字节，检查msb是否置位，并将位向左移位，以便我们可以检查下一个msb的四个字节。</p><p id="a93f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在此过程结束时，我们将获得访问模式标志的完整二进制表示。虽然这本身并不十分有用，但它可能有助于进一步的低级编程工作，即拥有一个可以快速生成您正在查看的任何内容的二进制表示的函数。如果没有别的，对程序中的位是如何移动的有一个坚实的理解是很好的，因为它可以让你思考优化代码的时间和空间复杂度的方法。</p><p id="7200" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在结束之前，我想演示一下OR位运算符如何用作加法运算符。O_WRONLY标志的值为1，O_APPEND标志的值为1024，O_CREAT标志的值为64。当我们调用display_flags()并打印O_WRONLY|O_APPEND|O_CREAT的十进制表示时，得到的是1089(与它们相加的结果相同)。只要每个数字中的所有位都是唯一的，这种方法就会一直有效。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mb"><img src="../Images/7de46f154b4fb56e086ca3c2af8cdf4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kjRRp2fLT4YZuPnYAPi-8Q.png"/></div></div></figure><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mc md l"/></div></figure></div></div>    
</body>
</html>