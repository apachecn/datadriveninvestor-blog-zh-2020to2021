<html>
<head>
<title>Learn to Python: Codewars 6kyu question</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习Python: Codewars 6kyu问题</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/learn-to-python-codewars-6kyu-question-cff75a33b518?source=collection_archive---------2-----------------------#2020-03-24">https://medium.datadriveninvestor.com/learn-to-python-codewars-6kyu-question-cff75a33b518?source=collection_archive---------2-----------------------#2020-03-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1af5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解决编码挑战是提高编程语言的一个很好的方法。在本文中，我们将使用Python解决一个6kyu Codewars问题。我还会在底部放一个我反复解决这个问题的YouTube视频的链接。</p><p id="afae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们开始吧！</p><p id="a9bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是个问题:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/1a5ffb9ae7f3428b2cc024640cbdb1a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JUx3Z6rsxtWTiZgS2q1UOQ.png"/></div></div></figure><p id="6022" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">给我们两个字符串数组，<em class="kx"> a1 </em>和<em class="kx"> a2 </em>，要求我们找出<em class="kx"> a1 </em>中的哪些字符串是<em class="kx"> a2 </em>中的字符串的子字符串。我们将把这些字符串存储在一个数组中，对它们进行排序，并返回数组作为结果。我们将定义该函数:</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="fcc3" class="ld le iq kz b gy lf lg l lh li">def in_array(array1, array2):</span></pre><p id="c4ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要查找a1中的所有字符串，我们必须遍历a1中的字符串:</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="c04e" class="ld le iq kz b gy lf lg l lh li">def in_array(array1, array2):<br/>    for item in array1:</span></pre><p id="511f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个for循环的每次迭代中，我们将检查array1中的一个项目，我们希望检查它们是否是array2中任何字符串的子串。因此，我们必须在第一个for循环中启动另一个循环来检查array2中的每一项:</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="a8c3" class="ld le iq kz b gy lf lg l lh li">def in_array(array1, array2):<br/>    for item in array1:<br/>        for item2 in array2:</span></pre><p id="2bbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Python <em class="kx"> in </em>关键字检查第一项是否包含在第二项中(或者说，第二项的子串):</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="99d1" class="ld le iq kz b gy lf lg l lh li">def in_array(array1, array2):<br/>    for item in array1:<br/>        for item2 in array2:<br/>            if item in item2:</span></pre><p id="e758" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个阶段，我们知道<em class="kx">项</em>满足我们的要求，并希望将<em class="kx">项</em>存储在一个数组中以便稍后返回。所以我们将在for循环之外定义一个名为<em class="kx"> result </em>的数组——我们不想在每次迭代中重新定义<em class="kx"> result </em>数组。我们还想确保我们不会在<em class="kx">结果</em>数组中存储重复的数据。如例1所示，array1中的“arp”是array2中“harp”和“sharp”的子串，但在返回的数组中，我们只需要它的一个实例。因此，在if语句中，我们将放入另一个条件，以确保在将<em class="kx">项</em>追加到<em class="kx">结果</em>数组之前，它还不在<em class="kx">结果</em>中:</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="0bf5" class="ld le iq kz b gy lf lg l lh li">def in_array(array1, array2): <br/>    result = []<br/>    for item in array1:<br/>        for item2 in array2:<br/>            if item in item2 and item not in result:<br/>                result.append(item)</span></pre><p id="599f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，为了获得一个按字典顺序排列的数组，我们将使用内置的Python方法。排序()并返回结果:</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="fe93" class="ld le iq kz b gy lf lg l lh li">def in_array(array1, array2): <br/>    result = []<br/>    for item in array1:<br/>        for item2 in array2:<br/>            if item in item2 and item not in result:<br/>                result.append(item)<br/>                continue<br/>    result.sort()<br/>    return result</span></pre><p id="444c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了节省计算时间，我在将<em class="kx">项</em>添加到<em class="kx">结果</em>后添加了关键字<em class="kx">继续</em>。当if条件满足时，它将基本上停止执行第二个循环，并继续第一个循环中的下一次迭代。如果没有<em class="kx">继续</em>，第二个<em class="kx"> </em>循环将迭代数组2的全长，即使我们已经追加了<em class="kx">项</em>。这是不必要的，并且随着array2变大，计算量会很大。</p><div class="lj lk gp gr ll lm"><a href="https://www.datadriveninvestor.com/2019/03/25/a-programmers-guide-to-creating-an-eclectic-bookshelf/" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab fo"><div class="lo ab lp cl cj lq"><h2 class="bd ir gy z fp lr fr fs ls fu fw ip bi translated">创建折衷书架的程序员指南|数据驱动的投资者</h2><div class="lt l"><h3 class="bd b gy z fp lr fr fs ls fu fw dk translated">每个开发者都应该有一个书架。他的内阁中可能的文本集合是无数的，但不是每一个集合…</h3></div><div class="lu l"><p class="bd b dl z fp lr fr fs ls fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="lv l"><div class="lw l lx ly lz lv ma kv lm"/></div></div></a></div><p id="c71b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我挣扎的视频:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="md mc l"/></div></figure></div></div>    
</body>
</html>