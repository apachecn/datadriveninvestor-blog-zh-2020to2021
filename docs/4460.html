<html>
<head>
<title>Angular / RxJS — Top 5 ways to unsubscribe from Observables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">angular/RxJS——取消订阅可观项目的5大方法</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/angular-rxjs-top-5-ways-to-unsubscribe-from-observables-6e8d0a7226c?source=collection_archive---------4-----------------------#2020-08-09">https://medium.datadriveninvestor.com/angular-rxjs-top-5-ways-to-unsubscribe-from-observables-6e8d0a7226c?source=collection_archive---------4-----------------------#2020-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9bf080cccda71b5fe567488293d0e726.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oGfAtBYiAfeZRjBgCxe34w.png"/></div></div></figure><h1 id="8e70" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">1.手动呼叫取消订阅()</h1><p id="4cb2" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">Angular有一个在拆卸阶段调用的<code class="fe lx ly lz ma b">ngOnDestroy</code>钩子，提供垃圾收集。</p><p id="e301" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">当我们在Angular的组件中使用Observables时，我们应该设置ngOnDestroy方法，并对所有Observables调用unsubscribe方法。</p><pre class="mg mh mi mj gt mk ma ml mm aw mn bi"><span id="5ba8" class="mo kc it ma b gy mp mq l mr ms">@Component({...})<br/>export class MessageComponent implements OnInit, OnDestroy {<br/>  messageSub: Subscription;<br/>  <br/>  ngOnInit () {<br/>    const messages$ = this.messageService.getMessages();<br/>    this.messageSub = messages$.subscribe()</span><span id="c273" class="mo kc it ma b gy mt mq l mr ms">  ngOnDestroy() {<br/>    this.messageSub.unsubscribe()<br/>  }<br/>}</span></pre><p id="d205" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">我们将ngOnDestroy添加到AppCompoennt中，并在<code class="fe lx ly lz ma b">this.messageSub</code> Observable上调用unsubscribe方法。</p><p id="703d" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">如果有多个订阅，请考虑将它们推送到一个数组中。AppComponent中有两个订阅。它们都在ngOnDestroy钩子中被取消订阅，以防止内存泄漏。</p><pre class="mg mh mi mj gt mk ma ml mm aw mn bi"><span id="6bbb" class="mo kc it ma b gy mp mq l mr ms">@Component({...})<br/>export class AppComponent implements OnInit, OnDestroy {<br/>  messages$: Subscription;<br/>  currentUser$: Subscription;<br/>  subscriptions: Subscription[];</span><span id="b730" class="mo kc it ma b gy mt mq l mr ms">  ngOnInit () {<br/>    const messages$ = this.messageService.getMessages();<br/>    const currentUser$ = this.userService.currentUser();<br/>    this.subscriptions.push(messages$, currentUser$);</span><span id="6362" class="mo kc it ma b gy mt mq l mr ms">  ngOnDestroy() {<br/>    [...this.subscriptions].map(sub =&gt; sub.unsubscribe());<br/>  }<br/>}</span></pre><h1 id="c0b2" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">2.使用异步<code class="fe lx ly lz ma b">|</code>管道</h1><p id="5915" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated"><code class="fe lx ly lz ma b">async</code>管道订阅一个<code class="fe lx ly lz ma b">Observable</code>或<code class="fe lx ly lz ma b">Promise</code>并返回最新发出的值。当组件被破坏时，<code class="fe lx ly lz ma b">async</code>管道会自动取消订阅，以避免潜在的内存泄漏。</p><pre class="mg mh mi mj gt mk ma ml mm aw mn bi"><span id="7307" class="mo kc it ma b gy mp mq l mr ms">@Component({<br/>    ...,<br/>    template: `<br/>        &lt;div class="messages" *ngIf="<strong class="ma iu">messages$ | async as message</strong>"&gt;<br/>         &lt;div class="item" *ngFor="let message of messages"&gt;<br/>           &lt;span [innerText]="message.text"&gt;&lt;/span&gt;<br/>           &lt;/div&gt;<br/>        &lt;/div&gt;<br/>    `<br/>})<br/>export class AppComponent implements OnInit {<br/>    messages$: Observale&lt;Messages[]&gt;<br/>    ngOnInit () {<br/>        this.messages$ = this.messageService.getMessages();<br/>    }<br/>}</span></pre><p id="6353" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">如果我们在组件中使用Observables，使用异步管道是一个巨大的优势，因为它会自动订阅/取消订阅它们。我们不必手动取消订阅应用程序中的可观测量。</p><div class="mu mv gp gr mw mx"><a href="https://www.datadriveninvestor.com/2020/05/27/clean-code-is-crucial-in-software-development-heres-why/" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">干净的代码在软件开发中至关重要——这就是为什么|数据驱动投资者</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">干净的代码是“容易理解和容易改变的”，它是关于对细节的关注。但是开发人员为什么要担心…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl jz mx"/></div></div></a></div><h1 id="914e" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">3.使用RxJS <code class="fe lx ly lz ma b">take*</code>运算符</h1><p id="5456" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">RxJS有许多有用的操作符，我们可以用它们在应用程序中取消订阅。他们由<code class="fe lx ly lz ma b">take*</code>系列运营商组成:</p><ul class=""><li id="c37d" class="nm nn it lb b lc mb lg mc lk no lo np ls nq lw nr ns nt nu bi translated"><strong class="lb iu">取(</strong>金额:数量<strong class="lb iu"> ) </strong></li><li id="b84d" class="nm nn it lb b lc nv lg nw lk nx lo ny ls nz lw nr ns nt nu bi translated"><strong class="lb iu"> takeUntil( </strong>通知者:可观察<strong class="lb iu"> ) </strong></li><li id="a23f" class="nm nn it lb b lc nv lg nw lk nx lo ny ls nz lw nr ns nt nu bi translated"><strong class="lb iu"> takeWhile( </strong>条件:可观察)</li></ul><h1 id="5109" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">拿走</h1><p id="2da6" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">该运算符使订阅执行一次。该操作符使源订阅发生指定的次数<code class="fe lx ly lz ma b">n</code>并完成。</p><p id="91a7" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated"><code class="fe lx ly lz ma b">1</code>通常与take操作符一起使用，因此订阅发生一次就退出。</p><p id="5b35" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">当我们希望一个源可观察对象发出一次，然后从流中取消订阅时，这个操作符是有效的；在使用路径解析器时尤其有用，只需调用take(1)来确保获得一个数据源，以便解析器可以移动到下一个数据集。</p><pre class="mg mh mi mj gt mk ma ml mm aw mn bi"><span id="8f4a" class="mo kc it ma b gy mp mq l mr ms">@Component({<br/>    ...<br/>})<br/>export class MessageComponent implements OnInit {<br/>    ngOnInit () {<br/>        const messages$ = this.messageService.getMessages()<br/>        <br/>        messages$.pipe(take(1)).subscribe();<br/>     }<br/>}</span></pre><h1 id="e031" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">takeUntil(通知程序)</h1><p id="93af" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">该操作符发出由源可观察对象发出的值，直到通知者可观察对象发出一个值。</p><pre class="mg mh mi mj gt mk ma ml mm aw mn bi"><span id="1801" class="mo kc it ma b gy mp mq l mr ms">@Component({...})<br/>export class AppComponent implements OnInit, OnDestroy {<br/>    destroyed$ = new Subject&lt;boolean&gt;();</span><span id="af00" class="mo kc it ma b gy mt mq l mr ms">  ngOnInit () {<br/>    const messages$ = this.messageService.getMessages();    <br/>    messages$$.pipe(takeUntil(this.destroyed$)).subscribe();<br/>  }    <br/>  <br/>  ngOnDestroy() {<br/>    this.destroyed$.next(true);<br/>    this.destroyed$.unsubscribe();<br/>    }<br/>}</span></pre><p id="1eb9" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">我们有一个额外的通知主题，这是用来让<code class="fe lx ly lz ma b">this.destroyed$</code>取消订阅的。在我们订阅之前，我们用管道把可观察的东西输送到。takeUntil将发出间隔发出的值，直到<code class="fe lx ly lz ma b">destroyed$</code>主题发出，然后它将取消订阅<code class="fe lx ly lz ma b">messages$</code></p><h1 id="0e08" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">takeWhile(条件)</h1><p id="8d82" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated"><code class="fe lx ly lz ma b">takeWhile</code>是另一个强大的操作符，但是如果您需要条件中的数据，就不要使用它。对于那些场景，建议坚持使用<code class="fe lx ly lz ma b">takeUntil</code>，并使用一个主题实例来触发它。</p><pre class="mg mh mi mj gt mk ma ml mm aw mn bi"><span id="3812" class="mo kc it ma b gy mp mq l mr ms">// 1, 2, 3, 4, 5<br/>const array$ = of(1, 2, 3, 4, 5);</span><span id="1171" class="mo kc it ma b gy mt mq l mr ms">array$.pipe(takeWhile(val =&gt; val &lt;= 4))</span></pre><h1 id="4b4d" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">如果这对你有帮助，请鼓掌！🙏</h1><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/310b4e51aaa4b87c9fd2261939a32732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6iaKPnfvW92K2LUrxempHw.gif"/></div></div></figure><p id="72eb" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated"><strong class="lb iu">访问专家视图— </strong> <a class="ae ob" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>