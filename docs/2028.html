<html>
<head>
<title>Deploy Stack To Docker Swarm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将堆栈部署到Docker Swarm</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/deploy-stack-to-docker-swarm-1b23582d0279?source=collection_archive---------3-----------------------#2020-04-10">https://medium.datadriveninvestor.com/deploy-stack-to-docker-swarm-1b23582d0279?source=collection_archive---------3-----------------------#2020-04-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dde20e61eb4e12e708c36befa3d945fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ddhn6dsnSruEGHYyxw0gQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Docker Swarm</figcaption></figure><p id="380f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这篇博客中，我将通过部署一个由Python应用程序组成的应用程序向您展示，该应用程序在Redis实例中维护一个计数器，并在您访问它时递增该计数器。这不是一个介绍性的教程，但我将来会创建一个。</p><p id="33c3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Docker swarm是Docker(从1.12版本开始)的新增功能。它旨在使用Docker CLI轻松管理多个主机上的容器调度。</p><h1 id="8fa2" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">首要的</h1><p id="c19b" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">1]应配置docker群组模式<br/> 2]应安装docker-compose 1.10或更高版本</p><p id="c4ab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意</strong>:如果您正在本地开发环境中进行尝试，您可以将您的引擎置于swarm模式，而<strong class="ke ir"> </strong>如果您已经运行了一个多节点swarm，请记住所有命令都必须从一个管理节点运行。</p><p id="9726" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，检查docker swarm模式是否配置正确:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi md"><img src="../Images/fa5ae6cedd6c6fcf0802a8df41c751db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sc7s0uyH-6asJYINm28oNQ.png"/></div></div></figure><p id="dd33" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，设置docker注册中心，因为一个群由多个Docker引擎组成，需要一个注册中心来向所有引擎分发图像。在你的swarm上启动注册表并检查它的状态。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/dde354911d441945463b6f317d7797e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qamWsymXvEqscoGhiKbtUg.png"/></div></div></figure><p id="88b1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">部署一个应用程序来理解要群集的堆栈，现在创建一个工作区，所有需要的程序都将在这里编写。首先在项目工作区中创建一个名为app.py的文件，并在其中编写这段代码。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/cb3e5f2a17c15610235e5d4affea8576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MwbQ9GfaDTEPj27ZHjK1vQ.png"/></div></div></figure><p id="ae28" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">创建一个名为<code class="fe mk ml mm mn b">requirements.txt</code>的文件，并将这两行写入:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/30f458682f4e0e3ad7bc261db39007e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xREoyWQAaSlxxEwnnyP4hw.png"/></div></div></figure><p id="60e6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">创建一个名为<code class="fe mk ml mm mn b">Dockerfile</code>的文件和一个名为<code class="fe mk ml mm mn b">docker-compose.yml</code>的文件，分别写几行。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/9920da41ce338ec04d4242fd3e806450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FTUV7gO8N7jrJI5DPAaRTg.png"/></div></div></figure><p id="4d0d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用<code class="fe mk ml mm mn b">docker-compose up</code>启动应用程序，开始撰写。这将构建web应用程序映像，如果您还没有Redis映像，则提取它，并创建两个容器。</p><div class="mq mr gp gr ms mt"><a href="https://www.datadriveninvestor.com/2020/03/29/microsoft-having-an-edge-over-chrome/" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">数据驱动的投资者|微软比Chrome有“优势”</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">简史我从来不是浏览器的粉丝，确切地说，我只是一个浏览器的粉丝，Chrome。这是我的…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh jw mt"/></div></div></a></div><p id="25a5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您会看到一个关于引擎处于群集模式的警告。这是因为Compose没有利用群体模式，而是将所有内容部署到单个节点上。您可以放心地忽略这一点。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/37785aa4fcd8d7d468644da985d606a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dmDOHLHnb5TxbJq8GFHHYw.png"/></div></div></figure><p id="eacf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用<code class="fe mk ml mm mn b">docker-compose ps command :</code>检查应用程序是否正在运行</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/99cf0b2e9b1880d84c6f60389ccac1e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uLz5opChSdilFrup19sZDQ.png"/></div></div></figure><p id="cfb7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，您可以使用curl命令或在chrome中使用端口号浏览节点IP来测试应用程序。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/ca659c9c324b3a877151128ad14cd3ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ub6UBNH5iACEWnjAgXgb7g.png"/></div></div></figure><p id="4dc4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">之后，在将生成的图像放入注册表之前，关闭应用程序。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/b65c2fe9993477323c5598f071a03d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G30LhLgcKbPxaFAtRqIXLg.png"/></div></div></figure><p id="0071" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了在整个群体中分发web应用程序的图像，需要将它推送到您之前设置的注册中心。使用Compose，这非常简单:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/3d7d69adc679174585d18f313e27cd14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVRCcL8dJOA6kdJoz8BREQ.png"/></div></div></figure><p id="b040" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在可以部署堆栈了，用<code class="fe mk ml mm mn b">docker stack deploy </code>创建堆栈。最后一个参数是堆栈的名称。每个网络、卷和服务名称都以堆栈名称为前缀，并检查它是否与<code class="fe mk ml mm mn b">docker stack services demo:</code>一起运行。一旦运行，您应该会看到两个服务的<code class="fe mk ml mm mn b">REPLICAS</code>下的<code class="fe mk ml mm mn b">1/1</code>。如果您有一个多节点群，这可能需要一些时间，因为需要提取图像。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/d729e5887e39dc35009f1f724a2515b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6AIoDgokL7tyX5-ry720aA.png"/></div></div></figure><p id="4a32" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">像以前一样，你可以用<code class="fe mk ml mm mn b">curl and </code>测试应用程序由于Docker内置的路由网格，你可以在端口8000上访问swarm中的任何节点，并路由到应用程序:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/96989de7172aa4b359278b30e1c43c4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0JtiijroufCJmWg4Nt6osg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Chrome with connecting with container</figcaption></figure><p id="4a19" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是我和Docker Swarm合作的经历。我考虑过其他选择，但在我看来。对于最简单的所需文件已经在这里找到:<a class="ae np" href="https://github.com/VarshitAgarwal/Docker_Swarm.git" rel="noopener ugc nofollow" target="_blank">https://github.com/VarshitAgarwal/Docker_Swarm.git</a>。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div></div>    
</body>
</html>