<html>
<head>
<title>Alternative Hyperparameter Optimization Techniques You Need to Know — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您需要知道的替代超参数优化技术—第3部分</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/alternative-hyperparameter-optimization-techniques-you-need-to-know-part-3-efc93489a27f?source=collection_archive---------4-----------------------#2020-10-05">https://medium.datadriveninvestor.com/alternative-hyperparameter-optimization-techniques-you-need-to-know-part-3-efc93489a27f?source=collection_archive---------4-----------------------#2020-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8b11" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">微调机器学习模型以提高性能的不同方法。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5af9a1bfe6bc5926afe7aaa84530a0cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fb3xkQ230N6sKZoi7yT_-g.png"/></div></div></figure><p id="81b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是本系列的第三部分，也是最后一部分，重点介绍您需要了解的备选超参数优化技术。在第一部分中，我们看了最常用的方法(GridsearchCV和randomizedSearchCV)和第一种替代方法，称为<strong class="kt ir">hyperpt</strong>(点击<a class="ae ln" href="https://medium.com/datadriveninvestor/alternative-hyperparameter-optimization-techniques-you-need-to-know-part-1-3f68d0448fcd" rel="noopener">此处</a>阅读第一部分)。在第二部分中，我们看了另一种替代的超参数优化技术，称为<strong class="kt ir"> scikit-optimize </strong>(点击<a class="ae ln" href="https://medium.com/datadriveninvestor/alternative-hyperparameter-optimization-techniques-you-need-to-know-part-2-e9b0d4d080a9" rel="noopener">此处</a>阅读第二部分)。</p><p id="6fec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们学习第三种可选的超参数优化技术。</p><h1 id="8250" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><strong class="ak"> Optuna </strong></h1><p id="1b47" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">Optuna是另一个用于超参数优化的开源python框架，它使用贝叶斯方法来自动搜索超参数空间。该框架由一家名为Preferred Networks的日本人工智能公司开发。Optuna提供了一种比Hyperopt更容易实现和使用的方法。您还可以指定优化过程应该持续多长时间。</p><h1 id="58fa" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">Optuna的特征</h1><p id="345d" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">Optuna包含至少5个您需要了解的重要特性，以便运行您的第一次优化。</p><h2 id="cd8d" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">(a)搜索空间</h2><p id="4e74" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">Optuna为所有超参数类型提供了不同的选项。最常见的选择如下。</p><ul class=""><li id="be26" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated"><strong class="kt ir">分类参数</strong>:使用<strong class="kt ir">trials . suggest _ categorial()</strong>方法，需要提供参数的名称及其选择。</li><li id="ad66" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">整型参数:</strong>使用<strong class="kt ir"> trials.suggest_int() </strong>方法，需要提供参数的名称，低值和高值。</li><li id="2b61" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir"> Float参数:</strong>使用<strong class="kt ir"> trials.suggest_float() </strong>方法时，需要提供参数的名称，低值和高值。</li><li id="19e6" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">连续参数:</strong>使用<strong class="kt ir">trials . suggest _ uniform()</strong>方法，需要提供参数的名称，低值和高值。</li><li id="d3db" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">离散参数:</strong>使用<strong class="kt ir">trials . suggest _ Discrete _ uniform()</strong>方法，需要提供参数的名称，低值，高值，以及离散化的步长。</li></ul><h2 id="af7a" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">优化方法(采样器)</h2><p id="f1f9" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">Optuna提供了不同的方法来执行超参数优化过程。最常见的方法是:-</p><ul class=""><li id="0455" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated"><a class="ae ln" href="https://optuna.readthedocs.io/en/stable/reference/generated/optuna.samplers.GridSampler.html" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">grid sampler</strong></a><strong class="kt ir">:</strong>它采用网格搜索，在研究过程中试验建议给定搜索空间中的所有参数组合。</li><li id="8163" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><a class="ae ln" href="https://optuna.readthedocs.io/en/stable/reference/generated/optuna.samplers.GridSampler.html" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">random sampler</strong></a><strong class="kt ir">:</strong>它采用随机抽样。该采样器基于独立采样。</li><li id="6bc3" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><a class="ae ln" href="https://optuna.readthedocs.io/en/stable/reference/generated/optuna.samplers.TPESampler.html" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">TPE sampler</strong></a><strong class="kt ir">:</strong>使用TPE(Tree-structured Parzen Estimator)算法。</li><li id="b1f3" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><a class="ae ln" href="https://optuna.readthedocs.io/en/stable/reference/generated/optuna.samplers.CmaEsSampler.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> CmaEsSampler </strong> </a>:使用CMA-ES算法。</li></ul><h2 id="e5c2" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">目标函数</h2><p id="c307" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">关于目标函数的解释与远视和scikit优化技术相同。唯一的区别是Optuna允许您在one函数中定义搜索空间和目标。</p><p id="d68e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="1877" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">研究</h2><p id="12e9" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">一项研究对应于一项优化任务(一组试验)。如果您需要开始优化过程，您需要创建一个研究对象，并将目标函数传递给一个名为<strong class="kt ir"> optimize() </strong>的方法，并按如下方式设置试验次数。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="064a" class="ml lp iq no b gy ns nt l nu nv">study = optuna.create_study()<br/>study.optimize(objective, n_trials=100)</span></pre><p id="92a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> create_study() </strong>方法允许您选择是<em class="nw">最大化</em>还是<em class="nw">最小化</em>您的目标函数。这是我喜欢optuna的有用特性之一，因为您可以选择优化过程的方向。</p><p id="e419" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> NB: </strong>你将在一个实际的例子中学习如何实现。</p><h2 id="7897" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">可视化</h2><p id="9113" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">Optuna中的可视化模块提供了不同的方法来创建优化结果的图形。这些方法有助于您获得关于参数之间的相互作用以及如何前进的信息。这里有一些你可以使用的方法。</p><ul class=""><li id="dd29" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated"><strong class="kt ir"> plot_contour() </strong>:该方法将参数关系绘制为病历报告中的等高线图。</li><li id="bae2" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">plot _ intermediate _ values():</strong>此方法绘制研究中所有试验的中间值。</li><li id="aeab" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">plot _ optimization _ history():</strong>此方法绘制研究中所有试验的优化历史。</li><li id="d8d9" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">plot _ param _ importances():</strong>该方法绘制超参数重要性及其值。</li><li id="c5e9" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir"> plot_edf(): </strong>该方法绘制研究的目标值edf(经验分布函数)。</li></ul><p id="f511" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">注意:</strong>我们将在实际例子中使用上面提到的一些方法。</p><h1 id="08bf" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">实践中的Optuna</h1><p id="baaa" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">现在你已经知道了Optuna的重要特性，在这个实际的例子中，我们将使用<strong class="kt ir">手机价格数据集</strong>，任务是创建一个模型来预测手机的价格有多高0( <em class="nw">低成本</em>)或1( <em class="nw">中成本</em>)或2( <em class="nw">高成本</em>)或3( <em class="nw">非常高成本</em>)。</p><h2 id="a0f5" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">安装Optuna</h2><p id="9596" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">您可以通过以下方式安装最新版本:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="a876" class="ml lp iq no b gy ns nt l nu nv">pip install optuna</span></pre><p id="1b17" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后导入重要的包包括optuna。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="9b5b" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">资料组</h2><p id="05d4" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">让我们从数据目录加载数据集。要了解更多关于数据集的信息，请阅读此处的<a class="ae ln" href="https://www.kaggle.com/iabhishekofficial/mobile-price-classification?select=train.csv" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="6259" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">检查数据集的前五行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/62c02e16cf204dff4315ecb73287924d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3iow1sGPedf4uxD6xiaClA.png"/></div></div></figure><p id="76a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，在我们的数据集中，我们有不同的带有数值的要素。</p><p id="7e13" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们观察数据集的形状。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="bfca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi">(2000, 21)</p><p id="4f67" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个数据集中，我们有<em class="nw"> 2000行</em>和<em class="nw"> 21列</em>。现在，让我们来了解一下该数据集中的要素列表。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="f06b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">['battery_power '，' blue '，' clock_speed '，' dual_sim '，' fc '，' four_g '，' int_memory '，' m_dep '，' mobile_wt '，' n_cores '，' pc '，' px_height '，' px_width '，' ram '，' sc_h '，' sc_w '，' talk_time '，' three_g '，' touch_screen '，' wifi '，' price_range']</p><p id="5742" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以在这里找到每个栏目名称<a class="ae ln" href="https://www.kaggle.com/iabhishekofficial/mobile-price-classification" rel="noopener ugc nofollow" target="_blank">的含义。</a></p><div class="ny nz gp gr oa ob"><a href="https://www.datadriveninvestor.com/2020/08/27/what-is-a-data-catalog-and-how-does-it-enable-machine-learning-success/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">什么是数据目录，它如何使机器学习取得成功？数据驱动的投资者</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">数据目录是机器学习和数据分析的燃料。没有它，你将不得不花费很多…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op kp ob"/></div></div></a></div><h2 id="36a4" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">将数据集分割成目标要素和独立要素</h2><p id="f7ec" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这是一个分类问题，我们将从数据集中分离目标特征和独立特征。我们的目标特征是<strong class="kt ir">价格范围</strong>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="25ef" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">预处理数据集。</h2><p id="69cc" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">然后使用scikit-learn中的<a class="ae ln" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html" rel="noopener ugc nofollow" target="_blank">standard scaler</a>方法对独立特征进行标准化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="d310" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">在一个函数中定义搜索空间和目标。</h2><p id="68e2" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">正如我之前解释过的，Optuna允许你在一个函数中定义搜索空间和目标。我们将为随机森林模型的以下超参数定义搜索空间:</p><ul class=""><li id="e73b" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated"><strong class="kt ir"> n_estimators </strong> —森林中树木的数量。</li><li id="8cc6" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir"> max_depth </strong> —树的最大深度。</li><li id="d133" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">标准</strong> —测量分割质量的功能。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4624" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使用<strong class="kt ir">trial . suggest _ categorial()</strong>方法为<em class="nw"> max_depth </em>和<em class="nw"> n_estimators </em>的<em class="nw">准则</em>和<strong class="kt ir"> trial.suggest_int() </strong>定义搜索空间。<br/>同样，我们使用交叉验证来避免过度拟合，然后函数将返回平均精度。</p><h2 id="0a06" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">创建研究对象</h2><p id="284f" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">然后，我们创建一个与优化任务相对应的研究对象。<strong class="kt ir"> create-study() </strong>方法允许我们提供研究的名称、优化的方向(<em class="nw">最大化</em>或<em class="nw">最小化</em>)以及我们想要使用的优化方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="f8f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的例子中，我们将我们的研究对象命名为<strong class="kt ir">randomForest _ optimization</strong>，优化的方向是<strong class="kt ir"> maximize </strong>(意味着分数越高越好)，使用的优化方法是<strong class="kt ir"> TPESampler()。</strong></p><h2 id="d465" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">微调模型</h2><p id="64e4" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">为了运行优化过程，我们需要在<strong class="kt ir"> optimize() </strong>方法中从我们创建的研究对象中传递目标函数和试验次数。我们将试验次数设置为10次(如果您想进行更多试验，可以更改次数)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="8438" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">输出:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/fdee69e8aaaa996c034a6352795fc3a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UQbAMTbKXfARlLffDDzYGw.png"/></div></div><figcaption class="or os gj gh gi ot ou bd b be z dk">Trials output.</figcaption></figure><p id="5e84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们可以打印出最佳精度和所用的选定超参数值。</p><p id="978e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(a)显示所选的最佳超参数值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="833a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">输出:</strong> { '准则':'熵'，'最大深度':8，' n _估计量':700}</p><p id="ce38" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(b)显示最佳得分或准确性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ef9f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">输出:</strong> 0.871499999999999。</p><p id="c8d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们最好的成绩是87.15%左右。</p><h2 id="74b4" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">地块优化历史</h2><p id="78d1" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们可以使用Optuna中的<strong class="kt ir">plot _ optimization _ history()</strong>方法来绘制研究中所有试验的优化历史。我们只需要在方法中传递优化的学习对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/26e3bda43a471e2cfa3c1369573c6249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wXhHRfoh2SVZoGJFDuogxg.png"/></div></div></figure><p id="f9aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该图显示了优化过程中不同试验的最佳值。</p><h2 id="65c2" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">绘图超参数重要性</h2><p id="f0ed" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">Optuna提供了一个名为<strong class="kt ir">plot _ param _ importances()</strong>的方法来绘制超参数重要性。我们只需要在方法中传递优化的学习对象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/043e67afc964ec3913baf7dd5cba1d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7QQ-fTuM7fylwmzmZBAWWA.png"/></div></div></figure><p id="e412" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从上图可以看出，最大深度是最重要的超参数。</p><h2 id="8566" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">保存和加载超参数搜索</h2><p id="b1e8" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">您可以使用<strong class="kt ir"> joblib </strong>包保存并加载超参数搜索。</p><p id="2b60" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(a)保存超参数搜索。<br/>我们将把超参数搜索保存在optuna_searches目录中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="b4d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(b)加载超参数搜索。<br/>然后，如果您想从optuna_searches目录加载超参数搜索，您可以使用joblib中的<strong class="kt ir"> load() </strong>方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="23b6" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">包扎</h1><p id="3e58" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">祝贺您，您已经完成了本系列的第二篇文章。！</p><p id="b189" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以在这里下载本文用到的数据集和笔记本:<br/><a class="ae ln" href="https://github.com/Davisy/Hyperparameter-Optimization-Techniques" rel="noopener ugc nofollow" target="_blank">https://github . com/Davisy/Hyperparameter-Optimization-Techniques</a></p><p id="401a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们来看看从第1部分到第3部分讨论的3种超参数优化技术选择的总体得分和超参数值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/5775e8c7f4ffa15343427ec305d927dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*640_y3cO6zxWiWXF-PIBjg.png"/></div><figcaption class="or os gj gh gi ot ou bd b be z dk">Optimization techniques overview</figcaption></figure><p id="f3f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每种技术呈现的结果彼此没有太大的不同。所选择的迭代或试验的次数非常重要。对我来说，Optuna提供了一种简单的实现方式，是我首选的超参数优化技术。请让我知道你的想法！</p><p id="7f4a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你学到了新的东西或者喜欢阅读这篇文章，请分享给其他人看。在那之前，我的下一篇文章再见！。也可以在推特上找到我<a class="ae ln" href="https://twitter.com/Davis_McDavid" rel="noopener ugc nofollow" target="_blank"> @Davis_McDavid </a></p><p id="814b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="nw">最后一件事:</em> </strong> <em class="nw">在以下链接中阅读更多类似这样的文章。</em></p><div class="ny nz gp gr oa ob"><a href="https://medium.com/datadriveninvestor/how-to-use-tree-based-algorithms-for-machine-learning-9da624c75755" rel="noopener follow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">如何使用基于树的算法进行机器学习</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">使用和理解随机森林算法的指南</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">medium.com</p></div></div><div class="ok l"><div class="oy l om on oo ok op kp ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a href="https://medium.com/analytics-vidhya/how-to-write-configuration-files-in-your-machine-learning-project-47bc840acc19" rel="noopener follow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">如何在你的机器学习项目中写配置文件？</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">用配置文件管理参数和初始设置。</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">medium.com</p></div></div><div class="ok l"><div class="oz l om on oo ok op kp ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a href="https://towardsdatascience.com/14-lesser-known-impressive-features-of-scikit-learn-library-e7ea36f1149a" rel="noopener follow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">Scikit学习库的14个鲜为人知的令人印象深刻的特性。</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">scikit学习库中经常未知和被低估的功能示例。</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">towardsdatascience.com</p></div></div><div class="ok l"><div class="pa l om on oo ok op kp ob"/></div></div></a></div><h2 id="ac91" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">访问专家视图— <a class="ae ln" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank">订阅DDI英特尔</a></h2></div></div>    
</body>
</html>