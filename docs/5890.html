<html>
<head>
<title>Go Beyond Mock: on Mocks, Stubs and Fakes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超越模仿:模仿，存根和假货</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/go-beyond-mock-on-mocks-stubs-and-fakes-e8b1888932f9?source=collection_archive---------4-----------------------#2020-10-04">https://medium.datadriveninvestor.com/go-beyond-mock-on-mocks-stubs-and-fakes-e8b1888932f9?source=collection_archive---------4-----------------------#2020-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b708141e8d9f3be4bc1559528f954b0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uv6CD4XQ3yQMF1IkT18Rlw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Go Beyond ̶R̶o̶c̶k̶ Mock :)</figcaption></figure><div class=""/><p id="64d5" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为开发人员，当提到几种不同的测试实践时，我们使用术语“模仿”和“嘲弄”。在这篇文章中，我将标准化Mocks、Stubs和Fakes的术语:它们的功能，它们之间的区别，以及何时使用它们。</p><p id="fe8d" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">了解不同的模拟替代方案可以帮助您编写更健壮和可维护的代码，享受更快的执行时间，并提高整体代码质量。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="858c" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从定义开始:</p><h1 id="bacd" class="li lj jf bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">嘲弄</strong></h1><p id="b363" class="pw-post-body-paragraph kd ke jf kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">模仿取代了原来的“模仿”对象。基本的mock没有自己的实现。模仿记录所有打给他们的电话，所以他们可以稍后被验证。</p><p id="d72e" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您不想调用原始对象/功能时，请使用模拟。</p><h1 id="f7cd" class="li lj jf bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">存根</strong></h1><p id="9bed" class="pw-post-body-paragraph kd ke jf kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">存根是更高级的模拟:它有一个返回静态数据的预定义实现<strong class="kf jg">。</strong></p><p id="8e55" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您想要测试依赖于固定数据的特定用例时，请使用存根。</p><h1 id="606a" class="li lj jf bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">假的</strong></h1><p id="e198" class="pw-post-body-paragraph kd ke jf kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">fake是更高级的模拟:它有一个实际的、简化的、有效的实现。</p><p id="22c5" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你想要简单、轻量级的逻辑而不是真正的实现时，使用fakes。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="1df3" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">理论背景讲的够多了，现在来讲一些Python代码！</p><p id="e66d" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们想测试这段代码:</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="a15c" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个简短的方法使用<a class="ae mr" href="https://boto3.amazonaws.com/v1/documentation/api/latest/index.html" rel="noopener ugc nofollow" target="_blank"> boto3 </a>(亚马逊S3的一个包装器)，将一个现有的对象移动到一个唯一的、随机的地方。boto中没有“move”方法，所以我们必须复制和删除对象。<br/>唯一性由<a class="ae mr" href="https://docs.python.org/3.7/library/uuid.html#uuid.uuid4" rel="noopener ugc nofollow" target="_blank"> uuid4 </a>确保，它以<code class="fe ms mt mu mv b">a4a8ec45–3c6f-4a75-b7d7–112611f302</code>的形式返回标识符，然后对其进行处理，使其更像目录结构:每个连字符('-')都用斜杠('/')替换。在上面的例子中是:<code class="fe ms mt mu mv b">a4a8ec45/3c6f/4a75/b7d7/112611f302</code>。</p><p id="83ef" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将编写的第一个测试将演示模拟和存根:</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="5ec9" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mv b">test_move_to_unique_location_ensure_uniqueness</code>是对<strong class="kf jg">模拟</strong>的一个很好的介绍:我们在这个方法中想要测试的就是得到唯一的目的地。我们关心算法逻辑，不关心s3运算。显而易见的解决方案是<strong class="kf jg">模仿s3而不做任何实现。</strong> <code class="fe ms mt mu mv b">@mock.patch('s3._s3')</code>正是这么做的——它用一个mock替换了boto3 s3句柄。测试函数的主体非常简单——调用被测试的方法一千次，并收集输出以验证它们都是唯一的。</p><div class="ip iq gp gr ir mw"><a href="https://www.datadriveninvestor.com/2020/07/07/introduction-to-time-series-forecasting-of-stock-prices-with-python/" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd jg gy z fp nb fr fs nc fu fw je bi translated">用Python |数据驱动投资者进行股票价格时间序列预测简介</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">在这个简单的教程中，我们将看看如何将时间序列模型应用于股票价格。更具体地说，一个…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk ix mw"/></div></div></a></div><p id="e630" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来我们有<code class="fe ms mt mu mv b">test_move_to_unique_location_destination_format</code>，它是一个<strong class="kf jg">存根</strong>的例子:注意固定的<code class="fe ms mt mu mv b">return_value='a4a8ec45–3c6f-4a75-b7d7–112611f302'</code>。它允许我们验证我们的格式产生正确的目的地。我们必须存根uuid4来获得我们想要的值，否则每次测试执行都会产生不同的目的地。</p><p id="1546" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模仿者还会记录打给他们的电话，这些电话可以被验证。让我们来看看实际情况:</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="414f" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe ms mt mu mv b">assert_called_once_with</code>来验证对s3模拟的调用。这个例子验证了所使用的确切参数，但是如果我们愿意，我们可以不那么严格。我们稍后将回到这个例子。</p><p id="1994" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，我们已经<strong class="kf jg">测试了算法逻辑</strong>，并且看到了一些模拟和存根的例子。我们<strong class="kf jg">尚未验证s3操作</strong>，更具体地说，我们尚未回答以下问题:</p><ol class=""><li id="53ed" class="nl nm jf kf b kg kh kk kl ko nn ks no kw np la nq nr ns nt bi translated">我们如何知道我们是否使用了带有正确参数的正确s3方法？</li><li id="c1cf" class="nl nm jf kf b kg nu kk nv ko nw ks nx kw ny la nq nr ns nt bi translated">我们如何知道实际的s3对象被正确地移动了？</li><li id="4a32" class="nl nm jf kf b kg nu kk nv ko nw ks nx kw ny la nq nr ns nt bi translated">我们如何知道被测试的代码没有脱离现实？</li></ol><p id="c86b" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了将所有这些理论问题具体化，想象您在<code class="fe ms mt mu mv b">move_to_unique_location</code> : <code class="fe ms mt mu mv b">_s3.typo()</code>中添加了下面一行。你的测试会全部通过，但是代码在现实生活中会完全被破坏！</p><p id="3bbe" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决这些问题(并获得许多额外的好处)，我们可以使用<strong class="kf jg">假货。</strong>在下面的例子中，我们使用s3的一个简单实现，称为<a class="ae mr" href="https://pypi.org/project/moto/" rel="noopener ugc nofollow" target="_blank"> moto </a>:</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="1b94" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这比前面的例子要多一点，所以让我们来分解一下。</p><p id="372e" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个文件有三个方法:<code class="fe ms mt mu mv b">empty_bucket</code>是一个<a class="ae mr" href="https://pytest.org/en/latest/fixture.html#fixture" rel="noopener ugc nofollow" target="_blank"> pytest fixture </a>，它为另外两个测试方法设置了一个干净的、假的s3桶。</p><p id="2d9b" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你仔细观察<code class="fe ms mt mu mv b">test_move_to_unique_location_no_source_object</code>，你会发现它与之前的测试不同:</p><ol class=""><li id="c316" class="nl nm jf kf b kg kh kk kl ko nn ks no kw np la nq nr ns nt bi translated">它测试一个负面的用例</li><li id="05e7" class="nl nm jf kf b kg nu kk nv ko nw ks nx kw ny la nq nr ns nt bi translated">它试图移动物体</li></ol><p id="017e" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个测试显示了我们之前的测试是如何与现实脱节的:要移动一个物体，你首先需要确保它是存在的。如果你不相信我，试着在没有<code class="fe ms mt mu mv b">@mock.patch('s3._s3')</code>的情况下运行之前的测试，看看你会得到什么异常。</p><p id="4dc8" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们准备好了最后一项测试:</p><ol class=""><li id="cec1" class="nl nm jf kf b kg kh kk kl ko nn ks no kw np la nq nr ns nt bi translated">它创建了一个对象</li><li id="542b" class="nl nm jf kf b kg nu kk nv ko nw ks nx kw ny la nq nr ns nt bi translated">使用测试过的代码移动它</li><li id="b7ae" class="nl nm jf kf b kg nu kk nv ko nw ks nx kw ny la nq nr ns nt bi translated">通过检查对象的内容来验证对象是否被正确移动</li><li id="84c1" class="nl nm jf kf b kg nu kk nv ko nw ks nx kw ny la nq nr ns nt bi translated">验证对象不再位于我们创建它的原始位置(我们希望该函数移动对象，而不仅仅是复制它)</li></ol><p id="1256" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哇，一个端到端的测试！</p><p id="fad2" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们都完了，还是…</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="05ba" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">过了一会儿，您决定更改<code class="fe ms mt mu mv b">move_to_unique_location</code>的实现:</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="c1e4" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个替代方案使用<code class="fe ms mt mu mv b">boto3.resource</code>而不是<code class="fe ms mt mu mv b">boto3.client</code>来达到相同的结果。</p><p id="8635" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问:你的测试会怎么样？</p><p id="5e00" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了一个人外，其他人都及格了。使用适当的技术测试正确的东西的测试将会通过。最好的例子是<code class="fe ms mt mu mv b">test_move_to_unique_location_verify_read</code>,它验证对象存在于新位置，而不检查它是如何到达那里的。</p><p id="90b6" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mv b">test_move_to_unique_location_destination_format</code>是另一个很好的例子:它确保目标结构不会改变。</p><p id="b260" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一出故障的测试是<code class="fe ms mt mu mv b">test_move_to_unique_location_verify_calls</code>。原因是它检查了被改变的特定实现。您可以删除这个测试，因为它的主要目标是展示模拟能力。</p><p id="9e71" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jg">总结:仿制品、存根和假货都有其用途。一定要恰当地使用它们:利用它们的优势，避免在它们不能提供真正的价值并且只会让你慢下来的时候使用它们。</strong></p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="83d1" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些最后的话:</p><p id="1cb4" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">光有理论知识是不够的！本文中的代码片段完全可以工作，因此可以通过运行、修改和探索这些代码将这些信息付诸实践。</p><p id="d625" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您在实际的代码库中使用几个模拟类型，以查看哪些类型适用于特定的情况，并对常见情况有更深的直觉，那么您将获得最大的好处。</p><p id="ce5d" class="pw-post-body-paragraph kd ke jf kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于进一步的阅读，查看这篇文章，它很好地解释了使用Java编程语言的相同主题。</p><h2 id="8a62" class="nz lj jf bd lk oa ob dn lo oc od dp ls ko oe of lw ks og oh ma kw oi oj me ok bi translated">访问专家视图— <a class="ae mr" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank">订阅DDI英特尔</a></h2></div></div>    
</body>
</html>