<html>
<head>
<title>YOLOv3 From Scratch Using PyTorch(Part1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">YOLOv3使用PyTorch从头开始(第1部分)</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/yolov3-from-scratch-using-pytorch-part1-474b49f7c8ef?source=collection_archive---------0-----------------------#2020-06-07">https://medium.datadriveninvestor.com/yolov3-from-scratch-using-pytorch-part1-474b49f7c8ef?source=collection_archive---------0-----------------------#2020-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d7d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将使用Pytorch从头开始实现YOLOv3算法，这样我们将有一个直观的理解。在开始写这篇文章之前，我建议你看一下我对<a class="ae kl" href="https://medium.com/datadriveninvestor/review-on-yolov1-3c85304b617d" rel="noopener"><strong class="jp ir"/></a><a class="ae kl" href="https://medium.com/datadriveninvestor/review-on-yolov2-11e93c5ea3f1" rel="noopener"><strong class="jp ir">【约洛夫2 </strong> </a>和【约洛夫3】的评论。我将分两部分解释这个实现。这将是文章的第一部分。</p><ol class=""><li id="f2ba" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated"><strong class="jp ir"> YOLOv3使用PyTorch从头开始(第1部分)</strong></li><li id="7650" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated"><strong class="jp ir"> YOLOv3使用PyTorch从头开始(第2部分)</strong></li></ol><p id="ce9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将把文章分成几个部分，这样你会更容易理解。</p><ol class=""><li id="1601" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated"><strong class="jp ir">配置文件(已解释)</strong></li><li id="fe4e" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated"><strong class="jp ir">初始化模块</strong></li><li id="d8e1" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated"><strong class="jp ir">模型的正向传递</strong></li></ol></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="6a35" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">1.配置文件(已解释)</h1><p id="e284" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">我们有一个“yolo.cfg ”,你可以从他们的官方网站下载。看起来是这样的。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mk"><img src="../Images/21d13d2f0aa569b65ed0f0e081955564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fLDM0lovYtvTcMNe6IysEA.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">part of configuration file</figcaption></figure><p id="db4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它由几个模块组成，如<strong class="jp ir">【net】、【协选】、【快捷方式】、【路线】、【上样】、【yolo】</strong>。我们将逐一解释。</p><p id="f444" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">【网】</strong></p><p id="f77f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只有一个[net]块存在。它给出了基本信息，如批次大小、动量、衰减等。我们不需要担心它。</p><p id="11d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">【卷积】</strong></p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi na"><img src="../Images/24b3387a87777aacf55cb8aa6fb8de58.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*8hBANRLgjhXkNJWDt8swJw.png"/></div></figure><p id="d835" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这给出了关于暗网53中存在的卷积网络的信息。</p><p id="7c0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">【快捷键】</strong></p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/800840cd68715ebcb50c113aeaf2dfae.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*pv6o5iQy3T1p85cxg2e4ZQ.png"/></div></figure><p id="b7b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快捷方式层与ResNet中使用的跳过连接层相同。from = -3表示快捷层后面有一个来自3层的快捷连接。</p><p id="ad2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">【路线】</strong></p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/880bf6a545067ac7a6d08a1786fe3b13.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*Uygw4E6_0yZSqUVDHPVlkQ.png"/></div></figure><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/38c55f8277fc29b84c44631d94fafd8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*3nUNYMJGD31i-7vDripyxg.png"/></div></figure><p id="c719" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">路径图层可以是1或2个值。当层参数的值为1时，表示采用该索引的特征图。例如，如果layers = -4表示图层将从第4层向后输出当前路径图层的要素地图。当层参数有2个值时，我们在那些索引处取特征图的连接值。例如，如果layer = -1，36，我们采用路线层的前一层和第36层的连接特征地图。</p><p id="eb56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">【上例】</strong></p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/9341ccf972515a79321073720cd36127.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*3pCPn_YzfWeXQ96KOGwDBg.png"/></div></figure><p id="aa8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将按给定步幅对先前的图层要素地图进行上采样。</p><p id="294c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">【yolo】</strong></p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nf"><img src="../Images/e2e41df4827690bfccd955ab282d0d93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9nk12fdDQ4Jf7UunPXMJ8A.png"/></div></div></figure><p id="66e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是检测层，我们将从这里进行预测。整个文件中有3个[yolo],表示我们以3种不同的比例输出。这里我们可以看到9对锚框，我们将根据给定的掩码值从中选择3对。这里mask=0，1，2意味着我们取锚的第一、第二和第三个值。因此，形成3个检测层，我们使用所有9个锚。</p><h2 id="239f" class="ng li iq bd lj nh ni dn ln nj nk dp lr jy nl nm lv kc nn no lz kg np nq md nr bi translated">解析配置文件</h2><p id="ea32" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">首先，我们将加载所需的库</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="363a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们将把这个配置文件解析成所需的格式。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/e871369eeb2dadf379e5a39c047826fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*H9QhJIXLyYzEw8bCWUBtwg.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">sample output</figcaption></figure><p id="4fea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解释上面的代码没有多大意义，因为它很容易理解。它只是将文件转换为一系列层的字典。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="34dc" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">2.初始化黑暗网络53的块</h1><p id="284e" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">在这一步中，我们将从我们创建的解析器输出中初始化DarkNet-53的所有块。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="575b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> darknet_details = block[0] </strong>表示我们前面解释的[net]块的细节。我们将它设置为单独的变量。</p><p id="01f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> nn。ModuleList() : </strong>这个类就像一个包含nn的普通列表。模块对象。当我们向nn添加对象时。ModuleList()，它们是作为nn的参数添加的。模块对象。</p><p id="21d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> output_filters: </strong>这里我们跟踪每一层中使用的过滤器。</p><p id="e3cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> channels = 3 </strong>表示网络的输入通道</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="ffde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们将从模块1开始，遍历网络的不同层。</p><p id="b39d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> nn。【Sequential())类用于顺序执行若干个nn。模块对象。例如，我们可以看到在卷积块中有批量归一化和激活。我们需要依次执行这个。所以我们用nn.Sequential。</strong></p><p id="3557" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的代码中，我们对协变和上采样块进行了处理。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="a79e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将检查如何迭代路由和快捷方式块。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="0f02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码有点复杂。别担心，我们会挺过去的。如前所述，路由将有1或2个值。如果路径参数的值为1，例如，第20层的route = [-4]，则表示第20层从第16层(20–4)输出要素地图。在这一步中，我们还用实际层数而不是负值来更新层值，因为这将进一步有用。</p><div class="nv nw gp gr nx ny"><a href="https://www.datadriveninvestor.com/2019/03/22/fixing-photography/" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">修复摄影|数据驱动的投资者</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">汤姆·津伯洛夫在转向摄影之前曾在南加州大学学习音乐。作为一个…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om mu ny"/></div></div></a></div><p id="d533" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，如果路径图层有两个值。例如，[-1，15]在第20层，我们将采用的过滤器是第19层和第15层过滤器的总和。在这个阶段，我们也用实际层数更新层参数。由于路由层除了转发和连接之外没有任何操作，我们使用了一个<strong class="jp ir"> <em class="on">虚拟层</em> </strong>。</p><p id="5fd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，在快捷图层的情况下，它也只是从某个先前图层传递特征地图。这里我们也将使用一个<strong class="jp ir"> <em class="on">虚拟层。</em> </strong></p><h2 id="1017" class="ng li iq bd lj nh ni dn ln nj nk dp lr jy nl nm lv kc nn no lz kg np nq md nr bi translated">什么是虚拟层？</h2><p id="6c0c" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">顾名思义，它只是一个虚拟或空层。通常在PyTorch我们子类<strong class="jp ir"> <em class="on"> nn。模块</em> </strong>并编写一个<strong class="jp ir"> <em class="on"> forward </em> </strong>函数来执行该层正在执行的操作。通常在路由层中，我们传递来自前一层的特征地图，或者我们连接两层并传递特征地图(仅用torch.cat()即可完成)。所以我们引入虚拟层来简化它。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="5634" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来是<strong class="jp ir"> <em class="on">约罗</em>T3】格挡。这里，我们将基于掩码更新每个yolo块的相应锚值。</strong></p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="4527" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也有一个检测层，我们将用于检测。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="b26f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们在每次迭代中添加过滤器和序列列表。我们还更新了通道，因为卷积层是在此基础上创建的。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="bb4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们块初始化函数如下所示:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2434" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们将测试我们的代码</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi oo"><img src="../Images/1fd1d835b7f368572a1d75fb581a6e25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oIIkVaijjOnGao2L7cWM5w.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">part of output</figcaption></figure></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="1635" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">3.模型向前传递</h1><p id="4ce4" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">在这一部分中，我们将看到如何通过我们之前定义的层来转发图像。我们将组装我们已经创建的构建块，以从图像中产生输出。</p><p id="df64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将定义一个类暗网，并将初始化我们计算的参数。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="237b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们将编写转发函数</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="11fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们将在字典输出中捕获每个图层的输出，因为路径图层和快捷方式图层需要它来进行操作。我们将在后面解释write=0。</p><p id="23e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们迭代<strong class="jp ir"> <em class="on"> self.blocks[1:] </em> </strong>而不是self.blocks，因为self.blocks的第一个元素是<strong class="jp ir"> <em class="on"> net </em> </strong> block，它不是向前传递的一部分。</p><p id="dff9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们要做的是枚举各层，并通过卷积和上采样层传递输入。在快捷方式和路由层的情况下，我们根据需要来做。在yolo层的情况下，我们进行预测并将其连接起来。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="0d72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，路由和快捷方式模块类型需要来自前一层的输出。因为我们将它缓存在输出字典中，所以我们可以使用它。在路径层中，如果层的长度大于1，我们将沿通道轴连接。例如，我们将大小为[1，256，26，26]和[1，512，26，26]的张量连接起来，得到大小为[1，768，26，26]的张量。</p><p id="9635" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一部分是yolo，在那里进行检测。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c09f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的<strong class="jp ir"> <em class="on">检测_预处理</em> </strong>功能如下:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="84a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顾名思义，这是一个预处理或转换我们的检测输出到适当的形式。该函数将检测输出、图像的输入尺寸、锚点和类别数作为输入。</p><p id="4c67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你觉得张量运算的函数很复杂，不要担心，我们会逐一讲解。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c372" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里x是4D特征地图输入。我们将从中提取batch_size和grid _ size。stride是指图像缩小到特征图的因子。有些也被称为子采样率。</p><p id="8e07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们的输入图像大小为128×128，我们的特征图大小为16×16。那么这里的步幅就是128//16 = 8。</p><p id="b90b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">框属性指示每个锚框的输出值的数量。这里5表示x，y，w，h和置信度，我们有80个类。所以总共是85英镑。接下来是锚的数量。在这里，因为我们在3个比例下使用3个锚盒，所以将是3。接下来是有趣的部分。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="5ee1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对4D张量做运算是复杂的。所以我们将把它转换成更简单的形式。发生的转换如下。假设我们的特征映射维数是[1，255，13，13]。这意味着我们有一个255深度的13x13特征图。这里我们有169个网格单元。对于每个网格单元，我们有255个值。即，3个锚框的85个值(80个类+ 5个边界框属性),总共225个值。我们将对此进行调整，这样我们将得到这样的行中的值，</p><p id="24bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="on">第一个网格单元上第一个锚定框的框属性</em> </strong></p><p id="810c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="on">第一个网格单元</em> </strong>上第二个锚定框的框属性</p><p id="175d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="on">第一个网格单元</em> </strong>上第三个定位框的框属性</p><p id="01a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="on">第二个网格单元上第一个定位框的框属性</em> </strong></p><p id="ee34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="on">。</em>T19】</strong></p><p id="aa6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="on">。</em> </strong></p><p id="41cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="on">第169格</em> </strong>第3锚框的框属性</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi op"><img src="../Images/df34f4469568af89bbeea92f2d4d3c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*OnHue8f66U16CKkzhPBn3A.png"/></div></figure><p id="3af4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个形状为507 x 85的张量。在上面的代码中，我们将[1，255，13，13]张量转换为[1，225，169]，然后将其转置为[1，507，85]。</p><p id="cad2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有3个<strong class="jp ir"> <em class="on"> yolo </em> </strong>积木。这意味着我们在3个不同的尺度上获取检测输出。所以我们会用三个音阶来做这个。</p><p id="f6d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将进行转换。假设<strong class="jp ir"> <em class="on"> tx，ty，tw，th，到</em> </strong>为网络输出的维度。为了进行边界框预测，我们必须进行如下一些变换:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/f227384232eaaa998417dfeed7012f10.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*PJAc56diAqkRTtD8h2BAYA.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">bbox transformations</figcaption></figure><p id="72dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里<strong class="jp ir"> <em class="on"> pw，ph </em> </strong>代表锚的高度和宽度。这里<strong class="jp ir"> cx，cy </strong>是网格单元相对于图像的偏移量。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="d23e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们将锚定框的尺寸除以步幅，以便根据特征图对其进行调整。现在我们将sigmoid应用到<strong class="jp ir"> <em class="on"> tx，ty </em> </strong>和<strong class="jp ir"> <em class="on">到</em> </strong>如等式。</p><p id="d3fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将中心x和y坐标(tx，ty)添加到偏移值中。为了使这一步更容易，我们创建一个网格网格，并调整其尺寸为我们之前创建的矢量。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="6971" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们将进行高度和宽度的对数空间转换。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="1d30" class="ng li iq bd lj nh ni dn ln nj nk dp lr jy nl nm lv kc nn no lz kg np nq md nr bi translated">装载重量</h2><p id="f8de" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">我们已经准备好了暗网53网络。现在我们必须用预训练的权重来初始化它。首先，我们将下载预训练的重量。</p><pre class="ml mm mn mo gt or os ot ou aw ov bi"><span id="5c9f" class="ng li iq os b gy ow ox l oy oz">!wget https://pjreddie.com/media/files/yolov3.weights</span></pre><p id="3eb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">官方重量文件是一个二进制文件，重量按顺序存储。权重以浮点形式存储。加载砝码文件时必须格外小心。一些需要注意的要点:</p><ul class=""><li id="7c2a" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk pa ks kt ku bi translated">权重只属于两种类型的层，或者是批范数层，或者是卷积层。</li><li id="02a1" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk pa ks kt ku bi translated">权重的存储顺序与配置文件中的顺序完全相同。</li><li id="3582" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk pa ks kt ku bi translated">如果卷积层包含批量归一化，我们将没有卷积的偏差值。对于这种卷积层，只有权重值。</li><li id="3a8c" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk pa ks kt ku bi translated">如果卷积图层不包含批量归一化，将同时存在偏差和权重值。</li></ul><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="65bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">权重文件的前160个字节存储5个int32值，这些值构成了文件头。其余位代表权重。重量以float32格式保存。在上面的代码中，我们将加载两者。</p><p id="d24d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们将遍历层并加载权重。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="b846" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们有一个批量归一化的卷积块，我们加载权重如下:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="11c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">否则我们将加载偏差as，</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="af2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后我们加载卷积层的权重</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c58f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的整个模型看起来如下</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="d1a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们将通过一个测试输入来检查输出</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="caac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出:</p><pre class="ml mm mn mo gt or os ot ou aw ov bi"><span id="1552" class="ng li iq os b gy ow ox l oy oz">torch.Size([1, 10647, 85])</span></pre><p id="952d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在文章的下一部分，我们将检查如何预测正确的边界框。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="c327" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">参考</h1><ul class=""><li id="fc01" class="km kn iq jp b jq mf ju mg jy pb kc pc kg pd kk pa ks kt ku bi translated"><a class="ae kl" href="https://pjreddie.com/media/files/papers/YOLOv3.pdf" rel="noopener ugc nofollow" target="_blank">https://pjreddie.com/media/files/papers/YOLOv3.pdf</a></li><li id="0335" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk pa ks kt ku bi translated"><a class="ae kl" href="https://blog.paperspace.com/how-to-implement-a-yolo-v3-object-detector-from-scratch-in-pytorch-part-2/" rel="noopener ugc nofollow" target="_blank">https://blog . paperspace . com/how-to-implementation-a-yolo-v3-object-detector-from-scratch-in-py torch-part-2/</a></li><li id="6c40" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk pa ks kt ku bi translated">【https://github.com/eriklindernoren/PyTorch-YOLOv3 T4】</li></ul><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="pe nt l"/></div></figure></div></div>    
</body>
</html>