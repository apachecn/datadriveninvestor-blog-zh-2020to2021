<html>
<head>
<title>JavaScript ES6 Numbers Parsing How to</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript ES6数字解析</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/javascript-numbers-parsing-how-to-89997964207a?source=collection_archive---------4-----------------------#2020-11-11">https://medium.datadriveninvestor.com/javascript-numbers-parsing-how-to-89997964207a?source=collection_archive---------4-----------------------#2020-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="280f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何解析JavaScript中的数字</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b5e859d0be4ffe47479bb17b35baefaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LfbELFT8FzehW2Yn"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@volkanolmez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Volkan Olmez</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="61cd" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">问题描述</h1><p id="e19e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated">avascript是一种种类繁多的语言，适用于任何类型的web应用程序。这是有意的，但对于像电子商务平台或网站这样的web应用程序，这种动态可能是非常混乱的数字转换的起源，因此很多时候会导致无意义的结果。如果您的应用程序得到的输入表单可以使用不同的数字格式，如10e5或0b11，甚至是10px或10em，而您想要解析它们，这对您来说可能是一个很长的时间。</p><p id="c096" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">在JavaScript中，算术运算可用于任何类型。但是，当两种类型不同时，这会导致类型强制，从而导致令人惊讶的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="43fa" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">使用“+”操作符，让JavaScript选择字符串类型并添加第二个。如果您使用“*”或“-”运算符，数字类型将胜出。因此，最后两个导致正确的算术运算。</p><p id="19bc" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">为了确保指定的算术运算产生正确的结果，从输入字段获取的数据应该总是被显式地转换成正确的类型。JavaScript在这里派上了用场，并为此提供了3个函数。不幸的是，它们都以不同的方式工作。解析CSS样式定义中的值时的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="454f" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">正如你所看到的，第一个删减了小数位，第二个精确，第三个毫无帮助。</p><blockquote class="nd"><p id="1895" class="ne nf it bd ng nh ni nj nk nl nm mm dk translated">我们有一个问题要回答:如何用JavaScript解析我的数字，并且不会再出错？</p></blockquote><h1 id="e1d3" class="kz la it bd lb lc ld le lf lg lh li lj jz nn ka ll kc no kd ln kf np kg lp lq bi translated">JavaScript中的数字类型</h1><p id="c472" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了更接近答案，我们需要对JavaScript中的数字有一个基本的了解。与强类型语言不同，在强类型语言中，大多数数字被分成子部分，就像在C#中，无符号整数只能是正数，浮点数是小数，而在JavaScript中没有这样的东西。“类型”操作员将证明:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="57c0" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">任何种类的数都被浓缩成类型数。JavaScript总共有六种类型，显示的这四种:string、number boolean和object几乎都是。</p><p id="5643" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们可以用数字文字创建一个数字类型的值。常见的数字文字是整数(10)和有符号浮点数(-34.8)。但是在JS中还有更多:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="9c34" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">他们四个都代表相同的价值。第一种是科学记数法，第二种是十六进制记数法，第三种是二进制记数法，第四种是八进制记数法。可以通过前缀区分。JavaScript还区分有限数值和无限数值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="142c" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">尽管数学上没有定义被零除，但是JavaScript允许这样做。它产生特殊值+/-无穷大。所有其他未定义的算术选项都会产生NaN(非数字)。那些未定义的是什么？无限/无限。JavaScript遵循IEEE-754-浮点数规范！</p><p id="c52a" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">JavaScript，哦JavaScript！所有的特殊值都是像number这样的类型，尽管文本说“不是一个数字”！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="e2b8" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">为了确定两个值是否是算术定义的，必须检查这些数字是否是有限的。幸运的是JS提供了静态函数编号。IsFinite:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="9cee" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">但是也要小心(JS真的是丛林)！ES6引入的功能号是有区别的。和全局函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="9f3c" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">全局的那个在偷偷的把其他类型转换成数字，会导致奇怪的结果。静态变量只接受number类型的变量。兄弟函数也是如此:IsNaN和Number.IsNaN。</p><p id="2e9a" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">记住这一点，你就比以前更接近你的目标了！</p><h1 id="0df1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">用parseFloat和parseInt转换值</h1><p id="a954" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有时输入值(来自表单或输入字段)没有类型号。因此，转换是必要的。JavaScript也为我们提供了3种解析它们的可能性。</p><ul class=""><li id="c754" class="nq nr it lt b lu mw lx mx ma ns me nt mi nu mm nv nw nx ny bi translated">数字</li><li id="d324" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">parseFloat/ Number.parseFloat</li><li id="feb9" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">parseInt / Number.parseInt</li></ul><p id="8dc4" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">ParseInt和ParseFloat在数字上也有一个兄弟。构造函数，但幸运的是，它们的工作原理是一样的。这两个函数都将字符串转换成数字。只要得到第一个非数字字符，它们就会读取，然后立即中断转换过程。空格、换行符、回车符和制表符会被忽略。当字符串只包含不可转换的字符或为空(null)时，两者都返回NaN作为输出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="42ad" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们在这里可以清楚地看到不同之处。ParseInt立即将小数点视为无效，并中断转换。结果总是一个整数。它转换其他数字文字和特殊值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="cf0c" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">但是文字是有限制的。一方面，ParseInt可以转换十六进制，但极度渴望八进制、二进制和科学指数记数法的转换。另一方面，ParseFloat可以读取科学指数记数法，但不能读取其他三种记数法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="93af" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这是一个潜在的鬼鬼祟祟的错误和转换过程中的错误。没有这些明确的知识，你就不会意识到那些细微的差别，并且在没有任何线索的情况下编码完成任务。最棘手的是前缀只是被截掉了，剩下的被视为有效值。根本不知道之前的值是多少。</p><p id="51f2" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">如果值不是字符串，那些函数也会把它转换成字符串。问题又来了:字符串有它自己的规则集:</p><ul class=""><li id="7e0d" class="nq nr it lt b lu mw lx mx ma ns me nt mi nu mm nv nw nx ny bi translated">字符串(未定义)= &gt;未定义</li><li id="af13" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">String(null) =&gt; null</li><li id="655d" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">String(true)/String(false)= &gt; true/false</li></ul><p id="9303" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">是输入类型对象，那么String试图从对象本身调用方法ToString()来获得一个基本类型，除object之外的所有其他类型。这是不是没有达到目标，然后调用valueOf()。这也没有达到目标，会抛出一个错误。</p><p id="cb8b" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">在你的大脑中有这些转换规则，转换是可以理解的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="e708" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">一个数组被转换成一个单一的数字可以用上面的规则来解释:</p><ol class=""><li id="580f" class="nq nr it lt b lu mw lx mx ma ns me nt mi nu mm oe nw nx ny bi translated">parseFloat([1，2，3])使用String-Method将输入转换为字符串</li><li id="fb80" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm oe nw nx ny bi translated">String([1，2，3])调用了方法toString，因为数组是JS中的一个对象</li><li id="18a3" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm oe nw nx ny bi translated">[1,2,3].toString()产生字符串“1，2，3”</li><li id="93bd" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm oe nw nx ny bi translated">转换继续使用parseFloat([1，2，3])</li><li id="aba2" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm oe nw nx ny bi translated">parseFloat一直读到第一个不可转换的字符，即1后面的逗号，然后停止转换</li><li id="2440" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm oe nw nx ny bi translated">因此，结果是1</li></ol><h1 id="03fc" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数字:JavaScript中转换数字的第三种方式</h1><p id="3249" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">将任何东西转换成数字的第三种方法是全局方法号。适用于parseInt和parseFloat的规则相同。整个字符串必须是可转换的，混合转换是不可能的，也不会带来结果。存在以下特殊规则:</p><ul class=""><li id="68cc" class="nq nr it lt b lu mw lx mx ma ns me nt mi nu mm nv nw nx ny bi translated">""，null和false将被转换为0</li><li id="1e56" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">真实结果为1</li><li id="10a8" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">NaN中未定义的结果</li><li id="5129" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">允许所有前缀</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="162f" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">如果输入是object类型的，那么这个函数的工作方式正好与parseInt和parseFloat相反。它首先使用valueOf进行转换，如果失败，它将调用toString转换。因此，有一些细微的区别:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="5167" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">正因为如此，日期对象在与数字的用法上是特殊的。valueOf的调用返回一个UNIX-timestamp，它也是number类型，根本不会被转换，只是通过管道传递。数组在被调用valueOf时会返回自身，由于这种失败的转换(Number需要一个数字)，导致调用toString-method。返回包含特殊字符的字符串会导致转换中止。结果是楠。</p><h1 id="b9e6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">JavaScript中解析数字的结论</h1><p id="fea4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下面，我总结了这三个功能是如何工作的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/880fecaf2cf7c8e6040a173a1603bd99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*KYCQJCyFcJ0jnYDd1l8N7Q.png"/></div></figure><p id="ae07" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在的问题是:应该使用这三个函数中的哪一个来转换给定的输入，以便通过转换正确地进行计算？</p><p id="1240" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">如果浮点数和整数都需要，parseInt不是您的候选。另外，是否接受十六进制文字？— parseFloat也不是正确的。使用Number可能是非常正确的，但是当涉及到日期、布尔值、null或一些单独的对象时，可能会导致奇怪的结果。此外，转换可能会导致NaN和Infinity，这对于算术运算来说是无效的值。</p><p id="226b" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">在成功完成转换之前，必须有一个筛选器。一个函数，检查输入是否可以转换成一个有限的数字。</p><p id="afa3" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">一些框架也设法回答了这个问题。JQuery提供了IsNumeric方法。在不同版本的JQuery发布期间，实现也发生了一些变化。根据您的需要检查正确的版本:下面，我总结了不同的框架及其将值转换为数字的能力。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/9128e3c3d5b64c7c0378f397c94e5c89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*AyLVGl_SdtfkkCWuEJTY4A.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Overview of frameworks and their conversions</figcaption></figure><p id="69e7" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">在JavaScript中转换数字不是一项简单的任务。选择函数来明智地转换您的数字。过滤掉不想要的值(NaN，Infinity，带有Unix时间戳的Date)，否则会产生不想要的奇怪结果。为你的过滤和转换方法编写单元测试。</p><blockquote class="nd"><p id="9526" class="ne nf it bd ng nh ni nj nk nl nm mm dk translated">因此，安全转换需要以下步骤:</p><p id="3f6b" class="ne nf it bd ng nh ni nj nk nl nm mm dk translated">检查给定的输入/值是否为数值</p><p id="0ded" class="ne nf it bd ng nh ni nj nk nl nm mm dk translated">将值转换成数字</p></blockquote><p id="e591" class="pw-post-body-paragraph lr ls it lt b lu oh ju lw lx oi jx lz ma oj mc md me ok mg mh mi ol mk ml mm im bi translated"><a class="ae ky" href="https://arnoldcodeacademy.ck.page/26-web-dev-cheat-sheets" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu"> <em class="om">节省自己大量的时间，专注于重要的主题。</em> </strong> </a></p></div></div>    
</body>
</html>