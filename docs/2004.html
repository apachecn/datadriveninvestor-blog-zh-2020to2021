<html>
<head>
<title>Introduction to Pandas for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者熊猫入门</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/introduction-to-pandas-for-beginners-d224d21b588?source=collection_archive---------5-----------------------#2020-04-09">https://medium.datadriveninvestor.com/introduction-to-pandas-for-beginners-d224d21b588?source=collection_archive---------5-----------------------#2020-04-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a0d3d6216fb1199b822e70c520f59b32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xRcXl9YKgpnb0zvXLvZprg.jpeg"/></div></div></figure><h1 id="a98e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="8100" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Pandas是构建在numpy之上的开源Python库，为Python编程语言提供了高性能、易于使用的数据结构和数据分析工具。</p><p id="1547" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">熊猫在学术、金融、经济、统计、分析等领域有着广泛的应用。</p><p id="92f4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我相信说pandas是数据科学家和分析师在Python中取得成功的工具箱中最重要的工具是没有错的。特别是在数据分析的情况下，pandas被用作大多数项目的主干。</p><p id="7911" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Pandas大约在2008年由开发者<strong class="ky ir"> Wes McKinney </strong>开始开发，目的是帮助python获得能力<strong class="ky ir">加载、清理、转换、建模和分析以不同格式保存的</strong>数据。</p><p id="ce19" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在熊猫出现之前，python并没有那么伟大，但现在有了熊猫，它就在那里大放异彩了！所以你应该明白这个包裹的重要性。</p><p id="84f3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这个完整的库及其所有特性不是我们可以在一篇文章中掌握甚至讨论的，但是当然必须有一个开始的方法。当我开始研究熊猫时，我真的发现作为一个分析领域的完全初学者，与我在网上找到的大多数材料合作是如此令人沮丧。</p><p id="0c6d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这就是为什么我有了一个初步的想法，总结出pandas特性的一个小的子集，可以说足以处理大多数或者几乎所有的常见用例。不管怎样，这取决于你自己，一旦你达到了理解这一点的水平。</p><p id="0228" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，让我们继续前进，看看熊猫给我们带来了什么。</p><p id="063c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">就像我在开头提到的，熊猫是建立在numpy库的基础上的，所以你很好地了解numpy是很重要的，以便继续前进并和熊猫一起玩。如果你觉得需要重温一下你的数字知识，可以在这里找到这篇<a class="ae lz" href="https://medium.com/analytics-vidhya/introduction-to-numpy-for-beginners-9a0db6bc2a07?source=---------2------------------" rel="noopener">文章</a>。希望有用。</p><h1 id="98d0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">安装并导入</strong></h1><p id="acdf" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Pandas是一个易于安装的软件包。根据您的环境，您可以使用以下命令之一进行安装:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="bf33" class="mj jz iq mf b gy mk ml l mm mn"><strong class="mf ir">conda install pandas</strong> # if you use anaconda<br/>OR<br/><strong class="mf ir">pip install pandas</strong></span></pre><h1 id="b70c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">熊猫数据结构</h1><p id="9f40" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">熊猫主要用于以下目的，在我们开始之前了解这些是值得的。</p><p id="d05b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">1.将不同文件格式的数据加载到内置数据对象中。</p><p id="5de1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">2.数据对齐和缺失数据的综合处理。</p><p id="d56a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">3.使用默认和自定义索引创建快速高效的数据框对象。</p><p id="1cdd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">4.数据集的整形和旋转。</p><p id="a6f0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">5.基于标签的大数据集切片、索引和细分。</p><p id="c0d6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">6.按数据分组以进行聚合和转换。</p><p id="0cd1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">7.数据的合并和连接。</p><p id="3752" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">8.时间序列功能。</p><p id="d1b6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Pandas有3种不同类型的数据结构来支持这些操作。</p><p id="3a1b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> 1。系列</strong> <code class="fe mo mp mq mf b"><strong class="ky ir">-</strong></code> <strong class="ky ir"> 1D集装箱</strong></p><p id="dc63" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> 2。数据框-2D容器</strong></p><p id="31cd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> 3。面板-3D容器</strong></p><p id="2237" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">通常数据序列被认为是熊猫中最常用和最主要的对象。但这不是最基本的开始。让我们从系列开始。</p><h1 id="061b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">系列</strong></h1><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/e82d70b6fcaf1f926a4d2b6b0c2e2f7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*bB1x1SnbUAOTTqDvPhd8jw.jpeg"/></div></figure><p id="8e45" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">series是一维数组，与numpy数组非常相似。一个系列本质上有两个组成部分，数据部分和索引。下面是创建新系列的常用语法。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="9ae2" class="mj jz iq mf b gy mk ml l mm mn"><strong class="mf ir">series = pd.Series ( data , index)</strong></span></pre><p id="4780" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">正如您所看到的，这个函数将两个列表作为输入来创建一个序列。</p><p id="2971" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们可以在这个地方提供它们，如下所示</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="63e0" class="mj jz iq mf b gy mk ml l mm mn"><strong class="mf ir">series=pd.Series([10,20,30,40],[‘a’,’b’,’c’,’d’])<br/>print(series)</strong></span></pre><p id="b436" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">或者我们可以先分别定义它们，然后给出如下参考。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="f98a" class="mj jz iq mf b gy mk ml l mm mn"><strong class="mf ir">mydata = [10,20,30,40]<br/>myindex =[‘a’,’b’,’c’,’d’]<br/>series=pd.Series(mydata,myindex)<br/>print(series)</strong></span></pre><p id="04d4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果我说第二种方法更合适，我希望你同意。所以是的，坚持第二种方法作为一个好的做法。</p><p id="1e92" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果我们不给出自己的索引方法呢？它将从0开始自动索引。</p><p id="a886" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">看看下面的例子。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/0b992b817f4d4b230291eaee52f39f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*Da0LgOsHzFprZM24l9Rh7A.jpeg"/></div></figure><p id="33d6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">请注意，当显示内容时，pandas使用的是垂直表示，所以我使用的上面的插图与用图形表示系列有点不匹配。相反，我们应该以下面的方式考虑一个系列。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/b395ce0b50c738abfa751f3489afc5bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*8tkesmRtwXXlhBAFq2Uz4w.jpeg"/></div></figure><p id="9bbe" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">过一会儿你会明白为什么最好这样想象一个系列，还是坚持住。</p><p id="ed23" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">请注意，当我没有提到使用列表作为索引字段时，已经发生了自动索引。</p><p id="38a8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，我希望你还记得python中的字典数据结构。</p><p id="3815" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果没有，它只是一个以键:值成对方式存储元素的结构。</p><p id="8ef1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">例如</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="965e" class="mj jz iq mf b gy mk ml l mm mn"><strong class="mf ir">mydict = {‘k1’:’val 1',’k2':’val 2',’k3':’val 3',’k4':’val 4'}</strong></span></pre><p id="55dc" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">因为字典中的数据是按照我们需要的格式组织的，所以当我们将它们排列成一个序列时，我们可以将字典作为唯一的输入来使用pd创建一个序列。Series()函数，这样键将自动成为索引字段的值。</strong></p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/7b4c18268d15808e1c9137f1bab85ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uQXvFxC6pugHbB6-gR1YGg.jpeg"/></div></div></figure><p id="c36e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">还要注意，我们也可以给numpy数组作为这个函数的输入参数。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/dcf26ceec5e9a98d9fd9bc10a26a4819.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2dB2XgixZHKYw1BZZRaD8w.jpeg"/></div></div></figure><p id="a663" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当我们的数据是一个标量值时，还有另一种有时很有用的方法来创建一个标量序列。必须提供一个索引来匹配所需的长度，然后标量值将被重复以匹配长度。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="9ed3" class="mj jz iq mf b gy mk ml l mm mn">scalar_series = pd.Series(5, index=[0, 1, 2, 3])<br/>print (scalar_series)</span></pre><p id="eb92" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">从我在上面展示的这些例子中，您可以注意到，系列数据结构可以保存各种数据类型。但是这种灵活性只适用于索引字段。数据字段是同质的。</p><p id="a6ee" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">关于一个系列，以下三个特性是需要注意的要点。</p><p id="b22f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">同质数据</strong></p><p id="05d3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">尺寸不可变——长度固定</strong></p><p id="5b97" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">可变数据的值——可以更改现有元素。</strong></p><h1 id="7ce0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">访问系列的元素</h1><p id="4a94" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">可以通过引用它们的索引来简单地访问值。</p><p id="b9ac" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里要注意的另一件事是，即使你在定义数据序列时提供了自己的索引，你仍然可以通过默认索引0 1 2等来引用这些元素。(这有时被称为绝对指数)</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/73193cdc9ba209f53d8eec693d0c192a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zekYLWC69ONx12D9A3GniQ.jpeg"/></div></div></figure><p id="4d4c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">此外，我们可以像这样选择一系列值。请注意使用绝对索引和给定索引值作为限制时的差异。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/3941ec56a94cbe290d84951024153429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bMgZ7gcQ7JaVFAOPOmxXtw.jpeg"/></div></div></figure><h1 id="5b4a" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">数据帧</h1><p id="6df6" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">数据框，就像我之前提到的，就像2D系列的对应物。基本上就像一张桌子。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/02c0205b05c8cd09cfd98a2de527ab59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*mkJtDTTCfNCC2dNcmnDYWw.jpeg"/></div></figure><p id="55ff" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">正如你在这里看到的，这是一个共享一个公共索引的系列的集合，不是吗？是的，它是。</p><p id="fba3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这就是为什么我之前说，以垂直的方式思考一个系列很重要，以适应这种情况。</p><p id="8b0d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">使用以下语法可以创建数据框</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="1444" class="mj jz iq mf b gy mk ml l mm mn">dataFrame = pd.DataFrame( data , row_indexing, column_indexing )</span></pre><p id="5d84" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了简单起见，我们先分别定义这三个对象，然后再创建数据框。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/fbb8ffd13795ddb314dcf13461e99216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*snLS_JJVYVT-Z2zhB_gU1w.jpeg"/></div></div></figure><p id="f3ad" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">不要被这个np.random搞糊涂了。randint (0，20，9)。整形((3，3))</p><p id="2f7b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我只需要9个随机整数，所以我使用numpy中的随机数生成器生成了一个由0到20之间的9个随机数组成的数组，并将其重塑为一个3x3的矩阵，然后使用该矩阵作为我的数据帧的数据部分。</p><p id="43d0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在我将使用熟悉的标签和细节来声明一个新的数据集，</p><p id="787d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们将在这里继续使用它。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="dd65" class="mj jz iq mf b gy mk ml l mm mn">data = [[‘Alice’,’22', ‘A01’] , [‘John’, 23, ‘A002’] ,[‘Ben’, 21, ‘A005’]]<br/>row_index = [‘r0’,’r1',’r2']<br/>column_index = [‘Name’,’Age’,’REG_NO’]<br/>mydf  = pd.DataFrame(data , row_index, column_index)<br/>print(mydf)</span><span id="5919" class="mj jz iq mf b gy na ml l mm mn">&gt;&gt;&gt; out<br/>Name Age REG_NO<br/>r0 Alice 22 A001<br/>r1 John 23 A002<br/>r2 Ben 21 A005</span></pre><h1 id="b7a0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">选择数据</h1><p id="f961" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">下面的选择是显而易见的操作，所以没什么好解释的，所以我只提一下语法。</p><p id="3426" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">选择一列</strong></p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/bf15a2abb58cadc64b216c6024d4ae5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CIodnm6hJtpKPJL0FLkw8w.jpeg"/></div></div></figure><p id="f2bf" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们还可以使用<strong class="ky ir">点符号</strong>从数据框中获取一列，但是这种符号的使用受到限制，因为它在以下情况下不起作用</p><p id="dad3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">列名中有空格，</strong></p><p id="1516" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">当列名等于方法名时，</strong></p><p id="6690" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">当列名等于变量名时</strong></p><h1 id="b98c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">选择多列</h1><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/f00f68977bfe2148c14dd1dcf77192b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j5oMDUVPzFgfLlpPI63jtw.jpeg"/></div></div></figure><h1 id="4fb1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">检查列的数据类型</h1><p id="5097" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">请注意，在pandas中，单列被视为一个系列。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/c75537917e422785515552c7ae9071a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dgptSj98qhofiRAvwwIBiA.jpeg"/></div></div></figure><p id="22da" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，列被视为一个系列，您可以应用系列的选择方法，进一步从选定的列中选择值，如下所示。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/eef52950030e2cd88d0ee58f52f5d2f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FV3Cs7bgq-_VA1PAkjRWmQ.jpeg"/></div></div></figure><h1 id="c7f7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">选择行</h1><p id="7f48" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">选择行有两种方法，使用<strong class="ky ir"> loc[ ]和iloc[ ] </strong>方法</p><p id="35ac" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> loc [ ] </strong>函数取记录的索引字段的值。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/75f453f30745734c4f62c49415ed8795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jkX-FhFVf3U-xUb47clp5Q.jpeg"/></div></div></figure><p id="ce3d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> iloc[] </strong>函数将记录的绝对索引作为输入。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/42a2acb6d99cfa06ac30e8a7d28c5f4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N7Dgoer9Bk5qrMQZ1AVrYQ.jpeg"/></div></div></figure><h1 id="966c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">选择多行并仅选择所需的列</h1><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/32148fa3faa81a55de44d5b7b651730e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UEeP6PrZvVKcLiihs4V5bw.jpeg"/></div></div></figure><h1 id="0a0e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">条件选择</h1><p id="6505" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">有时我们需要根据条件过滤出数据，例如特定列的值高于给定限制的行。(我知道你明白“<strong class="ky ir">有条件的”</strong>是什么意思但是你知道，必须保持它的完美所以，跟我裸露一点)</p><p id="43d7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这种情况下，下列符号将具有它们通常的含义</p><p id="abca" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> &lt; &gt; ==！= |(或)&amp;(和)</strong></p><p id="64f4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">下一个要记住的重要事情是，要使用类似于&lt; or &gt;的数字比较来执行条件选择，我们考虑的列必须是数字类型的。</p><p id="fc72" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">要检查数据框中各列的数据类型，可以使用<strong class="ky ir"> df.dtypes() </strong>方法，而要将特定列更改为数值字段，最好的方法是使用<strong class="ky ir"> pd.to_numeric( ) </strong>函数。</p><p id="2089" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">下面我展示了如何进行转换。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/faedc473188d6a5eff709cd72fddb35b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qW42Zk_1_GHmYNKfJ-IXPw.jpeg"/></div></div></figure><p id="8eee" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在让我们看看如何过滤年龄大于21岁的记录</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/5658af377a5a2ea0219bb35a822f38a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FCHnLv7U3MU4_bPp6psm6A.jpeg"/></div></div></figure><p id="af12" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在你可以看到，产生的结构也是一个数据框，现在如果你想从这个集合中只查看一个单独的列，你可以使用我们之前提到的方法过滤它。例如，我只想查看年龄超过21岁的人的名字。我可以这样做</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/401991dc58bdbf0679f44f76e701c39e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zfm37lAoFZAuNNB0mSW4dA.jpeg"/></div></div></figure><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/14a771af22835f0b906e2dd4acaa53b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yL7cxRKHlwwA0-l0_PEPSg.jpeg"/></div></div></figure><p id="5904" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">要应用多个条件，我们可以用逻辑运算符&amp; (AND)和| (OR)来组合条件。</p><p id="cb86" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">例如，返回年龄大于21小于23的数据</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/b47c6bcc05e97062054517dd969f7937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IUbQujeltlAUN7-xwfsYFQ.jpeg"/></div></div></figure><h1 id="4150" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">从文件导入数据</h1><p id="22d3" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">熊猫图书馆支持各种文件格式，excel文件，csv文件，JSON和sql和html等等。</p><p id="e887" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这种情况下，我们可以使用许多内置函数，我将只提到其中最常用和最有用的两个，但这里有一个很好的参考来阅读pandas中的所有输入函数。当您需要处理不同的数据格式时，可以随时去那里阅读。</p><p id="2d8d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">从excel文件导入数据</p><blockquote class="nl nm nn"><p id="2c96" class="kw kx no ky b kz lu lb lc ld lv lf lg np lw lj lk nq lx ln lo nr ly lr ls lt ij bi translated">通用语法</p></blockquote><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="2ce8" class="mj jz iq mf b gy mk ml l mm mn">Data_frame = pd.read_excel(‘file_path’,sheet_name = &lt;’sheet name’ or sheet index&gt;)</span></pre><p id="ffd4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> sheet_name </strong>参数用于引用包含您的数据的工作表。</p><p id="e570" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">请注意，在excel中，工作表索引从0开始。</p><p id="70d3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果你有第一张表本身的数据，只需要提到路径就足够了。</p><p id="e48a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这是我的电子表格中的表格</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/1a7b47317f43050a4eface00dd422b32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*WfH7U_TfsAaJCx2Rejzp-w.jpeg"/></div></figure><p id="efb8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这是我将它导入到我的熊猫数据框时的样子。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/c56338d2435628af015f6c2dedbd560d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oHyS64aYeyWUcT8lTO3vwg.jpeg"/></div></div></figure><p id="733e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">*注意，pandas为我的文件引入了一个新的索引字段</strong></p><p id="55c0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">从CSV文件导入数据</p><p id="7016" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">CSV —逗号分隔文件是数据科学领域中最广泛使用的文件格式，我想你会同意这一点。您可以轻松地将csv数据导入数据框，如下所示。这与导入excel非常相似。但是没有提到纸张编号，因为csv中没有多个纸张。</p><blockquote class="nl nm nn"><p id="ee67" class="kw kx no ky b kz lu lb lc ld lv lf lg np lw lj lk nq lx ln lo nr ly lr ls lt ij bi translated">通用语法</p></blockquote><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="e14e" class="mj jz iq mf b gy mk ml l mm mn">Data_frame = pd.read_csv (‘&lt;file_path&gt;’)</span></pre><p id="a9ed" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里，pandas将在您导入的表中包含一个额外的索引字段。</p><h1 id="afb0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">添加新行</h1><p id="84da" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">向数据框中添加新行有时会很棘手。也许你已经经历过了。还有其他方法来满足向数据框添加新数据的要求，但是我将讨论最有效和最容易记住的方法，而不是必须记住许多不同的语法，因为它非常容易完成这项工作。</p><p id="f0cb" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">要在数据框中添加一个新行，首先我们需要将数据安排到一个具有key : value格式的结构中，其中key必须是列标题，value必须是数据部分。</p><p id="fa20" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们可以通过将新数据放入字典或熊猫系列来实现这一点。</p><p id="f15a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">假设我需要向上面从excel导入的表中添加一个新行。</p><p id="6805" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我的新数据行就像<strong class="ky ir"> index : g，BatchNo : b1，Price :400 </strong></p><p id="26d5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">一旦我将这个细节放入字典或序列中，为了将这个记录插入到数据帧的末尾，我可以使用<strong class="ky ir"> dataframe.append() </strong>函数以及一个名为<strong class="ky ir"> ignore_index </strong>的附加参数</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/70c61c1deb1205f194150c2c85cc9ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V1l088cCI96J67VF6wjebg.jpeg"/></div></div></figure><p id="9909" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">此外，您还可以使用相同的方法将两个数据框合并在一起。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/46f29d59d06e0dcbae3c624f84a580f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dGG2SnvKJWqza1ZMAOj_Fw.jpeg"/></div></div></figure><p id="39e1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">请注意，如果在语法中交换两个数据框的位置，可以将新数据连接到现有表的开头。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/c4bbd822694f1e02f6c4fdce9e35e9ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OtVfLX3yLtFtVSlKbWZPRg.jpeg"/></div></div></figure><p id="58de" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">此外，如果我们需要合并两个不同大小的数据框，这意味着具有不同数量的列，我们可以再次使用append()方法。例如，假设我的新数据包含另一个名为“折扣百分比”的字段，而该字段在原始表中并不存在。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/e6aa0d629a936c96289b519454bb2669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ej21WBSLGW1ViaUcyIcLEQ.jpeg"/></div></div></figure><p id="2b0b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这个“Nan”的意思是“不是一个数字”，就像python中默认的空值。</p><p id="ce1e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">注意，这里如果我们没有提到排序参数值为False，旧版本的pandas将根据字母顺序对列进行重新排序。</p><p id="bae3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">永远记住，为了使您所做的更改永久，不要忘记您需要将新的结果替换到结构本身，或者将inplace = true作为一个输入参数。例如</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="469a" class="mj jz iq mf b gy mk ml l mm mn">table1 = table1.append(newtable,ignore_index=True,sort=False)</span><span id="428c" class="mj jz iq mf b gy na ml l mm mn">or</span><span id="e400" class="mj jz iq mf b gy na ml l mm mn">table1.append(newtable,ignore_index=True,sort=False,inplace=True)</span></pre><p id="1ad6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">就这样，用一个功能你就可以管理大部分操作，是不是很神奇？当然是了..</p><p id="74ff" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，请确保您也阅读了<strong class="ky ir"> merge() </strong>和<strong class="ky ir"> join() </strong>函数。我不打算在这里包括它们，因为我需要使这篇文章看起来足够简单，以免吓跑新的蜜蜂。但是我将在我的下一篇文章中包括它们，以供熊猫参考。(正在编写中)</p><h1 id="2da1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">添加新列</strong></h1><p id="ae74" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">新列应该首先定义为pandas系列，索引在现有表中。</p><p id="604c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后可以很容易地将其添加到数据系列中。</p><p id="c767" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果列长度小于数据框中的记录数，剩余的记录将用Nan字符填充。</p><p id="1b0d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果新列有额外的值，它们将被丢弃</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/3d70f25c20b7b52ff8a815a3ea4a3c3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KVb1M-xJUIbXVTMDmTkElA.jpeg"/></div></div></figure><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/4fc0cfeb8a8fb8271a610c775fc39385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LqypzUDfNnALTXRI8Lyw_w.jpeg"/></div></div></figure><h1 id="3d41" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">删除行和列</h1><p id="35a2" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这可以使用<strong class="ky ir"> drop() </strong>功能来完成</p><p id="cb26" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这个操作中，除了列名或行索引，我们还必须提到轴参数。</p><p id="ae87" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">对于行，轴参数为0，对于列，轴参数为1。</strong></p><p id="39d2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">看看下面的例子。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/7c192129ec448a6e9f67a5ee22ff7f67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YwU_bI0oIXfZrS0jzDCT-w.jpeg"/></div></div></figure><p id="5a37" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">需要注意的是，无论何时使用<code class="fe mo mp mq mf b">.drop() </code>方法，Pandas都不会永久删除一行/一列，因为它不希望您意外丢失数据。</p><p id="35ae" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">要永久删除一行/一列，必须在该函数中设置原位参数，如下<code class="fe mo mp mq mf b">inplace=True</code></p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b336" class="mj jz iq mf b gy mk ml l mm mn">mydf.drop(‘r0’,axis=0,inplace = True)</span></pre><h1 id="b101" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">索引选项</h1><h1 id="79a2" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">重置数据帧的索引</strong></h1><p id="24a5" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在对数据框进行一些操作后，如果您的索引看起来不完全像您想要的那样，您可以使用<code class="fe mo mp mq mf b">.reset_index()</code>轻松地重置它。这将我们的DataFrame索引重置为名为<code class="fe mo mp mq mf b">index</code> <em class="no"> </em>的列，Pandas的默认索引值<code class="fe mo mp mq mf b">[0,1,2 ...]</code>是我们的新索引。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/3fb205d559720fc13eb69b88faf2aef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z7860RWLGNnJESDk_fEeAQ.jpeg"/></div></div></figure><p id="c198" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里，为了永久地应用这个改变，我们必须提到inplace = True参数。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6b55" class="mj jz iq mf b gy mk ml l mm mn">mydf.reset_index(inplace=True)</span></pre><p id="d6db" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">设置数据帧的索引</strong></p><p id="a59f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">类似地，我们可以通过使用set_index()函数来指定想要使用哪一列作为索引标签。</p><p id="7ffd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我将为我的mydf数据帧创建一个新列，并将其设置为索引，如下所示。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/22caf96c15d818e84c1489587f6451f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IeMV3YgUzm7DvIbi8ohH3w.jpeg"/></div></div></figure><p id="f095" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因此，正如您所看到的，与reset_index()函数在旧列仍在的情况下插入新的索引列不同，set_index()函数完全替换了以前的索引字段。</p><p id="08e0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">同样，使用inplace = true使更改永久化。</p><p id="046a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">除此之外，如果你也能学习多级索引会更好，但是我相信这超出了一篇初学者文章的范围，所以为了简单起见，我将跳过它。</p><h1 id="d098" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">清理数据集</h1><p id="e0fe" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">最常见的情况是，当您使用一个巨大的数据集时，由于各种原因，数据集中有丢失的值。熊猫会自动用一个<code class="fe mo mp mq mf b">NaN or Null</code>值填充那些缺失的元素，就像你在上面的一些例子中看到的那样。但是这种Nan或Null在许多操作中是不需要的。</p><p id="0302" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因此，我们可以使用<code class="fe mo mp mq mf b">.dropna()</code>删除那些自动填充的值，或者使用<code class="fe mo mp mq mf b">.fillna().</code>将它们替换为合适的值</p><p id="df22" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我将创建两个具有不同形状的随机值的数据帧，如下所示，这样将有Nan个值。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/6e8b49cd4b679263050c3f8d962d34b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*xygAfVhK3rmdsHA0ZixBeQ.jpeg"/></div></figure><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="2ce5" class="mj jz iq mf b gy mk ml l mm mn">df1.isnull().sum()</span></pre><p id="03b7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">上面的方法可以用来检查每一列中有多少空值。</p><p id="0449" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">德罗普纳()</p><p id="1107" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在让我们看看dropna()是如何工作的</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b694" class="mj jz iq mf b gy mk ml l mm mn">dropna(axis=0) remove all the rows that has a missiing value in it.</span><span id="7f0d" class="mj jz iq mf b gy na ml l mm mn">dropna(axis=1) remove all the columns that has a missiing value in it.</span></pre><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/6f1d06d00b52f6ec2eb53a25a3c42b21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*9-5Pez5Xtt_W5Bjesq5m2g.jpeg"/></div></figure><p id="bb64" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">请注意，永久效果需要inplace参数。</p><p id="9c6b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">菲尔娜</p><p id="74f1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">fillna()函数将用给定的值填充所有的Nan点，如下所示。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi of"><img src="../Images/d2d49a00207f5573e7b1f738eccd1659.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*G-7_k_ek6Jl75DcZTJ-jdg.jpeg"/></div></figure><p id="b154" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">但是在大多数情况下，这种填充操作无法使用这样一个公共值来完成。</p><p id="e7b9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们经常需要逐列替换Nan值，而且大多数时候是使用它们的平均值来完成的。这就是如何使用平均值替换D列中的Nan值。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/2fce3cda0fbcce823b2c1a4b2e86a763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*yGf37Zi_HP9J78szBNG15w.jpeg"/></div></figure><p id="0384" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">分组</strong></p><p id="bd33" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">grouby()函数允许您根据特定列中的值将数据集中的行组合在一起，以便您可以对它们执行聚合函数，如求和、均值、中值、标准差等。</p><p id="556c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在下面的例子中，我有一个从excel导入的表格，我对它做了一点修改以适应这个例子。看看我们如何根据批次号对行进行分组，并查看每个批次中其他列的平均值。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/c8a30ff8f4eb1f363bba8fc7e04f8bd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*274DCODhkVpT-ijzDIw2nQ.jpeg"/></div></div></figure><p id="0c2d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">使用count()方法，我们可以获得一个项目在数据帧中出现的次数。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/65ec529e4dc8099c09a6eb2803604a9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*xOgqFjzsSB8xMlQGDdEisw.jpeg"/></div></figure><p id="0931" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">使用describe()方法，我们可以大致了解数据帧的样子。它为我们提供了每个数据帧索引的摘要。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/55ebea5f45616851f9d18f6f00a7aa23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mOljWiwxYLmKap7VQxG-ZA.jpeg"/></div></div></figure><p id="9a95" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果您不熟悉此视图，您可以将此描述转置90度</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="419f" class="mj jz iq mf b gy mk ml l mm mn">#try this</span><span id="81e7" class="mj jz iq mf b gy na ml l mm mn">table1.groupby(‘BatchNo’).describe().transpose()</span></pre><h1 id="da75" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">在数据帧中查找唯一值</h1><p id="3f5a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">唯一值就是数据帧中的不同值。下面是一些可以用来检查列中唯一值的方法。</p><p id="b1d7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">使用<code class="fe mo mp mq mf b">.unique()</code>，我们可以找到一列中所有唯一的值。</p><p id="7666" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">使用<code class="fe mo mp mq mf b">.nunique()</code>我们可以得到计数，或者不同值的数量。</p><p id="7d1b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">使用value_count()我们可以获得唯一值及其出现次数。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/a01cdf3c5a2e50978d1b80718b639db8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OIu6iqp_XeU1_l8nmwiZyQ.jpeg"/></div></div></figure><p id="3c3f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">apply()方法</strong></p><p id="3bc3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe mo mp mq mf b">.apply()</code>方法用于调用一个普通函数来重复作用于数据帧中特定列的元素。假设我们有一个函数来计算给定价格的10%折扣，我们需要将这个函数应用到表中的所有价格上，我们可以这样做。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi gj"><img src="../Images/a0832998e925e5d31fdb89fa9ff74c13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*beO09Sxp9i49Io3sVn7Bzg.jpeg"/></div></div></figure><h1 id="e7fa" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">数据帧操作</h1><p id="fc49" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">大多数情况下，当您专业地处理数据集时，您在导入数据后要做的第一件事是，打印几行以保留作为可视参考，因为打印整个数据集将会是一种混乱，在大型数据集的情况下，</p><p id="2900" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这可以通过以下方式轻松实现</p><p id="9af4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> df.head( n ) </strong>显示数据集的前n行，或者</p><p id="945d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> df.tail(n) </strong>它将显示数据集的最后n条记录。这两个函数都太简单了，我不认为我们需要执行一个例子。试试吧！</p><p id="1550" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> df.info() </strong>提供关于数据集的基本细节，例如行数和列数、非空值的数量、每列中的数据类型以及数据帧使用的内存等</p><p id="8fd5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> df.shape </strong>不是一个函数(因此没有括号),而是数据集的一个属性，它显示了数据集中的列数和行数。</p><p id="518d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> df.drop_duplicates( ) </strong></p><p id="3191" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">将从数据集中移除重复的行。该函数使用一个名为“keep”的参数。此参数的默认值为“first ”,这意味着当检测到重复时，将保留第一个重复，而删除其他重复。</p><p id="5241" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果设置keep = 'last '，将保留最后一次出现的内容，删除其他内容。</p><p id="f27c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果设置keep = 'false '，则不会保存任何重复的事件</p><p id="897d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">和inplace参数，以便保存对数据框的更改。</p><h1 id="ff81" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">列名争论</h1><p id="3275" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">通常，数据集会有冗长的列名，包括符号、大写和小写单词、空格等。</p><p id="2bf2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了使按列名选择数据更容易，我们可以花一点时间清理它们的标签。</p><p id="82fc" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> df.columns </strong>将打印出所有的列名。</p><p id="8603" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后我们可以使用。<strong class="ky ir"> rename() </strong>方法，通过将旧名称映射到新名称的字典来重命名所需的或所有的列。</p><p id="7b5c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">请参见下面的示例</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/d0cdda843c633cda31b0f997b691240c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fbZgIgB9c9mHiNJ4U-x7Dw.jpeg"/></div></div></figure><p id="9d1a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">有时，大写字母也很麻烦，你可以用下面的方法将所有的列名转换成小写字母，而不用分别重命名。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4bbe" class="mj jz iq mf b gy mk ml l mm mn">table1.columns = [col.lower() for col in table1]</span></pre><h1 id="61e2" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">对数据帧进行排序和排序</strong></h1><p id="3be1" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">假设我们需要显示数据帧，其中某一列按升序显示，我们可以使用<code class="fe mo mp mq mf b">.sort_values() </code>函数轻松地对其进行排序</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/179d9da1d2715e5162c2b5629bfdd4db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fR35R1nokymhGRZ_BS63SA.jpeg"/></div></div></figure><h1 id="6368" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">将数据保存到输出文件</h1><p id="9232" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在对数据进行清理和重新排列的大量工作后，如果您需要将它保存为您喜欢的格式，类似于我们读取数据的方式，pandas提供了直观的命令来将其保存为各种不同的格式。</p><p id="649a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">前夫;前妻;前男友;前女友</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="fdf7" class="mj jz iq mf b gy mk ml l mm mn">df.to_csv(‘file path/filename.csv’)</span><span id="bfb9" class="mj jz iq mf b gy na ml l mm mn">df.to_excel(‘file path/filename.csv’)</span></pre><p id="fd97" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">嗯，我希望这将涵盖开始使用熊猫的大部分内容，如果你一直热衷于此，现在你应该对什么是熊猫以及如何使用它进行数据准备有很好的了解。</p><p id="3ac2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，你不需要记住所有这些语法，它们会随着不断的使用而保存在你的记忆中。</p><p id="49f9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">但是此时最重要的是对这个库的能力有一个大致的了解，这样你就可以通过谷歌搜索你需要的操作很容易地找到精确的语法，直到你达到不需要参考的程度。</p><p id="b780" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我故意试图缩小文章的范围，以防冗长和深入的解释通常不是初学者友好的材料，但即使如此，文章似乎太长，但不能帮助！</p><p id="6e7f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">熊猫不是小孩子的游戏，好像是！</p><p id="15a5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">最后，熊猫肯定比这大，所以今天就开始发现，去寻找更多。</p></div></div>    
</body>
</html>