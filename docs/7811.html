<html>
<head>
<title>Top 40 iOS Swift Questions Solutions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">40大iOS Swift问题解决方案</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/top-40-ios-swift-questions-solutions-d038c7f20a48?source=collection_archive---------5-----------------------#2020-12-23">https://medium.datadriveninvestor.com/top-40-ios-swift-questions-solutions-d038c7f20a48?source=collection_archive---------5-----------------------#2020-12-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f019" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我讨论了40个问题| Swift编程</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/b407f60d215719eb6b35ce7ac2add8c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fv_tJzQPuEPGGr7msy-c4w.png"/></div></div></figure><h1 id="1415" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">1.什么是类型推理？</h1><p id="2144" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">简而言之，这是一种迅捷的能力。你不需要总是在代码中写变量和常量的类型。例如:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="ece8" class="mf ky iq mb b gy mg mh l mi mj">// swift know its Int type<br/>var age = 40 // Int <br/>// You dont need to tell them always like below<br/>var age : Int = 40</span></pre><h1 id="945e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">2.什么是泛型？</h1><p id="4b66" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated"><em class="mk">通用代码</em>使您能够编写灵活的、可重用的函数和类型，它们可以根据您定义的需求与任何类型一起工作。</p><h2 id="5348" class="mf ky iq bd kz ml mm dn ld mn mo dp lh jy mp mq ll kc mr ms lp kg mt mu lt mv bi translated">用一个例子来理解它:</h2><p id="da8b" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">假设你想换成Int类型的值，让我们写一个非泛型函数:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="b7c5" class="mf ky iq mb b gy mg mh l mi mj">func swapTwoInts(_ a: inout Int, _ b: inout Int) {<br/>    let temporaryA = a<br/>    a = b<br/>    b = temporaryA<br/>}var num1 = 4<br/>var num2 = 5<br/>swapTwoInts(&amp;num1 , &amp;num2)</span></pre><blockquote class="mw mx my"><p id="885f" class="jn jo mk jp b jq jr js jt ju jv jw jx mz jz ka kb na kd ke kf nb kh ki kj kk ij bi translated">现在，假设你想交换两个double值或两个string值，你需要写另一个函数，因为上面的函数只接受Int类型。</p></blockquote><p id="82b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们有一个函数接受任何类型值并交换它们，这就是泛型所做的。</p><p id="53a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们用一个通用函数做同样的事情:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="42ea" class="mf ky iq mb b gy mg mh l mi mj">func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) {<br/>    let temporaryA = a<br/>    a = b<br/>    b = temporaryA<br/>}<br/>var num1 = 3<br/>var num2 = 4<br/>swapTwoValues(&amp;num1 , &amp;num2)var str1 = "sdf"<br/>var str2 = "dafdf"<br/>swapTwoValues(&amp;str1 , &amp;str2)</span></pre><p id="1fcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你可以交换任何类型的值，你不需要写不同的函数来交换不同类型的值。</p><ul class=""><li id="e19e" class="nc nd iq jp b jq jr ju jv jy ne kc nf kg ng kk nh ni nj nk bi translated">t是一个占位符，称为类型参数。</li></ul><p id="87d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">我们在swift中使用数组，这也是一种通用类型</strong></p><ul class=""><li id="444a" class="nc nd iq jp b jq jr ju jv jy ne kc nf kg ng kk nh ni nj nk bi translated">数组<element>，字典<key value=""/></element></li></ul><h1 id="3633" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">3.什么是协议？</h1><p id="f9bb" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">它是适合特定任务的方法、属性和其他需求的蓝图，可以被类、结构或枚举所采用。</p><blockquote class="mw mx my"><p id="08b7" class="jn jo mk jp b jq jr js jt ju jv jw jx mz jz ka kb na kd ke kf nb kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">协议不包括任何实现！！！！</em>T15】</strong></p><p id="7281" class="jn jo mk jp b jq jr js jt ju jv jw jx mz jz ka kb na kd ke kf nb kh ki kj kk ij bi translated"><em class="iq"> T </em> <strong class="jp ir"> <em class="iq">采用该协议的类型应该具有给定协议中存在的所有方法。这个动作叫做整合协议。</em> </strong></p></blockquote><p id="e578" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其语法如下所示:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="a031" class="mf ky iq mb b gy mg mh l mi mj">protocol Vehicle {<br/>  func accelerate()<br/>  func stop()<br/>}class Unicycle : Vehicle {<br/>  var peddling = false<br/>  func accelerate(){<br/>    peddling = true<br/>  }<br/>  func stop() {<br/>    peddling = false<br/>  }<br/>}</span></pre><h1 id="908a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">4.什么是元组？</h1><p id="8491" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">有时数据是成对或成组的。这方面的一个例子是2D网格上的一对(x，y)坐标。类似地，3D网格上的一组坐标由x值、y值和z值组成。在Swift中，您可以通过使用元组以非常简单的方式表示这种相关数据。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="ec77" class="mf ky iq mb b gy mg mh l mi mj">let coordinates: (Int, Int) = (2, 3)</span></pre><h1 id="50a8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">5.Swift中的可变性呢？</h1><p id="a97a" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">常量(<em class="mk"> let </em>)在swift中是常量，变量(<em class="mk"> var </em>)是变量。</p><h1 id="60f5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">6.什么是下标？</h1><p id="7135" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">使用<em class="mk">下标</em>可以快速访问集合的成员元素。</p><p id="5146" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下标包括:</p><ul class=""><li id="e677" class="nc nd iq jp b jq jr ju jv jy ne kc nf kg ng kk nh ni nj nk bi translated">收藏的名称，如<code class="fe nl nm nn mb b">scores</code></li><li id="6fb3" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nh ni nj nk bi translated">两个方括号<code class="fe nl nm nn mb b">[</code>和<code class="fe nl nm nn mb b">]</code></li><li id="603c" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nh ni nj nk bi translated">支架内的<em class="mk">键</em>或<em class="mk">索引</em></li></ul><blockquote class="mw mx my"><p id="ae33" class="jn jo mk jp b jq jr js jt ju jv jw jx mz jz ka kb na kd ke kf nb kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">默认情况下，可以对数组、字典、集合、列表、序列使用下标。也可以用</em> </strong> <code class="fe nl nm nn mb b"><strong class="jp ir"><em class="iq">subscript</em></strong></code> <strong class="jp ir"> <em class="iq">函数实现自己的。</em> </strong></p></blockquote><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="5839" class="mf ky iq mb b gy mg mh l mi mj">subscript(parameterList) -&gt; ReturnType {<br/> get {<br/> // return someValue of ReturnType<br/> }<br/> set(newValue) {<br/> // set someValue of ReturnType to newValue<br/> }</span></pre><h1 id="4c32" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">7.什么是可选的？</h1><p id="2bc5" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">可选方案是Swift解决既有价值又无价值问题的方案。可选的允许保存一个值或零。</p><h1 id="9e30" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">8.你可以用什么方法打开一个可选的？</h1><p id="3284" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated"><strong class="jp ir">我们可以通过以下方式解开任何可选的:</strong></p><ol class=""><li id="4176" class="nc nd iq jp b jq jr ju jv jy ne kc nf kg ng kk nt ni nj nk bi translated">通过可选绑定</li><li id="9fb1" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nt ni nj nk bi translated">通过强制展开</li><li id="f64a" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nt ni nj nk bi translated">通过守卫声明</li><li id="4bee" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nt ni nj nk bi translated">通过零合并</li></ol><h2 id="4592" class="mf ky iq bd kz ml mm dn ld mn mo dp lh jy mp mq ll kc mr ms lp kg mt mu lt mv bi translated">可选绑定(如果有)</h2><p id="1a90" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">最简单的方法是打开一个可选的。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="c64b" class="mf ky iq mb b gy mg mh l mi mj">var authorName : String? = "Mohd Yasir"if let authorName == authorName {<br/>    print("Author name is \(authorName)")<br/>else{<br/>    print("No Author Name")<br/>}</span></pre><h2 id="2f47" class="mf ky iq bd kz ml mm dn ld mn mo dp lh jy mp mq ll kc mr ms lp kg mt mu lt mv bi translated">通过强制展开</h2><p id="d09a" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">为了强制展开，我们使用“！”。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="731b" class="mf ky iq mb b gy mg mh l mi mj">var authorName : String? = "Mohd Yasir"<br/>print("Auhor name : \(authorName!)")</span></pre><h2 id="a524" class="mf ky iq bd kz ml mm dn ld mn mo dp lh jy mp mq ll kc mr ms lp kg mt mu lt mv bi translated">守卫声明</h2><p id="e563" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">有时你想检查一个条件，只有当条件为真时才继续执行一个函数，比如当你使用optionals时。想象一个从网络上获取一些数据的函数。如果网络中断，提取可能会失败。封装这种行为的通常方法是使用可选的，如果获取成功，它将有一个值，否则为零。</p><p id="9f36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，Swift有一个有用且强大的功能可以提供帮助:T2守卫声明T3。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="9cf4" class="mf ky iq mb b gy mg mh l mi mj">func testingGuard( _ name : String?){<br/>    guard let unrappedname = name else {<br/>        print("You dont entered any name")<br/>        return <br/>    }<br/>    print("Hello , \(unrappedname)")<br/>}</span></pre><h2 id="c380" class="mf ky iq bd kz ml mm dn ld mn mo dp lh jy mp mq ll kc mr ms lp kg mt mu lt mv bi translated">零合并</h2><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="7f27" class="mf ky iq mb b gy mg mh l mi mj">let name = String? = nil<br/>let unwrappedName = name5 ?? "Unkonwn"</span></pre><h1 id="b3a6" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">9.Swift中会发生什么样的内存分配？</h1><p id="4017" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated"><strong class="jp ir">在短栈和堆里</strong></p><p id="2938" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你创建一个引用类型，比如<strong class="jp ir">类</strong>时，系统将实际的实例存储在一个叫做<strong class="jp ir">堆</strong>的内存区域中。值类型的实例，比如一个<strong class="jp ir">结构</strong>驻留在一个叫做<strong class="jp ir">堆栈</strong>的内存区域中。</p><h1 id="14d8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">10.堆栈内存和堆内存有什么区别？</h1><ul class=""><li id="2a09" class="nc nd iq jp b jq lv ju lw jy nu kc nv kg nw kk nh ni nj nk bi translated">系统使用堆栈来存储执行的即时线程上的任何内容；它由CPU严格管理和优化。当一个函数创建一个变量时，堆栈存储该变量，然后在函数退出时销毁它。因为堆栈是如此严格地组织的，所以它非常有效，因此也非常快。</li><li id="f930" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nh ni nj nk bi translated">系统使用堆来存储引用类型的实例。堆通常是一个大的内存池，系统可以从中请求和动态分配内存块。寿命是灵活的和动态的。堆不会像栈那样自动销毁它的数据；要做到这一点，还需要做更多的工作。与在堆栈上相比，这使得在堆上创建和移除数据的过程更慢。</li></ul><h1 id="af42" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">11.什么是输入输出参数？</h1><p id="7958" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">函数参数默认为常量，也就是说不能修改。为了说明这一点，请考虑以下代码:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="2ff0" class="mf ky iq mb b gy mg mh l mi mj">func incrementAndPrint(_ value: Int) {  <br/>    value += 1  <br/>    print(value) <br/>}</span></pre><p id="2fbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这会导致一个错误:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="4e11" class="mf ky iq mb b gy mg mh l mi mj">Left side of mutating operator isn't mutable: 'value' is a 'let' constant</span></pre><p id="f4cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种行为称为复制入复制出或按值结果调用。你这样做:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="3729" class="mf ky iq mb b gy mg mh l mi mj">func incrementAndPrint(_ value: inout Int) {  <br/>    value += 1 <br/>    print(value) <br/>}</span></pre><p id="9cf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">参数类型前的inout指示该参数应该被复制进来，即在函数中使用的本地副本，并在函数返回时被复制回来。</p><h2 id="aa09" class="mf ky iq bd kz ml mm dn ld mn mo dp lh jy mp mq ll kc mr ms lp kg mt mu lt mv bi translated">与符号(&amp;)</h2><p id="2cb9" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">您需要稍微调整一下函数调用来完成这个例子。在参数前添加一个&amp;符号，这可以在调用位置清楚地表明您使用的是复制入复制出:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="7c92" class="mf ky iq mb b gy mg mh l mi mj">var value = 5 <br/>incrementAndPrint(&amp;value) <br/>print(value)</span></pre><h1 id="da5e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">12.同步和异步的区别是什么？</h1><p id="1db5" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">异步意味着，你可以一次执行多件事情，并且你不必为了继续下一件事情而完成当前的事情。同步基本上意味着一次只能执行一件事。</p><h1 id="5ccd" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">13.如何将数据从一个ViewController传递到另一个？</h1><p id="7763" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">您可以通过6种方式在Swift视图控制器之间传递数据:</p><ol class=""><li id="3b29" class="nc nd iq jp b jq jr ju jv jy ne kc nf kg ng kk nt ni nj nk bi translated">通过使用实例属性(A → B)</li><li id="5521" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nt ni nj nk bi translated">通过使用片段(对于故事板)</li><li id="5b77" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nt ni nj nk bi translated">通过使用实例属性和函数(A ← B)</li><li id="fee4" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nt ni nj nk bi translated">通过使用委托模式</li><li id="5123" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nt ni nj nk bi translated">通过使用闭包或完成处理程序</li><li id="734a" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nt ni nj nk bi translated">通过使用<code class="fe nl nm nn mb b">NotificationCenter</code>和<em class="mk">观察器</em>模式</li></ol><h1 id="83f5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">14.Swift中的完成处理程序是什么？</h1><p id="6f1e" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">完成处理程序是一个闭包(“一个自包含的功能块，可以在代码中传递和使用”)。它作为参数传递给一个函数，然后在该函数完成时被调用。</p><p id="1abd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成处理程序的目的是告诉调用该函数的任何东西它已经完成了，并且可以选择给它一些数据或一个错误。有时它们被称为回调，因为它们回调了调用它们的函数。示例:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="3c21" class="mf ky iq mb b gy mg mh l mi mj">import UIKitlet firstVC = UIViewController()<br/>let nextVC = UIViewController()firstVC.present(nextVC, animated: true, completion: { () in print("Welcome") })</span></pre><h1 id="6e05" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">15.Swift使用什么编译器？</h1><p id="b898" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">Swift编译器使用LLVM。</p><h1 id="80f3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">16.Swift中的懒是什么？</h1><p id="527e" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在简单的"<em class="mk">中，惰性存储属性是一个直到第一次使用时才计算初始值的属性。</em>”</p><h1 id="d254" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">17.解释核心数据？</h1><p id="f815" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">~苹果文档</p><ul class=""><li id="7dd0" class="nc nd iq jp b jq jr ju jv jy ne kc nf kg ng kk nh ni nj nk bi translated">这是一个框架💯</li></ul><p id="fd60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">苹果公司表示:“<em class="mk">使用核心数据保存应用程序的永久数据以供离线使用，缓存临时数据，并在单个设备上为应用程序添加撤销功能。</em>”😮</p><p id="de62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">核心数据为您提供了以下功能:持久性、单个或批量更改的撤销和重做、后台数据任务、视图同步、版本控制和迁移等..。</p><h2 id="6895" class="mf ky iq bd kz ml mm dn ld mn mo dp lh jy mp mq ll kc mr ms lp kg mt mu lt mv bi translated">创建核心数据模型</h2><blockquote class="mw mx my"><p id="34e0" class="jn jo mk jp b jq jr js jt ju jv jw jx mz jz ka kb na kd ke kf nb kh ki kj kk ij bi translated"><em class="iq">使用核心数据的第一步是创建数据模型文件。在这里，您可以定义应用程序对象的结构，包括它们的对象类型、属性和关系。</em></p></blockquote><p id="6cf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过选中“使用核心数据”复选框，您可以在创建项目时创建核心数据模型。</p><h2 id="ab68" class="mf ky iq bd kz ml mm dn ld mn mo dp lh jy mp mq ll kc mr ms lp kg mt mu lt mv bi translated">核心数据堆栈</h2><p id="a4d5" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">创建数据模型文件后，设置协作支持应用程序模型层的类。这些类统称为核心数据堆栈。</p><p id="9aa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有几个核心数据组件:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nx"><img src="../Images/bbb2260b67ca31fca4111b4e41f2bfec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NW6labZfYheCkZTB.png"/></div></div></figure><ul class=""><li id="e63f" class="nc nd iq jp b jq jr ju jv jy ne kc nf kg ng kk nh ni nj nk bi translated"><code class="fe nl nm nn mb b">NSManagedObjectModel</code>的一个实例代表你的应用程序的模型文件，描述你的应用程序的类型、属性和关系。</li><li id="a65d" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nh ni nj nk bi translated">一个<code class="fe nl nm nn mb b">NSManagedObjectContext</code>实例跟踪你的应用程序类型的变化。</li><li id="625d" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nh ni nj nk bi translated">一个<code class="fe nl nm nn mb b">NSPersistentStoreCoordinator</code>实例从商店中保存和获取你的应用程序类型的实例。</li><li id="e4a3" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nh ni nj nk bi translated"><code class="fe nl nm nn mb b">NSPersistentContainer</code>的一个实例一次设置了模型、上下文和存储协调器。</li></ul><h2 id="5505" class="mf ky iq bd kz ml mm dn ld mn mo dp lh jy mp mq ll kc mr ms lp kg mt mu lt mv bi translated">核心数据中的不同数据类型</h2><p id="fb14" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">许多应用程序需要持久化并呈现不同种类的信息。核心数据提供不同的属性，包括所有数据库通用的属性，如<code class="fe nl nm nn mb b">Date</code>或<code class="fe nl nm nn mb b">Decimal</code>类型，以及用<code class="fe nl nm nn mb b">Transformable</code>类型处理的非标准属性。</p><h1 id="9bc5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">18.什么是哨兵值？</h1><p id="e4b7" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">代表特殊情况(如缺少值)的有效值称为标记值。这就是你的空字符串。🙂</p><h1 id="ea44" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">19.自动参考计数</h1><p id="6ced" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">Swift使用ARC来跟踪和管理应用程序的内存使用情况。当不再需要类实例时，ARC会自动释放这些实例所使用的内存，您不需要考虑内存管理。</p><p id="4494" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但在少数情况下，ARC需要更多关于代码各部分之间关系的信息，以便为您管理内存。</p><blockquote class="mw mx my"><p id="724b" class="jn jo mk jp b jq jr js jt ju jv jw jx mz jz ka kb na kd ke kf nb kh ki kj kk ij bi translated"><em class="iq">引用计数仅适用于类的实例。结构和枚举是值类型，而不是引用类型，并且不通过引用来存储和传递。</em></p><p id="dbab" class="jn jo mk jp b jq jr js jt ju jv jw jx mz jz ka kb na kd ke kf nb kh ki kj kk ij bi translated"><em class="iq">我会就这个话题发表一整篇文章，提供更多细节！</em></p></blockquote><h1 id="45d3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">20.什么是嵌套可选？</h1><p id="a553" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">考虑下面的嵌套可选——它对应于盒中盒中盒内的一个数字。</p><div class="ny nz gp gr oa ob"><a href="https://www.datadriveninvestor.com/2020/10/23/how-i-became-an-independent-researcher-of-the-tangled-net-of-economic-development-funding/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">我是如何成为经济发展资金纠结网的独立研究员|数据…</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">我很少发现自己处于一种看似独立的自由形式的身体抑郁状态，这种状态使人…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op kv ob"/></div></div></a></div><h1 id="bc86" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">21.什么是房产观察家？</h1><p id="6480" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">当属性将要改变时调用willSet观察器，而在属性改变后调用didSet观察器。它们的语法类似于getters和setters:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="aa8c" class="mf ky iq mb b gy mg mh l mi mj">struct S {<br/>    var stored: String {<br/>        willSet {<br/>            print("willSet was called")<br/>            print("stored is now equal to \(self.stored)")<br/>            print("stored will be set to \(newValue)")<br/>        }</span><span id="bb72" class="mf ky iq mb b gy oq mh l mi mj">        didSet {<br/>            print("didSet was called")<br/>            print("stored is now equal to \(self.stored)")<br/>            print("stored was previously set to \(oldValue)")<br/>        }<br/>    }<br/>}var s = S(stored: "first")<br/>s.stored = "second"</span></pre><ul class=""><li id="a105" class="nc nd iq jp b jq jr ju jv jy ne kc nf kg ng kk nh ni nj nk bi translated">威尔塞特被称为</li><li id="5c01" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nh ni nj nk bi translated">存储现在等于第一</li><li id="3072" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nh ni nj nk bi translated">存储将被设置为秒</li><li id="5106" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nh ni nj nk bi translated">didSet被调用</li><li id="36d0" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nh ni nj nk bi translated">存储现在等于秒</li><li id="45bd" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nh ni nj nk bi translated">存储先前被设置为第一</li></ul><h1 id="7395" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">22.什么时候你会说一个app处于活跃状态？</h1><p id="79bb" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">当一个应用程序接受事件并在前台运行时，它被称为处于活动状态。</p><h1 id="ae85" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">23.Viewdidload和Viewdidappear有什么区别？</h1><ul class=""><li id="ed0d" class="nc nd iq jp b jq lv ju lw jy nu kc nv kg nw kk nh ni nj nk bi translated">Viewdidload在加载到内存中时被调用。</li><li id="507f" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nh ni nj nk bi translated">当视图可见并呈现在设备上时，将调用Viewdidappear。</li></ul><h1 id="3e96" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">24.你说的并发是什么意思？</h1><p id="71a7" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">并发是程序中的一种情况，在这种情况下，两个或多个任务被独立定义，并且每个任务都可以独立于另一个任务执行，即使另一个任务也在同时执行。</p><h1 id="47dd" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">25.iOS中实现并发的方式有哪些？</h1><p id="10d4" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在iOS中实现并发的三种方式是:</p><ul class=""><li id="bbd0" class="nc nd iq jp b jq jr ju jv jy ne kc nf kg ng kk nh ni nj nk bi translated">线</li><li id="7675" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nh ni nj nk bi translated">调度队列</li><li id="700f" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nh ni nj nk bi translated">操作队列</li></ul><h1 id="9053" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">26.什么是线程？</h1><p id="1223" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">据苹果公司称:</p><blockquote class="mw mx my"><p id="3c7d" class="jn jo mk jp b jq jr js jt ju jv jw jx mz jz ka kb na kd ke kf nb kh ki kj kk ij bi translated">当您需要执行一项冗长的任务，但又不想让它阻塞应用程序其余部分的执行时，线程尤其有用。特别是，您可以使用线程来避免阻塞应用程序的主线程，主线程处理用户界面和事件相关的操作。线程还可以用来将一个大型作业分成几个较小的作业，这可以提高多核计算机的性能。”</p></blockquote><h1 id="6e4a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">27.什么是基础中的调度队列？</h1><p id="450d" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">据苹果公司称:</p><blockquote class="mw mx my"><p id="7d63" class="jn jo mk jp b jq jr js jt ju jv jw jx mz jz ka kb na kd ke kf nb kh ki kj kk ij bi translated"><em class="iq">管理应用程序主线程或后台线程上串行或并发任务执行的对象。</em></p></blockquote><h1 id="afd9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">28.前景和背景的区别？</h1><p id="aac7" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">前景包含用户正在使用的应用程序，背景包含幕后的应用程序。</p><h1 id="67bd" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">29.班级</h1><p id="098f" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">与值类型相反，类是引用类型。您创建一个类，如下所示:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="53c6" class="mf ky iq mb b gy mg mh l mi mj">class Person {<br/>    var firstName: String<br/>    var lastName: Stringinit(firstName: String, lastName: String) {<br/>        self.firstName = firstName<br/>        self.lastName = lastName<br/>    }<br/> <br/>    var fullName: String {<br/>        return "\(firstName) \(lastName)"<br/>    }<br/>}let john = Person(firstName: "Johnny", lastName: "Appleseed")</span></pre><p id="77a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Swift中，结构的实例是不可变的值，而类的实例是可变的对象。类是引用类型，所以类类型的变量不存储实际的实例——它存储对内存中存储实例的位置的引用。</p><h2 id="54d7" class="mf ky iq bd kz ml mm dn ld mn mo dp lh jy mp mq ll kc mr ms lp kg mt mu lt mv bi translated">堆栈vs堆来了！</h2><p id="63e5" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">当创建引用类型(如class)时，系统将实际的实例存储在称为堆的内存区域中，而值类型(如struct)的实例驻留在称为堆栈的内存区域中。</p><ul class=""><li id="c301" class="nc nd iq jp b jq jr ju jv jy ne kc nf kg ng kk nh ni nj nk bi translated">系统使用堆栈来存储执行的即时线程上的任何内容；它由CPU严格管理和优化。当一个函数创建一个变量时，堆栈存储该变量，然后在函数退出时销毁它。因为堆栈是如此严格地组织的，所以它非常有效，因此也非常快。</li><li id="2693" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nh ni nj nk bi translated">系统使用堆来存储引用类型的实例。堆通常是一个大的内存池，系统可以从中请求和动态分配内存块。寿命是灵活的和动态的。堆不会像栈那样自动销毁它的数据；要做到这一点，还需要做更多的工作。与在堆栈上相比，这使得在堆上创建和移除数据的过程更慢。</li></ul><h2 id="0c07" class="mf ky iq bd kz ml mm dn ld mn mo dp lh jy mp mq ll kc mr ms lp kg mt mu lt mv bi translated">使用引用</h2><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="a209" class="mf ky iq mb b gy mg mh l mi mj">var homeOwner = john <br/>john.firstName = "John" <br/>john.firstName // "John" <br/>homeOwner.firstName // "John"</span></pre><blockquote class="mw mx my"><p id="9511" class="jn jo mk jp b jq jr js jt ju jv jw jx mz jz ka kb na kd ke kf nb kh ki kj kk ij bi translated"><em class="iq">类实例之间的共享产生了一种新的传递事物的思维方式。例如，如果john对象发生变化，那么任何包含对john的引用的对象都会自动看到更新。如果你正在使用一个结构，你将不得不单独地更新每个副本，否则它将仍然有旧的值“Johnny”。</em></p></blockquote><h2 id="8b10" class="mf ky iq bd kz ml mm dn ld mn mo dp lh jy mp mq ll kc mr ms lp kg mt mu lt mv bi translated">标识运算符</h2><p id="444c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">因为类是引用类型，所以多个常量和变量在幕后引用同一个类实例是可能的。</p><p id="57f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Swift中，===运算符允许您检查一个对象的标识是否等于另一个对象的标识:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="5112" class="mf ky iq mb b gy mg mh l mi mj">john === homeOwner // truelet newInstance = Person(firstName: "Johnny",  lastName: "Appleseed")newInstance === John // false</span></pre><h1 id="c060" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">30.什么是MVC？</h1><p id="03e6" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">MVC代表模型视图控制器。模型代表应用程序数据；视图在屏幕上画东西；控制器管理模型和视图之间的数据流。模型和视图从不直接相互通信，而是依靠控制器来协调通信。</p><h1 id="18c8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">31.@State是什么？</h1><p id="b6b4" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">如果您将@State分配给一个属性，SwiftUI将监控该属性，如果它发生变异或更改，将使当前布局无效并重新加载。</p><p id="0374" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不需要调用refresh调用(或reloadData()，正如您以前在CollectionViews和TableViews中看到的那样)。</p><h1 id="8dcb" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">32.什么是修饰语？</h1><p id="2fe3" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这是一种呈现自定义交互和装饰的方式。<code class="fe nl nm nn mb b"><strong class="jp ir">font()</strong></code>、<code class="fe nl nm nn mb b"><strong class="jp ir">background()</strong></code>和<code class="fe nl nm nn mb b"><strong class="jp ir">clipShape()</strong></code>就是一些例子。</p><h1 id="7485" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">33.什么是嵌套语法？</h1><p id="c6d5" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">一个简单的例子是在导航视图中嵌套一个列表。</p><h1 id="f3ec" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">34.SwiftUI中的分组是什么？</h1><p id="a4b1" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">假设您编写了以下代码:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="6013" class="mf ky iq mb b gy mg mh l mi mj">VStack {<br/>    Text("Line")<br/>    Text("Line")<br/>    Text("Line")<br/>    Text("Line")<br/>    Text("Line")<br/>    Text("Line")<br/>    Text("Line")<br/>    Text("Line")<br/>    Text("Line")<br/>    Text("Line")<br/>}</span></pre><p id="5cab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样做很好，但是如果您尝试添加第11段文本，您将得到如下错误:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="4a85" class="mf ky iq mb b gy mg mh l mi mj">ambiguous reference to member 'buildBlock()'</span></pre><p id="876e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为SwiftUIs视图构建系统有各种代码，旨在让我们添加1个视图、2个视图或4个、5个、6个、7个、8个、9个和10个视图，但不能用于11个及以上的视图，这不起作用。</p><p id="3814" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们可以这样做:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="e5c5" class="mf ky iq mb b gy mg mh l mi mj"><strong class="mb ir">var</strong> body: some View {<br/>    VStack {<br/>        Group {<br/>            Text("Line")<br/>            Text("Line")<br/>            Text("Line")<br/>            Text("Line")<br/>            Text("Line")<br/>            Text("Line")<br/>        }</span><span id="4def" class="mf ky iq mb b gy oq mh l mi mj">        Group {<br/>            Text("Line")<br/>            Text("Line")<br/>            Text("Line")<br/>            Text("Line")<br/>            Text("Line")<br/>        }<br/>    }<br/>}</span></pre><p id="f632" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这产生了完全相同的结果，除了现在我们可以超越10个视图的限制，因为<code class="fe nl nm nn mb b"><strong class="jp ir">VStack</strong></code>只包含两个视图——<strong class="jp ir">两个</strong>组。</p><h1 id="cb02" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">35.什么是组合？</h1><p id="791b" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">Combine是Swift自己的Reactive Streams版本，它支持对对象进行监控(观察),并将数据通过流从核心应用程序逻辑传回UI层。</p><h1 id="21e3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">36.Swifts字典用什么函数？</h1><p id="2d16" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">Swift使用<strong class="jp ir"> SipHash </strong>散列函数来处理许多散列值计算。</p><h1 id="4209" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak"> 37。Swift中的init()是什么？</strong></h1><p id="effe" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">初始化是准备使用枚举、结构或类的实例的过程。</p><h1 id="f845" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak"> 38。iOS swift中使用的控制转移语句有哪些？</strong></h1><ol class=""><li id="5574" class="nc nd iq jp b jq lv ju lw jy nu kc nv kg nw kk nt ni nj nk bi translated">返回</li><li id="c7a9" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nt ni nj nk bi translated">破裂</li><li id="f92b" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nt ni nj nk bi translated">继续</li><li id="38c8" class="nc nd iq jp b jq no ju np jy nq kc nr kg ns kk nt ni nj nk bi translated">失败</li></ol><h1 id="4fef" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak"> 39。swift中的代表是什么？</strong></h1><p id="b3d4" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">委托是一种设计模式，用于在结构或类之间传递数据或通信。委托允许在特定事件发生时将消息从一个对象发送到另一个对象，并用于处理表视图和集合视图事件。</p><h1 id="7aac" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">四十。什么是可选链接？</strong></h1><p id="1047" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">可选链接是一个有用的过程，我们可以结合可选链接来调用可选链接上的方法、属性和下标，这些值可能为零，也可能不为零。在这个过程中，我们可能会尝试从可选值链中检索一个值。</p></div><div class="ab cl or os hu ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ij ik il im in"><h1 id="2668" class="kx ky iq bd kz la oy lc ld le oz lg lh li pa lk ll lm pb lo lp lq pc ls lt lu bi translated">从这里去哪里？</h1><blockquote class="mw mx my"><p id="07d8" class="jn jo mk jp b jq jr js jt ju jv jw jx mz jz ka kb na kd ke kf nb kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">我的领英</em></strong><em class="iq">:</em><a class="ae pd" href="https://www.linkedin.com/in/my-pro-file" rel="noopener ugc nofollow" target="_blank"><em class="iq">linkedin.com/in/my-pro-file</em></a></p></blockquote><p id="78a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">检查这个:</strong><a class="ae pd" href="https://bit.ly/38k4w7l" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://bit.ly/38k4w7l</strong></a></p><p id="adad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了取得联系，阅读那些有用的文章，在这里关注我<a class="ae pd" href="https://mdcode2021.medium.com/" rel="noopener">。</a></p><p id="1bb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">谢谢！<br/></strong><a class="ae pd" href="http://linkedin.com/in/my-pro-file" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"/></a></p><h2 id="f580" class="mf ky iq bd kz ml mm dn ld mn mo dp lh jy mp mq ll kc mr ms lp kg mt mu lt mv bi translated">访问专家视图— <a class="ae pd" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank">订阅DDI英特尔</a></h2></div></div>    
</body>
</html>