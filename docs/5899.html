<html>
<head>
<title>The Magic of the Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆栈的魔力</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/the-magic-of-the-stack-73d83f5530a2?source=collection_archive---------13-----------------------#2020-10-04">https://medium.datadriveninvestor.com/the-magic-of-the-stack-73d83f5530a2?source=collection_archive---------13-----------------------#2020-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/439e67c5773425cc515dd8acd9766be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*-muO5GsrnXz7F1mNfkiarw.jpeg"/></div></figure><p id="5cf5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">小时候，我最难忘的经历是和一群每周都会见到的人一起玩纸牌游戏。我从小时候的口袋妖怪交易卡游戏开始，在我初中和高中的时候毕业到游戏王。这一切都回到了2020年2月左右，当时我决定重温《魔法规则:聚会》，并最终尝试一下。</p><p id="5cfd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">与此同时，我在熨斗学校学习如何在各种不同的环境下编程。随着我花更多的时间学习普通Javascript、Rails和React的细节，编码软件和玩交易卡游戏之间的重叠开始真正吸引我。</p><p id="83ea" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请继续阅读，和我一起探索这个概念。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ks"><img src="../Images/f337920257183754a86145112dacb4b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ObWZQMMXjrjjdARX"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Photo by <a class="ae lf" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9c7f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">特别是，大多数纸牌游戏采用了堆栈的概念。在《魔法:聚会》中，它决定了出牌的顺序，这是游戏从头到尾的关键。有趣的是，Javascript <em class="lg">也</em>采用了堆栈的概念。</p><p id="b9b3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在【T2魔法】中，牌在被激活和实际发生之间游走。简而言之，当玩家一施放一个咒语(例如出一张牌)，它就会进入堆叠。然后，二号玩家有机会做出回应，这被称为拥有“优先权”然后，无论是否播放，玩家一都有机会回应。如果两个玩家都不做任何事，咒语就会生效。</p><h1 id="956a" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">螺栓和熊</h1><p id="936b" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">让我们探索一下<em class="lg">魔法</em>中一个非常常见的堆栈演示。</p><p id="23ce" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一号玩家有一只符文爪熊。他们攻击，玩他们手中的泰坦尼克增长，以增加熊的力量。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/177e37ff0d367ffa57705de9702d62c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/0*i_CvMBIv8vVzsJUg"/></div></figure><p id="42d1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一号玩家随着巨大的成长获得优先权并通过。但是第二个玩家有一个锦囊妙计，他敲打一座山，向熊射出闪电。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/eb9ecdae0f93871f15824b15a79d0a85.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/0*Cenuz6RlcJT31mFS"/></div></figure><p id="57e5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一号玩家再次获得优先权并通过。二号玩家也通过了。螺栓分解，熊死亡。巨大的增长仍在堆栈中，但它不会解决。卡片“嘶嘶作响”，什么也不做，因为它没有有效的目标。</p><p id="0a10" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果这种情况发生在不同的地方，会有一个非常不同的结果。例如，如果玩家1激活了泰坦尼克增长<em class="lg">以响应</em>闪电，熊将仍然活着，因为泰坦尼克增长由于堆栈的<strong class="jw ir">后进先出(LIFO) </strong>原则而首先解决。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/605e6ccfc16ecbbb471967f2896bbffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/0*2NJP0mRfzki4aTTd.png"/></div></figure><p id="5b57" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个小例子演示了堆栈是如何工作的，并暗示了作为一个魔术玩家，你可以使用许多技巧来利用系统并利用其细微差别。</p><h2 id="a65d" class="mm li iq bd lj mn mo dn ln mp mq dp lr kf mr ms lv kj mt mu lz kn mv mw md mx bi translated">Javascript调用堆栈</h2><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi my"><img src="../Images/710fec6bfbad65e2e0afc3da3b61b6da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oo5kYGdJA20CIzKO-FpXuQ.png"/></div></div></figure><p id="d684" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，浏览器中的JavaScript引擎是一个单线程解释器，由一个堆和一个调用栈组成。浏览器提供了web APIs，如DOM、AJAX和定时器。</p><p id="c472" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">调用堆栈主要用于调用函数。同步的调用堆栈(类似于<em class="lg"> Magic的)</em>从上到下一次执行一个函数。</p><div class="mz na gp gr nb nc"><a href="https://www.datadriveninvestor.com/2020/09/16/training-a-digit-recognizer-using-pytorch-and-inferencing-on-cpu-with-onnx-runtime/" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">用PyTorch训练数字识别器，用ONNX Runtime | Data Driven在CPU上进行推理…</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">在任何机器学习问题中，我们的神经网络的目标是在新的未知数据上做得很好，训练一个深度…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq js nc"/></div></div></a></div><p id="7979" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">简单地说，调用栈是一种数据结构，它使用<strong class="jw ir">后进先出(LIFO) </strong>原则来临时存储和管理函数调用。</p><p id="2b5a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们看一个代码示例，通过将堆栈跟踪错误打印到控制台来演示LIFO:</p><pre class="kt ku kv kw gt nr ns nt nu aw nv bi"><span id="75af" class="mm li iq ns b gy nw nx l ny nz">function firstFunction(){<br/>  throw new Error('Stack Trace Error');<br/>}</span><span id="7f22" class="mm li iq ns b gy oa nx l ny nz">function secondFunction(){<br/>  firstFunction();<br/>}</span><span id="f869" class="mm li iq ns b gy oa nx l ny nz">function thirdFunction(){<br/>  secondFunction();<br/>}</span><span id="40a5" class="mm li iq ns b gy oa nx l ny nz">thirdFunction();</span></pre><p id="e6d6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当代码运行时，我们得到一个错误。打印出一个堆栈，显示这些函数是如何相互堆叠的。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ob"><img src="../Images/b676667290ba52ecccd9514a28bc4b75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*My5iWE_vzELApJsq"/></div></div></figure><p id="92fb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您会注意到，函数作为堆栈的排列以<code class="fe oc od oe ns b">firstFunction()</code>(这是添加到堆栈中的最后一个函数，被弹出以抛出错误)开始，接着是<code class="fe oc od oe ns b">secondFunction()</code>，然后是<code class="fe oc od oe ns b">thirdFunction()</code>(这是代码执行时第一个被推入堆栈的函数)。</p><p id="68f7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当一个函数被调用时，该函数、它的参数和变量被压入调用堆栈，形成一个临时堆栈框架。这个堆栈帧是堆栈中的一个内存位置。当函数从堆栈中弹出并返回时，内存被清空。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi of"><img src="../Images/edcafd69dba15bdccb819bfa28061eb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/0*gLTpPNFU4zMcshpI"/></div></figure><p id="f9bc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">调用堆栈维护每个堆栈帧位置的记录。它知道下一个要执行的函数和执行后要删除的函数。这就是JavaScript中代码执行同步的原因。想想玩<em class="lg">魔法</em>吧:你可以在两个玩家都通过优先权后，按顺序解决出牌的效果。</p><h1 id="968c" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">调用堆栈和函数调用</h1><pre class="kt ku kv kw gt nr ns nt nu aw nv bi"><span id="d749" class="mm li iq ns b gy nw nx l ny nz">function firstFunction(){<br/>  console.log("Hello from firstFunction");<br/>}</span><span id="344f" class="mm li iq ns b gy oa nx l ny nz">function secondFunction(){<br/>  firstFunction();<br/>  console.log("The end from secondFunction");<br/>}</span><span id="7fed" class="mm li iq ns b gy oa nx l ny nz">secondFunction();</span></pre><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/9e80ef596593eef3af4fe705699b08a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8pr3bvorjasb0sLR"/></div></div></figure><p id="2c2b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">运行上述代码时会发生以下情况:</p><ol class=""><li id="41a9" class="oh oi iq jw b jx jy kb kc kf oj kj ok kn ol kr om on oo op bi translated">当<code class="fe oc od oe ns b">secondFunction()</code>被执行时，一个栈帧被创建，并且是程序的主入口点。<br/> 2。<code class="fe oc od oe ns b">secondFunction()</code>然后调用被推入堆栈的<code class="fe oc od oe ns b">firstFunction()</code>。<br/> 3。<code class="fe oc od oe ns b">firstFunction()</code>返回并打印“Hello from firstFunction”到控制台。<br/> 4。<code class="fe oc od oe ns b">firstFunction()</code>弹出堆栈。<br/> 5。然后执行顺序移动到<code class="fe oc od oe ns b">secondFunction()</code>。<br/> 6。<code class="fe oc od oe ns b">secondFunction()</code>返回并打印“secondFunction结束”到控制台。7。<code class="fe oc od oe ns b">secondFunction()</code>弹出堆栈，清空内存。</li></ol><p id="d9e6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">综上，Javascript调用栈为:<br/> 1。单线程，意味着它一次只能做一件事。<br/> 2。一次执行一个代码。<br/> 3。函数调用会创建一个占用临时内存的堆栈帧。<br/> 4。它的工作原理是后进先出法。</p><h2 id="628b" class="mm li iq bd lj mn mo dn ln mp mq dp lr kf mr ms lv kj mt mu lz kn mv mw md mx bi translated">作为一般原则的堆栈</h2><p id="694b" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">无论是Javascript还是<em class="lg">魔法:聚会</em>，理解堆栈对于能够利用其结构为你所用至关重要。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/4b5422f1e9a874ba8631c683edc1af58.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/0*v9ValRwjxwu4LA29"/></div></figure><p id="486c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，在<em class="lg">魔法中，</em>巧妙地使用堆叠允许玩家将他们刚刚施放的还押法术还押，这样反制失败，你可以再次使用还押，但这次是安全的。</p><p id="9359" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">深入了解调用栈如何工作对于异步JavaScript至关重要，在异步JavaScript中，我们有一个回调函数、一个事件循环和一个任务队列。在回调函数被事件循环压入堆栈后，回调函数在执行过程中由调用堆栈执行，但作为程序员，操纵回调函数可以更精确地控制程序的运行方式，从而避免出错。</p><p id="4526" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi">—</p><p id="10aa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">强化学习的最好方法之一是不断地将它与现实世界联系起来。在这种情况下，<em class="lg"> Magic:聚集</em>使用堆栈的编程概念作为基本机制，就像Javascript使用调用堆栈来确定函数调用一样。然而，最重要的是，它向我证明了花在玩纸牌游戏上的时间并没有白费！</p><h2 id="731d" class="mm li iq bd lj mn mo dn ln mp mq dp lr kf mr ms lv kj mt mu lz kn mv mw md mx bi translated">访问专家视图— <a class="ae lf" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank">订阅DDI英特尔</a></h2></div></div>    
</body>
</html>