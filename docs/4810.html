<html>
<head>
<title>Building a game with TypeScript. Drawing Grid 3/5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript构建游戏。绘制网格3/5</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/building-a-game-with-typescript-drawing-grid-3-5-1fb94211c4aa?source=collection_archive---------0-----------------------#2020-08-25">https://medium.datadriveninvestor.com/building-a-game-with-typescript-drawing-grid-3-5-1fb94211c4aa?source=collection_archive---------0-----------------------#2020-08-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="01f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">教程<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">系列</a>中的第三章讲述了如何用TypeScript和本地浏览器API从头开始构建游戏</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/f31986f31ed66a2b656ad4992eef05f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouxQAUSzUwNN0J5kA1CHpA.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk"><a class="ae kl" href="https://www.freepik.com/free-photos-vectors/background" rel="noopener ugc nofollow" target="_blank">Background vector created by freepik</a></figcaption></figure><p id="1581" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎回来！这是我们讨论如何用TypeScript和本地浏览器API构建一个简单的回合制游戏的系列文章！第三章，“绘制网格”，致力于构建游戏的关键部分:网格。其他章节可在此处获得:</p><ul class=""><li id="ffbf" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><a class="ae kl" href="/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener ugc nofollow" target="_blank">简介</a></li><li id="3b28" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><a class="ae kl" href="/@gregsolo/entity-component-system-in-action-with-typescript-f498ca82a08e" rel="noopener ugc nofollow" target="_blank">第一章实体组件系统</a></li><li id="906b" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第二章。游戏循环(<a class="ae kl" href="/@gregsolo/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71" rel="noopener ugc nofollow" target="_blank">第一部分</a>，<a class="ae kl" href="/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-game-loop-2-2-c0d57a8e5ec2" rel="noopener ugc nofollow" target="_blank">第二部分</a>)</li><li id="423f" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第三章。绘制网格(<a class="ae kl" href="/@gregsolo/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb" rel="noopener ugc nofollow" target="_blank">第1部分</a>、<a class="ae kl" href="https://medium.com/javascript-in-plain-english/building-a-game-with-typescript-drawing-grid-2-5-206555719490" rel="noopener">第2部分</a>、第3部分<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-iii-drawing-grid-4-5-398af1dd638d" rel="noopener">、第4部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-5-5-49454917b3af" rel="noopener">第5部分</a>)</li><li id="a019" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第四章。舰船(<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-colors-and-layers-337b0e4d71f" rel="noopener">第一部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-team-and-fleet-f223d39e9248" rel="noopener">第二部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-ship-14e6c19caa38" rel="noopener">第三部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-ship-and-locomotion-4f5969675993" rel="noopener">第四部分</a>)</li><li id="fd24" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第五章输入系统(<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-1-3-46d0b3dd7662" rel="noopener">第一部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-2-3-cd419e36027c" rel="noopener">第二部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-3-3-8492552579f1" rel="noopener">第三部分</a>)</li><li id="39cc" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第六章。寻路和移动(<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-17-introduction" rel="noopener ugc nofollow" target="_blank">部分1 </a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-27-highlighting-locomotion-range" rel="noopener ugc nofollow" target="_blank">部分2 </a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-37-graph-and-priority-queue" rel="noopener ugc nofollow" target="_blank">部分3 </a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-47-pathfinder" rel="noopener ugc nofollow" target="_blank">部分4 </a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-57-finding-the-path" rel="noopener ugc nofollow" target="_blank">部分5 </a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-6-instant-locomotion" rel="noopener ugc nofollow" target="_blank">部分6 </a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/pathfinding-and-movement-7-animated-locomotion" rel="noopener ugc nofollow" target="_blank">部分7 </a>)</li><li id="dd68" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第七章。玛奇纳州</li><li id="0682" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第八章。攻击系统:生命和伤害</li><li id="6aa5" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第九章。比赛的输赢</li><li id="eca3" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第十章敌人AI</li></ul></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="cd31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在<a class="ae kl" href="https://medium.com/javascript-in-plain-english/building-a-game-with-typescript-drawing-grid-2-5-206555719490" rel="noopener">的上一篇</a>中做了很多，但是从玩家的角度来看什么都没有改变。我们仍然在用<code class="fe lx ly lz ma b">game.ts</code>中的<code class="fe lx ly lz ma b">DirtyDraw</code>方法绘制网格。但是我们终于准备好摆脱它了！</p><blockquote class="mb mc md"><p id="0167" class="jn jo me jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated">随意切换到<a class="ae kl" href="https://github.com/soloschenko-grigoriy/gamedev-patterns-ts" rel="noopener ugc nofollow" target="_blank">库</a>的<code class="fe lx ly lz ma b">drawing-grid-2</code>分支。它包含了前几篇文章的工作成果，是这篇文章的一个很好的起点。</p></blockquote></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="21d0" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">目录</h1><ol class=""><li id="92d0" class="lc ld iq jp b jq ng ju nh jy ni kc nj kg nk kk nl li lj lk bi translated">伟大的代码迁移</li><li id="bbfa" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk nl li lj lk bi translated">淋巴结的解剖</li><li id="cab3" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk nl li lj lk bi translated">Vector2D简介</li><li id="2975" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk nl li lj lk bi translated">现在所有的都在一起了:网格、节点和绘图。</li><li id="3f0c" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk nl li lj lk bi translated">测试节点实体</li><li id="7529" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk nl li lj lk bi translated">测试网格实体</li><li id="f78e" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk nl li lj lk bi translated">结论</li></ol></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="e73a" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">伟大的代码迁移</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nm"><img src="../Images/8f9fc8159e647ccf097ea6aca1394f28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X3Pz8jnuZ7sG5vBXNyWgJg.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk"><a class="ae kl" href="https://www.freepik.com/free-photos-vectors/arrow" rel="noopener ugc nofollow" target="_blank">Arrow vector created by freepik</a></figcaption></figure><p id="542d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在系统中定义了一组清晰的职责:<code class="fe lx ly lz ma b">Grid</code>包含对<code class="fe lx ly lz ma b">Nodes</code>的引用，这些节点可能有自己特定的逻辑。和绘图功能都封装在它们的<code class="fe lx ly lz ma b">NodeDrawComponent</code>中。然而，当前的代码违反了我们的架构设计。此时，<code class="fe lx ly lz ma b">Game</code>呈现所有节点，在某种程度上，它是我们系统中的“上帝对象”:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="4c11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们应该将循环移动到<code class="fe lx ly lz ma b">Grid</code>。根据我们的计划，<code class="fe lx ly lz ma b">Grid</code>也不绘制节点，只是实例化它们:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9323" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我定义了一个私有方法<code class="fe lx ly lz ma b">InitNodes</code>，它在<code class="fe lx ly lz ma b">Grid</code>醒来时构造节点实体。</p><p id="5e05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">绘图代码被送到<code class="fe lx ly lz ma b">NodeDrawComponent</code>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="1b6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TS编译器对我们大喊缺少变量:<code class="fe lx ly lz ma b">x</code>和<code class="fe lx ly lz ma b">y</code>。这些变量是在网格的循环中定义的，所以我们必须以某种方式将它们传递到这里。</p><p id="82f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个显而易见的解决方案是简单地将这些变量设置为节点的字段，并将它们传递给组件。但是在我们进入代码之前，让我们花点时间仔细考虑一下这些<code class="fe lx ly lz ma b">x</code>和<code class="fe lx ly lz ma b">y</code>实际上代表什么。</p><p id="c20c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我们只使用它们来绘制矩形。然而，正如我们在以前的文章中所建立的，节点实体不仅仅是屏幕上的一个灰色矩形。<code class="fe lx ly lz ma b">Node</code>是一个<em class="me">实体</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/92f49cf1d8082b9b5bf01f1c5feebcaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*fG5MdEbtIwvKgI2MSVI1FA.gif"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">This is a demo of the gameplay we are looking to achieve</figcaption></figure><p id="d236" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过使它成为一个实体，我们可以存储和计算大量重要的信息。例如，我们可以使用这种能力来突出显示特定的节点，以指示玩家可以将他们的船移动到哪里。要做到这一点，我们必须知道任何给定的节点离玩家的当前位置有多远。反过来，为了能够做到这一点，我们必须跟踪每个<code class="fe lx ly lz ma b">Node</code>的位置。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="b6ab" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">淋巴结的解剖</h1><p id="1951" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy nq ka kb kc nr ke kf kg ns ki kj kk ij bi translated">我们可以用不同的方式思考一个位置。它可以是画布上的一个位置，由<code class="fe lx ly lz ma b">x</code>和<code class="fe lx ly lz ma b">y</code>坐标确定。或者可以通过网格内节点的<code class="fe lx ly lz ma b">index</code>来确定:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nt"><img src="../Images/80c6cedb5f888dda8f50e92d1a732874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qb_uAAKtIFZhRIZvQu3wgw.png"/></div></div></figure><p id="8d0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在图像中，您可以看到带有黄色圆圈的节点具有Index (2，1)，这意味着它位于行“2”和列“1”(从零开始计数)。</p><p id="fc71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，坐标是一个稍微复杂一点的故事。我是说，我们到底想怎么数，有很多方法。例如，我们可以假设<code class="fe lx ly lz ma b">Node</code>的坐标是它的左上角。听起来很合理，因为我们从画布的左上角开始计算位置。或者我们可以说:<code class="fe lx ly lz ma b">Node</code>的坐标就是其中心的位置。</p><p id="4764" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我发现对于<em class="me">这款</em>游戏来说，根据<em class="me">边界</em>来考虑<code class="fe lx ly lz ma b">Node</code>的位置是最方便的。我把边界定义为两点:<code class="fe lx ly lz ma b">Start</code>，是<code class="fe lx ly lz ma b">Node</code>左上角的坐标，<code class="fe lx ly lz ma b">End</code>，是右下角。在截图上，它们分别标记为红色和蓝色的点:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/fe2b05882ca58efecbaa82ded6df4f8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*s7CVEL5OLs9DzYJUEKwNIQ.png"/></div></figure><p id="54d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些点之间的区域属于<code class="fe lx ly lz ma b">Node</code>，它允许我们确定任何特定节点的边界。</p><p id="6d59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个点是两个数字的集合:<code class="fe lx ly lz ma b">x</code>和<code class="fe lx ly lz ma b">y</code>对应相关的轴；</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="23ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是边界不应该是<code class="fe lx ly lz ma b">NodeDrawComponent</code>而不是<code class="fe lx ly lz ma b">Node</code>本身的特征吗？不是绘图组件的责任吗？嗯，没有。</p><p id="dad1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">边界不一定与<code class="fe lx ly lz ma b">Node</code>的视觉表现有关。<em class="me">实际</em>和<em class="me">可见</em>边界可以不同。网格中任何节点所占的实际面积是它的核心特征，而<code class="fe lx ly lz ma b">NodeDrawComponent</code>可以自由地以任何方式表示它。想象我们用圆形而不是方形来绘制节点:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/bf0fc5f015f29c73628c5b6b912676b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:238/format:webp/1*K0koKWqXiaeg0-3b-apC1Q.png"/></div></figure><p id="7ef1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz ma b">Node</code>的实际区域将是这个灰色方块，而可见的将只是黄色圆圈。如你所见，它们是不同的。</p><blockquote class="mb mc md"><p id="f40c" class="jn jo me jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated">正如我们将在以后的章节中看到的，许多其他节点的组件依赖于<em class="iq">实际的</em>边界，而不仅仅是绘制组件。</p></blockquote><p id="557c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，是时候回到代码上了。由于<code class="fe lx ly lz ma b">Start</code>、<code class="fe lx ly lz ma b">End</code>和<code class="fe lx ly lz ma b">Index</code>是<code class="fe lx ly lz ma b">Node</code>的核心参数，我将其设为实例化所必需的:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7413" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能会注意到，我们在这里重复了几次<code class="fe lx ly lz ma b">x: number; y: number</code>结构。此外，我们将在游戏中反复使用它。我们应该为它定义一个专用的类或至少一个接口。它可能是类似于<code class="fe lx ly lz ma b">IPoint</code>或<code class="fe lx ly lz ma b">ICoordinate</code>的东西:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="3100" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就目前而言，这已经足够了，但是，正如经常发生的那样，还不止这些。我们不会定义像<code class="fe lx ly lz ma b">Point</code>这样狭窄的数据结构，而是会效仿<code class="fe lx ly lz ma b">Unity3d</code>，重用另一种数据结构:<code class="fe lx ly lz ma b">Vector</code>。</p><div class="nw nx gp gr ny nz"><a href="https://www.datadriveninvestor.com/2019/04/22/strategic-or-tactical-programming-the-road-ahead-for-software-engineers/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ir gy z fp oe fr fs of fu fw ip bi translated">战略或战术规划？软件工程师的未来之路|数据驱动的投资者</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">outer hout(2018)在他的书《软件设计哲学》中提到了一些原则，以便更深入地挖掘…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on kw nz"/></div></div></a></div><p id="1299" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将从小处着手，定义一个基础，然后在需要时逐步引入更多的功能。我们不打算实现<code class="fe lx ly lz ma b">Vector</code>必须提供的所有漂亮而强大的东西，而是只关注我们现在需要的部分。</p><blockquote class="mb mc md"><p id="2c69" class="jn jo me jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated">我发现这种方法是架构软件中最强大的方法之一。除非必要，否则我不会定义功能(利用“你不会需要它”的原则)。与此同时，我确实在努力思考代码潜在的更广泛的用途，并让它对未来的扩展开放。</p></blockquote></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="cf25" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">Vector2D简介</h1><p id="adcb" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy nq ka kb kc nr ke kf kg ns ki kj kk ij bi translated">在数学中，向量是既有大小又有方向的对象。出于我们的目的，我们将使用这个结构来保存关于点或坐标的信息，暂时忽略其他所有内容。</p><p id="77f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz ma b">Vector2D</code>作为ECS或生命周期方法，是一个<em class="me">实用程序</em>。这不取决于游戏。记住这一点，让我们把它放在<code class="fe lx ly lz ma b">utils</code>模块下:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a8d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要忘记桶:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c3b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！这就是我们现在需要<code class="fe lx ly lz ma b">Vector</code>为我们做的一切。但是我们保留选项，以便在将来添加更多功能。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="8d34" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">现在所有的都在一起了:网格、节点和绘图</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/0c1f4f02c7b04ce8723500fbd183b369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8LnPaxpEaDViJ5MTTtQOKA.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk"><a class="ae kl" href="https://www.freepik.com/free-photos-vectors/business" rel="noopener ugc nofollow" target="_blank">Business vector created by pikisuperstar</a></figcaption></figure><p id="f5aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了<code class="fe lx ly lz ma b">Vector2D</code>，我们现在可以在<code class="fe lx ly lz ma b">Node</code>内使用它:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="de9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">厉害！但是现在<code class="fe lx ly lz ma b">Grid</code>投诉说<code class="fe lx ly lz ma b">Node</code>签名不对。有道理，<code class="fe lx ly lz ma b">Node</code>要求<code class="fe lx ly lz ma b">Start</code>、<code class="fe lx ly lz ma b">End</code>、<code class="fe lx ly lz ma b">Index</code>进行实例化。</p><p id="cc96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将使用我们在<code class="fe lx ly lz ma b">DirtyDraw</code>中所做的相同计算来确定<code class="fe lx ly lz ma b">Node</code>的开始和结束位置。它的索引可以使用循环变量来定义:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="cb74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，<code class="fe lx ly lz ma b">NodeDrawComponent</code>还是漏了一个变量。但是现在我们有了一个<code class="fe lx ly lz ma b">Node</code>的<code class="fe lx ly lz ma b">Start</code>字段，这正是医生要求的:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="6b08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！同样，让我们把<code class="fe lx ly lz ma b">Node</code>作为它大小的唯一真实来源。我们要求实体提供以下信息，而不是直接访问组件中的设置:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d4ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我定义了一个<code class="fe lx ly lz ma b">Node</code>的公共<em class="me">计算值</em>。它仅仅计算<code class="fe lx ly lz ma b">Node</code>的<code class="fe lx ly lz ma b">Size</code>，分析它的边界。有了这个属性，我们可以从<code class="fe lx ly lz ma b">NodeDrawComponent</code>中移除大小和偏移量:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="5982" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！现在只有<code class="fe lx ly lz ma b">Node</code>提供了关于它的边界和大小的数据。有了这些，我们终于可以(终于！)去掉<code class="fe lx ly lz ma b">DirtyDraw</code>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8870" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，我们的代码仍然无法编译。我们必须更新我们在单元测试中实例化<code class="fe lx ly lz ma b">Node</code>的方式。此外，我们有一些新的功能，这将是很好的涵盖:<code class="fe lx ly lz ma b">Size</code>计算。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="1441" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">测试节点</h1><p id="0006" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy nq ka kb kc nr ke kf kg ns ki kj kk ij bi translated">更新签名是相当简单的事情。我只是定义了几个伪向量:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="e44f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过简单地将<code class="fe lx ly lz ma b">Size</code>与<code class="fe lx ly lz ma b">Node</code>的<code class="fe lx ly lz ma b">Start</code>和<code class="fe lx ly lz ma b">End</code>进行比较来验证其计算是否正确:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="23d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">厉害！如果您用<code class="fe lx ly lz ma b">npm start</code>运行代码，它应该编译没有错误。如果您打开浏览器，它应该会再次呈现网格，但这一次，它不再是一个“肮脏”的绘制:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oo"><img src="../Images/a32366a1334259f57c35b00ab345efd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TCDd2MTleP1WIUXWP_PDcg.png"/></div></div></figure><p id="16a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由<code class="fe lx ly lz ma b">npm t</code>运行的所有测试也应该通过:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi op"><img src="../Images/7c01c59e38c69e4c000907e4b3ae1e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xd33_FqWlkYLty9lmGh-wg.png"/></div></div></figure><p id="27cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">厉害！为了巩固我们的胜利，让我们也用测试来覆盖<code class="fe lx ly lz ma b">Grid</code>实体。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="4a7b" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">测试网格实体</h1><p id="0b63" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy nq ka kb kc nr ke kf kg ns ki kj kk ij bi translated">它还没有任何组件，但有许多子实体。这意味着我们应该验证网格唤醒和更新它们的能力。我们可以像对<code class="fe lx ly lz ma b">Game</code>那样做:通过监视一个孩子的<code class="fe lx ly lz ma b">prototype</code>。在这种情况下，它是<code class="fe lx ly lz ma b">Node</code>的原型:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a9a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的一切应该看起来很熟悉。我开始监视node的<code class="fe lx ly lz ma b">Awake</code>和<code class="fe lx ly lz ma b">Update</code>，确保它们还没有被调用。然后，调用网格的<code class="fe lx ly lz ma b">Awake</code>和<code class="fe lx ly lz ma b">Update</code>，检查各自的spy是否确实被调用。更准确地说，我检查了这些生命周期事件被调用的次数，并将其与节点数进行了比较。</p><p id="4b3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一点上，您的代码应该编译没有错误与<code class="fe lx ly lz ma b">npm start</code>。所有测试应通过<code class="fe lx ly lz ma b">npm t</code>运行:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi op"><img src="../Images/20c4bb5f03fdc32e62c42301506faba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ffTw53U4DbBf58uvVXbOuw.png"/></div></div></figure><blockquote class="mb mc md"><p id="91e6" class="jn jo me jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated">你可以在<a class="ae kl" href="https://github.com/soloschenko-grigoriy/gamedev-patterns-ts" rel="noopener ugc nofollow" target="_blank">库</a>的<code class="fe lx ly lz ma b">drawing-grid-3</code>分支中找到这篇文章的完整源代码。</p></blockquote></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="edf8" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">结论</h1><p id="308b" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy nq ka kb kc nr ke kf kg ns ki kj kk ij bi translated">酷！这是一个很大的编码！在这篇文章的开始，我们将所有的绘图功能硬编码在<code class="fe lx ly lz ma b">Game</code>实体中，使它几乎像一个“上帝的对象”。</p><p id="ba93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们重构了我们的代码，并将所有的绘图移动到它应该在的地方:<code class="fe lx ly lz ma b">NodeDrawComponent</code>。一路上，我们识别<code class="fe lx ly lz ma b">Node</code>的特征，并使用<code class="fe lx ly lz ma b">Start</code>、<code class="fe lx ly lz ma b">End</code>坐标和<code class="fe lx ly lz ma b">Grid</code>内的<code class="fe lx ly lz ma b">Index</code>位置来确定其位置。<code class="fe lx ly lz ma b">Vector2D</code>，我们引入的新结构，帮助我们处理二维属性。</p><p id="5e5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还有一些细节需要处理。例如，您可能注意到我们创建了几个画布元素，而不是一个。此外，我们的绘图在这一点上是相当静态的，不太适合频繁的变化。</p><p id="0f30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在本章的下一部分中讨论这一切。<strong class="jp ir">如果您有任何意见、建议、问题或任何其他反馈，请随时给我发私信或在下方留言！</strong>感谢您的阅读，我们下次再见！</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="d64a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="me">这是系列教程“</em> <strong class="jp ir"> <em class="me">用TypeScript </em> </strong> <em class="me">”中的第三章。其他章节可点击此处:</em></p><ul class=""><li id="b1fd" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><a class="ae kl" href="/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener ugc nofollow" target="_blank">简介</a></li><li id="fbe7" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><a class="ae kl" href="/@gregsolo/entity-component-system-in-action-with-typescript-f498ca82a08e" rel="noopener ugc nofollow" target="_blank">第一章实体组件系统</a></li><li id="46ce" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第二章。游戏循环(<a class="ae kl" href="/@gregsolo/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71" rel="noopener ugc nofollow" target="_blank">第一部分</a>、<a class="ae kl" href="/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-game-loop-2-2-c0d57a8e5ec2" rel="noopener ugc nofollow" target="_blank">第二部分</a>)</li><li id="b167" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第三章。绘制网格(<a class="ae kl" href="/@gregsolo/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb" rel="noopener ugc nofollow" target="_blank">第一部分</a>、<a class="ae kl" href="https://medium.com/javascript-in-plain-english/building-a-game-with-typescript-drawing-grid-2-5-206555719490" rel="noopener">第二部分</a>、第三部分<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-iii-drawing-grid-4-5-398af1dd638d" rel="noopener">第四部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-5-5-49454917b3af" rel="noopener">第五部分</a>)</li><li id="eea2" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第四章。舰船(<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-colors-and-layers-337b0e4d71f" rel="noopener">第一部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-team-and-fleet-f223d39e9248" rel="noopener">第二部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-ship-14e6c19caa38" rel="noopener">第三部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-ship-and-locomotion-4f5969675993" rel="noopener">第四部分</a>)</li><li id="b6fb" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第五章输入系统(<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-1-3-46d0b3dd7662" rel="noopener">第一部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-2-3-cd419e36027c" rel="noopener">第二部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-3-3-8492552579f1" rel="noopener">第三部分</a>)</li><li id="f296" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第六章。寻路和移动(<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-17-introduction" rel="noopener ugc nofollow" target="_blank">第一部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-27-highlighting-locomotion-range" rel="noopener ugc nofollow" target="_blank">第二部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-37-graph-and-priority-queue" rel="noopener ugc nofollow" target="_blank">第三部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-47-pathfinder" rel="noopener ugc nofollow" target="_blank">第四部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-57-finding-the-path" rel="noopener ugc nofollow" target="_blank">第五部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-6-instant-locomotion" rel="noopener ugc nofollow" target="_blank">第六部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/pathfinding-and-movement-7-animated-locomotion" rel="noopener ugc nofollow" target="_blank">第七部分</a>)</li><li id="3e24" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第七章。玛奇纳州</li><li id="576a" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第八章。攻击系统:生命和伤害</li><li id="0e50" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第九章。比赛的输赢</li><li id="cf90" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第十章敌人AI</li></ul><p id="353c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">访问专家视图— </strong> <a class="ae kl" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>