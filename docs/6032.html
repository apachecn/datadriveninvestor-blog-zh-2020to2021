<html>
<head>
<title>Deploy and Visualize Machine Learning Model in a Cost-Effective Manner</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以经济高效的方式部署和可视化机器学习模型</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/deploy-and-visualize-machine-learning-model-in-a-cost-effective-manner-9f9654e93058?source=collection_archive---------6-----------------------#2020-10-09">https://medium.datadriveninvestor.com/deploy-and-visualize-machine-learning-model-in-a-cost-effective-manner-9f9654e93058?source=collection_archive---------6-----------------------#2020-10-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="cc08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在AWS无服务器平台下构建、训练、部署和可视化黄金价格预测的机器学习模型</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/08912d37f41bd56e1fe3bd82d18b597f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o7JLk8s9Y2x1jL-d-9jWqg.jpeg"/></div></div></figure><p id="50ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章的目的是演示如何在机器学习中使用AWS无服务器平台。在这个<a class="ae la" href="http://kylui.com" rel="noopener ugc nofollow" target="_blank"> web应用</a>中，从构建、训练、部署和可视化机器学习模型性能到黄金价格预测，全程使用AWS服务。</p><p id="8b79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无服务器计算允许您构建和运行应用程序和服务，而无需考虑服务器。使用无服务器计算，您的应用程序仍然在服务器上运行，但是所有的服务器管理都由Amazon Web Services (AWS)完成。使用AWS及其无服务器平台，您可以在经济高效的服务上构建和部署应用程序，这些服务提供内置的应用程序可用性和灵活的伸缩能力。这使您可以专注于您的应用程序代码，而不是担心供应、配置和管理服务器。</p><h1 id="7358" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">建了什么</strong></h1><p id="3b15" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">已经构建了一个<a class="ae la" href="http://kylui.com" rel="noopener ugc nofollow" target="_blank"> web应用</a>来可视化机器学习模型在亚马逊S3静态托管下使用D3进行黄金价格预测的性能。D3.js是一个Javascript库，帮助您使用HTML、SVG和CSS将数据变成现实。亚马逊S3是一个对象存储，带有一个简单的web服务接口，可以从web上的任何地方存储和检索任何数量的数据。要使用S3的静态网站，你只需上传文件到S3桶，并配置您的S3桶为虚拟主机。</p><p id="ace9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae la" href="http://kylui.com" rel="noopener ugc nofollow" target="_blank"> web应用</a>中，一些用D3.js制作的简单图表，用来可视化使用AWS SageMaker构建的机器学习模型的性能。你可以在我的<a class="ae la" href="http://kylui.com" rel="noopener ugc nofollow" target="_blank">网络应用</a>中找到20天远期回报的图表。灰色线代表实际市场价值，而橙色线是预测价值。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi me"><img src="../Images/c022701f5d9dabc0aea3fa3ea8773184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hUk-wYzy26VmS4qON8RGBw.png"/></div></div></figure><p id="cc77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我喜欢D3的一个特性是画笔和缩放，使用交互性可以让你更详细地探索数据的内容。在<a class="ae la" href="http://kylui.com" rel="noopener ugc nofollow" target="_blank"> web应用程序</a>中，您可以通过移动或调整灰色框的大小来缩放X轴的一部分。下图是以美元计算的黄金价格。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mf"><img src="../Images/fcae6e674b97e0cf90b43c90f1ddc51c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3M7_DYQj0-mHQRkF6NNsEw.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">interactive chart for gold price prediction with D3</figcaption></figure><p id="e21f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">世界市场上的黄金价格是非常不稳定的，并且取决于许多不容易建模的外部因素。当前的模型并不完美，但希望你发现使用AWS无服务器平台构建应用程序的方法是有用的，并帮助你开始使用自己的应用程序。</p><p id="758c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于AWS S3只能向您的网站访问者提供HTML、JavaScript、图像、视频和其他文件，并且不包含服务器端应用程序代码，所以所有需要的服务器端逻辑都必须构建在后端。我将在接下来的小节中进一步阐述应用程序架构。</p><div class="mk ml gp gr mm mn"><a href="https://www.datadriveninvestor.com/2020/08/27/what-is-a-data-catalog-and-how-does-it-enable-machine-learning-success/" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd iu gy z fp ms fr fs mt fu fw is bi translated">什么是数据目录，它如何使机器学习取得成功？数据驱动的投资者</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">数据目录是机器学习和数据分析的燃料。没有它，你将不得不花费很多…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb ky mn"/></div></div></a></div><h1 id="0f7e" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">看看引擎盖下面</h1><p id="f504" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated"><a class="ae la" href="http://kylui.com" rel="noopener ugc nofollow" target="_blank"> web应用</a>使用亚马逊SageMaker、AWS Lambda、亚马逊DynamoDB、亚马逊简单存储服务(S3)、AWS Cloud9和亚马逊EventBridge。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/b90e526dadfa0ed17836d3bbb42064f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C3CfN0JWlM9d8a8Y1nMCrA.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">application architecture</figcaption></figure><p id="1074" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">构建、训练和调优机器学习模型</strong> : Scikit-Learn隶属于AWS SageMaker，用于构建和训练黄金价格预测模型。AWS SageMaker是一个完全托管的服务，为每个开发人员和数据科学家提供快速构建、训练和部署机器学习(ML)模型的能力。SageMaker从机器学习过程的每个步骤中移除了繁重的工作，从而更容易开发高质量的模型。具体情况你可以参考我之前发表的一篇<a class="ae la" href="https://medium.com/@ryankylui/prediction-gold-price-using-machine-learning-eba28313227d" rel="noopener">的文章</a>。</p><div class="mk ml gp gr mm mn"><a href="https://medium.com/@ryankylui/prediction-gold-price-using-machine-learning-eba28313227d" rel="noopener follow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd iu gy z fp ms fr fs mt fu fw is bi translated">利用机器学习预测黄金价格</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">在AWS Sagemaker下使用Scikit-Learn</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">medium.com</p></div></div><div class="mw l"><div class="nd l my mz na mw nb ky mn"/></div></div></a></div><p id="5f46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> (Lambda 1)使用Lambda部署机器学习模型:</strong> AWS Lambda是AWS无服务器平台的关键组件之一，它允许您通过触发器运行代码，而无需供应或管理服务器。在后端，我大量使用AWS Lambda来准备所有数据，以方便<a class="ae la" href="http://kylui.com" rel="noopener ugc nofollow" target="_blank"> web应用</a>。</p><p id="4526" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我构建的web应用程序中，黄金价格预测每天只需要一次。一种更具成本效益的方法是构建一个AWS Lambda函数，通过每天创建一次Amazon SageMaker端点来部署一个存储在AWS S3中的经过训练的Scikit-Learn模型，该端点将在所有必需的任务完成后被删除。</p><p id="1263" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然AWS Lambda是关键组件之一，但处理外部库可能很棘手，压缩代码的50MB大小限制使事情有点复杂。在我的web应用程序中，AWS Lambda应用程序是Lambda函数、事件源和其他一起执行任务的资源的组合，是用AWS Cloud9开发的。</p><p id="6d09" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在AWS Cloud9终端中，运行这个命令来安装所需的模块。安装模块后，它们会填充Lambda函数的父文件夹。</p><pre class="kp kq kr ks gt ne nf ng nh aw ni bi"><span id="75d9" class="nj lc it nf b gy nk nl l nm nn">python -m pip install --target=./ ModuleName</span></pre><p id="2034" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，它已经准备好进行编码，以使用存储在AWS S3中的Scikit-Learn训练模型和配置来部署机器学习模块。下面的Lambda函数的代码只是部署了一个机器学习模型作为AWS SageMaker端点，用于进一步的黄金价格预测。</p><pre class="kp kq kr ks gt ne nf ng nh aw ni bi"><span id="f625" class="nj lc it nf b gy nk nl l nm nn">from sagemaker.sklearn.model import SKLearnModel<br/><br/>EXECUTION_ROLE = 'YOUR_EXECUTION_ROLE'<br/>FRAMEWORK_VERSION = '0.23-1'<br/>artifact = 'S3_LOCATION_FOR_SCIKIT_MODEL'</span><span id="1e21" class="nj lc it nf b gy no nl l nm nn">def create_endpoint(endpoint_name, config_name):<br/>    try:<br/>        model = SKLearnModel(model_data=artifact, role=EXECUTION_ROLE, entry_point='script_model.py', framework_version=FRAMEWORK_VERSION)<br/>        predictor = model.deploy(endpoint_name=endpoint_name, instance_type='ml.c5.large', initial_instance_count=1)<br/>        return 'Success'<br/>    except Exception as e:<br/>        print(e)<br/>        raise(e)</span><span id="e168" class="nj lc it nf b gy no nl l nm nn">def lambda_handler(event, context):<br/>    endpoint_name = 'NAME_OF_YOUR_ENDPOINT'<br/>    config_name = 'ENDPOINT_CONFIG_IN_SAGEMAKER'<br/>    create_endpoint(endpoint_name, config_name)</span></pre><p id="2998" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦AWS Lambda函数通过AWS Cloud9发布，就必须创建一个触发器来调用该函数。通过Amazon EventBridge控制台创建一个每天触发的EventBridge规则在我的例子中，指定一个cron表达式来定义何时触发AWS Lambda函数。</p><p id="3915" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的cron表达式在我的应用程序中用于创建一个AWS Sagemaker端点，每天05:00 am (UTC)进行黄金预测，该预测由另一个AWS Lambda函数处理。</p><pre class="kp kq kr ks gt ne nf ng nh aw ni bi"><span id="c995" class="nj lc it nf b gy nk nl l nm nn">cron(0 05 ? * MON-SAT *)</span></pre><p id="27d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> (Lambda 2)用新创建的端点执行预测:</strong>现在我们要开发另一个AWS Lambda函数，使用前面的AWS Lambda函数创建的AWS SageMaker端点来执行黄金价格预测。</p><p id="4886" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，AWS Cloud9环境用于部署AWS Lambda功能。首先从yahoofinancials模块中检索当天黄金价格和美元指数，然后使用SKLearnPredictor做预测并将预测数据放入Amazon DynamoDB中，最后删除AWS SageMaker端点。用于预测的特征包括黄金价格和美元指数的20、50和200天移动平均线。预测值将存储在AWS DynamoDB中。</p><pre class="kp kq kr ks gt ne nf ng nh aw ni bi"><span id="da7a" class="nj lc it nf b gy nk nl l nm nn">#import all required libraries such as csv, numpy...<br/>import boto3<br/>from yahoofinancials import YahooFinancials<br/>from datetime import datetime, timezone, timedelta<br/>from sagemaker.sklearn.model import SKLearnModel, SKLearnPredictor</span><span id="1189" class="nj lc it nf b gy no nl l nm nn">ticker = ["GC=F", "DX-Y.NYB"]<br/>names = ["Gold", "USDX"]</span><span id="351e" class="nj lc it nf b gy no nl l nm nn">sagemaker = boto3.client('sagemaker')<br/>runtime= boto3.client('runtime.sagemaker')<br/>dydb = boto3.client('dynamodb')<br/>EXECUTION_ROLE = 'YOUR_EXECUTION_ROLE'<br/>FRAMEWORK_VERSION = '0.23-1'<br/>artifact = 'SCIKIT_MODEL_IN_S3'<br/>bucket = 'S3_BUCKET'<br/>endpoint_name = 'SAGEMAKER_ENDPOINT_NAME'<br/>config_name = 'SAGEMAKER_ENDPOINT_CONFIG'<br/>table_name = 'DYNAMODB_TABLE_NAME'</span><span id="1191" class="nj lc it nf b gy no nl l nm nn">#get the current day gold price<br/>def get_yf_data(start_date, end_date):<br/>    date_range = pd.bdate_range(start=start_date,end=end_date)<br/>    values = pd.DataFrame({ 'Date': date_range})<br/>    values['Date']= pd.to_datetime(values['Date'])<br/>    <br/>    for i in ticker:<br/>        raw_data = YahooFinancials(i)<br/>        raw_data = raw_data.get_historical_price_data(start_date, end_date, "daily")<br/>        df = pd.DataFrame(raw_data[i]['prices'])[['formatted_date','adjclose']]<br/>        df.columns = ['Date1', names[ticker.index(i)]]<br/>        df['Date1']= pd.to_datetime(df['Date1'])<br/>        values = values.merge(df,how='left',left_on='Date',right_on='Date1')<br/>        values = values.drop(labels='Date1',axis=1)</span><span id="52c8" class="nj lc it nf b gy no nl l nm nn">current_date = datetime.now(timezone.utc)<br/>    if values.iloc[-1, 0].strftime('%Y-%m-%d') &gt;= current_date.date().strftime('%Y-%m-%d'):<br/>        values.drop(values.tail(1).index,inplace=True)<br/>        <br/>    values = values.fillna(method="ffill",axis=0)<br/>    values = values.fillna(method="bfill",axis=0)<br/>    cols=values.columns.drop('Date')<br/>    values[cols] = values[cols].apply(pd.to_numeric,errors='coerce').round(decimals=1)<br/>    return values</span><span id="513f" class="nj lc it nf b gy no nl l nm nn">#prepare input data for the prediction model<br/>def prepare_predict_data(raw_data):<br/>    raw_data['Gold/20SMA'] = raw_data[names[0]].rolling(window=20).mean()<br/>    raw_data['Gold/50SMA'] = raw_data[names[0]].rolling(window=50).mean()<br/>    raw_data['Gold/200SMA'] = raw_data[names[0]].rolling(window=200).mean()<br/>    raw_data['USDX/20SMA'] = raw_data[names[1]].rolling(window=20).mean()<br/>    raw_data['USDX/50SMA'] = raw_data[names[1]].rolling(window=50).mean()<br/>    raw_data['USDX/200SMA'] = raw_data[names[1]].rolling(window=200).mean()<br/>    return raw_data</span><span id="6274" class="nj lc it nf b gy no nl l nm nn">def lambda_handler(event, context):<br/>    # TODO implement<br/>    #current_date = datetime.now(timezone.utc) + timedelta(days=1)<br/>    current_date = datetime.now(timezone.utc)<br/>    days_200_before = current_date - timedelta(days=300)<br/>    raw_data = get_yf_data(days_200_before.date().strftime('%Y-%m-%d'), current_date.date().strftime('%Y-%m-%d'))<br/>    <br/>    predict_x = prepare_predict_data(raw_data)<br/>    <br/>    # get only the current date figure<br/>    new_dydb_record = predict_x.tail(1)<br/>    predict_x = predict_x.tail(1)<br/>    predict_x = predict_x.drop(['Date', 'Gold', 'USDX'], axis=1)<br/>     <br/>    predictor = SKLearnPredictor(endpoint_name)<br/>    <br/>    predict_x_array = predict_x.to_numpy()<br/>    label_predict = predictor.predict(predict_x_array)<br/>    <br/>    new_dydb_record['nextday'] = float(label_predict[0])<br/>    <br/>    vDate = new_dydb_record['Date'].iloc[0]<br/>    strDate = vDate.strftime('%Y-%m-%d')<br/>    numGold = float(new_dydb_record['Gold'].iloc[0])<br/>    numUSDX = float(new_dydb_record['USDX'].iloc[0])<br/>    numG20SMA = float(new_dydb_record['Gold/20SMA'].iloc[0])<br/>    numG50SMA = float(new_dydb_record['Gold/50SMA'].iloc[0])<br/>    numG200SMA = float(new_dydb_record['Gold/200SMA'].iloc[0])<br/>    numU20SMA = float(new_dydb_record['USDX/20SMA'].iloc[0])<br/>    numU50SMA = float(new_dydb_record['USDX/50SMA'].iloc[0])<br/>    numU200SMA = float(new_dydb_record['USDX/200SMA'].iloc[0])<br/>    numnextday = float(new_dydb_record['nextday'].iloc[0])<br/>    <br/>    print('new record:')<br/>    print('strDate' + strDate)<br/>    print('numGold' + str(numGold))<br/>    print('numUSDX' + str(numUSDX))<br/>    print('numG20SMA' + str(numG20SMA))<br/>    print('numG50SMA' + str(numG50SMA))<br/>    print('numG200SMA' + str(numG200SMA))<br/>    print('numU20SMA' + str(numU20SMA))<br/>    print('numU50SMA' + str(numU50SMA))<br/>    print('numU200SMA' + str(numU200SMA))<br/>    print('numnextday' + str(numnextday))<br/>    <br/>    try:<br/>        response = dydb.put_item(<br/>            TableName = table_name,<br/>            Item={<br/>                'date' : {'S':str(strDate)},<br/>                'gold' : {'N':str(numGold)},<br/>                'usdx' : {'N':str(numUSDX)},<br/>                'gold/20sma' : {'N':str(numG20SMA)},<br/>                'gold/50sma' : {'N':str(numG50SMA)},<br/>                'gold/200sma' : {'N':str(numG200SMA)},<br/>                'usdx/20sma' : {'N':str(numU20SMA)},<br/>                'usdx/50sma' : {'N':str(numU50SMA)},<br/>                'usdx/200sma' : {'N':str(numU200SMA)},<br/>                'nextdaygold' : {'N':str(numnextday)},<br/>                }<br/>        )<br/>    except Exception as e:<br/>        print(e)    <br/>    <br/>    # Deleting Endpoint<br/>    predictor.delete_endpoint(delete_endpoint_config=True)</span></pre><p id="827f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Amazon EventBridge是一个无服务器的事件总线，它使得使用来自您自己的应用程序的数据将应用程序连接在一起变得很容易。EventBridge从事件源(如本例中的AWS SageMaker)交付实时数据流，并将该数据路由到AWS Lambda等目标。</p><p id="83c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第一个AWS Lambda函数成功创建AWS SageMaker端点后，此AWS Lambda函数将通过创建具有以下事件模式的EventBridge规则来传递和捕获“SageMaker端点状态更改”事件。</p><pre class="kp kq kr ks gt ne nf ng nh aw ni bi"><span id="4b44" class="nj lc it nf b gy nk nl l nm nn">{<br/>"source": ["aws.sagemaker"],<br/>"detail-type": ["SageMaker Endpoint State Change"],<br/>"detail.EndpointName": ["ENDPOINT_NAME"],<br/>"detail.EndpointStatus": ["IN_SERVICE"]<br/>}</span></pre><p id="6d9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> (Lambda 3)将DynamoDB数据导出到csv进行静态Web托管:</strong>为了简化前端开发，创建了另一个AWS Lambda函数，将Amazon DynamoDB中新追加的记录导出到AWS S3中的CSV文件。首先，在表上启用DynamoDB流，并将流Amazon资源名称(ARN)与您编写的AWS Lambda函数相关联。由于不需要外部库，这个AWS Lambda函数直接在AWS控制台中创建。这就容易多了。</p><p id="bee4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">DynamoDB流将通过事件对象发送新记录，下面的AWS Lambda函数将获取记录信息并更新存储在AWS S3中的csv文件，该文件用于web应用程序。</p><pre class="kp kq kr ks gt ne nf ng nh aw ni bi"><span id="d91e" class="nj lc it nf b gy nk nl l nm nn">import json<br/>import io<br/>import boto3</span><span id="eaaa" class="nj lc it nf b gy no nl l nm nn">def lambda_handler(event, context):<br/>    bucket_name = 'S3_BUCKET_NAME'<br/>    file_name = 'CSV_FILE_NAME'<br/>    new_record = ''<br/>    <br/>    for record in event.get('Records'):<br/>        if record.get('eventName') in ('INSERT'):<br/>            date = record['dynamodb']['NewImage']['date']['S']<br/>            gold = record['dynamodb']['NewImage']['gold']['N']<br/>            usdx = record['dynamodb']['NewImage']['usdx']['N']<br/>            gold20sma = record['dynamodb']['NewImage']['gold/20sma']['N']<br/>            gold50sma = record['dynamodb']['NewImage']['gold/50sma']['N']<br/>            gold200sma = record['dynamodb']['NewImage']['gold/200sma']['N']<br/>            usdx20sma = record['dynamodb']['NewImage']['usdx/20sma']['N']<br/>            usdx50sma = record['dynamodb']['NewImage']['usdx/50sma']['N']<br/>            usdx200sma = record['dynamodb']['NewImage']['usdx/200sma']['N']<br/>            nextdaygold = record['dynamodb']['NewImage']['nextdaygold']['N']<br/>            new_record = date + ',' + gold + ',' + usdx + ',' + gold20sma + ',' + gold50sma + ',' + gold200sma + ',' + usdx20sma+ ',' + usdx50sma + ',' + usdx200sma + ',' + nextdaygold + '\n' <br/>            print('add new record to S3: ')<br/>            print(new_record)<br/>            <br/>    s3 = boto3.resource('s3')<br/>    bucket = s3.Bucket(bucket_name)<br/>    with io.BytesIO() as data:<br/>        bucket.download_fileobj(file_name, data)<br/>        # add new record<br/>        data.write(new_record.encode('utf-8'))<br/>        data.seek(0)<br/>        # then write back to s3<br/>        bucket.upload_fileobj(data, file_name, ExtraArgs={'ACL':'public-read'})</span></pre><p id="096f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，静态web应用程序开发已经做好了一切准备，可以可视化机器学习模型在黄金价格预测方面的性能。当前的模型可能需要进一步优化，但希望您发现使用AWS无服务器平台构建应用程序的方法是有用的，并帮助您开始使用自己的应用程序。</p><h2 id="14b9" class="nj lc it bd ld np nq dn lh nr ns dp ll kb nt nu lp kf nv nw lt kj nx ny lx nz bi translated">访问专家视图— <a class="ae la" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank">订阅DDI英特尔</a></h2></div></div>    
</body>
</html>