<html>
<head>
<title>Getting started using Python’s ElementTree to navigate XML files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开始使用Python的ElementTree导航XML文件</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/getting-started-using-pythons-elementtree-to-navigate-xml-files-dc9bc720eaa6?source=collection_archive---------0-----------------------#2020-03-02">https://medium.datadriveninvestor.com/getting-started-using-pythons-elementtree-to-navigate-xml-files-dc9bc720eaa6?source=collection_archive---------0-----------------------#2020-03-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="54a2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一些关于开始和避免一些未被记录在案的挫折来源的提示。</h2></div><p id="c325" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，当你通过API收集数据时，你会看到<a class="ae lb" href="https://www.w3schools.com/whatis/whatis_json.asp" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="lc"> JSON </em> </strong> </a>格式，这是一个方便打包的嵌套字典(或它们的列表)。尽管JSON的采用无处不在，但有时您可能不得不使用旧的<a class="ae lb" href="https://www.w3schools.com/xml/xml_whatis.asp" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="lc"> XML </em> </strong> </a>标准。</p><p id="3ae1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如何使用XML？这取决于你使用什么库，因为有四个常用的库。其中三个包含在Python的标准库中:<a class="ae lb" href="https://docs.python.org/3/library/xml.dom.minidom.html" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lc">MiniDom</em></strong></a>，<a class="ae lb" href="https://docs.python.org/3/library/xml.sax.reader.html" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lc">Sax</em></strong></a>和<a class="ae lb" href="https://docs.python.org/3.8/library/xml.etree.elementtree.html" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lc">element tree</em></strong></a>；每个都提供不同的API来与XML文件交互；而<a class="ae lb" href="https://lxml.de/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lc">lxml</em></strong></a>(构建在元素树上的库)需要通过Python的包管理器额外下载。</p><div class="ld le gp gr lf lg"><a href="https://www.datadriveninvestor.com/2019/02/21/best-coding-languages-to-learn-in-2019/" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab fo"><div class="li ab lj cl cj lk"><h2 class="bd ir gy z fp ll fr fs lm fu fw ip bi translated">2019年最值得学习的编码语言|数据驱动的投资者</h2><div class="ln l"><h3 class="bd b gy z fp ll fr fs lm fu fw dk translated">在我读大学的那几年，我跳过了很多次夜游去学习Java，希望有一天它能帮助我在…</h3></div><div class="lo l"><p class="bd b dl z fp ll fr fs lm fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="lp l"><div class="lq l lr ls lt lp lu lv lg"/></div></div></a></div><p id="72a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些库都有自己的取舍。ElementTree的优点在于，它提供了方便读写整个XML的能力，该API是Python特有的，并针对Python进行了优化，而且它已经包含在大多数Python安装中。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/fa88ee303dc444f9e84156e86b6932e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SrWY24xNikFBUIb5DKiqdA.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">Image composed using <a class="ae lb" href="https://krita.org" rel="noopener ugc nofollow" target="_blank">Krita</a>.</figcaption></figure><p id="81e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在下面列出了智能手表生成的<a class="ae lb" href="https://en.wikipedia.org/wiki/Training_Center_XML" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lc">【TCX】</em></strong></a>文件(一种XML)中的一些代码示例。还提供了我编写Python类的一个非常规用例的编辑片段:修改低端智能手表创建的XML文件，以便在上传到在线运动跟踪器时提供关于游泳活动的额外见解。您可以在此处看到完整的回购代码:</p><p id="4375" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://github.com/coreyryanhanson/y_u_no_swim" rel="noopener ugc nofollow" target="_blank">https://github.com/coreyryanhanson/y_u_no_swim</a>:</p><h1 id="0b02" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">XML是如何工作的？</h1><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nd"><img src="../Images/ebed7d03a8fd4a55c69043ef1d6f1b67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eZ-YYZEv7dTRtU3K2U0MWA.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">Image composed using <a class="ae lb" href="https://inkscape.org/" rel="noopener ugc nofollow" target="_blank">Inkscape</a> and public domain sources.</figcaption></figure><p id="8594" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您熟悉HTML，您可能会觉得在XML结构中导航很轻松。每个<a class="ae lb" href="https://www.w3schools.com/xml/xml_elements.asp" rel="noopener ugc nofollow" target="_blank">元素都由标签标记，形成分层数据层</a>。</p><p id="30ce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开始标签由符号“&lt;<em class="lc">标签名称</em> &gt;”表示，而结束标签在名称前包含一个斜杠:“&lt; / <em class="lc">标签名称</em> &gt;”。开始标签还可以包含属性，这些属性提供关于标签的特定实例的额外信息，并且还可以将其与其他标签区分开来。</p><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="4322" class="nj mm iq nf b gy nk nl l nm nn"><em class="lc"># An excerpt of an xml document that recorded a swim showing how tags can fit inside other tags. Here "Activities" can contain one or more instances of an "Activity" which contains one or more instances of a Lap.</em><br/>&lt;Activities&gt;<br/>    &lt;Activity Sport="Other"&gt;<br/>        &lt;Id&gt;2019-08-21T23:43:28.000Z&lt;/Id&gt;<br/>        &lt;Lap StartTime="2019-08-21T23:43:29.000Z"&gt;<br/>            &lt;TotalTimeSeconds&gt;81.0&lt;/TotalTimeSeconds&gt;<br/>            &lt;DistanceMeters&gt;0.0&lt;/DistanceMeters&gt;<br/>            &lt;Calories&gt;279&lt;/Calories&gt;<br/>            <em class="lc">#The data continues with the closing tag for the lap,<br/>            followed by the closing tag for the activity, and<br/>            finally a closing tag for all of the activities.</em></span></pre><p id="0f3b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，Python会将这些标签中包含的所有数据视为一个庞大的文本字符串，但是使用element tree之类的库可以实现更高效的列表式导航。</p><h1 id="3693" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">ElementTree入门</h1><p id="62cf" class="pw-post-body-paragraph kf kg iq kh b ki no jr kk kl np ju kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">使用ElementTree时，整个XML被解析并存储在一个<a class="ae lb" href="https://docs.python.org/3.8/library/xml.etree.elementtree.html#xml.etree.ElementTree.ElementTree" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="lc"> ElementTree对象</em> </strong> </a>中。该API功能强大，不仅可以搜索特定的标签，将特定的<a class="ae lb" href="https://docs.python.org/3.8/library/xml.etree.elementtree.html#xml.etree.ElementTree.Element" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="lc">元素</em> </strong> </a>保存在其他变量中，而且对它们的任何修改和插入都将反映到整个树中。</p><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="c88c" class="nj mm iq nf b gy nk nl l nm nn">import xml.etree.ElementTree as ET</span><span id="60ef" class="nj mm iq nf b gy nt nl l nm nn"><em class="lc">#Uses element tree to parse the url or local file and stores it in memory.</em><br/>tree = ET.parse(<em class="lc">path</em>)</span><span id="6dbf" class="nj mm iq nf b gy nt nl l nm nn"><em class="lc">#Stores the top level tag (and all children) of the tree into a variable. You will mostly be using this in your xml interactions with the entire document.</em><br/>root = tree.getroot()</span></pre><h1 id="b946" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">输入名称空间:ElementTree中最不直观的部分</h1><p id="0687" class="pw-post-body-paragraph kf kg iq kh b ki no jr kk kl np ju kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">因此，您已经导入了库，解析了文件，并准备开始研究数据。还是你？如果您的XML恰好包含<a class="ae lb" href="https://www.w3schools.com/xml/xml_namespaces.asp" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="lc">名称空间</em> </strong> </a>，答案是否定的</p><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="967e" class="nj mm iq nf b gy nk nl l nm nn"><em class="lc">#Prints a string of the entire XML document<br/></em>print(ET.tostring(root, 'utf-8')</span></pre><p id="db94" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对文本的快速预览显示，一个奇怪的异常决定将自己插入到整个XML中。通过文本编辑器直接查看或用另一个库解析时，原始文档中不存在的对象。</p><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="ad04" class="nj mm iq nf b gy nk nl l nm nn"><em class="lc">#Unknown namespace causes "ns0:" to be inserted in every single tag.<br/></em>&lt;ns0:Trackpoint&gt;<br/>    &lt;ns0:Time&gt;<br/>        2019-08-22T00:10:16.000Z<br/>    &lt;/ns0:Time&gt;<br/>    &lt;ns0:HeartRateBpm&gt;<br/>        &lt;ns0:Value&gt;<br/>            120<br/>        &lt;/ns0:Value&gt;<br/>    &lt;/ns0:HeartRateBpm&gt;<br/>    &lt;ns0:SensorState&gt;<br/>        Present<br/>    &lt;/ns0:SensorState&gt;<br/>&lt;/ns0:Trackpoint&gt;</span></pre><p id="8e5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么会这样？未定义的名称空间会破坏ElementTree工作流。因为XML是一种可扩展的标准，允许任何人创建自己的系统和定义自己的标签集，所以XML提供了一种方法来确保不同XML生态系统中的这些标签彼此是唯一的，从而防止在必然会发生重叠时出现混淆。</p><p id="befb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然其他库会在后台处理这些问题，但ElementTree需要显式定义这些名称空间，否则您的XML将充斥着笨重的占位符注释。</p><p id="dc2a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">手动定义名称空间可能听起来令人生畏，但并不像听起来那么难。所有需要的信息都应该出现在您正在使用的XML中。ElementTree只需要用包含在由<strong class="kh ir"><em class="lc">【xmlns】</em></strong>(顺便说一下，它代表<strong class="kh ir"> <em class="lc"> XML名称空间</em> </strong>)指示的属性中的信息进行适当的配置。你会看到它后面有一个<a class="ae lb" href="https://dev.to/flippedcoding/what-is-the-difference-between-a-uri-and-a-url-4455" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="lc"> uri </em> </strong> </a>，通常采用url的形式。</p><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="da6f" class="nj mm iq nf b gy nk nl l nm nn"><em class="lc">#An xml namespace attribute inside that element's tag follows this basic format.<br/></em>&lt;Author xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="Application_t"&gt;</span></pre><p id="4b5e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">乍一看，它可能看起来像一个依赖于互联网连接的复杂组件，<strong class="kh ir"> <em class="lc">它仅仅是一个唯一的标识符</em> </strong>。任何超链接都只是作为约定和资源添加的，开发者可以根据自己的选择找到更多信息。还要注意，如果在xmlns属性和uri之间没有指定参数，那么它表示一个<strong class="kh ir"> <em class="lc">默认名称空间</em> </strong>。</p><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="b522" class="nj mm iq nf b gy nk nl l nm nn"><em class="lc">#Default namespaces follow this format.</em><br/>lc"&gt;namespaceURI"</span></pre><p id="80f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要在ElementTree中定义名称空间，可以找到并逐个传递它们…</p><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="efe6" class="nj mm iq nf b gy nk nl l nm nn"><em class="lc">#Be sure to replace "URI" with the actual URI in your XML document.</em><br/>ET.register_namespace('', "URI")<br/>ET.register_namespace('xsi', "http://www.w3.org/2001/XMLSchema-instance")</span></pre><p id="bad6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…或者您可以直接从文档中抽象出定义名称空间的过程，以更程序化的方式处理事情。做到这一点说起来容易做起来难，但可以通过ElementTree提供的<a class="ae lb" href="https://docs.python.org/3.8/library/xml.etree.elementtree.html?highlight=iterparse#xml.etree.ElementTree.iterparse" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lc">ITER parse</em></strong></a>函数中的一些低级诡计来实现。</p><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="7c74" class="nj mm iq nf b gy nk nl l nm nn"><em class="lc">#Uses a list comprehension and element tree's iterparse function to create a dictionary containing the namespace prefix and it's uri. The underscore is utilized to remove the "start-ns" output from the list.</em><br/>namespaces = {node[0]: node[1] for _, node in ET.iterparse(self.filepath, events=['start-ns'])}</span><span id="66fe" class="nj mm iq nf b gy nt nl l nm nn"><em class="lc">#Iterates through the newly created namespace list registering each one.</em><br/>for key, value in namespaces.items():<br/>    ET.register_namespace(key, value)</span></pre><p id="cfb5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个特定代码块的有用之处在于，它将文档的所有名称空间存储在一个字典中，这在以后执行搜索时会很方便，因为该字典需要作为参数传递。如果没有它，当使用类似于<a class="ae lb" href="https://docs.python.org/3.8/library/xml.etree.elementtree.html?highlight=findall#xml.etree.ElementTree.Element.findall" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lc">find all</em></strong></a>的命令时，很可能得不到匹配。</p><h1 id="fc07" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">准备开始工作了吗？不完全是…名称空间再次出击！</h1><p id="497f" class="pw-post-body-paragraph kf kg iq kh b ki no jr kk kl np ju kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">虽然可以说，如果您面临标记名重叠的情况，ElementTree所需的名称空间特异性水平可能会很高，但有一个特别的奇怪之处很难证明:ElementTree对默认名称空间的处理。</p><p id="afad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">长话短说，<a class="ae lb" href="https://stackoverflow.com/questions/34009992/python-elementtree-default-namespace" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="lc">它不知道如何处理空字符串</em> </strong> </a>的名称空间键。</p><p id="156b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这种笨拙的疏忽可能有些令人失望，但是您可以通过将允许在默认名称空间内手动搜索的文本存储到一个变量中以备后用，从而将不便之处降至最低并继续前进。</p><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="9262" class="nj mm iq nf b gy nk nl l nm nn"><em class="lc">#The curly brackets are needed around the uri when using Element Tree's find command with a manually passed namespace.</em><br/>default_ns = "{" + namespaces[""] + "}"</span><span id="eeb2" class="nj mm iq nf b gy nt nl l nm nn"><em class="lc"># By inserting your namespace variable immediately before the search term your code will return the results you expect.</em><br/>activ_tag = root.find(".//" + default_ns + "Activity")</span></pre><p id="f512" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您将可以毫无障碍地在XML上利用ElementTree的功能。参考<a class="ae lb" href="https://docs.python.org/3.8/library/xml.etree.elementtree.html" rel="noopener ugc nofollow" target="_blank">文档</a>中关于你能做什么的例子。</p><h1 id="b6a4" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">最后一个格式化说明</h1><p id="6a94" class="pw-post-body-paragraph kf kg iq kh b ki no jr kk kl np ju kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">XML是一种完全忽略空白的语言。如果出于某种原因，您需要无缝地将XML输出到一种使层次结构更易于阅读的格式中，那么在ElementTree中可能更难做到这一点。</p><p id="3973" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了克服这一点，<a class="ae lb" href="https://stackoverflow.com/questions/749796/pretty-printing-xml-in-python" rel="noopener ugc nofollow" target="_blank">有几种方法你可以采用</a>。对于我的智能手表脚本，我使用了一种变通方法，包括为了简洁而牺牲效率，在MiniDom中导入整个XML，以便在导出时使用它们的<a class="ae lb" href="https://docs.python.org/2/library/xml.dom.minidom.html?highlight=prettyxml#xml.dom.minidom.Node.toprettyxml" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lc">toprettyxml</em></strong></a>方法，因为文件不是太大。你可以查看<a class="ae lb" href="https://github.com/coreyryanhanson/y_u_no_swim" rel="noopener ugc nofollow" target="_blank">我的代码</a>中关于如何设置的例子。</p><p id="5038" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据XML的结构，第一次使用ElementTree可能会有些困难。开始使用对我来说是一个挫折的来源，但是一旦我想出了一些技巧，我发现它是一个非常通用的工具，正是我所需要的！</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="nu nv l"/></div></figure></div></div>    
</body>
</html>