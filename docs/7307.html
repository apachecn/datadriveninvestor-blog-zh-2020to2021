<html>
<head>
<title>How to Expand your dataset without Machine Learning with python (updated)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用python在没有机器学习的情况下扩展数据集(更新)</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/expand-your-dataset-without-machine-learning-d82d8174ac11?source=collection_archive---------6-----------------------#2020-12-03">https://medium.datadriveninvestor.com/expand-your-dataset-without-machine-learning-d82d8174ac11?source=collection_archive---------6-----------------------#2020-12-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/70871633552a464427351c970c53b521.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*GIDuyc86k2zt0xjHRmFlbA.jpeg"/></div></figure><p id="e01f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有时，我们会遇到这样的情况:我们想要解决现实生活中的数据科学问题，但由于没有好的数据集可用，我们无法开始解决问题。有很多机会，你开始制作自己的数据集，你开始收集一些数据，以便制作一个好的数据集，但你将面临许多障碍，其中之一是制作一个大型数据集。这是你陷入困境的时候，因为我们没有太多的现实生活资源或数字资源，对于那些不太懂编程的人来说，开始失望了。</p><p id="d8c4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">预备步骤:- </strong></p><p id="e7a5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">根据您的资源开始制作数据集。开始时可能有40-100条记录，但要尽可能增加记录的数量。</p><p id="033e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">第一步:- </strong></p><p id="39d6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以第一步是不要担心。</p><p id="be64" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> Python </strong>来帮你了。</p><p id="96cb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">第二步:- </strong></p><p id="f948" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">无论有没有ML，您都可以轻松地扩展数据集。在我的下一个故事中，我们将扩展来自机器学习的数据集。<br/>因此，在本文中，我们将借助Python以一种非常简单的方式来完成这项工作。</p><blockquote class="ks kt ku"><p id="cedf" class="ju jv kv jw b jx jy jz ka kb kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kr ij bi translated"><strong class="jw ir">需要Python库:- </strong></p></blockquote><p id="999a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> Random:- </strong>这个库有函数<strong class="jw ir"> </strong> choice()，这是Random库的内置函数，从列表、元组或字符串中返回一个随机项。</p><p id="3daf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，我们给出现有的值，或者你可以说现有的数据框，它会给你从我们的数据框中随机选择的值。</p><p id="f356" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">必要进口:- </strong></p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="3b12" class="li lj iq le b gy lk ll l lm ln">import pandas as pd<br/><br/>from random import choice</span></pre><p id="fe9c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在制作一个包含数据帧值的列表。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="819f" class="li lj iq le b gy lk ll l lm ln">choice_list= []</span></pre><p id="096e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在像往常一样阅读csv文件。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="430f" class="li lj iq le b gy lk ll l lm ln">dforignal = pd.read_csv(r"dataset.csv", encoding='utf8', low_memory=False)</span></pre><p id="9921" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在将所有的列名放入列表中，因为我们想要迭代所有这些列，以便展开所有这些列。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="9d6c" class="li lj iq le b gy lk ll l lm ln">colnames = dforignal.columns.values<br/>print(colnames)</span></pre><p id="cf06" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们根据我们简单的技术/算法来到这里。</p><p id="dae8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">保持第一列正常，它有索引值。所以请留意它是否有索引值。如果第一列中没有索引值，请跳过这一步。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="2e50" class="li lj iq le b gy lk ll l lm ln">dforignal = pd.DataFrame(df.drop(colnames[0],axis=1))</span></pre><p id="bcc6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，为了基于现有值生成新值，我们必须将数据帧转换为列表。为此，我们必须这样做:</p><p id="8102" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">注意:-如果您是逐行复制代码，则不能复制粘贴这一行。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="6cc3" class="li lj iq le b gy lk ll l lm ln">valueslist=dforignal[column_name].tolist()</span></pre><p id="2a3d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在从最左边的列开始，也就是第二列。我们将从最左边到最右边的列开始迭代所有的列名。</p><p id="7855" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">注意:-如果你是逐行复制代码，这一行不能被复制粘贴。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="0268" class="li lj iq le b gy lk ll l lm ln">for i in range(0,len(colnames)):<br/>   column_name=colnames[i]</span></pre><p id="6dda" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，在编写了一个循环之后，我们可以通过。to_list()函数。</p><p id="9b20" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后写一个你选择长度的环。该长度将决定输出数据集的长度。如果你想要一个包含6000条记录的数据集，那么把它写在内循环中。</p><p id="d52a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">选择函数将从我们现有的数据中随机选择一个值，然后我们将这个值添加到列表中。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="e38f" class="li lj iq le b gy lk ll l lm ln">for i in range(0,len(colnames)):<br/>   column_name=colnames[i]<br/>   print(column_name)<br/>   valueslist=dforignal[column_name].tolist()<br/>   for _ in range(6000):<br/>      selection = choice(valueslist)<br/>      choice_list.append(selection)<br/></span></pre><p id="cae3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个长度为6000的环路之外，但在外环之内。从该值列表中创建一个具有相同列名的数据框，并赋予它与现有数据框相同的列名。</p><p id="63f4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为两个列，即旧的现有列和新生成的列取相同的名称，这是一个必要的步骤，以便创建一个正确的数据框架。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="21f2" class="li lj iq le b gy lk ll l lm ln">df[column_name]= pd.DataFrame(choice_list, columns=[column_name])<br/>   print(df[column_name])<br/>   choice_list.clear()</span></pre><p id="65c9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们算法的整个代码块<strong class="jw ir">可以复制粘贴</strong> :-</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="f258" class="li lj iq le b gy lk ll l lm ln">for i in range(4,len(colnames)):<br/>   namee=colnames[i]<br/>   print(namee)<br/>   valueslist=dforignal[namee].tolist()<br/>   for _ in range(5879):<br/>      selection = choice(valueslist)<br/>      choice_list.append(selection)<br/>   df[namee]= pd.DataFrame(choice_list, columns=[namee])<br/>   print(df[namee])<br/>   choice_list.clear()</span></pre><p id="2e76" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在添加新制作的数据帧和原始数据帧。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="ea51" class="li lj iq le b gy lk ll l lm ln">dfnew = dforignal.append(df, ignore_index=True)</span></pre><p id="6bad" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后将这个扩展的数据帧导出到csv或excel格式。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="b1d0" class="li lj iq le b gy lk ll l lm ln">print(dfnew.to_csv("expanded.csv", encoding='utf-8', index=False))</span></pre><p id="b9f9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">只有当数据集反复显示索引时，“忽略索引”和“索引”才是重要的参数。所以请密切关注。</p></div></div>    
</body>
</html>