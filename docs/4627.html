<html>
<head>
<title>Queue in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的队列</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/queue-in-javascript-e77ab51f6de0?source=collection_archive---------10-----------------------#2020-08-17">https://medium.datadriveninvestor.com/queue-in-javascript-e77ab51f6de0?source=collection_archive---------10-----------------------#2020-08-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jn jo jp jq"><div class="bz fp l di"><div class="jr js l"/></div><figcaption class="jt ju gj gh gi jv jw bd b be z dk"><a class="ae jx" href="https://media.giphy.com/media/7SL1vhXStFVyASseb9/giphy.gif" rel="noopener ugc nofollow" target="_blank">https://media.giphy.com/media/7SL1vhXStFVyASseb9/giphy.gif</a></figcaption></figure><p id="6ba4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">队列</strong>是线性数据结构，遵循<strong class="ka ir"> FIFO(先进先出)的顺序。</strong>现实生活中排队的例子是在电影院前排队，先到先得。同样，当涉及到打印或测试处理时，我们处理第一个添加的项目。在队列中，插入(<strong class="ka ir">入队</strong>)和删除(<strong class="ka ir">出队</strong>)发生在不同的末端，插入在末端，删除在开始。</p><figure class="kx ky kz la gt jq gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi kw"><img src="../Images/26dd1baaae410771f6806941d7bfb692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HVKwDYYkTitsmyef_DRqqg.png"/></div></div><figcaption class="jt ju gj gh gi jv jw bd b be z dk">Example of Queue</figcaption></figure><p id="8974" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JavaScript没有队列数据结构，但是我们可以使用数组和链表类来实现它。</p><div class="lh li gp gr lj lk"><a href="https://www.datadriveninvestor.com/2020/07/13/2020-development-choices-for-multi-platform-saas-application/" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab fo"><div class="lm ab ln cl cj lo"><h2 class="bd ir gy z fp lp fr fs lq fu fw ip bi translated">多平台SaaS应用的2020年发展选择|数据驱动的投资者</h2><div class="lr l"><h3 class="bd b gy z fp lp fr fs lq fu fw dk translated">我目前正在为公司做一个新项目。该项目包括一个移动应用程序，由一个…</h3></div><div class="ls l"><p class="bd b dl z fp lp fr fs lq fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="lt l"><div class="lu l lv lw lx lt ly lf lk"/></div></div></a></div></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="6218" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">阵列实现</strong></p><p id="5140" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为插入和删除发生在不同的末端，对于JavaScript中的内置数组方法，我们使用<strong class="ka ir"> push() with shift() </strong> —将元素添加到末端，移除第一个元素。<strong class="ka ir"> </strong>和<strong class="ka ir">unshift()——用pop()——</strong>把元素加到开头，去掉最后一个元素。为了理解数组实现，让我们将它应用于一个leetcode问题。</p><div class="lh li gp gr lj lk"><a href="https://leetcode.com/problems/number-of-recent-calls/" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab fo"><div class="lm ab ln cl cj lo"><h2 class="bd ir gy z fp lp fr fs lq fu fw ip bi translated">最近通话次数- LeetCode</h2><div class="lr l"><h3 class="bd b gy z fp lp fr fs lq fu fw dk translated">写一个类RecentCounter来计算最近的请求。它只有一个方法:ping(int t)，其中t代表某个时间…</h3></div><div class="ls l"><p class="bd b dl z fp lp fr fs lq fu fw dk translated">leetcode.com</p></div></div><div class="lt l"><div class="mg l lv lw lx lt ly lf lk"/></div></div></a></div><pre class="kx ky kz la gt mh mi mj mk aw ml bi"><span id="a85a" class="mm mn iq mi b gy mo mp l mq mr">Write a class <!-- -->RecentCounter<!-- --> to count recent requests.</span><span id="b224" class="mm mn iq mi b gy ms mp l mq mr">It has only one method: <!-- -->ping(int t)<!-- -->, where t represents some time in milliseconds.</span><span id="2f98" class="mm mn iq mi b gy ms mp l mq mr">Return the number of <!-- -->ping<!-- -->s that have been made from 3000 milliseconds ago until now.</span><span id="50ac" class="mm mn iq mi b gy ms mp l mq mr">Any ping with time in <!-- -->[t - 3000, t]<!-- --> will count, including the current ping.</span><span id="0f0f" class="mm mn iq mi b gy ms mp l mq mr">It is guaranteed that every call to <!-- -->ping<!-- --> uses a strictly larger value of <!-- -->t<!-- --> than before.</span><span id="3ebc" class="mm mn iq mi b gy ms mp l mq mr"><strong class="mi ir">Example 1:</strong></span><span id="17de" class="mm mn iq mi b gy ms mp l mq mr"><strong class="mi ir">Input: </strong>inputs = ["RecentCounter","ping","ping","ping","ping"], inputs = [[],[1],[100],[3001],[3002]]<br/><strong class="mi ir">Output: </strong>[null,1,2,3,3]</span><span id="fede" class="mm mn iq mi b gy ms mp l mq mr"><strong class="mi ir"><em class="mt">Note:</em></strong><em class="mt"><br/>1.Each test case will have at most 10000 calls to ping.<br/>2.Each test case will call ping with strictly increasing values of t.<br/>3.Each call to ping will have 1 &lt;= t &lt;= 10^9.</em></span></pre><p id="b532" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个问题的解决方案如下。</p><figure class="kx ky kz la gt jq"><div class="bz fp l di"><div class="mu js l"/></div><figcaption class="jt ju gj gh gi jv jw bd b be z dk"><a class="ae jx" href="https://gist.github.com/GAierken/e226b4033a4d90e4b7cc6a11414ecbd7" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/GAierken/e226b4033a4d90e4b7cc6a11414ecbd7</a></figcaption></figure><p id="5363" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">链表实现</strong></p><p id="6751" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了用链表实现它，我们需要创建一个节点类和一个队列类。</p><figure class="kx ky kz la gt jq"><div class="bz fp l di"><div class="mu js l"/></div><figcaption class="jt ju gj gh gi jv jw bd b be z dk"><a class="ae jx" href="https://gist.github.com/GAierken/3cacb078eff64b43b80f052a45dd8a72" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/GAierken/3cacb078eff64b43b80f052a45dd8a72</a></figcaption></figure><p id="3077" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如何才能<strong class="ka ir">入队(插入)</strong>队列？我们接受一个值并创建一个新节点。如果队列中没有节点，则将这个新节点设置为队列的第一个和最后一个属性。否则，将当前最后一个的下一个属性设置为新节点，然后将队列的最后一个属性设置为新节点。不要忘记增加队列的大小。</p><figure class="kx ky kz la gt jq"><div class="bz fp l di"><div class="mu js l"/></div><figcaption class="jt ju gj gh gi jv jw bd b be z dk"><a class="ae jx" href="https://gist.github.com/GAierken/1cacbe33c127604c87f723ed13236ad9" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/GAierken/1cacbe33c127604c87f723ed13236ad9</a></figcaption></figure><p id="bb5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如何才能<strong class="ka ir">出队(删除)</strong>队列？如果没有第一个属性，就返回null。否则，将第一个属性存储在一个变量中，查看第一个属性是否与最后一个属性相同(检查队列中是否只有一个节点)。如果是，将第一个和最后一个设置为null。如果有多个节点，则将第一个属性设置为第一个节点的下一个属性。返回出队节点的值。不要忘记减少队列的大小。</p><figure class="kx ky kz la gt jq"><div class="bz fp l di"><div class="mu js l"/></div><figcaption class="jt ju gj gh gi jv jw bd b be z dk"><a class="ae jx" href="https://gist.github.com/GAierken/78acca706839497b3ab40f6cf04ba0fd" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/GAierken/78acca706839497b3ab40f6cf04ba0fd</a></figcaption></figure><p id="7c30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">队列的大O</strong></p><figure class="kx ky kz la gt jq gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi mv"><img src="../Images/e3bc67971397ed926f9420fd8ef1d62c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UUWyNIFif5ByVpQw7P_Ycw.png"/></div></div><figcaption class="jt ju gj gh gi jv jw bd b be z dk">Big O of Queue Data Structure</figcaption></figure></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="3ca3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">资源:</strong></p><div class="lh li gp gr lj lk"><a href="https://www.bigocheatsheet.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab fo"><div class="lm ab ln cl cj lo"><h2 class="bd ir gy z fp lp fr fs lq fu fw ip bi translated">了解你的复杂性！</h2><div class="lr l"><h3 class="bd b gy z fp lp fr fs lq fu fw dk translated">你好。这个网页涵盖了计算机科学中常用算法的空间和时间复杂性。当…</h3></div><div class="ls l"><p class="bd b dl z fp lp fr fs lq fu fw dk translated">www.bigocheatsheet.com</p></div></div><div class="lt l"><div class="mw l lv lw lx lt ly lf lk"/></div></div></a></div><div class="lh li gp gr lj lk"><a href="https://www.udemy.com/course/js-algorithms-and-data-structures-masterclass/" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab fo"><div class="lm ab ln cl cj lo"><h2 class="bd ir gy z fp lp fr fs lq fu fw ip bi translated">JavaScript (JS)算法和数据结构大师班</h2><div class="lr l"><h3 class="bd b gy z fp lp fr fs lq fu fw dk translated">嗨！我是柯尔特。我是一名热爱教学的开发人员。过去几年我一直在教人们…</h3></div><div class="ls l"><p class="bd b dl z fp lp fr fs lq fu fw dk translated">www.udemy.com</p></div></div><div class="lt l"><div class="mx l lv lw lx lt ly lf lk"/></div></div></a></div><div class="lh li gp gr lj lk"><a href="https://www.geeksforgeeks.org/queue-data-structure/" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab fo"><div class="lm ab ln cl cj lo"><h2 class="bd ir gy z fp lp fr fs lq fu fw ip bi translated">队列数据结构- GeeksforGeeks</h2><div class="lr l"><h3 class="bd b gy z fp lp fr fs lq fu fw dk translated">队列是一种线性结构，它遵循操作执行的特定顺序。顺序是…</h3></div><div class="ls l"><p class="bd b dl z fp lp fr fs lq fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="lt l"><div class="my l lv lw lx lt ly lf lk"/></div></div></a></div><p id="7e51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">进入专家视角— </strong> <a class="ae jx" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>