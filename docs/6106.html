<html>
<head>
<title>Polyfills</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多填充物</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/polyfills-a6a458c60b38?source=collection_archive---------22-----------------------#2020-10-12">https://medium.datadriveninvestor.com/polyfills-a6a458c60b38?source=collection_archive---------22-----------------------#2020-10-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3830f8966fea71153ac1e6424db482e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1GiYzs9ZVcwyyjCS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@lukechesser?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Luke Chesser</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fa81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几周前，<a class="ae kc" href="https://medium.com/@nicholasechevarria/a-junior-devs-musing-on-simplicity-in-coding-506a254b28e5" rel="noopener">我写了一篇关于网页设计简单性的文章。</a>在这篇文章中，我谈到了全球网络接入的不平等。过度设计网站加剧了这个问题。</p><p id="2c14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在那篇文章中，我介绍了一些程序员解决互联网接入和使用问题的有趣方法。不久之后，我了解了polyfills。</p><h2 id="7f25" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">一瞥Polyfills </strong></h2><blockquote class="lu lv lw"><p id="a14c" class="kd ke lx kf b kg kh ki kj kk kl km kn ly kp kq kr lz kt ku kv ma kx ky kz la ij bi translated"><a class="ae kc" href="https://remysharp.com/2010/10/08/what-is-a-polyfill" rel="noopener ugc nofollow" target="_blank">poly fill，或polyfiller，是一段代码(或插件),它提供了开发者希望浏览器本身提供的技术。-雷米夏普</a></p></blockquote><p id="2521" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用polyfills，用户可以向浏览器添加实用程序，以使其功能更加全面，能够运行我们想要运行的代码，而无需预处理器、命令行工具或要下载的库/包。</p><p id="4c76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何本机方法、属性或浏览器API都可以被聚合填充，因此，例如，可以向Internet Explorer这样的浏览器添加一个<strong class="kf ir"> fetch() </strong>方法。(虽然我承认使用Internet Explorer的人是罕见的、困惑的一群，但他们仍然应该和我们其他人一样拥有相同的网络。)这是可能的，因为Javascript中的一切都是对象，所以我们可以添加另一个对象，并赋予它属性来重新创建获取行为。</p><p id="c843" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也就是说，表达式和运算符不能被聚合填充，因为它们不是对象。相反，它们被嵌入到Javascript的解析引擎中，使得不可能添加ES5/ES6语法。</p><p id="3a4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管如此，多孔填料在打破网络壁垒方面还是非常有用的。通过有选择地将标准化代码注入旧的浏览器，竞争环境变得更加公平。</p><h2 id="54a4" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">生产聚合填料</h2><p id="ef88" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">在我们编写polyfill之前，让我们确保检查所讨论的浏览器是否具有执行(比如说)的本机功能。replaceAll()字符串方法:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="4a6e" class="lb lc iq ml b gy mp mq l mr ms">// Make sure there's no native method available first<br/>if (!String.prototype.replaceAll) {<br/>	// Add some polyfill code...<br/>}</span></pre><p id="87fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是为我们填充的方法创建一个函数。方法接受两个参数:要搜索的子字符串和替换它的字符串，所以让我们设置一下。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="2b46" class="lb lc iq ml b gy mp mq l mr ms">if (!String.prototype.replaceAll) {<br/>	String.prototype.replaceAll = function (str, newStr){<br/>		// Recreate the native method here...<br/>	};<br/>}</span></pre><h1 id="e8a2" class="mw lc iq bd ld mx my mz lg na nb nc lj nd ne nf lm ng nh ni lp nj nk nl ls nm bi translated">假装恐惧</h1><p id="5e38" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">现在我们可以尝试重新创建。replaceAll()字符串方法。解决这个问题的一个简单方法是思考:“<em class="lx">如果……我会怎么做。replaceAll()不可用？</em>”</p><p id="688b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，我们将让我们的函数根据用户输入生成一个新的regex模式。但是因为我们的函数是在原型上，在我们的函数内部，<code class="fe mt mu mv ml b">this</code>是调用<code class="fe mt mu mv ml b">replaceAll()</code>方法的字符串。我们可以调用<code class="fe mt mu mv ml b">this.replace()</code>，使用<code class="fe mt mu mv ml b">new RegExp()</code>创建一个新的正则表达式模式，并使用<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/global" rel="noopener ugc nofollow" target="_blank">全局(</a> <code class="fe mt mu mv ml b"><a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/global" rel="noopener ugc nofollow" target="_blank">g</a></code> <a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/global" rel="noopener ugc nofollow" target="_blank">)标志</a>传递我们的<code class="fe mt mu mv ml b">str</code>参数。然后，传入<code class="fe mt mu mv ml b">newStr</code>参数作为替换它的对象，然后返回结果。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="b31f" class="lb lc iq ml b gy mp mq l mr ms">if (!String.prototype.replaceAll) {<br/>	String.prototype.replaceAll = function (str, newStr){</span><span id="5876" class="lb lc iq ml b gy nn mq l mr ms">		// If a string<br/>		return this.replace(new RegExp(str, 'g'), newStr);</span><span id="4e64" class="lb lc iq ml b gy nn mq l mr ms">	};<br/>}</span></pre><p id="d7f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们快完成了。我们需要做的最后一件事是为我们<em class="lx">没有</em>接收到函数的正则表达式模式的情况创建一个异常。如果提供了一个，我们不想创建新的模式，而是检查<code class="fe mt mu mv ml b">str</code>是否是正则表达式，如果是，就传递它。<a class="ae kc" href="https://gomakethings.com/true-type-checking-with-vanilla-js/" rel="noopener ugc nofollow" target="_blank">否则，我们需要检查输入的类型。</a></p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="680e" class="lb lc iq ml b gy mp mq l mr ms">if (!String.prototype.replaceAll) {<br/>	String.prototype.replaceAll = function (str, newStr){</span><span id="8bb6" class="lb lc iq ml b gy nn mq l mr ms">		// If a regex pattern<br/>		if (Object.prototype.toString.call(str).toLowerCase() === '[object regexp]') {<br/>			return this.replace(str, newStr);<br/>		}</span><span id="0a6e" class="lb lc iq ml b gy nn mq l mr ms">		// If a string<br/>		return this.replace(new RegExp(str, 'g'), newStr);</span><span id="afa8" class="lb lc iq ml b gy nn mq l mr ms">	};<br/>}</span></pre><p id="fd4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">聚脂填料很好玩！</p></div></div>    
</body>
</html>