<html>
<head>
<title>Batch process in AWS and configure its infrastructure with Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在AWS中进行批处理，并使用Terraform配置其基础设施</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/batch-process-in-aws-and-configure-its-infrastructure-with-terraform-d4a2de3c783c?source=collection_archive---------2-----------------------#2020-03-28">https://medium.datadriveninvestor.com/batch-process-in-aws-and-configure-its-infrastructure-with-terraform-d4a2de3c783c?source=collection_archive---------2-----------------------#2020-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="576e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们开发API时，即使它是私有的或公共的，我们也应该知道API是如何工作的:请求负载的最大大小是什么，响应负载的最大大小是什么，以及它的API响应超时。</p><p id="c644" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我谈到API的时候，你首先想到的API应该是RESTful，但是除了REST之外还有其他类型的API。据我所知，这些是SOAP、XML-RPC和JSON-RPC。好了，我们来看看API叫什么，它的用法。</p><blockquote class="kl"><p id="eb1e" class="km kn iq bd ko kp kq kr ks kt ku kk dk translated">API(应用程序编程接口)是一组允许应用程序访问数据并与外部软件组件、操作系统或微服务交互的功能。(参考:<a class="ae kv" href="https://www.bigcommerce.com/blog/what-is-an-api/#what-is-an-api" rel="noopener ugc nofollow" target="_blank">链接</a>)</p></blockquote><p id="95f9" class="pw-post-body-paragraph jn jo iq jp b jq kw js jt ju kx jw jx jy ky ka kb kc kz ke kf kg la ki kj kk ij bi translated">当我用容器内的NodeJS开发Restful API时，我认为每个API进程都可以通过相互通信完美地工作和无缝地运行。但是当我们使用模拟的生产数据进行负载测试时，由于Restful API模式的有限负载和处理超时问题，一些繁重的流程API失败了。这时候，我们需要通过使用AWS Batch的方式，将这种繁重的流程API解耦为单独的服务。</p><blockquote class="lb lc ld"><p id="d583" class="jn jo le jp b jq jr js jt ju jv jw jx lf jz ka kb lg kd ke kf lh kh ki kj kk ij bi translated">AWS Batch是一组批处理管理功能，使开发人员、科学家和工程师能够在AWS上轻松高效地运行成千上万的批处理计算作业。AWS Batch根据提交的批处理作业的数量和特定资源要求，动态调配最佳数量和类型的计算资源(例如，CPU或内存优化实例)。</p></blockquote><p id="62d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用批处理，如果您是贵组织的解决方案架构，我们将了解成本优化和流程优化，当应用程序准备好开始启动时，这两种优化也可以让您安全。在批处理计算环境中，有两种<strong class="jp ir">实例类型</strong>，称为<strong class="jp ir">最优</strong>和“特定实例类型”。</p><p id="99f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为<strong class="jp ir">最佳</strong>，Batch将根据CPU和内存单元选择与您定义的作业队列需求相匹配的实例类型(从C、M和R实例系列中)。</p><div class="li lj gp gr lk ll"><a href="https://www.datadriveninvestor.com/2020/03/11/cloud-made-simple-for-undecided-career-change-planners-the-fundamentals/" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab fo"><div class="ln ab lo cl cj lp"><h2 class="bd ir gy z fp lq fr fs lr fu fw ip bi translated">云让犹豫不决的职业生涯规划者变得简单:基础|数据驱动的投资者</h2><div class="ls l"><h3 class="bd b gy z fp lq fr fs lr fu fw dk translated">尽管IT在当今的商业中扮演着重要的角色，但许多IT求职者都不愿意从事云计算职业…</h3></div><div class="lt l"><p class="bd b dl z fp lq fr fs lr fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="lu l"><div class="lv l lw lx ly lu lz ma ll"/></div></div></a></div><p id="a937" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果您只在实例类型列表中定义为<strong class="jp ir"> ["c4.large "，" c4.xlarge"] </strong>，Batch将根据您的作业队列的需求或您根据CPU和内存单元定义的需求选择合适的实例。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/bb2f6eaa9e7f348abc92f2f9e2cd490f.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*eE2A56zVlyTBHRK_s6bAug.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">sample AWS Batch architecture</figcaption></figure><p id="bc35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上图是AWS批处理如何工作的示例工作流，这就是我应该创建Terraform来建立架构的原因。</p><ol class=""><li id="9cf7" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">首先，我们将创建一个Step函数来触发Lambda检查批处理及其作业流程的状态，无论它是处于可运行阶段、开始阶段、运行阶段还是结束阶段。</li><li id="3704" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">Lambda将启动批处理，并根据触发它的步骤函数来观察它的状态。</li><li id="4e52" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">当它准备好开始运行时，Batch将从ECR中提取Docker图像，并在EC2实例中运行。</li><li id="2532" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">作业成功完成后，Lambda会将其作业状态发送给Step函数，您的作业可以在应用程序中标记为完成状态。</li></ol></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nh"><img src="../Images/362e842f75d6be08a0eff8a9c28e1486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hd3zHtBJPmbyBwYyryotlQ.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk"><a class="ae kv" href="https://www.hashicorp.com/resources/create-change-and-orchestrate-aws-infrastructure-wi" rel="noopener ugc nofollow" target="_blank">https://www.hashicorp.com/resources/create-change-and-orchestrate-aws-infrastructure-wi</a></figcaption></figure><p id="7a52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，让我们创建一个平台来建立批处理的架构。由于这是一个如何用Terraform设置批处理资源的简单项目，我不会不创建其批处理的完整Terraform项目。</p><ol class=""><li id="465e" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">aws _批处理_计算_环境</li></ol><pre class="mc md me mf gt nm nn no np aw nq bi"><span id="8d3a" class="nr ns iq nn b gy nt nu l nv nw">resource "aws_batch_compute_environment" "my-heavy-function" {<br/>  compute_environment_name = "my-heavy-function"<br/>  compute_resources {<br/>    instance_role = "${aws_iam_instance_profile.ec2-profile.arn}"<br/>    <strong class="nn ir">instance_type</strong> = [<br/>      "c4.xlarge",<br/>      "c4.large"<br/>    ]<br/>    <strong class="nn ir">max_vcpus</strong>     = 256<br/>    <strong class="nn ir">min_vcpus</strong>     = 0<br/>    desired_vcpus = 1<br/>    security_group_ids = [<br/>      "${aws_security_group.processor-batch.id}"<br/>    ]<br/>    subnets = "${data.aws_subnet_ids.my_subnet_ids.ids}"<br/>    type    = "EC2"<br/>  }<br/>  service_role = "${aws_iam_role.batch-service-role.arn}"<br/>  type         = "MANAGED"<br/>  depends_on   = ["aws_iam_role_policy_attachment.batch-service-role"]<br/>}</span></pre><p id="9ef3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> instance_type </strong>批处理将在创建作业时创建两种类型的实例类型。默认是<strong class="jp ir"> c4.large </strong>。</p><p id="e2f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">max _ vcpu</strong>一个环境可以达到的Amazon EC2 vCPUs的最大数量。</p><p id="40e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">min _ vcpu</strong>一个环境应该维护的Amazon EC2 vCPUs的最小数量。因为这是一个开发环境，需要进行成本优化，所以应该为零。当它被定义为零时，当作业不可用时，批处理将不创建备用实例，当作业准备好进行处理时，批处理将根据其作业配置创建实例。但是根据实例类型创建实例需要一些时间。</p><p id="e3cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.aws _批处理_作业_队列</p><pre class="mc md me mf gt nm nn no np aw nq bi"><span id="bfa9" class="nr ns iq nn b gy nt nu l nv nw">resource "aws_batch_job_queue" "my-heavy-function-queue" {<br/>  name     = "my-heavy-function-queue"<br/>  state    = "ENABLED"<br/>  priority = 1<br/>  <strong class="nn ir">compute_environments</strong> = [<br/>    "${aws_batch_compute_environment.my-heavy-function.arn}"<br/>  ]<br/>}</span></pre><p id="471c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> compute_environments </strong>它是批处理环境和作业队列之间的链接。</p><p id="0431" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.aws _批处理_作业_定义</p><pre class="mc md me mf gt nm nn no np aw nq bi"><span id="0a21" class="nr ns iq nn b gy nt nu l nv nw">resource "aws_batch_job_definition" "my-heavy-function-job" {<br/>  name = "my-heavy-function-job"<br/>  type = "container"<br/>  depends_on = [<br/>    "aws_ecr_repository.my-heavy-function-job-repo"<br/>  ]<br/>  container_properties = &lt;&lt;CONTAINER_PROPERTIES<br/>{<br/>  <strong class="nn ir">"image": "${aws_ecr_repository.my-heavy-function-job-repo.repository_url}:latest",</strong><br/>  "jobRoleArn": "${aws_iam_role.job-role.arn}",<br/>  "<strong class="nn ir">vcpus</strong>": 1,<br/>  "<strong class="nn ir">memory</strong>": 1024,<br/>  "<strong class="nn ir">command</strong>": [<br/>    "node",<br/>    "index.js",<br/>    "Ref::processId",<br/>  ]<br/>}<br/>CONTAINER_PROPERTIES<br/>}</span></pre><p id="07cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于您熟悉创建AWS ECS环境，因此对您来说并不陌生，因为它与ECS定义文件以及批处理作业定义文件相同。它是获取哪些资源以及使用哪个命令来运行批处理作业的命令器。</p><p id="8006" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> image </strong>它是要在ECR repo中存储的创建Docker映像时对流程的所有重要功能执行的源代码。</p><p id="3d56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">vcpu</strong>将根据您的工艺需求定义。</p><p id="3855" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">记忆</strong>也会一样。</p><p id="f683" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">命令</strong>将对您的Docker图像执行。您可以根据您的流程需求定义各种命令。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><p id="b47f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是时候用Lambda执行批处理了。</p><pre class="mc md me mf gt nm nn no np aw nq bi"><span id="644b" class="nr ns iq nn b gy nt nu l nv nw">exports.handler = async (event) =&gt; {<br/>  let params = event['body'];<br/>  let response = {}, result = {};<br/>  let jobInfo = {<br/>    <strong class="nn ir">jobDefinition</strong>: process.env.JOB_DEFINITION,<br/>    <strong class="nn ir">jobName</strong>: `job-${UUID()}`,<br/>    <strong class="nn ir">jobQueue</strong>: process.env.JOB_QUEUE,<br/>    <strong class="nn ir">parameters</strong>: {<br/>      <strong class="nn ir">processId: params.processId</strong><br/>    },<br/>    <strong class="nn ir">containerOverrides: {<br/>      vcpus: 2,<br/>      memory: 2000<br/>    }</strong><br/>  };<br/>  result = await client.submitJob(jobInfo).promise();<br/>  response = {<br/>    statusCode: 200,<br/>    body: {<br/>      jobId: `${result.jobId}`<br/>    }<br/>  }<br/>  return response;<br/>}</span></pre><p id="b037" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> jobDefinition </strong>是之前创建的批处理作业定义ARN。</p><p id="44a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> jobQueue </strong>是之前创建的批处理作业队列ARN。</p><p id="7267" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">作业名</strong>是一个批处理作业名。要重要，应该是独一无二的。</p><p id="f82f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">参数</strong>与<strong class="jp ir">命令</strong>属性在批处理作业定义中的配置相同。</p><p id="e8ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> containerOverrides </strong>这就是我喜欢的AWS，它使我们能够灵活地根据我们的工作流程创建所需的内容。配置<strong class="jp ir"> aws_batch_job_definition </strong>时，已经定义默认其配置为<strong class="jp ir">1 vcpu</strong>和<strong class="jp ir"> 1024内存</strong>。但是当需要获得比之前配置的更多的资源时，<strong class="jp ir"> containerOverrides </strong>属性可以用来覆盖默认配置。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><p id="5da1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，现在运行Terraform在AWS中设置批处理资源，只需执行以下简单命令:</p><pre class="mc md me mf gt nm nn no np aw nq bi"><span id="e1b3" class="nr ns iq nn b gy nt nu l nv nw">terraform plan</span><span id="96ac" class="nr ns iq nn b gy nx nu l nv nw">terraform apply</span></pre><p id="11f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快乐的云计算和基础设施代码。当这个博客能帮助你或多或少地了解AWS Batch和Terraform时，请不要忘记鼓掌，谢谢。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="ny nz l"/></div></figure></div></div>    
</body>
</html>