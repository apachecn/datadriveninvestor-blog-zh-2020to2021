<html>
<head>
<title>Kaggle Machine Learning Challenge done using SAS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SAS完成的Kaggle机器学习挑战</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/kaggle-machine-learning-challenge-done-using-sas-a71e72a94cf4?source=collection_archive---------1-----------------------#2020-03-31">https://medium.datadriveninvestor.com/kaggle-machine-learning-challenge-done-using-sas-a71e72a94cf4?source=collection_archive---------1-----------------------#2020-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4a30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经使用SAS进行了一段时间的安静，但除了用于纯粹的分析，我还没有使用它进行其他一些通常需要的数据科学功能，如数据管理、清理和插补。所以我决定这样做。我决定在SAS中实现的项目并不新奇，但是通过它，我可以尝试SAS的各种产品。</p><h1 id="ca86" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">访问服务协议</h1><p id="e59d" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">学生可以访问SAS大学版，也有一项服务允许您在线按需使用SAS，浏览下面提供的链接应该可以让您找到运行本示例中提供的代码所需的资源。</p><p id="784f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae lr" href="https://www.sas.com/en_us/software/university-edition/download-software.html" rel="noopener ugc nofollow" target="_blank">https://www . SAS . com/en _ us/software/university-edition/download-software . html</a></p><h1 id="2131" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">基本SAS概念</h1><p id="0af0" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated"><strong class="js iu">数据步骤:</strong>数据步骤由一组以数据语句开始的SAS语句组成。DATA语句开始构建SAS数据集的过程，并命名数据集。编译组成数据步骤的语句，并检查语法。如果语法正确，则执行语句。最简单的形式是，数据步骤是一个带有自动输出和返回动作的循环。</p><div class="ls lt gp gr lu lv"><a href="https://www.datadriveninvestor.com/2020/02/19/cognitive-computing-a-skill-set-widely-considered-to-be-the-most-vital-manifestation-of-artificial-intelligence/" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd iu gy z fp ma fr fs mb fu fw is bi translated">认知计算——一套被广泛认为是……</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">作为它的用户，我们已经习惯了科技。这些天几乎没有什么是司空见惯的…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj mk lv"/></div></div></a></div><p id="0719" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> PROC步骤:</strong>PROC步骤由一组调用和执行过程的SAS语句组成，通常使用SAS数据集作为输入。PROCs分析SAS数据集中的数据，生成格式化报告或其他结果，或者提供管理SAS文件的方法。您可以用最少的努力来修改过程，以生成您需要的输出。PROCs还可以执行诸如显示关于SAS数据集的信息之类的功能。</p><h1 id="ddfe" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">数据集</h1><p id="c3a7" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">对于这个例子，我决定使用Titanic数据集的例子，而不是任何新的分析方法，我决定尝试重新创建一个现有的笔记本作为SAS程序。因此，在这篇文章中，作为读者的你可以预期对机器学习和数据科学最佳实践的强调会减少，而不是将现有材料翻译成SAS代码。</p><div class="ls lt gp gr lu lv"><a href="https://www.kaggle.com/mrisdal/exploring-survival-on-the-titanic" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd iu gy z fp ma fr fs mb fu fw is bi translated">探索泰坦尼克号上的生存</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">使用Kaggle笔记本探索和运行机器学习代码|使用《泰坦尼克号:灾难中的机器学习》中的数据</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">www.kaggle.com</p></div></div><div class="me l"><div class="ml l mg mh mi me mj mk lv"/></div></div></a></div><p id="1478" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的笔记本是由Kaggle用户Megan Risdal创作的，作品简单易懂，也很受欢迎，是泰坦尼克号生存预测比赛中最受欢迎的笔记本之一。它是用R编写的，讲述了Kaggle风格数据科学的一些基本知识，包括特征工程、清理和基本的树建模。我会试着把她笔记本上的一些代码加入到这篇文章中，但是我可能会去掉一部分，这样看起来会干净一些。建议您同时学习这两个教程。</p><h1 id="21d2" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">1.加载数据</h1><p id="5f63" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">执行的第一步是加载三个数据集，即训练、测试和提交。按照教程中所做的(我将Megans的工作称为“教程”)，创建了一个名为full的数据集，它是通过将训练和测试数据集堆叠在一起而创建的，对于熟悉r。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="a357" class="mv kp it mr b gy mw mx l my mz">proc import datafile = '/home/***/Titanic/Data/train.csv'  <br/>    out = train <br/>    dbms=csv <br/>    replace;<br/>run; </span><span id="04b4" class="mv kp it mr b gy na mx l my mz">proc import datafile = '/home/***/Titanic/Data/test.csv'  <br/>    out = test <br/>    dbms=csv <br/>    replace;<br/>run;</span><span id="9949" class="mv kp it mr b gy na mx l my mz">proc import datafile = '/home/***/Titanic/Data/gender_submission.csv'  <br/>    out = submission <br/>    dbms=csv <br/>    replace;</span><span id="8f36" class="mv kp it mr b gy na mx l my mz">run;</span><span id="dd59" class="mv kp it mr b gy na mx l my mz">data full; <br/>    set train test;<br/>run;</span></pre><p id="9c2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码执行前面描述的内容。有几种方法可以将“csv”文件导入SAS，但最简单的方法是使用Proc(过程的缩写)导入。在代码中，我遵循的基本步骤是，首先描述我要读取的文件的路径，声明我的“SAS-Dataset”的名称，该名称将主动用于分析，指定我要读取的数据类型为“CSV ”,最后允许SAS-Dataset名称被替换或覆盖。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="233e" class="mv kp it mr b gy mw mx l my mz">*The first line is used to specify plot size;<br/>ods graphics / width=640px height=480px;  <br/>proc print data = full(obs = 5);  <br/>title 'Sample output of the Data'; <br/>run;  </span><span id="0c5f" class="mv kp it mr b gy na mx l my mz">proc contents data=full; *For meta data; <br/>title 'Summary of training data'; <br/>run;</span></pre><p id="fa60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们看看我们的数据。SAS是一个很棒的报告工具，可以生成大量的信息图表，其中大部分我不会展示。PROC内容是生成数据集元数据的好方法。</p><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nb"><img src="../Images/7e236401f8751417f85fe9c452995722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-aWkTh3uYs2sft-IsN2AQQ.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Output for PROC PRINT</figcaption></figure><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/f114b99fb33bdf8cec639d05760e2388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*B501EzKyHMUFnDCQ_aEs9A.png"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Output for PROC CONTENTS</figcaption></figure><h1 id="0fb9" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">2.特征工程</h1><h2 id="70c0" class="mv kp it bd kq nn no dn ku np nq dp ky kb nr ns lc kf nt nu lg kj nv nw lk nx bi translated">2.1名字里有什么？</h2><p id="c27f" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">第一个特征工程步骤包括从名字中提取标题。使用R，这个过程相对简单，但是在SAS中需要的步骤稍微有点复杂，但是仍然可以实现。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="7414" class="mv kp it mr b gy mw mx l my mz">full<strong class="mr iu">$</strong>Title &lt;- <strong class="mr iu">gsub</strong>('(.*, )|(\\..*)', '', full<strong class="mr iu">$</strong>Name)</span></pre><p id="71ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的代码片段是从乘客姓名中提取标题的R代码。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="fed4" class="mv kp it mr b gy mw mx l my mz">/*Helpr macros for SAS*/</span><span id="cafd" class="mv kp it mr b gy na mx l my mz">%macro Reg_searchReplace(df= , col=, newcol= , regex=);<br/> data &amp;df;<br/>  set &amp;df;<br/>   &amp;newcol = &amp;col;<br/>   array Chars[*] &amp;newcol; <br/>   do i = 1 to dim(Chars); <br/>    retain re;<br/>    re = prxparse(&amp;regex); <br/>    Chars[i] =  prxchange(re, -1,Chars[i]); <br/>    ;  <br/>   end;<br/>   drop re i;*drop newly creatd temp columns;<br/> run;</span><span id="35cd" class="mv kp it mr b gy na mx l my mz">%mend Reg_searchReplace;</span></pre><p id="dd7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本教程中，正则表达式用于优雅地从一个名字中提取标题。SAS也有正则表达式功能，但是要对“Name”列中的所有数据点进行大规模的正则表达式运算，需要一个for循环。为此，我创建了如上所示的宏(宏是SAS函数)。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="c601" class="mv kp it mr b gy mw mx l my mz">*import macros from tools;<br/>%include '/home/***/Titanic/Code/tools.sas';</span></pre><p id="803e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">宏被保存到不同的SAS文件中，并使用include语句加载到当前文件中。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="08ed" class="mv kp it mr b gy mw mx l my mz">%Reg_searchReplace(df = full, col = Name, newcol = Title_col, <br/>regex = 's/(.*, )|( .*)//');</span></pre><p id="8fa0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">指定了数据集、列名、新列名和正则表达式模式，运行搜索和替换功能从乘客姓名中提取标题。现在我们使用“Proc Freq”创建信息图表，这是一种制作列联表的简便方法。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5e4a" class="mv kp it mr b gy mw mx l my mz">proc freq data = full;<br/>title 'Contingency Table of Male and Female and their Titles';<br/>tables Sex*Title_col / nopercent nocol norow;<br/>run;</span></pre><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ny"><img src="../Images/cbedba90f938eba4afa65d843a87c42c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y1qw54lVGIUug5_UpXlvXA.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">PROC FREQ Output</figcaption></figure><p id="7acf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一步是纠正“标题”中的一些拼写错误，然后将所有不常用的标题(如Jonkheer、Dona等)分组。)合并成一个叫“稀有”的单组。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="9ad1" class="mv kp it mr b gy mw mx l my mz">*replace unfrequent titles with rare;<br/> data full;<br/>  set full;<br/>   Title_col = translate(Title_col,'','.');<br/>   Title_col = translate(Title_col,'',' '); <br/>   re = prxparse('s/Mlle/Miss/');<br/>   Title_col = prxchange(re, -1,Title_col);<br/>   re = prxparse('s/Ms/Miss/');<br/>   Title_col = prxchange(re, -1,Title_col);<br/>   re = prxparse('s/Mme/Mrs/');<br/>   Title_col = prxchange(re, -1,Title_col);<br/>   array Chars{11} $ ('Dona', 'Lady', 'the Countess','Capt', 'Col', 'Don', 'Dr', 'Major', 'Rev', 'Sir', 'Jonkheer'); <br/>   do i = 1 to dim(Chars);<br/>    regex_1 = catx('','s/',Chars[i]);<br/>    regex_1 = compress(catx('',regex_1, '/Rare/'));<br/>    re = prxparse(regex_1); <br/>    Title_col =  prxchange(re, -1,Title_col); regex;<br/>    ;  <br/>   end;<br/>   drop Chars1 Chars2 Chars3 Chars4 Chars5 Chars6 Chars7 Chars8 Chars9 Chars10 Chars11 regex_1 i re;<br/>   <br/> run;</span></pre><p id="925c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在SAS中执行时间稍长，但是一旦理解了基础知识，就很容易分解和解决大问题。诸如translate和scan之类的函数对于文本处理来说是必不可少的，但是对于更繁重的操作来说，regex总是最好的，这里使用regex来进行拼写纠正。稍后，重新应用正则表达式来替换不太常用的标题组，并用“稀有”替换它们。要查看这些变化，可以使用PROC FREQ。</p><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nz"><img src="../Images/50b0cae783026ff0b6ea9f700e532735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DYlqZjIMLPIj4i-dFRMZvA.png"/></div></div></figure><h2 id="c480" class="mv kp it bd kq nn no dn ku np nq dp ky kb nr ns lc kf nt nu lg kj nv nw lk nx bi translated">2.2一家人是一起沉还是一起游？</h2><p id="ed1e" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">这一步需要通过添加变量“Parch”和“Sibp”来计算家庭规模，使用SAS数据步骤很容易实现这一点。在数据步骤中，我们读取sas表“full”并用编辑过的变量“Fsize”和“FsizeD”重写该表(使用“set”)。“FsizeD”是“Fsize”变量的离散化版本，可以在SAS中使用简单的“if then”语句来实现。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="63a9" class="mv kp it mr b gy mw mx l my mz">*Analysis on Family Size;<br/> data full;<br/>  set full;<br/>   Fsize = SibSp + Parch + 1;<br/>   FsizeD = 'Singleton';<br/>   if Fsize &gt; 1 and Fsize &lt; 5 then FsizeD = 'samll';<br/>   if Fsize &gt; 4 then FsizeD = 'large';<br/>  run;</span></pre><p id="8b14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一步是观察不同家庭规模的不同性别的生存前景。为此，我们使用“SGPLOT”函数，它需要一个输入数据集。然后，我们将每个不同家庭规模的频率可视化，并输入其他变量对可视化进行分组。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="f702" class="mv kp it mr b gy mw mx l my mz">proc sgplot data = full;<br/>  vbar Fsize / group= Survived groupdisplay = cluster;<br/> title 'Survival vs Family Size';<br/> run;</span></pre><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oa"><img src="../Images/530cb28022fe164553d522c63b2f59b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DWIdqEV1uQiUasuhQPDNTw.png"/></div></div></figure><p id="1afd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">教程中指定的下一步是创建镶嵌图，以显示与上述相同的信息，并增加了一个使用离散化族尺寸而不是上述族尺寸的步骤。这个过程可以使用PROC FREQ来实现，并传递一个附加指令来构造一个镶嵌图。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="43a7" class="mv kp it mr b gy mw mx l my mz">ods graphics on;<br/> proc freq data=full;<br/> tables Survived*FsizeD / norow nofreq plots=MOSAIC; <br/> title 'Mosaic Plot Fsize Desc. vs Survived';<br/> run;</span></pre><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ob"><img src="../Images/16d68ac31370cd0e8f933444db6f054c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ylsOmeygP7YBIVu-6-DoxQ.png"/></div></div></figure><h2 id="4f21" class="mv kp it bd kq nn no dn ku np nq dp ky kb nr ns lc kf nt nu lg kj nv nw lk nx bi translated">2.3处理更多的变量…</h2><p id="8b60" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">最后，我们设计了变量“船舱”，这是变量“甲板”的第一个字符。为了完全公开，这个变量有许多缺失值，并从最终模型中删除，但尽管如此，经历这个过程是数据管理和特征工程中的一个很好的练习。我们使用SAS函数“substr”从目标变量中检索第一个索引字符。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="ac70" class="mv kp it mr b gy mw mx l my mz">*Extract deck from cabin;<br/> data full;<br/>  set full;<br/>   Deck = substr(Cabin,1,1);<br/> run;</span></pre><h1 id="1a75" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">3个缺失值</h1><h2 id="bf24" class="mv kp it bd kq nn no dn ku np nq dp ky kb nr ns lc kf nt nu lg kj nv nw lk nx bi translated">3.1合理价值估算</h2><p id="0b00" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">数据清理的重要性怎么强调都不为过。通常，像R &amp; Python这样灵活的语言更适合使用能够处理各种数据类型的多功能函数来清理数据。SAS也包括类似的数据清理功能。我们的第一个目标是估算PassengerID 63 &amp; 830的值，它缺少变量“apollowed”。为此，我们使用变量“Fare”的分布来完成。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="c4b0" class="mv kp it mr b gy mw mx l my mz">proc sgplot data = full;<br/>  vbox Fare / category=Embarked group=Pclass;  <br/>  refline 80;<br/> title 'Fare vs Embarkment';<br/> run;</span></pre><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ob"><img src="../Images/1eed78ad14067a4a5e4b9ad3c4d4607a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zYIYfC7fV0eFuqY5_I694g.png"/></div></div></figure><p id="2f10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">想法是；假设我们知道乘客编号63和830的机票价格为80英镑(上面未显示，但分析是单独进行的)，并且假设这两名乘客都属于头等舱(“Pclass”)，那么最有可能的登机地点是哪里(C、Q、S)。参考线为80°箱线图用于说明这一点。基于视觉，很容易看出，根据给定的信息，乘客很可能是从位置“C”出发的。然后，我们使用数据步骤，用我们的分析值估算乘客信息。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5e7d" class="mv kp it mr b gy mw mx l my mz">data full; <br/>  set full;<br/>   if PassengerId = 62 then Embarked = 'C';<br/>   if PassengerId = 830 then Embarked = 'C';<br/> run;</span></pre><p id="1f39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，在进入下一阶段之前，重要的是要找出我们的数据集中每一列存在多少缺失值。为此，下面的过程能够检索所需的信息。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0052" class="mv kp it mr b gy mw mx l my mz">proc format;<br/>   value $missfmt ' '='Missing' other='Not Missing';<br/>   value  missfmt  . ='Missing' other='Not Missing';<br/> run;<br/> <br/> proc freq data=full; <br/>  format _CHAR_ $missfmt.; <br/>  tables _CHAR_ / missing missprint nocum nopercent;<br/>  format _NUMERIC_ missfmt.;<br/>  tables _NUMERIC_ / missing missprint nocum nopercent;<br/> run;</span></pre><p id="377e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，PROC FREQ能够做到这一点，上面应用的方法的好处是不需要手动输入列。使用“_CHAR_”和“_NUMERIC_”检索所有需要的列，唯一的警告是我们需要在两者上运行过程(也可以尝试“_ALL_ ”)。下面显示了该过程输出的一个小示例。</p><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/12e4bf43a039ec0e610c4150f6347d39.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*_54w0IyWSsWxyJA4Ms4yNw.png"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Example output from procedure.</figcaption></figure><p id="e2e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们创建一个宏，它能够从数据集中找到并选择包含缺失值的行。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="bd5b" class="mv kp it mr b gy mw mx l my mz">%macro getMissing(df=);</span><span id="a56b" class="mv kp it mr b gy na mx l my mz">data missing;<br/>  set &amp;df;<br/>   numMissing = 0;<br/>   array cols1 _numeric_;<br/>   do over cols1;<br/>    numMissing = numMissing + cmiss(cols1);;<br/>   end;<br/>  <br/>   array cols2 _character_;<br/>   do over cols2;<br/>    numMissing = numMissing + cmiss(cols2);;<br/>   end;<br/> run;<br/> <br/> proc sql;<br/> title 'Rows with missing values'; <br/> select * from missing where numMissing &gt; 0;<br/> quit;</span><span id="ca0d" class="mv kp it mr b gy na mx l my mz">%mend getMissing;</span></pre><p id="2118" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面显示的过程(检索每列的缺失值)显示，“Cabin”、“Deck”和“Age”有许多缺失值，排除它们并运行上面的宏将找到任何需要特别注意的行。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="11fe" class="mv kp it mr b gy mw mx l my mz">*Subset dataframe with columns that don't have too many missing values;<br/> data sub_full;<br/>  set full;<br/>   drop Cabin Deck Age Survived;<br/>  run;<br/> %getMissing(df = sub_full);</span></pre><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi od"><img src="../Images/d5707d25c995713d2287e5a6d17eaf14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t_1Fm30PKtpDhYSCtbtZ9w.png"/></div></div></figure><p id="91eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它揭示了乘客Id 1044有一个丢失的票价，我们将使用票价中值估算该值。首先我们将分布可视化。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="ff29" class="mv kp it mr b gy mw mx l my mz">proc sql;<br/> create table sub_full as<br/> select * from full<br/> where Pclass = 3 and Embarked = 'S';<br/> quit;</span><span id="91ca" class="mv kp it mr b gy na mx l my mz">proc sgplot data = sub_full;<br/> title 'Density of Fare'; <br/> histogram Fare;<br/> *refline 21 / axis = x;<br/> run;</span></pre><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oe"><img src="../Images/f24facdf08b03acaa98a8c927d0bbb49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jbSDkN5EZtmToWAREorEKQ.png"/></div></div></figure><p id="16b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们将使用上面显示的票价中值来估算缺失值。为此，我们将利用PROC SQL，这是一个方便的过程，允许将SQL查询应用于SAS表。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="ee80" class="mv kp it mr b gy mw mx l my mz">*impute values with median value;<br/> proc sql;<br/>     update full<br/>     set Fare = (select median(Fare) from sub_full) <br/>     where PassengerId = 1044;<br/> quit;<br/> run;</span></pre><p id="6d43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们询问我们的插补是否成功。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0ecf" class="mv kp it mr b gy mw mx l my mz">proc sql;<br/>  select * from full<br/>  where PassengerId = 1044;<br/> quit;</span></pre><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi of"><img src="../Images/0d69804faa0515d2ebc3867619b39f2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oTMAmhx07xep3IXt-IO3fg.png"/></div></div></figure><p id="1717" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">PassengerId 1044来自测试集，因此幸存下来的可以保持原样，我们的最终目标是预测它。</p><h2 id="d216" class="mv kp it bd kq nn no dn ku np nq dp ky kb nr ns lc kf nt nu lg kj nv nw lk nx bi translated">3.2预测插补</h2><p id="5ca6" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">为了估算缺失的年龄值，我们将创建一个预测模型。这就是我使用的步骤与原始教程不同的地方。最初，R中通过链式方程进行多变量插补的MICE包被用于输入“年龄”,但由于我在SAS中搜索类似方法被证明不成功，我决定使用PROC MI。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="043a" class="mv kp it mr b gy mw mx l my mz">proc mi data= full nimpute=1 out=full seed=54321;<br/> class Embarked FsizeD Title_col Sex;<br/> monotone regression ;<br/> var Pclass Fsize Parch Embarked FsizeD Title_col Sex Age;<br/> run;<br/> <br/> data full;<br/>  set full;<br/>   Age = abs(age);<br/> run;</span></pre><p id="c238" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个过程的输出是通过分布直方图可视化的，虽然输出不如教程令人满意，但它完成了工作。任何出现的负值都被转换为绝对值(这也可以通过在程序步骤中指定“最小值”来实现)。</p><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi og"><img src="../Images/d85ece87bd1c9ca44db244ec915897ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8DFvnv1nowgjbTq7FI30OA.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">More info on PROC MI <a class="ae lr" href="https://support.sas.com/documentation/onlinedoc/stat/141/mi.pdf" rel="noopener ugc nofollow" target="_blank">https://support.sas.com/documentation/onlinedoc/stat/141/mi.pdf</a></figcaption></figure><h2 id="42f8" class="mv kp it bd kq nn no dn ku np nq dp ky kb nr ns lc kf nt nu lg kj nv nw lk nx bi translated">3.3特征工程:第2轮</h2><p id="3292" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">为了验证我们创建识别母亲和孩子的特征的动机(我们认为这可能是预测中的一个重要因素)，我们使用直方图来查看年龄和性别(母亲和决定是否要孩子的因素)对存活率结果的影响。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="a6df" class="mv kp it mr b gy mw mx l my mz">data sub_full;<br/>  set full;<br/>  if cmiss(of Survived) =0;<br/> run;<br/> proc sgpanel data = sub_full;<br/> title 'Age faceted by Survival &amp; Sex';<br/> panelby Sex;<br/> histogram Age / group=Survived nbins= 30;<br/> run;</span></pre><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oh"><img src="../Images/1972c3f739bc46a3ac84ab4e223f5493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7-7kjICDZwIopI0WycIQkA.png"/></div></div></figure><p id="73b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基于这些信息，我们构建我们特征的剩余部分，然后我们创建列联表来识别它们的频率。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="9733" class="mv kp it mr b gy mw mx l my mz">data full;<br/>  set full;<br/>   Child = 'Child';<br/>   if Age &gt;= 18 then Child = 'Adult';<br/>   Mother = 'Not Mother';<br/>   *<a class="ae lr" href="https://www.educba.com/sas-operators/" rel="noopener ugc nofollow" target="_blank">https://www.educba.com/sas-operators/</a>;<br/>   if Sex = 'female' and Parch &gt; 0 and Age &gt; 18 and Title_col ~= 'Miss' then Mother = 'Mother';<br/> run;<br/> <br/> data sub_full;<br/>  set full;<br/>  if cmiss(of Survived) =0;<br/> proc freq data = sub_full;<br/> title 'Contingency Table Child Var';<br/> tables Child*Survived / nopercent nocol norow;<br/> run;<br/> <br/> proc freq data = sub_full;<br/> title 'Contingency Table Mother Var';<br/> tables Mother*Survived / nopercent nocol norow;<br/> run;</span></pre><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/745e71c7f1d4ef59eafa0b6bac50781e.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*-1-Ghk5haehYPWphzgm-Gg.png"/></div></figure><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/c7a79a7af0c0edd90cc3211a45a5a587.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*wV0Ka9kGgwNdDywMNWWE6w.png"/></div></figure><p id="cf16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经完成了插补和特征工程，我们可以选择好的变量，并继续进行预测建模。另一个缺失值检查已经完成(输出没有显示)，这验证了我们可以进入下一阶段。</p><h1 id="3781" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">4预测</h1><h2 id="5bd5" class="mv kp it bd kq nn no dn ku np nq dp ky kb nr ns lc kf nt nu lg kj nv nw lk nx bi translated">4.1分成训练集和测试集</h2><p id="2991" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我们还选择没有太多缺失值的变量。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="960c" class="mv kp it mr b gy mw mx l my mz">Data Train;<br/>  set full;<br/>   if PassengerId &lt;= 891;<br/>   keep Survived Pclass Sex Age SibSp Parch Fare Embarked Title_col FsizeD Child Mother;<br/>  run;<br/> Data Test;<br/>  set full;<br/>   if PassengerId &gt; 891;<br/>   keep Pclass Sex Age SibSp Parch Fare Embarked Title_col FsizeD Child Mother;<br/>  run;</span></pre><h2 id="8aac" class="mv kp it bd kq nn no dn ku np nq dp ky kb nr ns lc kf nt nu lg kj nv nw lk nx bi translated">4.2建立模型</h2><p id="49b7" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">接下来，我们使用选择的变量拟合随机森林模型。为此，我们使用了PROC HPFOREST。最初，我们并不关注模型优化，而是仅仅拟合模型并获得特征重要性信息和基本训练误差信息。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="37a7" class="mv kp it mr b gy mw mx l my mz">proc hpforest data = Train maxtrees = 50 seed = 14561 trainfraction=0.85;<br/> input Pclass Sex Age SibSp Parch Fare Embarked Title_col FsizeD Child Mother;<br/> target Survived / level = BINARY;<br/> ods output FitStatistics = fit_at_runtime;<br/> ods output VariableImportance = Variable_Importance;<br/> ods output Baseline = Baseline;<br/>run;</span></pre><p id="3e99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们将错误和误分类错误可视化。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="fd2b" class="mv kp it mr b gy mw mx l my mz">title "The Average Square Error";<br/> proc sgplot data = fit_at_runtime;<br/>  series x=NTrees y=PredAll/legendlabel='Train Error';<br/>  series x=NTrees y=PredOOB/legendlabel='OOB Error';<br/>  xaxis values=(0 to 50 by 1);<br/>  yaxis values=(0 to 0.3 by 0.05) label='Average Square Error';<br/> run;</span></pre><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ok"><img src="../Images/ca79d87bfbc3213c65b1092270d807fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8fYrSOEECEy3ZMjm8b0iqQ.png"/></div></div></figure><p id="f9bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">出袋(OOB)误差，也称为出袋估计，是一种测量<a class="ae lr" href="https://en.wikipedia.org/wiki/Random_forest" rel="noopener ugc nofollow" target="_blank">随机森林</a>、<a class="ae lr" href="https://en.wikipedia.org/wiki/Gradient_boosting" rel="noopener ugc nofollow" target="_blank">增强决策树</a>和其他<a class="ae lr" href="https://en.wikipedia.org/wiki/Machine_learning" rel="noopener ugc nofollow" target="_blank">机器学习</a>模型预测误差的方法，利用<a class="ae lr" href="https://en.wikipedia.org/wiki/Bootstrap_aggregating" rel="noopener ugc nofollow" target="_blank"> bootstrap聚合</a> (bagging)对用于训练的数据样本进行子采样。OOB是每个训练样本<em class="ol"> xᵢ </em>的平均预测误差，仅使用在其引导样本中没有<em class="ol"> xᵢ </em>的树。(<a class="ae lr" href="https://en.wikipedia.org/wiki/Out-of-bag_error" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Out-of-bag_error</a>)</p><p id="350d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">分类准确率也很容易通过取值反过来变成误分类率或者错误率，比如:错误率= (1 —(正确预测/总预测))* 100。(<a class="ae lr" href="https://machinelearningmastery.com/confusion-matrix-machine-learning/" rel="noopener ugc nofollow" target="_blank">https://machine learning mastery . com/confusion-matrix-machine-learning/</a>)</p><h2 id="9dde" class="mv kp it bd kq nn no dn ku np nq dp ky kb nr ns lc kf nt nu lg kj nv nw lk nx bi translated">4.3可变重要性</h2><p id="f7dd" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">通常，训练随机森林模型的下一步涉及计算输入算法的每个特征的重要性。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="63ff" class="mv kp it mr b gy mw mx l my mz">title "Feature Importance Gini";<br/> proc sgplot data = Variable_Importance;<br/> vbar Variable /response=Gini  groupdisplay = cluster categoryorder=respdesc;<br/> run;</span></pre><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi om"><img src="../Images/9aeefd19ba17bf5f0e7972661044ce1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uJaH5szU3JvqxwVyDWAwzg.png"/></div></div></figure><p id="7d7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以进行两种类型的特征重要性计算，一种使用袋外(OOB)样本，另一种不使用它们。这里的度量或测量变量是“基尼”变量，当使用传统的“基尼”分数时，结果与教程中显示的结果相同。</p><h2 id="602d" class="mv kp it bd kq nn no dn ku np nq dp ky kb nr ns lc kf nt nu lg kj nv nw lk nx bi translated">4.4预测！</h2><p id="30cf" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">最后，我们使用一些基本的(2-3次手动运行)网格搜索来找到超参数，从而拟合出最终模型。然后我们保存模型，该模型可以应用于我们的测试集。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="a328" class="mv kp it mr b gy mw mx l my mz">proc hpforest data = Train maxtrees= 500 trainfraction=0.85<br/>     leafsize=1 alpha= 0.1 seed = 14561;<br/> input Pclass Sex Age SibSp Parch Fare Embarked Title_col FsizeD Child Mother;<br/> target Survived / level = BINARY;<br/> ods output FitStatistics = fit_at_runtime;<br/> save file = "/home/***/Titanic/output/model_fit.bin"; <br/> run;</span></pre><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi on"><img src="../Images/a73a5c5f56650e16b2ec8b06667f67b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fxhMRC6l6VnknjMS6sWnoA.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Training Statistics on the Final Model</figcaption></figure><p id="d139" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来的步骤包括将最终模型应用于我们的测试集，然后清理数据，最后将其导出到“CSV”文件中，这样我们就可以提交Kaggle了。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="b705" class="mv kp it mr b gy mw mx l my mz">proc hp4score data=Test; <br/> score file= "/home/***/Titanic/output/model_fit.bin"<br/> out=Predictions;<br/> run;<br/> <br/> data submission;<br/>  merge submission Predictions;<br/> run;</span><span id="73c4" class="mv kp it mr b gy na mx l my mz">data submission;<br/>  set submission;<br/>   Survived = I_Survived;<br/>   keep PassengerId Survived;<br/> run;</span><span id="c0ba" class="mv kp it mr b gy na mx l my mz">proc export data=submission<br/>    outfile='/home/***/Titanic/output/submission.csv'<br/>    dbms=csv<br/>    replace;<br/> run;</span></pre><h1 id="a7e6" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">结果</h1><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oo"><img src="../Images/b85356c7a61ad44843ef6dbd8697be83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CDfxQQrcgpS8l2zkyTED2Q.png"/></div></div></figure><h1 id="ef9c" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">参考</h1><div class="ls lt gp gr lu lv"><a href="https://documentation.sas.com/?docsetId=basess&amp;docsetTarget=n053a58fwk57v7n14h8x7y7u34y4.htm&amp;docsetVersion=9.4&amp;locale=en" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd iu gy z fp ma fr fs mb fu fw is bi translated">数据步骤如何工作:基本介绍</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">数据步骤如何工作:一个基本介绍::一步一步的基础SAS 9.4编程，第二版数据…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">documentation.sas.com</p></div></div><div class="me l"><div class="op l mg mh mi me mj mk lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://documentation.sas.com/?docsetId=lrcon&amp;docsetTarget=n0k19ydenc62jtn14mpv4fhzjmyg.htm&amp;docsetVersion=9.4&amp;locale=en" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd iu gy z fp ma fr fs mb fu fw is bi translated">过程步骤</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">过程步骤::SAS 9.4语言参考:概念，第六版由一组调用和执行…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">documentation.sas.com</p></div></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://github.com/siddharthapachhai/SAS_ml_0" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd iu gy z fp ma fr fs mb fu fw is bi translated">siddharthapachhai/SAS_ml_0</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">在GitHub上创建一个帐户，为siddharthapachhai/SAS_ml_0开发做贡献。</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">github.com</p></div></div><div class="me l"><div class="oq l mg mh mi me mj mk lv"/></div></div></a></div><figure class="mm mn mo mp gt nc"><div class="bz fp l di"><div class="or os l"/></div></figure></div></div>    
</body>
</html>