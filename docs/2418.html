<html>
<head>
<title>Getting Started with Kubernetes | Deep Dive into Kubernetes Core Concepts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes入门|深入了解Kubernetes的核心概念</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/getting-started-with-kubernetes-deep-dive-into-kubernetes-core-concepts-eb0518935508?source=collection_archive---------9-----------------------#2020-04-29">https://medium.datadriveninvestor.com/getting-started-with-kubernetes-deep-dive-into-kubernetes-core-concepts-eb0518935508?source=collection_archive---------9-----------------------#2020-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f305" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">阿里巴巴高级技术专家、CNCF TCO李想</em></p><h1 id="9507" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">什么是Kubernetes？</h1><p id="44c4" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated"><a class="ae lp" href="https://www.alibabacloud.com/product/kubernetes?spm=a2c41.14458578.0.0" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>是一个工业级容器编排平台。Kubernetes这个名字来源于希腊语，意思是舵手或领航员。“K8s(或某些文章中的“ks”)，是通过将八个字母“ubernete”替换为“8”而得到的缩写。“如果你想知道为什么选择Kubernetes这个名字，意思是“舵手”，那么让我们看看下图。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/48b601729a176847eff7239caa761ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/0*RYT1qkRhc5mARzUw.png"/></div></figure><p id="58ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一艘载有一堆集装箱的船。这艘船正驶向大海，将集装箱运往目的地。在英语中，这个词也意味着包装要运输的货物的“容器”。因此，顾名思义，Kubernetes希望成为一艘运输集装箱的船。换句话说，它打算帮助管理这些容器。因此，用“Kubernetes”这个词来代表这个项目。更具体地说，Kubernetes是一个自动化容器编排平台，它负责部署、弹性伸缩和管理基于容器的应用程序。</p><h1 id="2a45" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">Kubernetes的核心特征</h1><p id="5de5" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">服务发现和负载平衡</p><ul class=""><li id="11e5" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated">自动集装箱装箱:这个特性也被称为“调度”通过将容器放在集群中的一个节点上，Kubernetes帮助协调存储系统，以便将存储的声明期与容器的生命周期联系起来。</li><li id="e444" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">自我修复:Kubernetes有助于自动恢复失败的容器。在集群中，主机或操作系统问题可能会导致容器停止服务。如果是这种情况，Kubernetes会自动恢复这些容器。</li><li id="5ce2" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">自动推出和回滚:Kubernetes有助于自动推出和回滚应用程序，并管理应用程序相关的配置密文。</li><li id="ce6d" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">批处理执行:Kubernetes允许批量运行作业。</li><li id="5b9d" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">水平伸缩:为了使集群和应用程序更加灵活，Kubernetes还支持水平伸缩。</li></ul><p id="3c18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面几节使用三个例子详细描述了Kubernetes的主要功能。</p><h1 id="f6cc" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">1)日程安排</h1><p id="4739" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在Kubernetes中，用户提交的容器被部署到由Kubernetes管理的集群中的一个节点上。Kubernetes中的调度器就是实现这一功能的组件。它监控被调度的集装箱的尺寸和规格。例如，调度程序估计所需的CPU和内存容量，然后将容器放在集群中相对空闲的节点上。在这个例子中，调度器可以将红色容器放置在第二空闲节点上以完成调度任务。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/8237d13212b12f00053e92c576fac2f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*UtXNI7oXuq2SxXvr.png"/></div></figure><h1 id="cf5b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">2)自动恢复</h1><p id="5c1a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">Kubernetes提供节点健康检查。此功能允许系统监视群集中的所有主机。当主机或软件出现问题时，Kubernetes会自动检测故障，并自动将故障节点上运行的容器迁移到健康的主机上，以自动恢复集群中的容器。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/c4ec68684a24216420567da532591fb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/0*ClvOZpNJaiBMLix-.png"/></div></figure><h1 id="606a" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">3)水平缩放</h1><p id="c9aa" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">Kubernetes能够通过监控检查服务负载。如果服务的CPU使用率过高，或者对服务的响应过慢，Kubernetes会相应地扩展特定的服务。在下面的例子中，第一个黄色节点非常繁忙，因此，Kubernetes将黄色节点的负载分布到三个部分。然后，通过负载均衡，Kubernetes将第一个黄色节点上的原始负载平均分配给三个黄色节点，包括第一个黄色节点本身，以提高响应速度。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/05d6b1e4200efaae9721c3436245755a.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/0*-ceLaldrl1tG1ZfI.png"/></div></figure><h1 id="b471" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">库伯内特建筑</h1><p id="1b69" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">Kubernetes架构是一个典型的两层服务器-客户端架构。作为中央控制节点，主节点连接到多个节点。所有UI客户端和用户端组件都连接到主设备，以向主设备发送所需的状态或要执行的命令。然后，主设备将这些命令或状态发送到相应的节点进行最终执行。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/76bc47c41f6eee741a8c7da87f92afcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/0*Dho7Z3aBHBKUZVzV.png"/></div></figure><p id="19ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Kubernetes中，主机运行四个关键组件，包括API服务器、控制器、调度程序和etcd。下图显示了详细的Kubernetes架构。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/d1af7aafffc86354731e34cbd8e81f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/0*doA1X7E5KZkTRXyG.png"/></div></figure><ul class=""><li id="d885" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated">API服务器:顾名思义，API服务器处理API操作。Kubernetes中的所有其他组件都连接到API服务器。一般来说，这些组件不是单独相互连接的。然而，它们依赖于API服务器来相互传输消息。</li><li id="34ea" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">控制器:Kubernetes附带的控制器监视和管理集群状态。例如，在前面的例子中，容器的自动恢复和自动水平缩放都是由Kubernetes中的控制器完成的。</li><li id="99f5" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">调度程序:顾名思义，调度程序执行调度。如第一个示例中所述，调度器根据请求的CPU和内存容量，将用户提交的容器放置在适当的节点上。</li><li id="01f9" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">etcd:它是一个分布式存储系统，API服务器所需的所有原始信息都存储在etcd中。作为一个高可用性系统，etcd负责确保Kubernetes中主服务器的所有组件都具有高可用性。</li></ul><p id="2b77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">API服务器是一个部署组件，它允许在部署结构方面进行水平扩展。此外，控制器代表实现热备份的部署组件。只有一个控制器是活动的，并有相应的调度程序。尽管如此，仍然可以实现热备份。</p><div class="mq mr gp gr ms mt"><a href="https://www.datadriveninvestor.com/2020/03/11/cloud-made-simple-for-undecided-career-change-planners-the-fundamentals/" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">云让犹豫不决的职业生涯规划者变得简单:基础|数据驱动的投资者</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">尽管IT在当今的商业中扮演着重要的角色，但许多IT求职者都不愿意从事云计算职业…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh lw mt"/></div></div></a></div><h1 id="887d" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">Kubernetes架构—节点</h1><p id="b2e8" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在Kubernetes中，服务负载实际上是由节点承载的，每个服务负载作为一个pod运行。稍后将介绍pod的概念。此外，一个或多个容器正在pod中运行。实际运行这些pod的组件被称为kubelet，这也是节点上最关键的组件。它从API服务器接收所需pod的运行状态，并将运行状态提交给容器运行时组件，如下图所示。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/ce4e7e85aedc6b72e4fe8bd65f0fe8d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/0*MmmrQNiZQ6X-YfFv.png"/></div></figure><p id="0aa6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">管理存储和网络对于在操作系统上为容器创建运行环境并最终运行容器或pod至关重要。Kubernetes不直接执行任何存储或网络操作，而是依靠存储插件或网络插件来完成这些操作。通常情况下，用户或云厂商会开发相应的存储插件或网络插件来执行实际的存储或网络操作。</p><p id="e3ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes还包括一个Kubernetes网络，为联网提供服务网络。服务的概念后面会介绍。真正完成服务联网的组件是kube-proxy。它利用iptables在Kubernetes中建立了一个集群网络。到目前为止，您已经了解了节点上的所有四个组件。在Kubernetes中，节点不直接与用户交互，而是依赖于主节点。用户通过主节点向节点传递消息。在Kubernetes中，每个节点都运行前面的四个组件。</p><p id="469e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的例子展示了这些组件在Kubernetes架构中是如何相互作用的。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/bda603dd370061a230f218375dabfb21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/0*ozk0ANHoGrmFe2e3.png"/></div></figure><p id="158a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用户可以通过UI或CLI向Kubernetes提交pod部署请求。这个请求首先通过CLI或UI提交给Kubernetes中的API服务器。然后，API服务器将请求信息写入etcd存储。最后，调度程序通过API服务器的监视或通知机制来获取这些信息。该信息表明需要对pod进行调度。</p><p id="6ae4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，调度器基于其存储器状态做出调度决定。完成调度后，它向API服务器报告“OK！这个pod需要调度到某个节点。”</p><p id="e56c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">收到这个报告后，API服务器将调度结果写入etcd。然后，API服务器通知相应的节点启动pod。在收到这个通知后，相应节点上的kubelet与容器运行时进行通信，以实际开始配置容器和容器的运行环境。此外，kubelet分别安排存储插件配置存储，安排网络插件配置网络。此示例显示了这些组件如何相互通信并协同工作来完成pod的调度。</p><h1 id="6baf" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">Kubernetes的核心概念和API</h1><h1 id="9f91" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">核心概念</h1><h2 id="f80b" class="nk kn iq bd ko nl nm dn ks nn no dp kw jy np nq la kc nr ns le kg nt nu li nv bi translated">概念1) Pod</h2><p id="2d84" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">pod是Kubernetes中最小的调度和资源单位。用户通过Kubernetes的pod API创建一个Pod，以便Kubernetes安排Pod。具体来说，pod放在Kubernetes管理的节点上运行。简而言之，pod是一组容器的抽象，包含一个或多个容器。</p><p id="2426" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如下图所示，pod包含两个容器，每个容器指定其所需的资源大小，例如1 GB内存和1个CPU核心，或者0.5 GB内存和0.5个CPU核心。</p><p id="5b04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此pod还包含其他必需的资源，例如称为卷的存储资源，或者100 GB或20 GB内存。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/da2e200930d95d201108e7d5efa52fb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/0*QLZ9ny75fUm8bjqa.png"/></div></figure><p id="4875" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在pod中，定义运行容器的方式，例如运行容器的命令或环境变量。pod还为其中的容器提供了一个共享的运行环境。在这种情况下，这些容器共享一个网络环境，并通过本地主机直接找到彼此。此外，豆荚是相互隔离的。</p><h2 id="9224" class="nk kn iq bd ko nl nm dn ks nn no dp kw jy np nq la kc nr ns le kg nt nu li nv bi translated">概念2)体积</h2><p id="fa12" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在Kubernetes中，卷用于管理存储和声明由pod中的容器访问的文件目录。可以将卷装载到pod中一个或多个容器的指定路径。</p><p id="9dbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">体积本身是一个抽象概念。一个卷支持多种类型的后端存储。例如，Kubernetes中的卷支持许多存储插件。支持本地存储，支持Ceph、GlusterFS等分布式存储，支持阿里云、AWS、Google中的磁盘等云存储。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="ny nz di oa bf ob"><div class="gh gi nx"><img src="../Images/12ba8f3e5880b54b2cc78c035d8aefdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/0*493Vb9A4cmyPljQL.png"/></div></div></figure><h2 id="7291" class="nk kn iq bd ko nl nm dn ks nn no dp kw jy np nq la kc nr ns le kg nt nu li nv bi translated">概念3)部署</h2><p id="061e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">部署是pod之上的抽象，定义了一组pod和pod版本的副本数量。通常，这种抽象用于实际管理应用程序，而pod是构成部署的最小单元。在Kubernetes中，控制器维护部署中的pod数量，并帮助部署自动恢复失败的pod。例如，定义一个包含两个单元的部署。如果一个pod发生故障，相应的控制器会检测到该故障，并通过创建pod将部署中的pod数量从一个恢复到两个。Kubernetes中的控制器还允许我们实现已发布的策略，例如滚动升级、再生升级或版本回滚。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/011438418fc0833f22bc456544f25237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/0*7nSIc1QgJ8CE351J.png"/></div></figure><h2 id="2e66" class="nk kn iq bd ko nl nm dn ks nn no dp kw jy np nq la kc nr ns le kg nt nu li nv bi translated">概念4)服务</h2><p id="a7d5" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">服务为一个或多个pod实例提供静态IP地址。在前面的示例中，一个部署可以包括两个或更多相同的pod。对于外部用户来说，访问任何pod都是一样的，因此负载平衡是首选。为了实现负载平衡，用户希望访问静态虚拟IP (VIP)地址，而不是知道所有pod的具体IP地址。如前所述，pod可能处于终端运行(终止)状态。如果是这种情况，它可能会被一个新的吊舱所取代。</p><p id="9cf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于外部用户，如果提供了多个pod的特定IP地址，则该用户需要不断更新pod的IP地址。如果一个pod发生故障，然后重新启动，抽象可以将对所有pod的访问抽象到第三方IP地址中。在Kubernetes中实现这个特性的抽象称为服务。Kubernetes支持服务的多种入口模式，包括ClusterIP、NodePort和LoadBalancer模式。它还支持使用kube-proxy通过网络进行访问。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/f87ba8d242e384befa65f45e11044fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/0*ZUOhZ8xyZt-vkKaH.png"/></div></figure><h2 id="a141" class="nk kn iq bd ko nl nm dn ks nn no dp kw jy np nq la kc nr ns le kg nt nu li nv bi translated">概念5)名称空间</h2><p id="97d2" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">命名空间用于在集群中实现逻辑隔离，这涉及到身份验证和资源管理。Kubernetes中的每个资源，比如pod、部署和服务，都属于一个名称空间。资源名称在一个命名空间中必须是唯一的，但在不同的命名空间中可以是相同的。下面描述了名称空间的一个用例。在阿里巴巴，有很多业务部门(BUs)。为了在视图级别隔离每个业务部门，并使它们在身份验证和计算统一设备架构(CUDA)中有所不同，我们将使用名称空间为每个业务部门提供这样一种可视化隔离机制。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi od"><img src="../Images/82021563f68172a95e50e36083f958fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/0*CNBGrOzTSLvJGdlZ.png"/></div></figure><h1 id="e2e6" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">Kubernetes API</h1><p id="950e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">下图描述了Kubernetes API的基础。从高层的角度来看，Kubernetes API是基于HTTP和JSON的。具体来说，用户通过HTTP访问API，被访问API的内容是JSON格式的。在Kubernetes中，kubectl命令行工具，Kubernetes UI，或者有时curl，用于基于HTTP和JSON直接与Kubernetes通信。在以下示例中，pod的HTTP访问路径由以下部分组成:API、API版本:V1、命名空间、pod和pod名称。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/5b14a2d91ebecab5845953f9d844fc8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/0*4JUWRoGw100i2ejP.png"/></div></figure><p id="ba69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，如果我们提交一个pod或获得一个pod，pod的内容以JSON或YAML格式表示。上图显示了一个YAML文件示例。在这个YAML文件中，pod的描述由几个部分组成。</p><p id="7893" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一般第一部分是API版本。在本例中，API版本是V1。第二部分是正在开发的资源。例如，如果资源的种类是一个pod，那么这个pod的名称就写在元数据中。如果资源的种类是Nginx，我们会给它添加一些标签。标签的概念将在后面描述。在元数据中，有时我们也编写注释，从用户的角度额外描述资源。</p><p id="9211" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个重要的部分是spec，它表示pod的期望状态。例如，规范显示了需要在pod中运行的容器、包含在pod中的Nginx容器的图像以及公开端口的ID。</p><p id="c345" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们通过Kubernetes API获得这个资源时，规范通常会附带一个名为status的项目，它指示这个资源的当前状态。例如，pod可能处于计划、运行或终止状态。终止状态意味着pod已被执行。</p><p id="8422" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在描述API的时候，我们提到了一个有趣的元数据元素，叫做“标签”。标签可以是一组键值对。例如，对于下图中的第一个窗格，标签可能是红色，这表示该窗格是红色的。也可以添加其他标签，比如size big，表示尺寸定义为大。此外，还可以添加一组标签。这些标签由选择器查询。事实上，这种能力与SQL select语句非常相似。例如，您可以从下图所示的三个窗格中进行选择。当颜色命名为红色时，意味着一个pod的颜色是红色，请注意，只选择了两个pod，因为只有它们的标签指示红色。另一个pod的标签上写着颜色是黄色的，说明这个pod是黄色的，因此没有被选中。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi of"><img src="../Images/9bb10187d534e98790f63f14a3545634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/0*H9EGOnp7VH3OuElL.png"/></div></figure><p id="a419" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">标签允许Kubernetes API过滤这些资源。过滤也是Kubernetes中指示资源集合的默认方式。</p><p id="5682" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，一个部署可能代表一组pod，或者是一组pod的抽象。这组窗格通过使用标签选择器来指示。如前所述，一个服务对应于一个或多个pod，以便以集中的方式访问它们。在此描述中，标签选择器也选择了一组窗格。</p><p id="3ecc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，标签是Kubernetes API的核心概念。在后续教程中，我们将深入研究标签的概念以及如何充分利用标签。</p><h1 id="9196" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">示范</h1><p id="a4ae" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">最后，让我们尝试一个Kubernetes集群演示。在此之前，通过执行以下步骤，确保在本地安装一个Kubernetes集群和一个Kubernetes沙盒环境:</p><ul class=""><li id="deba" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated">步骤1:安装一个虚拟机，以便在虚拟机中启用Kubernetes。我们建议使用VirtualBox作为虚拟机的运行环境。</li></ul><p id="8b02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在安装之前，从https://www.virtualbox.org/wiki/Downloads下载VirtualBox</p><ul class=""><li id="b2f6" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated">第二步:在虚拟机中启动Kubernetes。Kubernetes包括一个名为minikube的有趣工具。这是启动一个最小的本地Kubernetes集群的环境。我们推荐使用<a class="ae lp" href="https://yq.aliyun.com/articles/221687?spm=a2c41.14458578.0.0" rel="noopener ugc nofollow" target="_blank">阿里云版本的minikube </a>。这个minikube版本和官方minikube版本的主要区别在于，后者所需的谷歌特定依赖项被替换为在中国更容易访问的图像。这有利于安装。</li><li id="b9e9" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">第三步:安装VirtualBox和minikube后，运行<code class="fe og oh oi oj b">minikube start —vm-driver virtualbox</code>启动命令启动minikube。</li></ul><p id="9aca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注:如果您的计算机没有运行在Mac系统上，请访问下面的this <a class="ae lp" href="https://kubernetes.io/docs/tasks/tools/install-minikube/?spm=a2c41.14458578.0.0" rel="noopener ugc nofollow" target="_blank">链接</a>了解如何在其他操作系统上安装minikube沙盒环境。</p><p id="b6c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成安装后，实现如下用例。</p><p id="e263" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1)提交Nginx部署:<code class="fe og oh oi oj b">kubectl apply -f https://k8s.io/examples/application/deployment.yaml</code> <br/> 2)更新Nginx部署:<code class="fe og oh oi oj b">kubectl apply -f https://k8s.io/examples/application/deployment-update.yaml</code> <br/> 3)扩展Nginx部署:<code class="fe og oh oi oj b">kubectl apply -f <a class="ae lp" href="https://k8s.io/examples/application/deployment-update.yaml" rel="noopener ugc nofollow" target="_blank">https://k8s.io/examples/application/deployment-update.yaml</a></code></p><p id="147f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说，首先提交一个Nginx部署，然后升级这个部署的版本，以更改其pod的版本。最后，横向扩展Nginx部署。现在让我们进行三个操作。首先，检查minikube的状态。输出显示kubelet主机和kubectl都已正确配置。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/85293f1bfa68a63140890df349b350c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/0*r10dxmizt5D_iMHs.png"/></div></figure><p id="1e92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，通过kubectl检查这个集群中节点的状态。输出显示主服务器正在运行。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/9ff6a7e303c9565601e857a4118983b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/0*BLvV9P_DHwWOd985.png"/></div></figure><p id="3224" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们基于主服务器检查集群中的部署。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi om"><img src="../Images/fc0a1598b36ac9c989b9666b24b31c0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/0*rmfqvWiA19xU-Mts.png"/></div></figure><p id="06cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出显示该集群不包括任何部署。使用观察语义查看集群中部署的更改。现在，它准备执行前面的三个操作。首先，创建一个部署。下面的第一张图显示了API的内容。具体来说，种类是部署，名称是nginx-deployment。如第二张图所示，副本数量为2，镜像版本为1.7.9。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi on"><img src="../Images/8b1d51da64d25872ce6ff724a7c60bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/0*ec0JUhAM09qLc22G.png"/></div></figure><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi on"><img src="../Images/dc13409b3a306c729b9bb5a9e463b174.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/0*zHLBDtnz5qyRYxb4.png"/></div></figure><p id="7e5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，运行kubectl命令来创建部署。请注意，一个简单的操作使部署能够不断生成副本。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/8d3ac8cbb89de268dcc652bf69877546.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/0*GcPu93S66rtK62vL.png"/></div></figure><p id="525a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">副本的数量是2。以前不存在名为nginx-deployment的部署。现在让我们描述一下这个部署的当前状态。</p><p id="4870" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下图中，注意已经生成了一个名为nginx-deployment的部署。副本数量如所愿，选择器符合要求，镜像版本也是1.7.9。此外，观察名为deployment-controller的控制器正在管理生成。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi op"><img src="../Images/7a72655450e716f7b89a68aed16bde6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/0*qiITG53Lg4BTKmTV.png"/></div></figure><p id="8610" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们更新这个部署的版本。首先，下载另一个名为<code class="fe og oh oi oj b">deployment-update.yaml.</code>的YAML文件。另外，请注意，该文件中的镜像版本从1.7.9更新到了1.8。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/bcb72413689173d8aa880628e1c39300.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/0*6fopE_d0qGbtlB-b.png"/></div></figure><p id="42a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后应用新的<code class="fe og oh oi oj b">deployment-update.yaml file.</code>这个部署更新的一些操作出现在另一边的屏幕上，最新值从0变为2。这表明所有容器和单元都是最新的。运行describe命令检查是否所有pod的版本都已更新。输出显示映像版本已从1.7.9更新到1.8。</p><p id="eded" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，请注意，控制器随后会执行几个新的操作来维护部署和pod的状态。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi or"><img src="../Images/dcde06cc2e1915494f1f9f307a61f549.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/0*KwnQR9X-7zFKTdqZ.png"/></div></figure><p id="e213" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们通过下载另一个<code class="fe og oh oi oj b">deployment-scale.yaml file.</code>来横向扩展部署。该文件显示副本的数量已从2个更改为4个。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi os"><img src="../Images/2c188b2ce63159563509e0bd97e00dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*kNxhwm05Ok5xR7e2.png"/></div></figure><p id="c816" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">返回初始窗口，使用kubectl在另一个窗口中应用新的<code class="fe og oh oi oj b">deployment-scale.yaml file.</code>，注意在应用<code class="fe og oh oi oj b">deployment-scale.yaml</code>文件后，pod的数量从2变为4。再次描述当前集群中的部署。输出显示副本的数量从2个增加到了4个，控制器执行了几个新的操作。这表明扩大规模已经完成。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/22a032dd82563b067b323c30f12843ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/0*zzvk5HTSq4LGVhWZ.png"/></div></figure><p id="8519" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们执行删除操作来删除生成的部署。如下图所示，kubectl delete deployment也是原始部署的名称。删除后，所有需要的操作都完成了。因此，此部署不再存在，群集返回到其原始的干净状态。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/d7436bf643dfb2b45570542c5711e3a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/0*9nmb1Z-PmYuJQ1G4.png"/></div></figure><h1 id="cd7d" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论</h1><p id="85be" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">本文重点介绍Kubernetes的核心概念和建筑设计，主要包括以下几点:</p><ul class=""><li id="7fbc" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated">Kubernetes是一个自动化容器编排平台。它负责部署、弹性伸缩和管理基于容器的应用程序。</li><li id="c370" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">Kubernetes架构是一个典型的两层服务器-客户端架构。</li></ul><h1 id="88b3" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">原始来源:</h1><div class="mq mr gp gr ms mt"><a href="https://www.alibabacloud.com/blog/getting-started-with-kubernetes-%7C-deep-dive-into-kubernetes-core-concepts_595896?spm=a2c41.14458578.0.0" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">Kubernetes入门|深入了解Kubernetes的核心概念</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">阿里巴巴开发者2020年2月26日417由阿里巴巴高级技术专家、CNCF Kubernetes TCO is…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">www.alibabacloud.com</p></div></div><div class="nc l"><div class="ov l ne nf ng nc nh lw mt"/></div></div></a></div><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="ow ox l"/></div></figure></div></div>    
</body>
</html>