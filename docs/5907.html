<html>
<head>
<title>Using RegEx to extract expenses information from a text file</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用正则表达式从文本文件中提取费用信息</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/using-regex-to-extract-expenses-information-from-a-text-file-e1ac9a8452a5?source=collection_archive---------0-----------------------#2020-10-05">https://medium.datadriveninvestor.com/using-regex-to-extract-expenses-information-from-a-text-file-e1ac9a8452a5?source=collection_archive---------0-----------------------#2020-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9fb450b9f132bb3a7143c6c7681e199a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lz1-LmnqMKkU94KN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://www.pexels.com/photo/abstract-black-and-white-blur-book-261763/" rel="noopener ugc nofollow" target="_blank">(source)</a></figcaption></figure><p id="92c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正则表达式(ReGex)模式看起来毫无意义，但是它们是从文本中提取信息的强大工具。一堆看似随意的标点符号加上许多括号和几个字母，实际上可以找到你要找的信息。</p><p id="c986" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，本着实践的精神，我写这篇文章向您展示如何从文本文件中提取费用的成本和名称。这可能不是最简单的例子，但是我们将讨论一些不同的正则表达式特性来找到解决方案。我还假设您已经对正则表达式有所了解。</p><p id="027d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这个演示，我们将使用Python和它的ReGex专用库re来加载一个. txt文件，并查找所有费用的名称和成本。</p><p id="d584" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">示例文本是一个简单的费用列表，格式如下:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="795a" class="lk ll iq lg b gy lm ln l lo lp">cost - expense<br/>cost - expense<br/>cost - expense<br/>cost - expense<br/>cost - expense<br/>Total: total_cost</span></pre><p id="9775" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一个真实的例子:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="58cf" class="lk ll iq lg b gy lm ln l lo lp">0.70 - Coffee<br/>0.75 - Cake slice<br/>12 - Lunch<br/>15 - Lunch<br/>Total: 28.45</span></pre><p id="0242" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，我们提取了四项费用，并忽略了总额(无论如何，以后很容易计算)。</p><p id="0b56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们将一次一个地检查模式的各个部分，并在最后将它们集合在一起，形成用Python实现的完整的正则表达式模式。</p><h1 id="1777" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">获取整数值</h1><p id="2053" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">如示例所示，expenses的成本可以是一个整数(两份午餐)，也可以是一个浮点数(咖啡和蛋糕)。下面的模式足以匹配整数成本。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/4f9c6eaf142a5a3c7e430f3f10f2dcc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/format:webp/1*-a2hBIRHupJMiUvnUtwO9g.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Pattern to extract integer costs</figcaption></figure><p id="670a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(请注意，垂直的红色虚线只是图案不同部分的视觉辅助)</p><p id="f7a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">脱字符号(<code class="fe mt mu mv lg b">^</code>)表示一行的开始，也就是说，我们匹配的任何文本都必须在一行的开始。方括号中的<code class="fe mt mu mv lg b">\d</code>表示我们正在匹配数字(0-9),<code class="fe mt mu mv lg b">+</code>用于匹配一个或多个数字。如果没有加号，那么它只会匹配第一顿午餐的1，而不是正确的12。</p><p id="5f9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的截图显示了使用<code class="fe mt mu mv lg b">+</code>量词的(非)结果。该模式在regex101.com<a class="ae kc" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank">网站</a>进行测试。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/e3f74688d90cab030df06c7520973493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*94xHrsbGzW0ZHEZJkjadjg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Integer pattern without quantifier test</figcaption></figure><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/8d3713f05c8fc55bf438c2292854925b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*hhVsU4aw82KyOxRA3IzEJg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Integer pattern with quantifier test</figcaption></figure><p id="c4f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于方括号和圆括号，前者用于将加号的“匹配一个或多个数字”规则应用于数字。后者用于创建适当的正则表达式组。简单地说，每场比赛都可以单独引用组。我们将在最后的Python脚本中回到这个主题。</p><h1 id="75bb" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">改善成本模式</h1><p id="bce2" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">前面的模式适用于整数成本。然而，也有浮点成本。我们需要扩展模式以适应这两种选择。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/57c4111d8810a51658d4ea2162efa3e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*BNvRk4AukgB4uOjBF5YuEw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Complete cost pattern</figcaption></figure><p id="d055" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以复制之前的模式，因为我们仍然在匹配数字序列。我们把它放在第二个模式的开头，但是现在我们只匹配小数点前的数字。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/8d3713f05c8fc55bf438c2292854925b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*hhVsU4aw82KyOxRA3IzEJg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Integer pattern results</figcaption></figure><p id="287d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">整数是一个或多个数字的序列。另一方面，浮点数有两个这样的序列，用小数点(<code class="fe mt mu mv lg b">.</code>)隔开。因此，我们可以重复整数匹配组<code class="fe mt mu mv lg b">[\d]+</code>，来匹配浮点数整数和小数部分。我们只需要在中间添加一个组来匹配小数点。</p><p id="2f0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们使用<code class="fe mt mu mv lg b">[\.]?</code>。方括号中的内容将被逐字匹配，但是由于句点在正则表达式中有特殊的含义，我们需要通过在它前面加上反斜杠<code class="fe mt mu mv lg b">\</code>来对其进行转义。这样，我们指定要匹配数字序列之间的实际周期。否则，将使用句点来匹配它找到的任何字符。</p><div class="mz na gp gr nb nc"><a href="https://www.datadriveninvestor.com/2020/07/23/learn-data-science-in-a-flash/" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">一瞬间学会数据科学！？数据驱动的投资者</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">在我之前的职业生涯中，我是一名训练有素的古典钢琴家。还记得那些声称你可以…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq jw nc"/></div></div></a></div><p id="fda9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我们还将第二个数字序列中的量词从<code class="fe mt mu mv lg b">+</code>改为<code class="fe mt mu mv lg b">*</code>(星号)，因为我们需要使用“匹配零个或多个数字”规则来代替。如果其中一份午餐的价格低于10英镑，那么我们就无法用两个“匹配一个或多个数字”(一个在小数点之前，另一个在小数点之后)来匹配这个一位数的整数。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/1a69bacc9a576613127e69210756bd6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*dsxhlLgD39rDqh8eHOfgwA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Complete cost pattern test</figcaption></figure><p id="6ee3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在所有成本都匹配成功了。颜色让我们很难理解每笔费用的总成本是匹配的，但是当我们在Python中实现它时，我们会看到我们实际上匹配了总成本。因为我们用括号将模式的各个部分分组，所以我们匹配了整个成本，同时还可以访问匹配的各个组。</p><h1 id="6ebc" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">获取费用名称</h1><p id="86c9" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">随着成本的完成，困难的部分已经过去。现在我们只需要匹配匹配行中的其余内容，即分隔成本和名称的连字符，以及名称。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/66be79a3c1469a5b0ef6204afc4a8691.png" data-original-src="https://miro.medium.com/v2/resize:fit:262/format:webp/1*dFIIlhUuDYaMZewysdnbUw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Pattern for extracting the expense name</figcaption></figure><p id="7384" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">提醒我们自己，一项支出看起来像这样</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6eb9" class="lk ll iq lg b gy lm ln l lo lp">0.70 - Coffee</span></pre><p id="b3dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也就是说，费用后面跟一个空格，然后是连字符，然后是另一个空格，最后是费用名称，费用名称是一个字符序列(字母、数字、空格等。).</p><p id="05be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以为这个模式创建两个简单的组:一个组匹配连字符及其周围的空格，另一个组匹配名称。由于名称可以有各种类型的字符，这次我们使用句点的功能，即匹配任何字符。同样，星号匹配序列中的零个或多个字符。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/8f185934dec782652df9f1e51d6a8f2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*NMSHdmNRakG7_vmk1q08Wg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Name pattern test</figcaption></figure><p id="60b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">连字符及其周围的空格本身都不是费用的一部分，但它们是匹配费用的重要文本引用。</p><h1 id="a476" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">把所有的东西放在一起</h1><p id="60d4" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">现在我们已经完成了模式的每个部分，您可以看到最终的模式和实现它的Python脚本了。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/d04fdaad0e73b18b53864b21348d81de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*7rKaNR35MbgR2Qm5VB52jQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Complete ReGex pattern</figcaption></figure><p id="9eff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(请注意，绿色下划线仅用于在视觉上区分成本和名称模式)</p><p id="f6bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里没有什么新的东西，只是你以前见过的相同的模式，这次是一个单一的模式。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/1746d9a02c45dc108c5c2f83b213651e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*zQ6my86X5rxHgtHWxw3EEA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Final pattern test</figcaption></figure><p id="96b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在是Python代码！</p><p id="2378" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先是示例文本。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="bfa3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在是剧本！</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="95d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个脚本中，我们从一个. txt文件中加载文本，通过匹配ReGex模式提取费用，并将数据存储在一个导出为CSV的pandas DataFrame中。</p><p id="9646" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些函数很简单，但是让我们回顾一下。</p><ul class=""><li id="70d2" class="nx ny iq kf b kg kh kk kl ko nz ks oa kw ob la oc od oe of bi translated">从文件中获取整个文本，作为一个字符串列表(每行一个字符串)</li><li id="2b7f" class="nx ny iq kf b kg og kk oh ko oi ks oj kw ok la oc od oe of bi translated"><code class="fe mt mu mv lg b">"".join(expenses_text)</code>从不同的行中创建一个单独的字符串(字符串包含换行符，所以我们仍然知道每一行的开始和结束)</li><li id="a7d2" class="nx ny iq kf b kg og kk oh ko oi ks oj kw ok la oc od oe of bi translated"><code class="fe mt mu mv lg b">re.findall</code>使用我们创建的模式匹配费用。<code class="fe mt mu mv lg b">re.MULTILINE</code>确保我们获得每一场比赛，而不仅仅是第一场</li><li id="e58b" class="nx ny iq kf b kg og kk oh ko oi ks oj kw ok la oc od oe of bi translated"><code class="fe mt mu mv lg b">[[m[5], m[0]] for m in matches]</code>创建一个列表列表，其中内部列表包含费用的名称和成本</li><li id="f89b" class="nx ny iq kf b kg og kk oh ko oi ks oj kw ok la oc od oe of bi translated">pandas部分使用该列表创建一个新的数据帧，从1开始添加一个索引列，并将其导出为一个新的CSV文件</li></ul><p id="dda7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，关于正则表达式组。如果我们打印由<code class="fe mt mu mv lg b">re.findall</code>返回的单个匹配</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/820cb1805a667c56566312c6a3fa8930.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*di2yDaEy9K9gENVsLWdeHA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">re.findall results</figcaption></figure><p id="0c52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们发现该函数为每个匹配返回一个元组。每个元组元素代表一组模式。换句话说，对于每笔费用，我们都可以访问整个成本、整数部分、小数点、浮点部分、连字符及其周围的空格，以及费用名称。我们只需要第一个和最后一个组，但是不需要进一步的字符串转换就可以访问匹配的不同部分是很有用的。</p><h1 id="2836" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="bcbd" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">使用上面的示例，我们已经成功创建了下面的CSV文件，只从一个文本文件开始。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/79bc80007c75944572fcd56469f3aab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*_OszQ3KM-9hnK1dkEkUBJQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Resulting CSV</figcaption></figure><p id="cd23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我在开始时所说的，这是一个简单的正则表达式练习，但仍然是一个好的正则表达式练习。</p><p id="7cd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为最后的想法，我想给你指出<a class="ae kc" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank">regex101.com</a>和<a class="ae kc" href="https://www.debuggex.com/cheatsheet/regex/python" rel="noopener ugc nofollow" target="_blank"> Python ReGex cheatsheet上的Debuggex </a>。前者是编写和测试你的模式的绝佳环境，而后者是一个正则表达式的备忘单。</p><p id="1495" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哦，你可以在我的GitHub库上找到这篇文章<a class="ae kc" href="https://github.com/Ze1598/medium-articles/tree/master/Using%20RegEx%20to%20extract%20expenses%20information%20from%20a%20text%C2%A0file" rel="noopener ugc nofollow" target="_blank">的Python代码和所有相关资源！</a></p><h2 id="4d69" class="lk ll iq bd lr om on dn lv oo op dp lz ko oq or md ks os ot mh kw ou ov ml ow bi translated">访问专家视图— <a class="ae kc" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank">订阅DDI英特尔</a></h2></div></div>    
</body>
</html>