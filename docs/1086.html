<html>
<head>
<title>Infrastructure as code in DevOps life</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基础设施是DevOps生活中的代码</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/infrastructure-as-code-in-devops-life-50761d7bec21?source=collection_archive---------15-----------------------#2020-03-01">https://medium.datadriveninvestor.com/infrastructure-as-code-in-devops-life-50761d7bec21?source=collection_archive---------15-----------------------#2020-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9b74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在讨论任何关于作为代码(IaC) 的<strong class="jp ir">基础设施之前，我们首先要考虑什么是DevOps，它的文化是什么。正如我在一些提到DevOps的网站上发现的，下面是如何描述其文化的座右铭。</strong></p><blockquote class="kl"><p id="c579" class="km kn iq bd ko kp kq kr ks kt ku kk dk translated"><a class="ae kv" href="https://docs.microsoft.com/en-us/azure/devops/learn/what-is-devops-culture" rel="noopener ugc nofollow" target="_blank"> DevOps文化强调小的、多学科的团队，他们自主工作，并对实际用户如何体验他们的软件承担集体责任。</a></p></blockquote><figure class="kx ky kz la lb lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kw"><img src="../Images/2d57e6ac25bb90824e87e6f4a72201b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aCWGpGwy6MGGxBoRQ8D4Nw.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">Image source: <a class="ae kv" href="https://www.atlassian.com/devops" rel="noopener ugc nofollow" target="_blank">https://www.atlassian.com/devops</a></figcaption></figure><p id="a395" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据我之前的经验，我总是手动设置AWS、GCP和Heroku的所有基础设施。与此同时，我觉得自己在观看YouTube、Udemy、Edx等网站时，配置起来很容易，也很健壮。不幸的是，当首席技术官或老板告诉你在另一个地区配置相同的基础设施作为灾难恢复计划(<strong class="jp ir"> DRP </strong>)或新环境，如Staging或UAT，然后会让你头痛地回忆起你以前做过的事情，如IAM角色、策略、安全组、EC2中的软件包安装等等。</p><p id="a78c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仍然可以为小组资源手动配置环境，并配置到另一个区域或新环境。但对于大规模的资源量和多区域复制这样的重型基础设施来说，这将是一场噩梦，而不是我们年轻时听过的童话。</p><blockquote class="ln lo lp"><p id="d009" class="jn jo lq jp b jq jr js jt ju jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj kk ij bi translated">那时，被称为<strong class="jp ir">基础设施代码(IaC) </strong>的主角是管理大规模、分布式系统和面向服务的架构。基础设施作为代码的概念类似于编程脚本，用于自动化IT流程。然而，脚本主要用于自动化一系列静态步骤，这些步骤必须在多个服务器上重复多次。基础架构代码使用更高级或描述性语言来编写更加通用和适应性更强的配置和部署流程。</p></blockquote></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><p id="e4eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，我们长话短说。下面是我基于AWS为我们的新钱包项目建议的基础设施图，我应该做什么。</p><figure class="mc md me mf gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi mb"><img src="../Images/181ae4e95497a396dbc6f12f7ed88113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSlwr__VX0fbYwnvs7WW7g.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">my wallet infrastructure</figcaption></figure><p id="3649" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上图所示，已经提供了很多工具来用代码构建整个架构。在它们之中，我应该选择云层结构或地形结构。因为它在AWS中，难怪我要选择Cloudformation而不是Terraform，因为假定的云提供商是AWS。</p><p id="f701" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在做任何事情之前，想一想我需要使用哪种云形成策略。然后我意识到，我应该基于每个服务创建解耦的多个Cloudformation模板作为嵌套模板，而不是像<strong class="jp ir">敏捷方法</strong>那样创建单个模板。你可能需要问为什么我需要创建这么多的模板而不是一个。</p><blockquote class="kl"><p id="7a81" class="km kn iq bd ko kp kq kr ks kt ku kk dk translated">这是因为嵌套堆栈风格提供了保持一切敏捷和维护多种环境，成本效益，可靠的方式和可重复使用。</p></blockquote><p id="58ce" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">但是使用Cloudformation嵌套堆栈有好处也有坏处。</p><blockquote class="ln lo lp"><p id="6917" class="jn jo lq jp b jq jr js jt ju jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj kk ij bi translated">我不强烈推荐嵌套栈，因为更新它是危险的，并且如果你不能很好地控制并且缺乏经验，可能会破坏一些复杂程度的服务。</p></blockquote><p id="8d2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我将根据堆栈来分割模板。</p><ul class=""><li id="ab33" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk mq mr ms mt bi translated">创建所有必需的IAM角色</li><li id="a015" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">用Cloudfront创建静态的两个网站</li><li id="8f2c" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">创造VPC</li><li id="3497" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">为这两个静态网站创建管道</li><li id="7df8" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">使用ALB创建ECS Fargate服务</li><li id="7a74" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">为跨区域灾难恢复的Fargate服务创建管道</li><li id="3123" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">在EC2实例中创建mongo集群</li><li id="30fe" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">使用晶圆创建路径53</li></ul><p id="c6af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好，我们现在就开始吧。嗯，我将展示使用Cloudformation嵌套栈的基本概念，其中包含示例信息，而不是完整的Cloudformation模板。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><blockquote class="ln lo lp"><p id="b1c5" class="jn jo lq jp b jq jr js jt ju jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj kk ij bi translated">为了减少空间和时间，我将用IAM策略中的<strong class="jp ir"> * </strong>创建所有策略文档。</p></blockquote><p id="fb2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">创建所有必需的IAM角色</strong></p><pre class="mc md me mf gt mz na nb nc aw nd bi"><span id="0596" class="ne nf iq na b gy ng nh l ni nj">AWSTemplateFormatVersion: '2010-09-09'<br/>Description: &gt;<br/>  That CloudFormation template is to create required IAM Roles to all AWS services used in PPS.</span><span id="d966" class="ne nf iq na b gy nk nh l ni nj">Resources:</span><span id="02a5" class="ne nf iq na b gy nk nh l ni nj">PPSAPIRole:<br/>    Type: AWS::IAM::Role<br/>    Description: Lambda Function Role.<br/>    Properties:<br/>      RoleName: PPSAPIRole<br/>      AssumeRolePolicyDocument:<br/>        Version: 2012-10-17<br/>        Statement:<br/>          - Action:<br/>              - "sts:AssumeRole"<br/>            Effect: Allow<br/>            Principal:<br/>              Service:<br/>                - lambda.amazonaws.com<br/>      Policies:<br/>        - PolicyDocument:<br/>            Version: 2012-10-17<br/>            Statement:<br/>              - Effect: Allow<br/>                Action:<br/>                  - logs:*<br/>                  - logs:CreateLogStream<br/>                Resource: "*"<br/>              - Effect: Allow<br/>                Action:<br/>                  - dynamodb:*<br/>                Resource: "arn:aws:dynamodb:*:*:*"<br/>              - Effect: Allow<br/>                Action:<br/>                  - lambda:InvokeFunction<br/>                Resource: "*"<br/>          PolicyName: "PPSPolicy"</span><span id="43bf" class="ne nf iq na b gy nk nh l ni nj"><strong class="na ir">Outputs:<br/>  PPSAPIRole:<br/>    Description: PPSAPIRole to use PPS Backend Stacks<br/>    Value: !GetAtt [PPSAPIRole, Arn]</strong></span></pre><p id="d8af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上述模板将被命名为<strong class="jp ir"> iam.yml </strong>，以创建整个项目所需的所有iam角色。在上面的代码片段中，您会注意到突出显示的文本显示了需要使用另一个Cloudformation模板的<strong class="jp ir">输出</strong>部分。目的是为另一个Cloudformation输出创建的IAM角色，名为<strong class="jp ir"> PPSAPIRole </strong>。</p><p id="0e9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们继续创建另一个后端服务。</p><pre class="mc md me mf gt mz na nb nc aw nd bi"><span id="482d" class="ne nf iq na b gy ng nh l ni nj">AWSTemplateFormatVersion: '2010-09-09'<br/>Description: &gt;<br/>  That CloudFormation template is to setup Backend NodeJS API of PPS.</span><span id="9975" class="ne nf iq na b gy nk nh l ni nj"><strong class="na ir">Parameters:<br/>  PPSAPIRole:<br/>    Type: String<br/>    Description: The name of role for Lambda</strong></span><span id="0c7d" class="ne nf iq na b gy nk nh l ni nj">Resources:<br/>  PPSLambdaLogs:<br/>    Type: AWS::Logs::LogGroup<br/>    Properties:<br/>      LogGroupName: "/aws/lambda/PPSLambdaBackend"<br/>      RetentionInDays: 90<br/>  PPSLambdaBackend:<br/>    Type: AWS::Lambda::Function<br/>    DependsOn:<br/>      - PPSLambdaLogs<br/>    Properties:<br/>      Code:<br/>        ZipFile: |<br/>          exports.handler = (event) =&gt; {<br/>            const response = {<br/>                statusCode: 200,<br/>                body: JSON.stringify('Hello from Lambda!'),<br/>            };<br/>            return response;<br/>          };      <br/>      Description: "PPS Backend NodeJS API of PPS"<br/>      FunctionName: PPSLambdaBackend<br/>      Handler: index.handler<br/>      MemorySize: 2048<br/>      <strong class="na ir">Role: !Ref PPSAPIRole</strong><br/>      Runtime: nodejs10.x<br/>      Timeout: 900</span></pre><p id="d24d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的，再次命名为<strong class="jp ir"> api.yml </strong>。在上面的模板中，你会再次注意到<strong class="jp ir"> PPSAPIRole </strong>在<strong class="jp ir"> PPSAPIRole </strong>部分，这是在Lambda函数中使用高亮文本所必需的。</p><p id="1f42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果不使用嵌套栈，我们可能需要先上传<strong class="jp ir"> iam.yml </strong>。然后复制那个IAM角色的ARN，上传后粘贴为第二个<strong class="jp ir"> api.yml </strong>模板的参数段。很方便吧？这就是为什么我要使用Cloudformation的嵌套特性，称为<strong class="jp ir">AWS::cloud formation::Stack</strong>。</p><p id="8de9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们可能需要先在S3桶中上传这两个堆栈。然后复制下载S3公共网址的那两个栈，保存在别的地方。</p><pre class="mc md me mf gt mz na nb nc aw nd bi"><span id="6e20" class="ne nf iq na b gy ng nh l ni nj">AWSTemplateFormatVersion: '2010-09-09'</span><span id="8049" class="ne nf iq na b gy nk nh l ni nj">Description: &gt;<br/>  That CloudFormation template is to setup PPS architecture that all AWS Services stacks used in PPS Project.</span><span id="6cd6" class="ne nf iq na b gy nk nh l ni nj">Resources:<br/>  <strong class="na ir">IAMRoleStacks</strong>:<br/>    Type: AWS::CloudFormation::Stack<br/>    Properties:<br/>      TemplateURL: "<a class="ae kv" href="https://cf-templates-pps.s3-ap-southeast-2.amazonaws.com/iam.yaml" rel="noopener ugc nofollow" target="_blank">https://cf.s3-us-east-1.amazonaws.com/iam.yml</a>"<br/>  <strong class="na ir">BackendStacks</strong>:<br/>    Type: AWS::CloudFormation::Stack<br/>    Properties:<br/>      TemplateURL: "<a class="ae kv" href="https://cf-templates-pps.s3-ap-southeast-2.amazonaws.com/backend.yaml" rel="noopener ugc nofollow" target="_blank">https://cf.s3-us-east-1.amazonaws.com/api.yml</a>"<br/>      Parameters:<br/>        <strong class="na ir">PPSAPIRole: !GetAtt IAMRoleStacks.Outputs.PPSAPIRole</strong></span></pre><p id="8808" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码片段中，你会注意到<strong class="jp ir"> iam.yml </strong>模板被嵌入为<strong class="jp ir"> IAMRoleStacks。</strong>同样<strong class="jp ir"> api.yml </strong>模板被嵌入为<strong class="jp ir"> BackendStacks </strong>并接受从<strong class="jp ir"> IAMRoleStacks </strong>创建的IAM角色作为<strong class="jp ir"> PPSAPIRole </strong>参数作为<strong class="jp ir">！GetAtt iamrolestacks . outputs . ppsapirole .</strong></p><blockquote class="kl"><p id="0470" class="km kn iq bd ko kp kq kr ks kt ku kk dk translated">！GetAtt { Stack name } . Output . { Stack-Output-Parameter }</p></blockquote><p id="213a" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">希望你能理解嵌套栈是如何敏捷地工作的，它提供了使用模块来避免复杂和大的模板。</p><p id="daff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">向所有人致敬……</strong></p></div></div>    
</body>
</html>