<html>
<head>
<title>Data cleansing in ML using python functions — models don’t like dirty data.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用python函数在ML中清理数据——模型不喜欢脏数据。</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/data-cleansing-in-ml-using-python-functions-models-dont-like-dirty-data-5c64d8d3f3a8?source=collection_archive---------2-----------------------#2020-04-30">https://medium.datadriveninvestor.com/data-cleansing-in-ml-using-python-functions-models-dont-like-dirty-data-5c64d8d3f3a8?source=collection_archive---------2-----------------------#2020-04-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/23c4bec2b3a21f1fd9c82b8c402af661.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*Jkue4lL3m9jImvM6afA42w.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Image credits: DataEntryServices-Info</figcaption></figure><p id="cb1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">难道我们不都希望能够完全按照上图所示的方式清理数据吗？嗯，这只是一个愿望。但是在将脏数据输入模型之前，我们在python中有一些有趣的方法来处理脏数据。</p><p id="208e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">首先让我们理解为什么需要数据清理:</strong></p><p id="7daa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一般来说，需要进行数据清理，以使特征中没有杂乱的数据，并为许多下游过程构建更合适的数据版本。</p><p id="7b1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">然而，在数据科学中，</strong>最重要的事情是模型的准确性，以及它理解未知数据的准确程度，从而给出无错误的预测/结果。这反过来将有助于企业和组织减少意外成本，带来更多的利润。</p><p id="c738" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们用一个例子来理解这一点:假设一个节日即将来临，我有一个精品店。所以，为了增加我的收藏并找出能给我带来更多利润的物品，我需要了解前几年的销售趋势。做到这一点的一个方法是建立一些洞察力，并在我收集的海量历史数据上运行一个预测模型。但是如果我用来预测销售额的模型不能给我准确的信息，我的生意就会亏损。这就是为什么我们的模型有最高的精确度是非常必要的。</p><div class="kw kx gp gr ky kz"><a href="https://www.datadriveninvestor.com/2020/02/19/five-data-science-and-machine-learning-trends-that-will-define-job-prospects-in-2020/" rel="noopener  ugc nofollow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">将定义2020年就业前景的五大数据科学和机器学习趋势|数据驱动…</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">数据科学和ML是2019年最受关注的趋势之一，毫无疑问，它们将继续发展…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="li l"><div class="lj l lk ll lm li ln js kz"/></div></div></a></div><p id="92eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们用数据清洗产生的高质量信息训练模型时，以上所有这些都可以实现。</p><p id="d2f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">在一个数据科学项目中，数据清洗消耗了总工作量的50%以上。</strong></p><p id="28f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的图表让我们了解了一些需要清理的不相关的数据场景。</p><p id="d9a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将逐一讨论这些场景，以及使用python处理它们的策略。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi lo"><img src="../Images/a00048b4c2c2713b994d07b8573ac5c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DD6jneB9HfXtPxGZnTaj9Q.png"/></div></div></figure><p id="a55f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">喔呼，现在是时候把手弄脏了。让我们直接进入Jupyter笔记本，从一步一步的清洁开始。</p><p id="467b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">先决条件:</strong>我正在使用数据集XYZCorp_LendingData。(图片来源:Kaggle)</p><h1 id="7754" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated"><strong class="ak"><em class="mv">1&gt;</em></strong><em class="mv"/><strong class="ak"><em class="mv">导入所有重要的python库。</em> </strong></h1><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/f6fdb642afbf5d0ad51819e3fe84925a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*vTtbtODKk05T7GTvmzv02w.png"/></div></figure><h1 id="012f" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated"><strong class="ak">T19】2&gt;导入数据集。 </strong></h1><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mx"><img src="../Images/9641034238e43e675bd582e06125aee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DOKP5ngDLwcdvtVlrGIeOQ.png"/></div></div></figure><h1 id="f523" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">3 &gt;看一下数据。</h1><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi my"><img src="../Images/75cf8b85606dd97c83b669d02869490b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0R9vbWj4KV3w2GBsWAjltw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">I am using head() function here because I want to see first 5 rows.</figcaption></figure><p id="bff3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看到上面的截图，我们意识到有些列是隐藏的。当数据集的列数过多，无法全部显示时，通常会发生这种情况。</p><p id="1ce4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了解决这个问题，如果我们想查看Jupyter笔记本中的所有列，我们可以使用下面的命令:</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/006c15f781c3e85d5e2278df7780797f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*ZV96kPdgOICVudoxT3hyAg.png"/></div></figure><p id="096e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们再次读取数据，所有列都将显示在Jupyter笔记本中。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi na"><img src="../Images/f044e8477c97e17804d181214316f49f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EanKN8hi1DayJqxFjN4sag.png"/></div></div></figure><h1 id="56b6" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated"><strong class="ak"><em class="mv">4&gt;</em></strong><em class="mv"/><strong class="ak"><em class="mv">标识列数和行数。</em>T9】</strong></h1><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/aa148425176c3761ffff3f62f11549c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*3rkmecbqU5jzMSqimU4omA.png"/></div></figure><h1 id="d47c" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated"><em class="mv"> 5 &gt;数据清理:</em></h1><p id="7e26" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated"><strong class="ka ir">在数据清理部分，我们将首先识别丢失的值，然后确定处理它们的方法。</strong></p><p id="8ba6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="nh">缺失值</em> </strong> <em class="nh">通常发生在没有为特定特征存储值时。在整数数据类型中可以用NA和NAN(不是数字)来标识，在字符数据类型中可以用空格来标识。</em></p><p id="c32b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">检测缺失值的各种方法:</strong></p><p id="0e7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">了解缺失值的最简单方法是使用函数<strong class="ka ir"> df.info() </strong>，该函数让我们对所有列有一个总体的了解，比如它们的数据类型以及它们是否包含空值/非空值。</p><p id="55f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，在下面的截图中，我们可以看到我们的示例数据集的所有73列的数据类型。我们还知道数据集中的总行数是855969。因此，以蓝色突出显示的列“desc”有121812个非空值，这可能意味着剩余的值是空格/null/NA/NaN。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/b908601848281024e413cdb3d2e9405f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*tPdlUd9A8OJRPPeIkeqDrg.png"/></div></figure><p id="5645" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nh">检测缺失值</em>的第二种方法是通过<strong class="ka ir">使用可视化技术。</strong></p><p id="5c5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">o <strong class="ka ir"> Seaborn库和热图函数</strong>可用于检测缺失值——看一下下图，我们就能了解缺失数据的列。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nj"><img src="../Images/090fcff3f0b4abbe43e3b3d122ab9fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yTXupVkjetU6uKzekr8nmA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">The white lines and white spaces in the heatmap shows us the missing values.</figcaption></figure><p id="1baf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">o <strong class="ka ir"> Missingno </strong>是python中另一个有用的可视化库，它有助于可视化数据帧的空值。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/7f6c1645c3bd4507bf63ff990adbc510.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*3wDWM3uRe624nFAd00k9OA.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Install the library</figcaption></figure><p id="085f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">o <strong class="ka ir"> Msno.matrix() </strong>函数给出了与sns.heatmap()类似的结果。因此，它们中的任何一个都可以用来可视化丢失的值。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nl"><img src="../Images/3a8b348876e6d12531233c0fd16ede6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*22kXMpydMq1n97ZTICnqUg.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">The white lines and white spaces indicate that our example dataset has lots of missing values.</figcaption></figure><p id="0827" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">使用缺失号库</strong>，我们可以<strong class="ka ir">使用msno.bar()函数绘制缺失值</strong>。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nm"><img src="../Images/d6725facc9e42335e4abc2a4a5e3ac3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hgvWVIBj6OUnIC9u8NBLUw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">In the bar plot, we can easily identify all the columns with missing values.</figcaption></figure><p id="c530" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第三种也是最有效的检测缺失值的方法</strong>是使用python脚本和python函数。</p><p id="a10b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果数据集的列数较少，我们可以使用下面的python代码来检查缺失值的数量和百分比。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nn"><img src="../Images/58d4c0650d3a33f2ee3cfaee9a07d07a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6bNVJgQsdJM2gfisfISbCA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Example dataset : BlackFriday sales (Source: Kaggle)</figcaption></figure><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi no"><img src="../Images/f52213794453a94d00de81d7cee5a3ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ACbODWiTSmKyRAJiKhWrvA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">The above table gives us a count and percent of missing values</figcaption></figure><p id="c2cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，如果数据集中的列数量很大，那么这些脚本的挑战在于，所有的列不会一起显示在Jupyter notebook中。例如:</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi np"><img src="../Images/e2ca485752fa335aa03e11140cfe1a0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R5YADOjcbRreF2ddlq1v6Q.png"/></div></div></figure><p id="6303" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="nh">为了克服这个缺点，我们可以编写python函数，可以用在各种数据量小或大的数据集上。</em>T45】</strong></p><p id="433b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们可以设置一个标志来检查数据集是否有空值。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/dd15a3422ae66015fc5098457f1bd568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*zCssSMFyyFUbq0bZGfkCaw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">True means our dataset has null values.</figcaption></figure><p id="14c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用下面的python函数来计算缺失值的数量和百分比。该函数可用于任何数据集。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nr"><img src="../Images/2eef2c561a1fc797dd9699e76e7e8507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pApwMBhh87XJcNPBNgfnUA.png"/></div></div></figure><p id="6684" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在使用上面的python函数检查我们的示例数据集“XYZCorp_BankLending”是否有任何丢失的值。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/309d62b23fd79a5ec7eb277f8485a803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*Kae3-UIJsAVJ9uBTrJ4NCQ.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Looks like there are lots of missing data.</figcaption></figure><p id="5f5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">首先，识别缺失值超过60%的数据:</strong></p><p id="a638" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的屏幕截图中，我们可以看到一些以红色突出显示的列有大约80–100%的缺失值。在进一步检查下面的代码时，我们观察到“True = 20 ”,这意味着20列有超过60%的缺失值。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nt"><img src="../Images/83f0ae354b2b4719d5c4d3efe697cdf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1NSDEmRG4CNaD4dawq-bHA.png"/></div></div></figure><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nu"><img src="../Images/51831c56c96c73e12345bee7f0c45af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mkVK8-C1J9Y3ey6q4LL4WA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">The code above indicates that Dataframe ‘bankdata_missingsixty_values’ contains the 20 columns having more than 60% missing values.</figcaption></figure><p id="da81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">下一步是识别缺失值少于60%的数据。</strong></p><p id="6a3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的脚本让我们了解了缺失值小于60%的不同数据类型的列的数量和名称。这是必要的，因为它使我们的工作更容易识别不同的数据，以便处理它们，因为浮动数据应由平均值估算，对象数据应由模式估算。</p><ul class=""><li id="0595" class="nv nw iq ka b kb kc kf kg kj nx kn ny kr nz kv oa ob oc od bi translated"><strong class="ka ir">标识数据类型为“float”的列。</strong></li></ul><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi oe"><img src="../Images/314408808109f70f18c766a299d0ada5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tIUwwgJnlE1zk5YsA9OSYA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">True = 6 indicates 6 columns with data type float has &lt; 60% missing values and needs imputation.</figcaption></figure><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi of"><img src="../Images/e831d0631770efaebc245575e5e55dcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mlNIU-gjMui9f_iAwerW5Q.png"/></div></div></figure><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi og"><img src="../Images/169baf58ba05bc50ac029d35c7256235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xNtc3pr0Ozxg9ovy4jzM0Q.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Dataframe ‘bankdata_missless60_floatdt1’ contains the 6 columns of datatype float with missing values&lt;60%</figcaption></figure><ul class=""><li id="fc7b" class="nv nw iq ka b kb kc kf kg kj nx kn ny kr nz kv oa ob oc od bi translated"><strong class="ka ir">识别数据类型为“对象”的列。</strong></li></ul><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi oh"><img src="../Images/7a1f2d32f3d9ac131992783eda3cd7f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4yWxtv7VYnOLU_n7zJB9eQ.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">True = 6 indicates 6 columns with data type ‘object’ has &lt; 60% missing values and needs imputation.</figcaption></figure><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi oi"><img src="../Images/6cd9905f861a446c77af88e0b2e74fd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-jkvSioaSglronBL6fbew.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Dataframe ‘bankdata_missless60_objectdt1’ contains the 6 columns of datatype object with missing values&lt;60%</figcaption></figure><p id="d0bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="nh">既然我们已经确定了有缺失值的数据，我们需要看看处理它们的各种方法。</em>T11】</strong></p><ul class=""><li id="0873" class="nv nw iq ka b kb kc kf kg kj nx kn ny kr nz kv oa ob oc od bi translated"><strong class="ka ir">处理缺失值</strong>的一种方式是，如果一列包含超过60%的缺失数据<strong class="ka ir">，那么最好<strong class="ka ir">删除列</strong>，因为具有大量缺失值的数据对模型准确性没有太大帮助。</strong></li></ul><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi oj"><img src="../Images/7c042acc81beb780adab5a48432babc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dkSi_7CyuGxtw_7PBl4Z5Q.png"/></div></div></figure><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ok"><img src="../Images/2b7dc67e1ca682aed7de5859872c60c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XlDCewaAWFJ7hSyFy6lZcw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">After dropping columns with &gt;60% missing values from our example dataset , the number of columns changed from 73 to 53,.</figcaption></figure><ul class=""><li id="25f7" class="nv nw iq ka b kb kc kf kg kj nx kn ny kr nz kv oa ob oc od bi translated"><strong class="ka ir">第二种方法是估算/替换缺失值。</strong></li></ul><p id="3178" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">缺失数据少于60%的列仍可用于进一步处理，但在此之前必须对其进行处理(估算/替换)。</p><p id="7f83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用来自Scikit learn的SimpleImputer()方法来估算缺失值。</p><p id="c1a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我在这个turorial中使用了fillna()方法。</p><p id="e04d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">整型数据类型</strong>，缺失的值可以用<strong class="ka ir">替换，表示该列的</strong>。</p><p id="be38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果列数较少，我们可以手动逐个进行插补，如下所示；如果需要插补的列数较多，我们可以编写一个循环函数。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ol"><img src="../Images/7dca538a556b329a94ff55d78b92694e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QoGhKMvMiknq2CZcFmQX8A.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Manual Imputation with mean.</figcaption></figure><p id="0a6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">使用循环:</strong>下面的函数将首先检查列的dtype。如果它是float，数据中具有na值的列将通过fillna方法由平均值估算。这个过程对所有符合标准的列进行迭代。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi om"><img src="../Images/57e8c621762454e58523e1731a845e54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*SsLmiFPCZMlCn1POJAFLMw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Mean imputation using Loop function.</figcaption></figure><p id="21e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">同样，对于字符数据类型</strong>，该列的<strong class="ka ir">模式</strong>(出现次数最高的值)可用于估算缺失值。</p><p id="5ccd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这也可以手动或使用循环来完成。我们将在这里讨论这两个问题。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/d4183c61692ff92c97f53b90cf3c7ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*Db5Z8NpgKo3kYKw6YenJsQ.png"/></div></figure><p id="62e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">手动逐个输入</strong>:当需要输入的列数较少时首选。</p><p id="6c48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我将使用下面的函数找到所有需要清理的列的模式，然后用各自的模式估算它们。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/f7b022437214106d6e16b33834eb31d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*ygyy_K--RU2KQcBUJY9xIg.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Statistics library is used for it.</figcaption></figure><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/ee4a90aa4b5cb616fafd3795187b6c8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*k6Q1Dfda_8x3jTFI8Ozk5w.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Manual imputation with mode.</figcaption></figure><p id="7d9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">使用循环:</strong>下面的函数将首先检查列的dtype。如果是object，数据中具有na值的列将通过fillna方法由mode估算。这个过程对所有符合标准的列进行迭代。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/1b173ab5ffc03fd01939a7aa77dc4b26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*WsuFkqMkFqIYKaW_yww9nQ.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Mode imputation using Loop Function</figcaption></figure><h1 id="c25f" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated"><strong class="ak">我们来总结一下上面的过程:</strong></h1><p id="cc91" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">1 &gt;使用可视化技术/python脚本/python函数检测缺失值(总数和百分比)。</p><p id="95b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2 &gt;删除缺失数据超过60%的列。</p><p id="6e53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3 &gt;对于int/char数据类型，分别用mean/mode估算剩余值。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/97f6cdb873336c19f0059e5aa883e678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*vJ97IVFxExAXVF3LLCaOIw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">After all the imputation done in the preceding steps, the missing flag is finally false which means our example dataset is completely void of missing values now.</figcaption></figure><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/8f286775a2591e7ee13c4fa87c15dbf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*nhEay4L-Zkf5_IkcLEf6tA.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Shape of dataset after dealing with missing values.</figcaption></figure><p id="3792" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">现在，数据清理的下一部分围绕着不必要的列，这些列不会给模型/结果增加任何价值。</strong></p><p id="86ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些列如序列号、卷号、id等对于每一行都是唯一的。因此，我们可以删除这种类型的列。</p><p id="5a83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">识别此类数据的一个简单技术是</strong>创建一个如下图所示的函数，以识别每列中唯一行的数量。如果一列中唯一的行数与该列中的总行数匹配，并且如果它们似乎没有给预测增加任何值，那么我们可以删除它们。</p><p id="1ede" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，在使用这种技术丢弃任何东西之前，我们需要格外小心，因为有时可能会有连续的特征，如年龄、距离等，它们可能都有唯一的值。在这种情况下，我们需要小心，在盲目放弃它们之前，理解观察结果对我们的分析有什么贡献。T11】</p><p id="b2d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，像人名这样的列也可以删除。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/6311d79279771732ae5dabbcdf8063a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*7MFh9NPpzZeF9rnM6YQZAg.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Function for finding unique values.</figcaption></figure><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi oq"><img src="../Images/8707e4a4ad9a873067cfa8620501ad67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2mMRKVJwQYCBVeNp4l26bA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">In our example dataset ‘XYZCorp_LendingData’, the total number of rows is 855969 and as seen above, the number of unique rows for columns ‘id’ and ‘member_id’ is also 855969. Hence, we can drop these columns.</figcaption></figure><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/12fafcb3806b619c1a7871a02f9c87fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*q4feG5Mj1la8OBbMlkNVvw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">After<strong class="bd lz"> </strong>cleansing , 51 columns of the dataset turned out to be with appropriate data.</figcaption></figure><p id="1959" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">另一个需要数据清理的重要场景是处理离群值。</strong>要了解更多关于离群值的信息，请访问我的文章<a class="ae or" href="https://medium.com/@anjurajbangshi2/outliers-in-data-and-ways-to-detect-them-1c3a5f2c6b1e?source=your_stories_page---------------------------" rel="noopener">离群值</a>。</p><p id="8f97" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">最后但同样重要的是，有时，我们收集的数据可能有不正确的列名。</strong></p><p id="e7be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如:一个列名可能以数字开头，可能包含空格，python不能识别的其他特殊字符。因此，我们需要将它们转换成适当的格式以便进一步处理。</p><p id="37d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，我们可以直接在文件本身中更正它们。</p><p id="db8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，我们也可以利用python的replace()函数就是这样的情况。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi os"><img src="../Images/a2a936e2c990ebb852c49d8b2155dd08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*pSVOHZH1aQSb7hIZm5iIiw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Example code to convert all spaces in a column name to underscore(_).</figcaption></figure><p id="a5b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">附加说明</strong>:此外，有时许多列可能包含值，如'&gt; 9 '，'&lt; 6 '等。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/ce3d7bd67407352953b11d55458901c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*7Nv9798Om4U_e-szIuxWxQ.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Example</figcaption></figure><p id="5292" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的示例数据集“XYZCorp_LendingData”包含像emp_length这样的列，这些列的值在上面的屏幕截图中突出显示。因此，我们需要将这种类型的数据转换为机器/机器学习算法可以理解的正确格式。这可以通过标签编码等策略轻松实现，我们将在另一篇文章中讨论。</p><p id="1afd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我欢迎任何关于这个话题的建议/反馈/额外信息，请保持联系。在那之前，享受阅读吧！！</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="ot ou l"/></div></figure></div></div>    
</body>
</html>