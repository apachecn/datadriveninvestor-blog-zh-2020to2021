<html>
<head>
<title>Face Detection using OpenCV and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于OpenCV和Python的人脸检测</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/face-detection-using-opencv-and-python-75f58eb325b1?source=collection_archive---------10-----------------------#2020-07-21">https://medium.datadriveninvestor.com/face-detection-using-opencv-and-python-75f58eb325b1?source=collection_archive---------10-----------------------#2020-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="6e14" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">OpenCV</h1><p id="a5a9" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">OpenCV是一个开源的计算机视觉和机器学习软件库。这是一个BSD许可的产品，因此对于商业和学术目的都是免费的。该库提供了2500多种算法，包括用于分类和聚类的机器学习工具、图像处理和视觉算法、基本算法和绘图功能、GUI以及图像和视频的I/O功能。这些算法的一些应用包括人脸检测、物体识别、提取3D模型、图像处理、摄像机校准、运动分析等。</p><p id="868d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">OpenCV是用C/C++原生编写的。它有C++、C、Python和Java接口，支持Windows、Linux、Mac OS、iOS和Android。OpenCV是为计算效率而设计的，目标是实时应用。该库用优化的C/C++编写，可以利用多核处理。</p><h1 id="d13c" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">人脸检测</h1><p id="f488" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">人脸检测因其实时应用而受到广泛关注。为了改进和快速实现人脸检测算法，已经进行了大量的研究，并且这些研究仍在继续。为什么人脸检测对一台机器来说很难？由于图像外观的许多变化，如姿势变化(正面，非正面)，遮挡，图像方向，光照变化和面部表情，人脸检测并不像看起来那么容易。</p><p id="c9a7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">包含许多预先训练好的人脸、眼睛、微笑等分类器。预训练分类器的XML文件存储在<code class="fe lr ls lt lu b">opencv/data/</code>中。特别是对于人脸检测，有两个预训练的分类器:</p><ol class=""><li id="edd8" class="lv lw it kq b kr lm kv ln kz lx ld ly lh lz ll ma mb mc md bi translated">哈尔级联分类器</li><li id="2832" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">LBP级联分类器</li></ol><p id="e5e2" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我们将在本教程中探讨这两种人脸检测器。</p><h2 id="3528" class="mj jr it bd js mk ml dn jw mm mn dp ka kz mo mp ke ld mq mr ki lh ms mt km mu bi translated">哈尔级联分类器</h2><p id="1d84" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是一种基于机器学习的方法，其中从许多正面(有脸的图像)和负面图像(没有脸的图像)中训练级联函数。该算法由保罗·维奥拉和迈克尔·琼斯提出。</p><p id="8c8c" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">该算法有四个阶段:</p><ol class=""><li id="1154" class="lv lw it kq b kr lm kv ln kz lx ld ly lh lz ll ma mb mc md bi translated"><strong class="kq iu">哈尔特征选择:</strong>在输入图像的子部分中计算哈尔特征。计算相邻矩形区域的像素强度之和之间的差，以区分图像的子部分。获得面部特征需要大量的haar-like特征。</li><li id="3c04" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated"><strong class="kq iu">创建积分图像:</strong>当对所有像素执行操作时，将进行太多的计算，因此使用积分图像，将计算减少到只有四个像素。这使得算法相当快。</li><li id="6111" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated"><strong class="kq iu"> Adaboost: </strong>所有计算出的特征都与分类目的无关。<code class="fe lr ls lt lu b">Adaboost</code>用于对相关特征进行分类。</li><li id="5058" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated"><strong class="kq iu">级联分类器:</strong>现在我们可以使用相关特征将人脸从非人脸中分类出来，但是算法使用<code class="fe lr ls lt lu b">cascades of classifiers</code>的概念提供了另一种改进。图像的每个区域不是面部区域，因此在图像的所有区域中应用所有特征是没有用的。不要一次使用所有的特征，而是将特征分组到分类器的不同阶段。逐一应用每个阶段以找到面部区域。如果在任何阶段分类器失败，该区域将从进一步的迭代中被丢弃。只有面部区域将通过分类器的所有阶段。</li></ol><h2 id="d116" class="mj jr it bd js mk ml dn jw mm mn dp ka kz mo mp ke ld mq mr ki lh ms mt km mu bi translated">LBP级联分类器</h2><p id="b545" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">LBP是一种纹理描述符，人脸由微纹理图案组成。因此，LBP特征被提取以形成一个特征向量来区分人脸和非人脸。以下是LBP级联分类器算法的基本步骤:</p><ol class=""><li id="f83d" class="lv lw it kq b kr lm kv ln kz lx ld ly lh lz ll ma mb mc md bi translated"><strong class="kq iu"> LBP标签化:</strong>一串二进制数的标签被分配给图像的每个像素。</li><li id="275d" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated"><strong class="kq iu">特征向量:</strong>图像被分成子区域，并且对于每个子区域，构建标签的直方图。然后，通过将子区域直方图连接成大直方图来形成特征向量。</li><li id="250a" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated"><strong class="kq iu"> AdaBoost学习:</strong>使用温和AdaBoost构建强分类器，从特征向量中去除冗余信息。</li><li id="b0c2" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated"><strong class="kq iu">级联分类器:</strong>级联分类器由温和AdaBoost算法获得的特征形成。从简单分类器到强分类器开始评估图像的子区域。如果在任何阶段分类器失败，该区域将从进一步的迭代中被丢弃。只有面部区域将通过分类器的所有阶段。</li></ol><h2 id="a535" class="mj jr it bd js mk ml dn jw mm mn dp ka kz mo mp ke ld mq mr ki lh ms mt km mu bi translated">Haar和LBP级联分类器的比较</h2><p id="366a" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下面给出了<code class="fe lr ls lt lu b">haar cascade classifier</code>和<code class="fe lr ls lt lu b">LBP cascade classifier</code>的简短对比:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mv"><img src="../Images/93ed1c295357a03c909e12b65e53d2b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6-yKITPP8j0vo5K1BWPFAA.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Comparison between LBP and Haar</figcaption></figure><p id="9bbb" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">每个OpenCV人脸检测分类器都有自己的优点和缺点，但主要的区别在于准确性和速度。因此，在需要更精确检测的用例中，<code class="fe lr ls lt lu b">Haar</code>分类器更适合安全系统，而<code class="fe lr ls lt lu b">LBP</code>分类器比Haar分类器更快，由于其速度快，所以更适合速度很重要的应用，如移动应用或嵌入式系统。</p><h1 id="143d" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">基于OpenCV的编码人脸检测</h1><h2 id="3262" class="mj jr it bd js mk ml dn jw mm mn dp ka kz mo mp ke ld mq mr ki lh ms mt km mu bi translated">属国</h2><ol class=""><li id="3563" class="lv lw it kq b kr ks kv kw kz nl ld nm lh nn ll ma mb mc md bi translated"><a class="ae no" href="http://opencv.org/releases.html" rel="noopener ugc nofollow" target="_blank">应该安装OpenCV </a>。</li><li id="8b83" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated"><a class="ae no" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank">应该安装Python v3 </a>。</li><li id="63be" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">(可选)<a class="ae no" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank">如果你想看到我在本教程中展示的有组织的结果，应该安装Matplotlib </a>，但这是完全可选的。</li></ol><p id="45b9" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">注意:</strong>如果你不想安装<code class="fe lr ls lt lu b">matplotlib</code>，那么用OpenCV代码替换它的代码。</p><p id="235b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">例如，代替</p><pre class="mw mx my mz gt np lu nq nr aw ns bi"><span id="f696" class="mj jr it lu b gy nt nu l nv nw">plt.imshow(gray_img, cmap='gray')</span></pre><p id="ed8a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">你可以用</p><pre class="mw mx my mz gt np lu nq nr aw ns bi"><span id="a9a3" class="mj jr it lu b gy nt nu l nv nw">cv2.imshow('Test Imag', gray_img) cv2.waitKey(0) cv2.destroyAllWindows()</span></pre><ul class=""><li id="f013" class="lv lw it kq b kr lm kv ln kz lx ld ly lh lz ll nx mb mc md bi translated"><code class="fe lr ls lt lu b"><strong class="kq iu">cv2.waitKey()</strong></code>是键盘绑定功能。它的参数是以毫秒为单位的时间。该函数为任何键盘事件等待指定的毫秒数。如果您在这段时间内按下任何键，程序将继续运行。如果传递0，它将无限期等待击键。它也可以设置为检测特定的击键，如，如果a键被按下等。</li><li id="004d" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll nx mb mc md bi translated"><code class="fe lr ls lt lu b"><strong class="kq iu">cv2.destroyAllWindows()</strong></code>简单地摧毁我们创造的所有窗户。</li></ul><h2 id="3f54" class="mj jr it bd js mk ml dn jw mm mn dp ka kz mo mp ke ld mq mr ki lh ms mt km mu bi translated">导入所需的库</h2><p id="cdaf" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">要运行代码，必须首先导入以下库</p><pre class="mw mx my mz gt np lu nq nr aw ns bi"><span id="6784" class="mj jr it lu b gy nt nu l nv nw">#import required libraries <br/>import numpy as np<br/>import cv2<br/>import matplotlib.pyplot as plt<br/>import time <br/>%matplotlib inline</span></pre><p id="f092" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">默认情况下，当你使用OpenCV加载图像时，它会将图像加载到BGR色彩空间中。为了使用<code class="fe lr ls lt lu b">matplotlib</code>显示彩色图像，我们必须将其转换到RGB空间。下面是一个帮助器函数来完成这个任务。</p><pre class="mw mx my mz gt np lu nq nr aw ns bi"><span id="517c" class="mj jr it lu b gy nt nu l nv nw">def convertToRGB(img):<br/>    return cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span></pre><h2 id="7cc9" class="mj jr it bd js mk ml dn jw mm mn dp ka kz mo mp ke ld mq mr ki lh ms mt km mu bi translated">码—哈尔级联分类器</h2><p id="e5c9" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Haar cascade的XML训练文件存储在<code class="fe lr ls lt lu b">opencv/data/haarcascades/</code>文件夹中。</p><p id="7c10" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">首先，我们需要加载所需的XML分类器。然后在灰度模式下加载我们的输入图像。OpenCV <strong class="kq iu">中的很多操作都是在灰度</strong>中完成的。</p><pre class="mw mx my mz gt np lu nq nr aw ns bi"><span id="b36e" class="mj jr it lu b gy nt nu l nv nw">#load cascade classifier training file for haarcascade<br/>haar_face_cascade = cv2.CascadeClassifier('data/haarcascade_frontalface_alt.xml')<br/><br/>#load test iamge<br/>test1 = cv2.imread('data/test1.jpg')<br/><br/>#convert the test image to gray image as opencv face detector expects gray images<br/>gray_img = cv2.cvtColor(test1, cv2.COLOR_BGR2GRAY)<br/><br/>#display the gray image using OpenCV<br/># cv2.imshow('Test Imag', gray_img)<br/># cv2.waitKey(0)<br/># cv2.destroyAllWindows()<br/><br/>#or if you have matplotlib installed then <br/>plt.imshow(gray_img, cmap='gray')</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/ff65a00d9efdb5c48ff533cb96921cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/0*ry9LQylYs2rmo8bl.png"/></div></figure><p id="5402" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">现在我们用<code class="fe lr ls lt lu b"><strong class="kq iu">detectMultiScale</strong></code>找到图像中的人脸。如果找到了面，该函数将检测到的面的位置作为Rect(x，y，w，h)返回。</p><pre class="mw mx my mz gt np lu nq nr aw ns bi"><span id="fe24" class="mj jr it lu b gy nt nu l nv nw">#let's detect multiscale (some images may be closer to camera than others) images<br/>faces = haar_face_cascade.detectMultiScale(gray_img, scaleFactor=1.1, minNeighbors=5);<br/><br/>#print the number of faces found<br/>print('Faces found: ', len(faces))</span></pre><p id="9a12" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">输出</p><pre class="mw mx my mz gt np lu nq nr aw ns bi"><span id="4f6d" class="mj jr it lu b gy nt nu l nv nw">Faces found:  1</span></pre><p id="f415" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">接下来，让我们遍历它返回的面部(矩形)列表，并使用内置的OpenCV <code class="fe lr ls lt lu b"><strong class="kq iu">rectangle</strong></code>函数在我们的原始彩色图像上绘制这些矩形，看看它是否检测到正确的面部。</p><pre class="mw mx my mz gt np lu nq nr aw ns bi"><span id="ac0b" class="mj jr it lu b gy nt nu l nv nw">#go over list of faces and draw them as rectangles on original colored img<br/>for (x, y, w, h) in faces:<br/>    cv2.rectangle(test1, (x, y), (x+w, y+h), (0, 255, 0), 2)</span></pre><p id="77fe" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">显示原始图像以查看绘制的矩形，并验证检测到的人脸确实是人脸，而不是误报。</p><pre class="mw mx my mz gt np lu nq nr aw ns bi"><span id="4b2b" class="mj jr it lu b gy nt nu l nv nw">#conver image to RGB and show image<br/>plt.imshow(convertToRGB(test1))</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/841b4723f9ba88dadd776617bb78b90b.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/0*QDdcdOP69nM071kB.png"/></div></figure><h2 id="e0ec" class="mj jr it bd js mk ml dn jw mm mn dp ka kz mo mp ke ld mq mr ki lh ms mt km mu bi translated">将代码分组到一个函数中</h2><p id="ef40" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果我们将这段代码组合成一个函数，这将是很容易和可重用的，所以让我们用这段代码创建一个函数。</p><pre class="mw mx my mz gt np lu nq nr aw ns bi"><span id="433d" class="mj jr it lu b gy nt nu l nv nw">def detect_faces(f_cascade, colored_img, scaleFactor = 1.1):<br/>    img_copy = np.copy(colored_img)<br/>    #convert the test image to gray image as opencv face detector expects gray images<br/>    gray = cv2.cvtColor(img_copy, cv2.COLOR_BGR2GRAY)<br/>    <br/>    #let's detect multiscale (some images may be closer to camera than others) images<br/>    faces = f_cascade.detectMultiScale(gray, scaleFactor=scaleFactor, minNeighbors=5);<br/>    <br/>    #go over list of faces and draw them as rectangles on original colored img<br/>    for (x, y, w, h) in faces:<br/>        cv2.rectangle(img_copy, (x, y), (x+w, y+h), (0, 255, 0), 2)<br/>        <br/>    return img_copy</span></pre><p id="b625" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">现在让我们在另一个测试图像上尝试这个功能。</p><pre class="mw mx my mz gt np lu nq nr aw ns bi"><span id="fc9f" class="mj jr it lu b gy nt nu l nv nw">#load another image<br/>test2 = cv2.imread('data/test3.jpg')<br/><br/>#call our function to detect faces<br/>faces_detected_img = detect_faces(haar_face_cascade, test2)<br/><br/>#conver image to RGB and show image<br/>plt.imshow(convertToRGB(faces_detected_img))</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/69c86a5f16863b8d6c3c7de48d7b92ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/0*ZFyL9ubbB5anHzWA.png"/></div></figure><h2 id="87c9" class="mj jr it bd js mk ml dn jw mm mn dp ka kz mo mp ke ld mq mr ki lh ms mt km mu bi translated"><code class="fe lr ls lt lu b">detectMultiScale</code>参数详细信息</h2><p id="f527" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">此功能检测给定测试图像中的人脸，以下是其选项的详细信息。</p><ul class=""><li id="8268" class="lv lw it kq b kr lm kv ln kz lx ld ly lh lz ll nx mb mc md bi translated"><code class="fe lr ls lt lu b"><strong class="kq iu">detectMultiScale</strong></code> <strong class="kq iu"> : </strong>检测物体的一般功能。因为我们在face cascade上调用它，所以它检测的就是这个。第一个选项是灰度图像。</li><li id="f3ac" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll nx mb mc md bi translated"><code class="fe lr ls lt lu b"><strong class="kq iu">scaleFactor</strong></code> <strong class="kq iu"> : </strong>因为有些脸可能离镜头更近，所以看起来会比后面的脸大。比例因子对此进行了补偿。</li><li id="3d73" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll nx mb mc md bi translated"><code class="fe lr ls lt lu b"><strong class="kq iu">minNeighbors</strong></code> <strong class="kq iu"> : </strong>检测算法使用移动窗口检测物体。此参数定义了在当前对象附近检测到多少个对象，然后才声明找到了面。</li></ul><p id="e6dd" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">还有其他参数，你可以在这里查看这个函数<a class="ae no" href="http://docs.opencv.org/2.4.13.2/modules/objdetect/doc/cascade_classification.html#cv2.CascadeClassifier.detectMultiScale" rel="noopener ugc nofollow" target="_blank">的全部细节</a>。这些参数需要根据您的数据进行调整。</p><p id="8eb8" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">例如，让我们在另一个测试图像上尝试我们的<code class="fe lr ls lt lu b">Haar</code>人脸检测器。</p><pre class="mw mx my mz gt np lu nq nr aw ns bi"><span id="6a63" class="mj jr it lu b gy nt nu l nv nw">#load another image<br/>test2 = cv2.imread('data/test4.jpg')<br/><br/>#call our function to detect faces<br/>faces_detected_img = detect_faces(haar_face_cascade, test2)<br/><br/>#conver image to RGB and show image<br/>plt.imshow(convertToRGB(faces_detected_img))</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/1437f758a76c227920d30bffc207f097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/0*K1QsHudGJmgvlYo7.png"/></div></figure><p id="65a2" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我们有两个误报。那里出了什么问题？记住，有些脸可能离镜头更近，看起来会比后面的脸大。比例因子对此进行补偿，因此可以调整该参数。比如<code class="fe lr ls lt lu b">scaleFactor=1.2</code>提高了成绩。</p><pre class="mw mx my mz gt np lu nq nr aw ns bi"><span id="da18" class="mj jr it lu b gy nt nu l nv nw">#load another image<br/>test2 = cv2.imread('data/test4.jpg')<br/><br/>#call our function to detect faces<br/>faces_detected_img = detect_faces(haar_face_cascade, test2, scaleFactor=1.2)<br/><br/>#conver image to RGB and show image<br/>plt.imshow(convertToRGB(faces_detected_img))</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/9bbbe7c8f2085f7e82aae6e4a1cf5ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/0*WjMi0iroCVR4ZzZ1.png"/></div></figure><p id="676b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">因此，您必须根据您所掌握的数据信息来调整这些参数。</p><h2 id="63f0" class="mj jr it bd js mk ml dn jw mm mn dp ka kz mo mp ke ld mq mr ki lh ms mt km mu bi translated">代码LBP级联分类器</h2><p id="bca3" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">LBP级联的XML文件存储在<code class="fe lr ls lt lu b">opencv/data/lbpcascades/</code>文件夹中。</p><p id="39a0" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">从编码的角度来看，你不需要改变任何东西，除了，不是加载<code class="fe lr ls lt lu b">Haar</code>分类器训练文件，你必须加载<code class="fe lr ls lt lu b">LBP</code>训练文件，其余的代码是相同的。</p><pre class="mw mx my mz gt np lu nq nr aw ns bi"><span id="23bf" class="mj jr it lu b gy nt nu l nv nw">#load cascade classifier training file for lbpcascade<br/>lbp_face_cascade = cv2.CascadeClassifier('data/lbpcascade_frontalface.xml')<br/><br/>#load test image<br/>test2 = cv2.imread('data/test2.jpg')<br/>#call our function to detect faces<br/>faces_detected_img = detect_faces(lbp_face_cascade, test2)<br/><br/>#conver image to RGB and show image<br/>plt.imshow(convertToRGB(faces_detected_img))</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/6cd31eb8d4b2494ac6bf2164648655f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/0*W0QtOvHcMJYJva6a.png"/></div></figure><p id="7f0a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">让我们在另一个测试图像上尝试一下。</p><pre class="mw mx my mz gt np lu nq nr aw ns bi"><span id="1cea" class="mj jr it lu b gy nt nu l nv nw">#load test image<br/>test2 = cv2.imread('data/test3.jpg')<br/>#call our function to detect faces<br/>faces_detected_img = detect_faces(lbp_face_cascade, test2)<br/><br/>#conver image to RGB and show image<br/>plt.imshow(convertToRGB(faces_detected_img))</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/3a36667f4ea6acdc8f3e659c76bc27ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/0*ibb4m9-B5IgH1ElJ.png"/></div></figure><h1 id="5eff" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Haar和LBP结果分析</h1><p id="6e96" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们将在测试和图像上运行<code class="fe lr ls lt lu b">Haar</code>和<code class="fe lr ls lt lu b">LBP</code>,以查看各自的准确性和时间延迟。</p><pre class="mw mx my mz gt np lu nq nr aw ns bi"><span id="37a9" class="mj jr it lu b gy nt nu l nv nw">#load cascade classifier training file for haarcascade<br/>haar_face_cascade = cv2.CascadeClassifier('data/haarcascade_frontalface_alt.xml')<br/>#load cascade classifier training file for lbpcascade<br/>lbp_face_cascade = cv2.CascadeClassifier('data/lbpcascade_frontalface.xml')<br/><br/>#load test image1<br/>test1 = cv2.imread('data/test5.jpg')<br/>#load test image2<br/>test2 = cv2.imread('data/test6.jpg')</span></pre><h2 id="eed0" class="mj jr it bd js mk ml dn jw mm mn dp ka kz mo mp ke ld mq mr ki lh ms mt km mu bi translated">测试1</h2><pre class="mw mx my mz gt np lu nq nr aw ns bi"><span id="746b" class="mj jr it lu b gy nt nu l nv nw">#------------HAAR-----------<br/>#note time before detection<br/>t1 = time.time()<br/><br/>#call our function to detect faces<br/>haar_detected_img = detect_faces(haar_face_cascade, test1)<br/><br/>#note time after detection<br/>t2 = time.time()<br/>#calculate time difference<br/>dt1 = t2 - t1<br/>#print the time differene<br/><br/>#------------LBP-----------<br/>#note time before detection<br/>t1 = time.time()<br/><br/>lbp_detected_img = detect_faces(lbp_face_cascade, test1)<br/><br/>#note time after detection<br/>t2 = time.time()<br/>#calculate time difference<br/>dt2 = t2 - t1<br/>#print the time differene<br/><br/>#----------Let's do some fancy drawing-------------<br/>#create a figure of 2 plots (one for Haar and one for LBP)<br/>f, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))<br/><br/>#show Haar image<br/>ax1.set_title('Haar Detection time: ' + str(round(dt1, 3)) + ' secs')<br/>ax1.imshow(convertToRGB(haar_detected_img))<br/><br/>#show LBP image<br/>ax2.set_title('LBP Detection time: ' + str(round(dt2, 3)) + ' secs')<br/>ax2.imshow(convertToRGB(lbp_detected_img))<br/><br/>#show images<br/># plt.imshow(faces_detected_img)</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi oc"><img src="../Images/70988ab202b5240bd0e87017ed10b6e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cRgXx-aYBwQ38iA2.png"/></div></div></figure><ul class=""><li id="65c5" class="lv lw it kq b kr lm kv ln kz lx ld ly lh lz ll nx mb mc md bi translated">准确性:<code class="fe lr ls lt lu b">Haar</code>和<code class="fe lr ls lt lu b">LBP</code>都成功检测到人脸。</li><li id="857e" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll nx mb mc md bi translated">速度:<code class="fe lr ls lt lu b">LBP</code>比<code class="fe lr ls lt lu b">Haar</code>快。</li></ul><h2 id="7058" class="mj jr it bd js mk ml dn jw mm mn dp ka kz mo mp ke ld mq mr ki lh ms mt km mu bi translated">测试2</h2><pre class="mw mx my mz gt np lu nq nr aw ns bi"><span id="7d2b" class="mj jr it lu b gy nt nu l nv nw">#------------HAAR-----------<br/>#note time before detection<br/>t1 = time.time()<br/><br/>#call our function to detect faces<br/>haar_detected_img = detect_faces(haar_face_cascade, test2)<br/><br/>#note time after detection<br/>t2 = time.time()<br/>#calculate time difference<br/>dt1 = t2 - t1<br/>#print the time differene<br/><br/>#------------LBP-----------<br/>#note time before detection<br/>t1 = time.time()<br/><br/>lbp_detected_img = detect_faces(lbp_face_cascade, test2)<br/><br/>#note time after detection<br/>t2 = time.time()<br/>#calculate time difference<br/>dt2 = t2 - t1<br/>#print the time differene<br/><br/>#----------Let's do some fancy drawing-------------<br/>#create a figure of 2 plots (one for Haar and one for LBP)<br/>f, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))<br/><br/>#show Haar image<br/>ax1.set_title('Haar Detection time: ' + str(round(dt1, 3)) + ' secs')<br/>ax1.imshow(convertToRGB(haar_detected_img))<br/><br/>#show LBP image<br/>ax2.set_title('LBP Detection time: ' + str(round(dt2, 3)) + ' secs')<br/>ax2.imshow(convertToRGB(lbp_detected_img))<br/><br/>#show images<br/># plt.imshow(faces_detected_img)</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi od"><img src="../Images/9ce14a0fe82e7c7e87c32d23f936ca2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jFvnDNqsYb0kySiB.png"/></div></div></figure><ul class=""><li id="e4cf" class="lv lw it kq b kr lm kv ln kz lx ld ly lh lz ll nx mb mc md bi translated">准确性:<code class="fe lr ls lt lu b">Haar</code>比<code class="fe lr ls lt lu b">LBP</code>检测到更多的人脸。</li><li id="f97a" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll nx mb mc md bi translated">速度:<code class="fe lr ls lt lu b">LBP</code>明显快于<code class="fe lr ls lt lu b">Haar</code>。</li></ul><h1 id="2c48" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结束注释</h1><p id="a861" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">正如你所看到的,<code class="fe lr ls lt lu b">LBP</code>比<code class="fe lr ls lt lu b">Haar</code>快得多，在准确性上也没有落后太多，所以根据你的应用需要，你可以使用任何上述的人脸检测算法。尝试代码，并享受检测不同的脸和分析结果的乐趣。还有别忘了感谢OpenCV给出了上述算法的实现。</p><p id="0f17" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">人脸检测具有丰富的实时应用，包括人脸识别、情感检测(微笑检测)、面部特征检测(如眼睛)、人脸跟踪等。您还可以探索OpenCV库中更令人兴奋的机器学习和计算机视觉算法。</p><p id="1639" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">你可以从这个<a class="ae no" href="https://github.com/informramiz/Face-Detection-OpenCV" rel="noopener ugc nofollow" target="_blank"> repo </a>下载完整的代码，以及测试图像和LBP和Haar训练文件。</p><p id="3223" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在我的下一篇文章中，我会讨论如何使用这个人脸检测代码来做<a class="ae no" href="https://medium.com/@informramiz/face-recognition-with-opencv-and-python-f51fb0389254" rel="noopener">人脸识别</a>，如果你有兴趣，可以看看。</p><p id="f71f" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我喜欢玩游戏和分享我的想法，所以如果你感兴趣，就来我的<a class="ae no" href="https://www.youtube.com/channel/UCRfBKh1u3nXzkTmKBWqDo5A" rel="noopener ugc nofollow" target="_blank"> YouTube频道</a>关注我吧。还有，在<a class="ae no" href="https://twitter.com/informramiz" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae no" href="https://www.instagram.com/informramiz" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上关注我，看看我是怎么玩art和NFT的。</p><p id="bdbb" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">如果你有兴趣加入任何自由职业者/远程平台，我会推荐你去。这是我的<a class="ae no" href="https://topt.al/nVcw5a" rel="noopener ugc nofollow" target="_blank">总推荐链接</a>！</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="a014" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><em class="ol">原载于</em><a class="ae no" href="https://github.com/informramiz/Face-Detection-OpenCV/blob/master/README.md" rel="noopener ugc nofollow" target="_blank"><em class="ol">https://github.com/informramiz</em></a><em class="ol">。</em></p></div></div>    
</body>
</html>