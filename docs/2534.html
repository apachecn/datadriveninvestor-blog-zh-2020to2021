<html>
<head>
<title>Batch vs Mini-batch vs Stochastic Gradient Descent with Code Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">批量与小批量与随机梯度下降的比较及代码示例</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/batch-vs-mini-batch-vs-stochastic-gradient-descent-with-code-examples-cd8232174e14?source=collection_archive---------1-----------------------#2020-05-05">https://medium.datadriveninvestor.com/batch-vs-mini-batch-vs-stochastic-gradient-descent-with-code-examples-cd8232174e14?source=collection_archive---------1-----------------------#2020-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2220" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在研究机器学习和深度学习时出现的一个主要问题是梯度下降的几种类型。我应该使用批量梯度下降吗？小批量梯度下降还是随机梯度下降？在这篇文章中，我们将理解这些概念之间的区别，并从梯度下降的角度来看代码实现，以阐明这些方法。</p><p id="59a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">编辑:</em> </strong> <em class="kl">更新版</em> <a class="ae km" href="https://edgeaiguru.com/Batch-vs-Mini-batch-vs-Stochastic-Gradient-Descent" rel="noopener ugc nofollow" target="_blank"> <em class="kl">此处</em> </a> <em class="kl">。</em></p><p id="0331" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我们知道我们的权重矩阵<strong class="jp ir"> W </strong>和我们的偏差向量<strong class="jp ir"> b </strong>是我们的神经网络(NN)的核心值(查看深度学习基础篇)。我们可以将这些概念与神经网络存储模式的存储器进行类比，通过调整这些参数，我们可以教授神经网络。调整的动作是通过优化算法来完成的，这一惊人的特性使神经网络能够学习。在训练网络一段时间后，这些模式被学习，我们有一组权重和偏差，有希望正确分类输入。</p><h1 id="7a5a" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">梯度下降</h1><p id="b278" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">帮助神经网络达到正确的权重和偏差值的最常见算法之一。梯度下降(GD)是在每一步中最小化成本函数J(W，b)的算法。它迭代地更新权重和偏差，试图达到成本函数中的全局最小值。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lq"><img src="../Images/9ebf58cb0103b2c43e22f76c4a587e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yyrkm6wnNu7csvLLQd0n1g.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Minimizing the Cost Function, a Gradient Descent Illustration. Source: <a class="ae km" href="https://www.coursera.org/learn/machine-learning" rel="noopener ugc nofollow" target="_blank">Stanford’s Andrew Ng’s MOOC Machine Learning Course</a></figcaption></figure><p id="c347" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快速回顾一下，在我们计算GD之前，首先获取输入并通过神经网络的所有节点，计算输入、权重和偏差的加权和。第一次通过是计算梯度下降的主要步骤之一，称为<strong class="jp ir">正向传播</strong>。一旦我们有了一个输出，我们将这个输出与预期输出进行比较，并计算两者之间的距离，即误差。有了这个误差，我们现在可以将它向后传播，更新每个权重和偏差，并尝试最小化这个误差。正如你所料，这部分被称为<strong class="jp ir">反向传播</strong>。使用导数计算反向传播步长，并返回“梯度”，这些值告诉我们应该沿着哪个方向最小化成本函数。</p><p id="8d67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在准备更新权重矩阵W和偏置向量b。梯度下降规则如下:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/513c15208182f3a2722726f38bb97b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*HThkviCBCvHvZ78pB5PxNA.png"/></div></figure><p id="c8bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">换句话说，新的权重/偏移值将是最后一个减去梯度的值，使其接近成本函数的全局最小值。我们还将这个梯度乘以学习率α，学习率α控制步长的大小。对于更深入的方法向前和向后传播，计算损失，梯度下降，检查这个职位。</p><p id="045f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种经典的梯度下降也称为批量梯度下降。在这种方法中，每个历元贯穿所有训练数据集，然后计算损失并更新W和b值。尽管它提供了稳定的收敛和稳定的误差，但是该方法使用了整个训练集；因此，对于大数据集来说，速度非常慢。</p><h1 id="e9f1" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">小批量梯度下降</h1><p id="21ff" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">想象一下，把你的数据集分成几块，或者几批。因此，不是等到算法运行整个数据集之后才更新权重和偏差，而是在每个所谓的小批量结束时更新。这允许我们快速移动到成本函数中的全局最小值，并且现在每个时期多次更新权重和偏差。最常见的小批量是16、32、64、128、256和512。大多数项目使用小批量GD，因为它在较大的数据集中速度更快。</p><ul class=""><li id="41ec" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><strong class="jp ir">小批量梯度下降</strong>:</li></ul><pre class="lr ls lt lu gt mq mr ms mt aw mu bi"><span id="ab3b" class="mv ko iq mr b gy mw mx l my mz">X = data_input<br/>Y = labels<br/>parameters = initialize_parameters(layers_dims)</span><span id="ac56" class="mv ko iq mr b gy na mx l my mz">for i in range(0, num_iterations):<br/>	<br/>	minibatches = random_mini_batches(X, Y, mini_batch_size)</span><span id="1a18" class="mv ko iq mr b gy na mx l my mz">        for minibatch in minibatches:</span><span id="c7d8" class="mv ko iq mr b gy na mx l my mz">            # Select a minibatch<br/>	    (minibatch_X, minibatch_Y) = minibatch<br/>	    # Forward propagation<br/>	    a, caches = forward_propagation(X, parameters)<br/>	    # Compute cost.<br/>	    cost += compute_cost(a, Y)<br/>	    # Backward propagation.<br/>	    grads = backward_propagation(a, caches, parameters)<br/>	    # Update parameters.<br/>	    parameters = update_parameters(parameters, grads)</span></pre><p id="1e67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了准备小批量，大多数应用一些预处理步骤:随机化数据集以随机分割数据集，然后将其划分为正确数量的块。但是，如果我们选择将批次数设置为1或等于训练样本数，会发生什么情况呢？</p><h1 id="d584" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">批量梯度下降</h1><p id="c406" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">如前所述，在这种梯度下降中，每个批次等于整个数据集。那就是:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/0de89b22c5a129d0d5b160db80e741cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*7302m-ZEF8Ate3vGGUYC-g.png"/></div></figure><p id="351a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中{1}表示小型批次中的第一批。缺点是每次迭代花费的时间太长。该方法可用于训练少于2000个训练样本的数据集。</p><ul class=""><li id="5825" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><strong class="jp ir">(批次)梯度下降</strong>:</li></ul><pre class="lr ls lt lu gt mq mr ms mt aw mu bi"><span id="a15d" class="mv ko iq mr b gy mw mx l my mz">X = data_input<br/>Y = labels<br/>parameters = initialize_parameters(layers_dims)</span><span id="8edf" class="mv ko iq mr b gy na mx l my mz">for i in range(0, num_iterations):</span><span id="3b12" class="mv ko iq mr b gy na mx l my mz">    # Forward propagation<br/>    a, caches = forward_propagation(X, parameters)<br/>    # Compute cost.<br/>    cost += compute_cost(a, Y)<br/>    # Backward propagation.<br/>    grads = backward_propagation(a, caches, parameters)<br/>    # Update parameters.<br/>    parameters = update_parameters(parameters, grads)</span></pre><h1 id="e362" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">随机梯度下降</h1><p id="51fc" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">另一方面，在这种方法中，每一批等于训练集中的一个示例。在此示例中，第一个小批量等于第一个训练示例:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/f41aff9fca9c58e7fd73e9992fe3bb26.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/format:webp/1*FjvP2Gitm9l9gikce0CYFQ.png"/></div></figure><p id="ac3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中(1)表示第一个训练示例。这里的缺点是，它失去了矢量化带来的优势，振荡更多，但收敛更快。</p><ul class=""><li id="e332" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><strong class="jp ir">随机梯度下降</strong>:</li></ul><pre class="lr ls lt lu gt mq mr ms mt aw mu bi"><span id="8fa7" class="mv ko iq mr b gy mw mx l my mz">X = data_input<br/>Y = labels<br/>parameters = initialize_parameters(layers_dims)</span><span id="e919" class="mv ko iq mr b gy na mx l my mz">for i in range(0, num_iterations):</span><span id="5366" class="mv ko iq mr b gy na mx l my mz">    for j in range(0, m):</span><span id="ef9a" class="mv ko iq mr b gy na mx l my mz">        # Forward propagation<br/>        a, caches = forward_propagation(X[:,j], parameters)<br/>        # Compute cost<br/>        cost += compute_cost(a, Y[:,j])<br/>        # Backward propagation<br/>        grads = backward_propagation(a, caches, parameters)<br/>        # Update parameters.<br/>        parameters = update_parameters(parameters, grads)</span></pre><h1 id="fc59" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">摘要</h1><p id="e657" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">理解这些优化算法之间的差异是很重要的，因为它们构成了神经网络的关键功能。综上所述，虽然批量GD比随机GD精度高，但后者速度更快。这两种方法的中间点，也是最常用的小批量GD，结合了两者的优点，可提供良好的精度和性能。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/ad813d5bb5de2e752e9464501a1cd671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*YLNFGMJldpPOtUdO61R1MQ.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Batch vs Stochastic vs Mini-batch Gradient Descent. Source: <a class="ae km" href="https://www.coursera.org/learn/deep-neural-network/" rel="noopener ugc nofollow" target="_blank">Stanford’s Andrew Ng’s MOOC Deep Learning Course</a></figcaption></figure><p id="f0c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以只使用小批量梯度下降代码来实现所有版本的梯度下降，您只需要将mini_batch_size设置为随机GD等于1，或者将训练样本数设置为批量GD。因此，批量、小批量和随机梯度下降之间的主要区别是每个时期使用的样本数量以及达到成本函数的全局最小值所需的时间和精力。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="3cdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">参考:这篇博文基于Coursera的</em><a class="ae km" href="http://deeplearning.ai" rel="noopener ugc nofollow" target="_blank"><em class="kl">Deep learning . ai</em></a><em class="kl"/><a class="ae km" href="https://www.coursera.org/learn/deep-neural-network" rel="noopener ugc nofollow" target="_blank"><em class="kl">改进深度神经网络:超参数调优、正则化和优化课程</em> </a> <em class="kl">。</em></p></div></div>    
</body>
</html>