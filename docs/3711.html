<html>
<head>
<title>10 Functional Testing Tips in Symfony.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Symfony中的10个功能测试技巧。</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/10-functional-testing-tips-in-symfony-a6d8a1185ac1?source=collection_archive---------1-----------------------#2020-07-03">https://medium.datadriveninvestor.com/10-functional-testing-tips-in-symfony-a6d8a1185ac1?source=collection_archive---------1-----------------------#2020-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="874d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过参与超过50个项目的测试，我们看到了测试是如何增强对代码库的信心，开始为整个开发团队节省时间，并帮助满足业务需求的。</p><p id="180c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于那些来自其他生态系统的人，让我们首先解释一下术语“功能测试”在Symfony中的含义。文档中给出了以下定义:</p><blockquote class="km kn ko"><p id="1110" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">“功能测试验证应用程序不同级别的集成(从路由到视图)”。</p></blockquote><p id="ff20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本质上，这些是端到端的测试。您编写向应用程序发送HTTP请求的代码。您得到一个HTTP响应，并基于它做出假设。但是，您可以联系数据库并对数据存储级别进行更改，这有时会为检查状态提供额外的机会。</p><p id="f711" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，<a class="ae kl" href="https://geniusee.com/single-blog/10-functional-testing-tips-in-symfony" rel="noopener ugc nofollow" target="_blank">根据我们的经验，我们准备了10个关于用Symfony编写功能测试的技巧</a>。</p><div class="kt ku gp gr kv kw"><a href="https://www.datadriveninvestor.com/2020/02/14/turn-hobby-showcase-into-money-maker/" rel="noopener  ugc nofollow" target="_blank"><div class="kx ab fo"><div class="ky ab kz cl cj la"><h2 class="bd ir gy z fp lb fr fs lc fu fw ip bi translated">将爱好展示变成赚钱机器|数据驱动的投资者</h2><div class="ld l"><h3 class="bd b gy z fp lb fr fs lc fu fw dk translated">这是造梦者奥斯卡·冈萨雷斯响应号召的地方。他是一名独立的在家工作的顾问，担任…</h3></div><div class="le l"><p class="bd b dl z fp lb fr fs lc fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="lf l"><div class="lg l lh li lj lf lk ll kw"/></div></div></a></div><h1 id="1391" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">1.使用数据存储层进行测试</h1><p id="7605" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">运行功能测试时，您可能要做的第一件事就是将测试基础与开发基础分开。这样做是为了创建一个运行测试的干净工作台，并允许您创建和管理应用程序的期望状态。此外，测试不应该将随机数据写入开发数据库的副本。</p><p id="3032" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，当运行测试时，Symfony应用程序连接到另一个数据库。如果您有Symfony 4或5，那么您可以在. env.test文件中定义用于测试的环境变量。另外，配置PHPUnit，将环境变量APP_ENV更改为test。幸运的是，当您安装PHPUnit Bridge的Symfony组件时，默认情况下会发生这种情况。</p><p id="0c71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于低于4的版本，当您运行功能测试时，您可以在测试模式下使用内核引导。使用config_test.yml文件，您可以定义您的测试配置。</p><h1 id="d2d0" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">2.LiipFunctionalTestBundle</h1><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mp"><img src="../Images/eb71eb73b117645cd15418bfaa964bae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Rpb1RQzPSUy-XuN1.png"/></div></div></figure><p id="5b74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个包包含了一些编写Symfony测试的重要支持工具。有时他试图做得太多，可能会干涉，但总的来说有助于工作。</p><p id="75e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，在测试期间，您可以模拟用户输入，上传夹具数据，统计数据库查询以检查回归性能，等等。我们建议在开始测试新的Symfony应用程序时安装这个包。</p><h1 id="1ac6" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">3.每次测试后清理数据库</h1><p id="68a3" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">测试期间我什么时候需要清洁底座？Symfony工具包没有给出提示。我们更喜欢在每个测试方法之后更新数据库。测试套件如下所示:</p><pre class="mq mr ms mt gt na nb nc nd aw ne bi"><span id="d9ac" class="nf ln iq nb b gy ng nh l ni nj">&lt;?php<br/>namespace Tests;<br/>use Tests\BaseTestCase;<br/>class SomeControllerTest extends TestCase<br/>{<br/>public function test_a_registered_user_can_login()<br/>{<br/>// Clean slate. Database is empty.<br/>// Create your world. Create users, roles and data.<br/>// Execute logic<br/>// Assert the outcome.<br/>// Database is reset.<br/>}</span><span id="0bec" class="nf ln iq nb b gy nk nh l ni nj">}</span></pre><p id="5e21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">清理数据库的一个很好的方法是将空的fixtures加载到PHPUnit中一个特殊的setUp方法中。如果已经安装了LiipFunctionalTestBundle，就可以这样做。</p><pre class="mq mr ms mt gt na nb nc nd aw ne bi"><span id="e8f8" class="nf ln iq nb b gy ng nh l ni nj">&lt;?php<br/>namespace Tests;<br/>class BaseTestCase extends PHPUnit_Test_Case<br/>{<br/>public function setUp()<br/>{<br/>$this-&gt;loadFixtures([]);<br/>}<br/>}</span></pre><h1 id="a7f3" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">4.数据创建</h1><p id="fc5d" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">如果您从一个空数据库开始每个测试，那么您需要有几个实用程序来创建测试数据。这些可以是数据库创建模型或实体对象。</p><p id="aeed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Laravel对模型工厂有一个非常简单的方法。我们试着遵循同样的方法，制作创建我经常在测试中使用的对象的接口。下面是一个创建用户实体的简单界面示例:</p><pre class="mq mr ms mt gt na nb nc nd aw ne bi"><span id="e40b" class="nf ln iq nb b gy ng nh l ni nj">&lt;?php<br/>namespace Tests\Helpers;<br/>use AppBundle\Entity\User;<br/>trait CreatesUsers<br/>{<br/>public function makeUser(): User<br/>{<br/>$user = new User();<br/>$user-&gt;setEmail($this-&gt;faker-&gt;email);<br/>$user-&gt;setFirstName($this-&gt;faker-&gt;firstName);<br/>$user-&gt;setLastName($this-&gt;faker-&gt;lastName);<br/>$user-&gt;setRoles([User::ROLE_USER]);<br/>$user-&gt;setBio($this-&gt;faker-&gt;paragraph);<br/>return $user;<br/>}</span></pre><p id="3a0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以将这样的接口添加到所需的测试套件中:</p><pre class="mq mr ms mt gt na nb nc nd aw ne bi"><span id="9661" class="nf ln iq nb b gy ng nh l ni nj">&lt;?php<br/>namespace Tests;<br/>use Tests\BaseTestCase;<br/>use Tests\Helpers\CreatesUsers;<br/>class SomeControllerTest extends TestCase<br/>{<br/>use CreatesUsers;<br/>public function test_a_registered_user_can_login()<br/>{<br/>$user = $this-&gt;createUser();<br/>// Login as a user. Do some tests.<br/>}<br/>}</span></pre><h1 id="dd4e" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">5.替换容器中的服务</h1><p id="07b4" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">在Laravel应用程序中，在容器中交换服务非常容易，但是在Symfony项目中，这就比较困难了。在Symfony 3.4–4.1版本中，容器中的服务被标记为私有。这意味着在编写测试时，您不能访问容器中的服务，也不能指定另一个服务(存根)。</p><p id="6d35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管有些人认为功能测试不需要使用存根，但是可能会有这样的情况，您没有第三方服务的沙箱，并且您不想给他们随机的测试数据。</p><p id="fa0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，在Symfony 4.1中，您可以按照自己的意愿访问容器和更改服务。例如:</p><pre class="mq mr ms mt gt na nb nc nd aw ne bi"><span id="2ed8" class="nf ln iq nb b gy ng nh l ni nj">&lt;?php<br/>namespace Tests\AppBundle;<br/>use AppBundle\Payment\PaymentProcessorClient;<br/>use Tests\BaseTestCase;<br/>class PaymentControllerTest extends BaseTestCase<br/>{<br/>public function test_a_user_can_purchase_product()<br/>{<br/>$paymentProcessorClient = $this-&gt;createMock(PaymentProcessorClient::class);<br/>$paymentProcessorClient-&gt;expects($this-&gt;once())<br/>-&gt;method('purchase')<br/>-&gt;willReturn($successResponse);<br/>// this is a hack to make the container use the mocked instance after the redirects<br/>$client-&gt;disableReboot();<br/>$client-&gt;getContainer()-&gt;set(PaymentProcessorClient::class, $paymentProcessorClient)<br/>}<br/>}</span></pre><p id="a86e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是请注意，在功能测试期间，Symfony核心可以在测试期间启动几次，重新组装所有依赖项并丢弃您的存根。</p><h1 id="1768" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">6.内存中的SQLite执行</h1><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/e4e26662fa54b771df301006099cab99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*WT0T11V_MquVsZ9w.jpg"/></div></figure><p id="31d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在测试时，SQLite经常被用作数据存储层，因为它非常紧凑并且非常容易配置。这些特性也使得它在CI / CD环境中使用非常方便。</p><p id="4292" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">SQLite是无服务器的，即程序将从文件中写入和读取所有数据。毫无疑问，这将成为性能方面的瓶颈，因为I / O操作增加了，其完成将不得不等待。因此，您可以使用内存选项。然后，数据将从内存中写入和读取，这可以加快操作速度。</p><p id="e651" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Symfony应用中配置数据库时，不需要指定database.sqlite文件，只需用关键字:memory:进行传输即可。</p><h1 id="c9c0" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">7.使用tmpfs在内存中执行SQLite</h1><p id="f8ed" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">在内存中工作很好，但是有时用旧版本的LiipFunctionalTestBundle配置这种模式会非常困难。如果你也碰到这个，那就有这样一招。</p><p id="dba9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Linux系统上，您可以分配部分RAM，这将像正常存储一样。这就是所谓的tmpfs。本质上，您创建一个tmpfs文件夹，将SQLite文件放入其中，并使用它来运行测试。</p><p id="3e0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以对MySQL使用相同的方法，但是设置会更复杂。</p><h1 id="dd1e" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">8.弹性搜索级别测试</h1><p id="fcd3" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">与连接到数据库的测试实例一样，您也可以连接到Elasticsearch的测试实例。或者更好的是:您可以使用其他索引名称来以这种方式分隔测试和开发环境。</p><p id="b63d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试Elasticsearch看似简单，但实际上可能很难。我们有强大的工具来生成数据库模式、创建夹具以及用测试数据填充数据库。当涉及到Elasticsearch时，这些工具可能不存在，你必须创建你的解决方案。也就是说，很难进行测试。</p><p id="f4b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还存在着为新数据编制索引和确保信息可用性的问题。一个常见的错误是Elasticsearch的更新间隔。通常，经过配置中指定的时间后，索引文档变得可搜索。默认情况下，这是1秒钟，如果你不小心，它可能会成为你测试的一个插头。</p><h1 id="84bb" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">9.使用Xdebug过滤器加速覆盖率报告</h1><p id="7c06" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">覆盖率是测试的一个重要方面。不需要把它当作素数，它有助于在代码中找到未测试的分支和线程。</p><p id="fbfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，Xdebug负责评估覆盖率。</p><p id="37a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将会看到，开始覆盖率分析降低了测试的速度。在每分钟都要花钱的CI / CD环境中，这可能是一个问题。</p><p id="c312" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，可以进行一些优化。当Xdebug生成运行测试的覆盖率报告时，它会对测试中的每个PHP文件都这样做。这包括位于供应商文件夹中的文件—不属于我们的代码。</p><p id="7ec9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过在Xdebug中设置代码覆盖过滤器，我们可以让它不对我们不需要的文件生成报告，从而节省大量时间。</p><p id="b318" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何创建过滤器？这可以通过PHPUnit来实现。创建过滤器配置文件只需要一个命令:</p><pre class="mq mr ms mt gt na nb nc nd aw ne bi"><span id="9966" class="nf ln iq nb b gy ng nh l ni nj">phpunit --dump-xdebug-filter build/xdebug-filter.php</span></pre><p id="8c58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们在运行测试时传递这个配置:</p><pre class="mq mr ms mt gt na nb nc nd aw ne bi"><span id="522e" class="nf ln iq nb b gy ng nh l ni nj">phpunit --prepend build/xdebug-filter.php --coverage-html build/coverage-report</span></pre><h1 id="3fbb" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">10.并行化工具</h1><p id="b614" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">运行功能测试会花费很多时间。例如，一组77个测试和524个假设的完整运行可能需要3-4分钟。这是正常的，考虑到每个测试都会对数据库进行一系列查询，生成模式簇，在这些模式上运行爬虫，并做出某些假设。</p><p id="b7dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您打开活动监视器，您会看到测试只使用了计算机的一个核心。您可以使用paratest和fast等并行化工具来使用其他内核。它们很容易配置来运行单元测试，如果您需要数据库连接，您可能需要修补。</p><p id="fce6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望这些建议对你有用。如果您有任何问题— <a class="ae kl" href="https://geniusee.com" rel="noopener ugc nofollow" target="_blank">请填写联系我们表格。你可以在我们的</a><a class="ae kl" href="https://geniusee.com/blog" rel="noopener ugc nofollow" target="_blank">博客</a>中找到更多有趣的文章。</p><p id="d8b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">进入专家视角— </strong> <a class="ae kl" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>