<html>
<head>
<title>Aborting/Cancelling requests with Fetch or Axios</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Fetch或Axios中止/取消请求</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/aborting-cancelling-requests-with-fetch-or-axios-db2e93825a36?source=collection_archive---------0-----------------------#2020-09-16">https://medium.datadriveninvestor.com/aborting-cancelling-requests-with-fetch-or-axios-db2e93825a36?source=collection_archive---------0-----------------------#2020-09-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a6183d71a9bb903161469b3dff2033db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*47HNugix0IvZ0fo14GB5RA.png"/></div></div></figure><div class=""/><div class=""><h2 id="008d" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">Axios取消和获取中止</h2></div><p id="73e6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">异步行为是JS中任何<strong class="ks jc"> XHR </strong>调用的基础。处理这种行为以产生期望的输出，可能看起来很容易。毕竟这只是一个简单的<em class="lm">承诺。然后或等待，但随着条件的变化，解决方案必须改变以适应它们。</em></p><p id="5902" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有时，用户可能会使用不同的输入多次调用一个事件。当JS向端点发出异步请求时，人们不能认为响应也是同样的顺序。</p><figure class="lo lp lq lr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ln"><img src="../Images/abfb4208b4f73718ed3a0e76f4a4adff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4_9QE6bnxjhJbxZgKxLTKg.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">same event tiggers multiple request</figcaption></figure><p id="80c6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">最简单的方法是让事情以某种方式同步，但这没有意义。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="6609" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果我们能在一个新的请求产生之前，仅仅<strong class="ks jc"> <em class="lm">取消</em> </strong> <em class="lm">请求</em>会怎么样。</p><p id="3269" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">例如，让我们以<em class="lm">可观察模式为例，</em>您创建了一个<em class="lm">订阅</em>，在进行新的订阅之前，<em class="lm">销毁之前的订阅</em>是可行的方法。</p><p id="c66b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果一个请求没有被满足，<strong class="ks jc">在提出新的请求之前中止/取消</strong>该请求可以帮助我们接受类似的行为。</p><p id="ea6a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">理论上，我们的解决方案应该是这样的:</p><figure class="lo lp lq lr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi md"><img src="../Images/c0d79f1b45c16c93aedf8916a1bdac23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dqlw_tf2fdiH_x94FJe2Yg.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">If request is not fulfilled, cancel the request</figcaption></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="8402" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这可以通过使用<a class="ae me" href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController" rel="noopener ugc nofollow" target="_blank"> <strong class="ks jc">人工控制器</strong></a><strong class="ks jc"/>来实现，这是一个内置的浏览器界面。</p><p id="c00a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="lm">*注意:这适用于fetch，axios有自己的实现</em></p><pre class="lo lp lq lr gt mf mg mh mi aw mj bi"><span id="f97b" class="mk ml jb mg b gy mm mn l mo mp">const controller = new AbortController();<br/>const signal = controller.signal</span></pre><p id="8f02" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">Signal表示一个信号对象，它允许您与DOM请求(如Fetch)进行通信，并在需要时通过AbortController对象中止它。该信号作为参数在<strong class="ks jc">获取请求:</strong>中传递</p><pre class="lo lp lq lr gt mf mg mh mi aw mj bi"><span id="3a41" class="mk ml jb mg b gy mm mn l mo mp">fetch("http://localhost:4001/", { signal });</span></pre><p id="ad24" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了演示Abort，我使用了一个基本的express服务器和一个React前端，你可以在这里  检查解决方案<a class="ae me" href="https://github.com/devAbhimanyu/AbortApiRequest" rel="noopener ugc nofollow" target="_blank"> <strong class="ks jc"> <em class="lm">。</em></strong></a></p><figure class="lo lp lq lr gt is gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/4225b7fa516a38d1be36ce40e54a72b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*M1r1cQTt07NGPMHU60rkIg.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">On click, a new request is generated</figcaption></figure><p id="70c6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">每次点击“<strong class="ks jc">创建获取请求</strong>”时，都会产生一个新的请求，旧的请求会被中止，如下图所示。</p><figure class="lo lp lq lr gt is gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/ef9f372f70f3df003669270a09d4756b.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*XHmKuFwo91QMX3jBFlSYsw.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">If clicked before the response, the previous request is aborted</figcaption></figure><p id="5e1c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了实现这一点，必须将请求包装在订阅中，以便在发出新的请求(订阅)之前，关闭先前的订阅。</p><p id="1364" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在React中，我们可以通过使用“<strong class="ks jc"> useEffect </strong>”钩子来实现这一点。清理功能可用于释放订阅。</p><pre class="lo lp lq lr gt mf mg mh mi aw mj bi"><span id="0f4d" class="mk ml jb mg b gy mm mn l mo mp">useEffect(() =&gt; {<br/> const controller = new <strong class="mg jc">AbortController()</strong>;<br/> const <strong class="mg jc">signal</strong> = controller.signal;<br/> setFetchRes("fetch request created");<br/> hitApi(<strong class="mg jc">signal</strong>).then((res) =&gt; {<br/>  setFetchRes(res);<br/> });<br/> //cleanup function<br/> return () =&gt; {<strong class="mg jc">controller.abort()</strong>;};<br/>}, [fetchClick]);</span></pre><p id="fb89" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这个"<strong class="ks jc">信号"</strong>被传递给请求:</p><pre class="lo lp lq lr gt mf mg mh mi aw mj bi"><span id="2881" class="mk ml jb mg b gy mm mn l mo mp">const response = await fetch("http://localhost:4001/", { <strong class="mg jc">signal</strong> });</span></pre><p id="4cf1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一旦请求被取消，还需要检查请求失败的<em class="lm">原因是中止还是实际失败。</em></p><p id="2048" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">使用AbortControlled时，如果请求被中止，error.name属性将为"<em class="lm"> AbortError </em>"</p><pre class="lo lp lq lr gt mf mg mh mi aw mj bi"><span id="68fe" class="mk ml jb mg b gy mm mn l mo mp">catch (err) {<br/> if (err.name === "AbortError") {<br/>  return "Request Aborted ";<br/> }<br/> return err;<br/>}</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="66d8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">让我们看看如何用<strong class="ks jc">轴</strong>实现同样的效果</p><p id="38fd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在Axios中，我们需要生成一个<strong class="ks jc">取消令牌。</strong>可以使用CancelToken.source方法生成令牌。</p><pre class="lo lp lq lr gt mf mg mh mi aw mj bi"><span id="6923" class="mk ml jb mg b gy mm mn l mo mp">const cancelToken = axios.CancelToken;<br/>const <strong class="mg jc">source</strong> = cancelToken.source();</span></pre><p id="2e62" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这个<strong class="ks jc">源</strong>然后被传递给axios请求:</p><pre class="lo lp lq lr gt mf mg mh mi aw mj bi"><span id="f921" class="mk ml jb mg b gy mm mn l mo mp">const { data } = await instance.get("/", {<br/>  cancelToken: source.token,<br/>});</span></pre><p id="fdd7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我将使用与上述AbortController示例中相同的模式:</p><figure class="lo lp lq lr gt is gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/678bfc8dabfe3bcd7c3f4357d352c274.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*V38C7QICdU5NlzlrshOoCg.png"/></div></figure><p id="21b6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">源</strong>包含<em class="lm">取消</em>方法，可以调用该方法来中止/取消请求。</p><pre class="lo lp lq lr gt mf mg mh mi aw mj bi"><span id="a3d5" class="mk ml jb mg b gy mm mn l mo mp">useEffect(() =&gt; {<br/> const cancelToken = axios.CancelToken;<br/> const <strong class="mg jc">source</strong> = cancelToken.source();<br/> setAxiosRes("axios request created");<br/> getReq(source).then((res) =&gt; { setAxiosRes(res);});<br/> <br/> return () =&gt; {<br/>  <strong class="mg jc">source.cancel</strong>("axios request cancelled");<br/> };<br/>}, [axiosClick]);</span></pre><p id="0fcc" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了检查请求是否被取消，Axios为我们提供了"<em class="lm"> isCancel" </em>方法，该方法可用于确定请求失败的原因。</p><pre class="lo lp lq lr gt mf mg mh mi aw mj bi"><span id="d7ca" class="mk ml jb mg b gy mm mn l mo mp">catch (err) {<br/> if (axios.isCancel(err)) {<br/>  return "axios request cancelled";<br/> }<br/>return err;<br/>}</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="13c4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我希望你能取消/中止你的任何请求。要查看示例代码，可以在这里  查看git解决方案<a class="ae me" href="https://github.com/devAbhimanyu/AbortApiRequest" rel="noopener ugc nofollow" target="_blank"> <strong class="ks jc"> <em class="lm">。</em></strong></a></p><p id="874c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果有任何问题或疑问，请告诉我。</p></div></div>    
</body>
</html>