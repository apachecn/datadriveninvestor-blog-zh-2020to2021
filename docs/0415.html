<html>
<head>
<title>Quick fix for extracting time-series data from SQL Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从SQL Server提取时序数据的快速修复</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/quick-fix-to-importing-time-series-data-from-sql-server-93ad77f9b3d0?source=collection_archive---------5-----------------------#2020-01-29">https://medium.datadriveninvestor.com/quick-fix-to-importing-time-series-data-from-sql-server-93ad77f9b3d0?source=collection_archive---------5-----------------------#2020-01-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/72a5db172cc1822e699eeccb059363f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*12BfUx8eG0t8Bl2RuXnj8w.png"/></div></figure><p id="c1f7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">随着现代预测算法和技术的出现，时间序列数据和分析变得极其重要，它适用于所有行业结构。但有时使用好的旧SQL server会非常麻烦，特别是准备连续的时间序列数据，按时间索引分组，处理缺失值或用0替换缺失值！</p><p id="a1a0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，这是非常必要的，不仅是为了生成时间序列预测，甚至是为了绘制连续的时间序列图，其中你需要有0值，使你的信号或图看起来像一个连续的信号，而不是一个离散的！</p><p id="46af" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">说了这么多，还是跳到精确解吧！</p><p id="0460" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果您有一个简单的表，并且希望获得某个特定字段的每月计数，则典型的查询如下所示:</p><blockquote class="kv kw kx"><p id="f164" class="jx jy ky jz b ka kb kc kd ke kf kg kh kz kj kk kl la kn ko kp lb kr ks kt ku im bi translated">选择DATEADD(MONTH，DATEDIFF(MONTH，0，T.CreatedOn)，0)作为月份，</p><p id="c3b6" class="jx jy ky jz b ka kb kc kd ke kf kg kh kz kj kk kl la kn ko kp lb kr ks kt ku im bi translated">将(T.CreatedOn)计为[计数]</p><p id="7783" class="jx jy ky jz b ka kb kc kd ke kf kg kh kz kj kk kl la kn ko kp lb kr ks kt ku im bi translated">来自表T</p><p id="ae9c" class="jx jy ky jz b ka kb kc kd ke kf kg kh kz kj kk kl la kn ko kp lb kr ks kt ku im bi translated">GROUP BY DATEADD(MONTH，DATEDIFF(MONTH，0，T.CreatedOn)，0)</p></blockquote><p id="8ebf" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这就是您的SQL server如何从您的表T中为您提供结果，该表将包含一些数据:</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/43f9c829a379972ed93cd87d2524c396.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*DZi9tIMCdBSalbbiAZvFsA.png"/></div></figure><p id="4267" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是你要找的是这个:</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/a521481618e336e879a7655f2630135b.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/format:webp/1*_AhYcAN_DdJwEpM_MiWXUg.png"/></div></figure><p id="a401" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">那么，你到底是怎么做到的呢？</p><p id="6160" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">有什么魔术吗？:)</p><p id="4714" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">显然不是！这可以通过创建一个虚拟表和一个简单的左连接来完成！更新后的脚本应该是这样的:</p><pre class="ld le lf lg gt li lj lk ll aw lm bi"><span id="2763" class="ln lo it lj b gy lp lq l lr ls">IF OBJECT_ID('tempdb..#Results') IS NOT NULL DROP TABLE #Results<br/><br/>CREATE TABLE #Results ( <br/>MonthYear DATE,<br/>[Month] INT, <br/>[Year] INT                         <br/>)<br/><br/>DECLARE @Y1 INT = 2019, @Y2 INT = 2020, @M1 INT = 1, @M2 INT = 12<br/><br/>WHILE @Y1 &lt;= @Y2<br/>BEGIN<br/>        WHILE @M1 &lt;= @M2<br/>        BEGIN<br/>            INSERT INTO #Results (MonthYear, [Month], [Year])<br/>            VALUES(DATEFROMPARTS(@Y1,@M1,1),@M1,@Y1)<br/>            SET @M1 = @M1+1<br/>        END<br/>        SET @Y1 = @Y1 + 1, @M1 = 1<br/>END<br/><br/>SELECT R.MonthYear,<br/>COUNT(T.CreatedOn) AS [Counts]<br/>FROM #Results R<br/>LEFT JOIN MyTable T ON DATEADD(MONTH, DATEDIFF(MONTH, 0, T.CreatedOn), 0) = R.MonthYear<br/>GROUP BY MonthYear</span></pre><p id="a40d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您还可以使用简单的聚合函数(如MAX和MIN)动态分配系列的开始和结束年份，然后分配这些变量。</p><div class="lt lu gp gr lv lw"><a href="https://www.datadriveninvestor.com/2020/02/19/five-data-science-and-machine-learning-trends-that-will-define-job-prospects-in-2020/" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd iu gy z fp mb fr fs mc fu fw is bi translated">将定义2020年就业前景的五大数据科学和机器学习趋势|数据驱动…</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">数据科学和ML是2019年最受关注的趋势之一，毫无疑问，它们将继续发展…</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="mf l"><div class="mg l mh mi mj mf mk jv lw"/></div></div></a></div><p id="7170" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是为了使事情简单，这是如何，手边的问题可以很容易地解决！我们都可以继续享受和老朋友SQL Server在一起的时光:)</p><p id="0a01" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你想要更多关于用SQL Server实现奇特的机器学习和时间序列的文章，请投赞成票并给我留言！</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure></div></div>    
</body>
</html>