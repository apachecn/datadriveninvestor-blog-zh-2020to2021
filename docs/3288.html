<html>
<head>
<title>YOLOv3 From Scratch Using PyTorch(Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PyTorch从头开始使用YOLOv3(第2部分)</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/yolov3-from-scratch-using-pytorch-part-2-2a481c62aa86?source=collection_archive---------3-----------------------#2020-06-10">https://medium.datadriveninvestor.com/yolov3-from-scratch-using-pytorch-part-2-2a481c62aa86?source=collection_archive---------3-----------------------#2020-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e545" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是使用PyTorch(Part1)  从零开始的post <a class="ae kl" href="https://medium.com/datadriveninvestor/yolov3-from-scratch-using-pytorch-part1-474b49f7c8ef" rel="noopener"> <strong class="jp ir"> YOLOv3的延续。请先浏览一下那篇文章。</strong></a></p><p id="9caf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在前一篇文章中，我们已经构建了模型，并加载了权重。现在我们将开始检测物体。我们已经测试了我们的模型，我们得到了大小为[B，10647，85]的输出，其中B是批量图像的数量，10647是边界框的数量，85是边界框属性。</p><p id="1369" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们必须做一个客观分数阈值和非最大值抑制，以获得真正的检测器。让我们看看我们将如何做到这一点。</p><p id="6b2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将把文章分成两部分</p><ol class=""><li id="2559" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated"><strong class="jp ir">客观分数阈值和非最大值抑制</strong></li><li id="ee70" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated"><strong class="jp ir">对不可见图像的检测</strong></li></ol></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="be2a" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">1.客观分数阈值和非最大值抑制</h1><p id="f6a6" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">对于每个边界框，如果客观性分数低于阈值，我们将把每个属性(整行)的值设置为零。</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ea25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在将盒子的(中心x，中心y，高度，宽度)属性转换为(左上角x，左上角y，右下角x，右下角y)。</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="2daa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望在单个图像中进行非最大值抑制。所以我们要做的是批量迭代图像，并对非最大值抑制进行一些操作。首先，我们将选择每行上具有最大类概率的值。现在，我们连接类别号、我们获得的最大概率和相应的边界框坐标。</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="a9ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经将那些客观性分数小于阈值的框的边界框属性设置为零。现在我们将移除它们。</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="947b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于一个图像，可以有多个滞留。我们将筛选出唯一的类，因为我们必须在每个类中执行NMS。</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="bf14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有课了。现在我们将对每个类的bbox属性执行NMS。</p><div class="mr ms gp gr mt mu"><a href="https://www.datadriveninvestor.com/2019/03/22/fixing-photography/" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd ir gy z fp mz fr fs na fu fw ip bi translated">修复摄影|数据驱动的投资者</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">汤姆·津伯洛夫在转向摄影之前曾在南加州大学学习音乐。作为一个…</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni nj mu"/></div></div></a></div><h2 id="5ada" class="nk li iq bd lj nl nm dn ln nn no dp lr jy np nq lv kc nr ns lz kg nt nu md nv bi translated">非最大抑制</h2><p id="80ed" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">如果你不知道非最大压制，我会推荐你去看看我对YOLOv1的评论。现在让我们进入代码</p><p id="0535" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于每个班级，</p><ul class=""><li id="9def" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk nw ks kt ku bi translated">首先，我们将获得属于某个类的检测。</li></ul><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><ul class=""><li id="b382" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk nw ks kt ku bi translated">现在根据包围盒的置信概率对它们进行排序</li></ul><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="0fed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了排序边界框属性的索引。我们将使用<strong class="jp ir"><em class="nx">bounding _ box _ iou</em></strong>函数将可信度高的包围盒与其他包围盒进行比较。一旦我们找到它，我们将用这个边界框消除iou大于阈值的所有框。(我们首先将所有具有置信度的属性&gt;阈值设置为零，然后从中获取非零值)</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="1c4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们查找借据的函数是:</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="776f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们进入检测代码的最后一部分。这里我们将批次id与检测连接起来。这有助于识别检测属于哪幅图像。</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="352b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们的整个代码看起来像这样:</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="fb75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经建造了我们的YOLO天体探测器。让我们来看看它是如何从看不见的图像中发现物体的。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="414e" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">2.对不可见图像的检测</h1><p id="423d" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">现在让我们看看我们将如何预测一个单一的图像。我们将采取以下图像。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi ny"><img src="../Images/def03639c89dd9a1d0733a75b0dbd390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*83xF_2ER-ufty_RPC78EBA.png"/></div></div></figure><p id="81ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将编写一个函数来加载Yolo类(80个类)。</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d583" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们将加载我们的图像并通过网络传递它</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="0f84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="nx"> conf_inp_dim </em> </strong>在yolo提供的配置中抓取输入图像尺寸。</p><p id="92d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="nx">预处理_图像</em> </strong>函数将抓取输入图像并进行预处理。这需要一点解释。</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6d5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"><em class="nx">preprocess _ image</em></strong>函数将配置文件中的图像和尺寸作为输入，并在此基础上构建一个画布。这里调整了图像的大小，保持了纵横比不变，并填充了遗漏的部分。例如，如果我们要将一个1900 x 1280的图像调整为416 x 415，416 x 415尺寸的区域将被图像占据，区域的其余部分将被填充，如下图所示。通过该函数后，图像将被调整到[1，3，608，608]而不改变纵横比。对于这个预处理_图像函数，将调用<strong class="jp ir"> <em class="nx"> canvas_image </em> </strong>函数。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/0be8a15023ca0513e2dbfd92c5ff1663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*Hn-89Rtmtv7t_AxJabaQcw.png"/></div></figure><p id="2d7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们进入代码的下一部分。这里我们将保留原始图像形状的张量，我们将在后面使用。如果GPU(CUDA)可用，我们将把我们的模型和<strong class="jp ir"> <em class="nx"> im_dim </em> </strong>传递给它。现在，通过将模型设置为评估模式，我们可以进行预测。</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6040" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在填充图像上做了预测。但是我们必须在原始图像上绘制边界框。因此，我们将调整边界框的坐标值。</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e8d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们在检测到的类上画出包围盒。</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="0c94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们将检查我们保存的输出:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi of"><img src="../Images/0f68258052152af8efa263fb09717d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*VbnuuFRvEZ-rJPAcqzPH6w.png"/></div></figure><p id="2ef4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一部分的全部代码如下所示</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="53b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们从零开始开发了YOLO检测系统。我想通过阅读这段代码，你会对YOLO的工作方式有一个很好的直觉。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="d686" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">参考</h1><ul class=""><li id="c2ba" class="km kn iq jp b jq mf ju mg jy og kc oh kg oi kk nw ks kt ku bi translated"><a class="ae kl" href="https://blog.paperspace.com/how-to-implement-a-yolo-v3-object-detector-from-scratch-in-pytorch-part-5/" rel="noopener ugc nofollow" target="_blank">https://blog . paper space . com/how-to-implementation-a-yolo-v3-object-detector-from-scratch-in-py torch-part-5/</a></li><li id="7824" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk nw ks kt ku bi translated"><a class="ae kl" href="https://www.kaggle.com/arunmohan003/yolo-v3-pytorch-tutorial" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/arunmohan 003/yolo-v3-py torch-tutorial</a></li><li id="f644" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk nw ks kt ku bi translated"><a class="ae kl" href="https://pjreddie.com/media/files/papers/YOLOv3.pdf" rel="noopener ugc nofollow" target="_blank">https://pjreddie.com/media/files/papers/YOLOv3.pdf</a></li><li id="9a04" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk nw ks kt ku bi translated"><a class="ae kl" href="https://github.com/eriklindernoren/PyTorch-YOLOv3" rel="noopener ugc nofollow" target="_blank">https://github.com/eriklindernoren/PyTorch-YOLOv3</a></li></ul><p id="aeea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">访问专家视图— </strong> <a class="ae kl" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>