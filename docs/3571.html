<html>
<head>
<title>Let’s Create Training App For IOS Using Swift UI Interaction With Redux.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们使用Redux的Swift UI交互为IOS创建培训应用程序。</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/lets-create-training-app-for-ios-using-swift-ui-interaction-with-redux-f0314c731732?source=collection_archive---------1-----------------------#2020-06-25">https://medium.datadriveninvestor.com/lets-create-training-app-for-ios-using-swift-ui-interaction-with-redux-f0314c731732?source=collection_archive---------1-----------------------#2020-06-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/18faaf6594bfe167131a4d0a5319f07a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PmyXV1MyA5D19s6gJ1ciLw.png"/></div></div></figure><p id="fc05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将结合Redux讨论SwiftUI框架。这一对允许我们快速而容易地创建应用程序。与UIKit不同，SwiftUI用于创建声明式用户界面。反过来，Redux用来控制应用程序的状态。</p><p id="864c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">状态</strong>是SwiftUI和Redux中的一个基本概念。在我们的情况下，这不仅是一个时髦的词，而且是一个连接它们的实体，并允许它们非常好地一起工作。在这篇文章中，我们将试图证明上述论点是正确的，所以让我们开始吧！</p><p id="33b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们深入编写代码之前，首先让我们了解Redux是什么，它由什么组成。</p><p id="bf0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redux是一个用于管理应用程序状态的开源库。它通常与React或Angular结合使用来开发客户端。它包含许多工具，可以显著简化通过上下文传输存储数据。它的创造者是丹尼尔·阿布拉莫夫和安德鲁·克拉克。</p><p id="8c93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对我们来说，Redux不仅仅是一个库，它已经是更多的东西。我们将其归因于应用程序所基于的架构决策，主要是由于其单向数据流。</p><div class="kw kx gp gr ky kz"><a href="https://www.datadriveninvestor.com/2020/02/26/surviving-in-a-digital-age-of-instability/" rel="noopener  ugc nofollow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">在不稳定的数字时代生存|数据驱动的投资者</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">如果你是一名计算机科学家，你可能已经注意到新的框架不断出现。编程…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="li l"><div class="lj l lk ll lm li ln jw kz"/></div></div></a></div><h2 id="2e60" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kj lx ly lz kn ma mb mc kr md me mf mg bi translated">多向或单向流动</h2><p id="52d3" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">为了解释我们所说的数据流，我们将给出下面的例子。使用VIPER创建的应用程序支持模块之间的多方向数据流:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi gj"><img src="../Images/620d4d1957d8178f22224ce8d0aa7af3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uB-x_dSGVzzBNkmsH-hq7A.jpeg"/></div></div></figure><p id="f5a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">反过来，Redux是一个单向数据流，最容易根据其组成部分来解释。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/0590a4996ccaf3d6ab08fa8965d62726.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FDI7wokPKM7iYQE9Wc59uw.png"/></div></div></figure><p id="f2b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们更详细地讨论一下每个Redux组件。</p><p id="4ab4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">状态</strong>是包含我们应用程序所有必要信息的唯一真实来源。</p><p id="2d60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">动作</strong>是意图改变状态。在我们的例子中，这是一个枚举，包含我们想要在当前状态下添加或更改的新信息。</p><p id="3446" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Reducer </strong>是以动作和当前状态为参数，返回新状态的函数。这是创造它的唯一方法。另外值得注意的是，这个功能要干净。</p><p id="c2af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Store </strong>是一个包含状态的对象，提供了更新状态所需的所有工具。</p><p id="6f7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">理论上的第一次尝试可能就足够了，现在让我们继续实践吧。</p><h2 id="6e3f" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kj lx ly lz kn ma mb mc kr md me mf mg bi translated">Redux实现</h2><p id="1d5f" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">了解一个工具最简单的方法之一就是开始使用它。大家都知道，想学一门编程语言，就要用它写一个应用。因此，让我们创建一个小应用程序，例如一个简单的训练日记。它只有四个选项，第一个是显示锻炼列表，第二个是添加已完成的锻炼，第三个是删除，第四个是对锻炼进行排序。一个非常简单的应用程序，但同时它将允许我们熟悉Redux和SwiftUI。</p><p id="289e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Xcode中创建一个干净的项目，将其命名为WorkoutsDiary，最重要的是，为用户界面选择SwiftUI。</p><p id="dd30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建项目后，创建一个健身结构，负责我们执行的健身。</p><pre class="mm mn mo mp gt mr ms mt mu aw mv bi"><span id="b7fe" class="lo lp iq ms b gy mw mx l my mz">import Foundation<br/>struct Workout: Identifiable {<br/>let id: UUID = .init()<br/>let name: String<br/>let distance: String<br/>let date: Date<br/>let complexity: Complexity<br/>}</span></pre><p id="6218" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您所看到的，在这个结构中没有什么复杂的东西，id字段需要遵守可识别的协议，而复杂性字段只是一个具有以下定义的枚举:</p><pre class="mm mn mo mp gt mr ms mt mu aw mv bi"><span id="2e80" class="lo lp iq ms b gy mw mx l my mz">enum Complexity: Int {<br/>case low<br/>case medium<br/>case high<br/>}</span></pre><p id="2a73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经拥有了开始实现Redux所需的一切。让我们从创建一个状态开始。</p><pre class="mm mn mo mp gt mr ms mt mu aw mv bi"><span id="322f" class="lo lp iq ms b gy mw mx l my mz">struct AppState {<br/>var workouts: [Workout]<br/>var sortType: SortType?<br/>}</span></pre><p id="5251" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">状态是一个简单的结构，包含两个字段:锻炼和排序类型。第一个是锻炼列表，第二个是可选字段，用于确定列表的排序方式。</p><p id="07c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SortType是一种枚举，定义如下:</p><pre class="mm mn mo mp gt mr ms mt mu aw mv bi"><span id="eedf" class="lo lp iq ms b gy mw mx l my mz">enum SortType {<br/>case distance<br/>case complexity<br/>}</span></pre><p id="ebe2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为简单起见，我们将按距离和难度降序排列。这意味着我们的训练越复杂，它在列表中显示的位置就越高。值得注意的是，sortType是可选类型，可以是nil，也就是说此时列表没有排序。</p><p id="7e7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将继续实现我们的组件。让我们创建一个操作:</p><pre class="mm mn mo mp gt mr ms mt mu aw mv bi"><span id="5a36" class="lo lp iq ms b gy mw mx l my mz">enum Action {<br/>case addWorkout(_ workout: Workout)<br/>case removeWorkout(at: IndexSet)<br/>case sort(by: SortType)<br/>}</span></pre><p id="b986" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们所看到的，动作是一个列举，有三种情况给了我们操纵状态的能力。</p><ul class=""><li id="de73" class="na nb iq ka b kb kc kf kg kj nc kn nd kr ne kv nf ng nh ni bi translated">addWorkout (_ workout: Workout)只是添加一个作为参数传递的锻炼。</li><li id="969f" class="na nb iq ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">removeWorkout (at: IndexSet)删除指定索引处的项目。</li><li id="0644" class="na nb iq ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">sort (by: SortType)按指定的排序类型对训练列表进行排序。</li></ul><p id="e63d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们创建一个最复杂的组件。它是<strong class="ka ir">减速器</strong>:</p><pre class="mm mn mo mp gt mr ms mt mu aw mv bi"><span id="67fc" class="lo lp iq ms b gy mw mx l my mz">func reducer(state: AppState, action: Action) -&gt; AppState {<br/>var state = state<br/>switch action {<br/>case .addWorkout(let workout):<br/>state.workouts.append(workout)<br/>case .removeWorkout(let indexSet):<br/>state.workouts.remove(atOffsets: indexSet)<br/>switch type {<br/>case .distance:<br/>state.workouts.sort { $0.distance &gt; $1.distance }<br/>state.sortType = .distance<br/>case .complexity:<br/>state.workouts.sort { $0.complexity.rawValue &gt; $1.complexity.rawValue }<br/>state.sortType = .complexity<br/>}<br/>}<br/>return state<br/>}</span></pre><p id="c879" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们编写的函数非常简单，工作方式如下:</p><ol class=""><li id="964b" class="na nb iq ka b kb kc kf kg kj nc kn nd kr ne kv no ng nh ni bi translated">它复制当前状态来使用它。</li><li id="87e4" class="na nb iq ka b kb nj kf nk kj nl kn nm kr nn kv no ng nh ni bi translated">2.基于动作，我们更新我们的复制状态。</li></ol><p id="2e2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.我们返回更新后的状态。</p><p id="3aed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要指出的是，上面的函数是纯函数，那也是我们想要实现的！一个函数必须满足两个条件才能被认为是“纯的”:</p><ul class=""><li id="077e" class="na nb iq ka b kb kc kf kg kj nc kn nd kr ne kv nf ng nh ni bi translated">每次用相同的数据集调用该函数时，它都返回相同的结果。</li><li id="b63e" class="na nb iq ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">没有副作用。</li></ul><p id="d327" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一个缺少的Redux元素是Store，所以让我们为我们的应用程序实现它。</p><pre class="mm mn mo mp gt mr ms mt mu aw mv bi"><span id="739c" class="lo lp iq ms b gy mw mx l my mz">final class Store: ObservableObject {<br/>@Published private(set) var state: AppState<br/>init(state: AppState = .init(workouts: [Workout]())) {<br/>self.state = state</span><span id="094b" class="lo lp iq ms b gy np mx l my mz">public func dispatch(action: Action) {<br/>state = reducer(state: state, action: action)<br/>}<br/>}</span></pre><p id="d6fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Store对象的实现中，我们利用了ObservableObject协议的所有优势，该协议允许我们排除大量模板代码的编写或第三方框架的使用。State属性是只读的，并使用@Published属性的包装器，这意味着无论何时它被更改，SwiftUI都会收到通知。init方法将初始状态作为一个参数，并以健身程序元素空数组的形式给出默认值。dispatch函数是更新状态的唯一方法:它根据作为参数传递的动作，用reducer函数创建的新状态替换当前状态。</p><p id="1716" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们实现了Redux的所有组件之后，我们可以开始为我们的应用程序创建一个用户界面。</p><h2 id="ec41" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kj lx ly lz kn ma mb mc kr md me mf mg bi translated">应用程序实现</h2><p id="df89" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">我们的应用程序的用户界面将非常简单。它将由两个小屏幕组成。第一个也是最主要的一个是显示锻炼列表的屏幕。第二个屏幕是“添加健身程序”屏幕。此外，每个要素将以某种颜色显示，颜色将反映健身程序的复杂程度。红色单元格表示锻炼的最高难度，橙色表示平均难度，绿色表示最容易的锻炼。</p><p id="1949" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用苹果公司一个名为SwiftUI的新框架来实现这个接口。SwiftUI来取代我们熟悉的UIKit。SwiftUI从根本上不同于UIKit，主要在于它是一种用代码编写UI元素的声明性方法。在本文中，我们不会深入研究SwiftUI的所有错综复杂之处，我们假设您已经有了SwiftUI的使用经验。如果您不了解SwiftUI，我们建议您关注Apple的文档，即查看他们的几个完整教程，其中包含逐步添加和结果的交互式显示。也有范例项目的链接。这些教程将让您快速进入SwiftUI的声明世界。</p><p id="64be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应该记住，SwiftUI还没有为生产项目做好准备，它还太年轻，一年多以后才能以这种方式使用。还有，别忘了它只支持iOS 13.0+版本。但同样值得注意的是，SwiftUI将在所有苹果平台上工作，这是比UIKit大的优势！</p><p id="aef6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从应用程序的主屏幕开始实现。转到文件ContentView.swift，将当前代码更改为以下代码:</p><pre class="mm mn mo mp gt mr ms mt mu aw mv bi"><span id="fca0" class="lo lp iq ms b gy mw mx l my mz">struct ContentView: View {<br/>@EnvironmentObject var store: Store<br/>@State private var isAddingMode: Bool = false</span><span id="cca6" class="lo lp iq ms b gy np mx l my mz">var body: some View {<br/>NavigationView {<br/>WorkoutListView()<br/>.navigationBarTitle("Workouts diary", displayMode: .inline)<br/>.navigationBarItems(<br/>leading: AddButton(isAddingMode: self.$isAddingMode),<br/>trailing: TrailingView()<br/>)<br/>}<br/>.sheet(isPresented: $isAddingMode) {<br/>AddWorkoutView(isAddingMode: self.$isAddingMode)<br/>.environmentObject(self.store)<br/>}<br/>}<br/>}</span></pre><p id="69ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">内容视图是SwiftUI中的标准视图。从我们的角度来看，最重要的部分是包含存储变量的代码行。我们将创建@EnvironmentObject。这将允许我们在任何需要的地方使用来自商店的数据，此外，如果数据发生变化，它将自动更新我们的视图。这有点像我们商店的Singleton。</p><p id="5c85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nq">@环境对象var商店:商店</em></p><p id="e094" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面一行代码很重要:</p><p id="ef6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nq">@ State private var is adding mode:Bool = false</em></p><p id="04ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">@State是一个包装器，我们可以用它来指示视图的状态。SwiftUI会将它存储在视图结构之外的一个特殊内存中。只有链接视图可以访问它。一旦State属性的值发生变化，SwiftUI就会重新构建视图以考虑状态变化。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/f2fbeb5332b48bf5ea5c7e5457351a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wb8jtLbSzlbMrAGjjAERXQ.png"/></div></div></figure><p id="0c98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们将转到SceneDelegate.swift文件，并将代码添加到方法中:</p><pre class="mm mn mo mp gt mr ms mt mu aw mv bi"><span id="1bc4" class="lo lp iq ms b gy mw mx l my mz">func scene(<br/>_ scene: UIScene,<br/>willConnectTo session: UISceneSession,<br/>options connectionOptions: UIScene.ConnectionOptions<br/>) {<br/>let contentView = ContentView().environmentObject(Store())</span><span id="1563" class="lo lp iq ms b gy np mx l my mz">if let windowScene = scene as? UIWindowScene {<br/>let window = UIWindow(windowScene: windowScene)<br/>window.rootViewController = UIHostingController(rootView: contentView)<br/>self.window = window<br/>window.makeKeyAndVisible()<br/>}<br/>}</span></pre><p id="e2fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，任何@EnvironmentObject都可以传递给整个应用程序中的任何子表示，这一切都要感谢环境。变量isAddingMode被标记为State，并指示是否显示辅助视图。store变量由WorkoutListView自动继承，我们不需要显式地传递它，但我们需要为AddWorkoutView这样做，因为它以工作表的形式呈现，而不是ContentView的子视图。</p><p id="628d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在创建一个将从视图继承的WorkoutListView。创建名为WorkoutListView的新swift文件。</p><pre class="mm mn mo mp gt mr ms mt mu aw mv bi"><span id="2b56" class="lo lp iq ms b gy mw mx l my mz">struct WorkoutListView: View {<br/>@EnvironmentObject var store: Store<br/>var body: some View {<br/>List {<br/>ForEach(store.state.workouts) {<br/>WorkoutView(workout: $0)<br/>}<br/>.onDelete {<br/>self.store.dispatch(action: .removeWorkout(at: $0))<br/>}<br/>.listRowInsets(EdgeInsets())<br/>}<br/>}</span></pre><p id="d980" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">视图，该视图使用容器列表元素来显示健身程序列表。onDelete功能用于删除健身程序，并使用removeWorkout操作，该操作通过商店提供的dispatch功能执行。要在列表中显示健身程序，请使用WorkoutView。</p><p id="ba3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建另一个文件WorkoutView.swift，它将负责在列表中显示我们的项目。</p><pre class="mm mn mo mp gt mr ms mt mu aw mv bi"><span id="c111" class="lo lp iq ms b gy mw mx l my mz">struct WorkoutView: View {<br/>let workout: Workout</span><span id="b91e" class="lo lp iq ms b gy np mx l my mz">private var backgroundColor: Color {<br/>switch workout.complexity {<br/>case .low:<br/>return .green<br/>case .medium:<br/>return .orange<br/>case .high:<br/>return .red<br/>}<br/>}</span><span id="c8ed" class="lo lp iq ms b gy np mx l my mz">var body: some View {<br/>HStack {<br/>VStack(alignment: .leading) {<br/>Text(workout.name)<br/>Text("Distance:" + workout.distance + "km")<br/>.font(.subheadline)<br/>}<br/>Spacer()<br/>VStack(alignment: .leading) {<br/>Text(simpleFormat(workout.date))<br/>}<br/>}<br/>.padding()<br/>.background(backgroundColor)<br/>}<br/>}<br/>private extension WorkoutView {<br/>func simpleFormat(_ date: Date) -&gt; String {<br/>let dateFormatter = DateFormatter()<br/>dateFormatter.dateFormat = "dd MMM yyyy"<br/>dateFormatter.locale = .init(identifier: "en_GB")<br/>return dateFormatter.string(from: date)<br/>}<br/>}</span></pre><p id="c39c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此视图将培训对象作为参数，并根据其属性进行配置。</p><p id="c34f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">若要向列表中添加新项，必须将isAddingMode参数更改为true以显示AddWorkoutView。这是AddButton的责任。</p><pre class="mm mn mo mp gt mr ms mt mu aw mv bi"><span id="863c" class="lo lp iq ms b gy mw mx l my mz">struct AddButton: View {<br/>@Binding var isAddingMode: Bool</span><span id="15ff" class="lo lp iq ms b gy np mx l my mz">var body: some View {<br/>Button(action: { self.isAddingMode = true }) {<br/>Image(systemName: "plus")<br/>}<br/>}<br/>}</span></pre><p id="7dc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">AddButton也值得放到一个单独的文件中。</p><p id="2326" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个视图是一个简单的按钮，它是从主ContentView中提取出来的，用于更好的结构和代码分离。</p><p id="284a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建视图以添加新的健身程序。创建新的AddWorkoutView.swift文件:</p><pre class="mm mn mo mp gt mr ms mt mu aw mv bi"><span id="40dc" class="lo lp iq ms b gy mw mx l my mz">struct AddWorkoutView: View {<br/>@EnvironmentObject private var store: Store</span><span id="b517" class="lo lp iq ms b gy np mx l my mz">@State private var nameText: String = ""<br/>@State private var distanceText: String = ""<br/>@State private var complexityField: Complexity = .medium<br/>@State private var dateField: Date = Date()<br/>@Binding var isAddingMode: Bool</span><span id="9f51" class="lo lp iq ms b gy np mx l my mz">var body: some View {<br/>return .red<br/>}<br/>}<br/>var body: some View {<br/>NavigationView {<br/>Form {<br/>TextField("Name", text: $nameText)<br/>TextField("Distance", text: $distanceText)<br/>Picker(selection: $complexityField, label: Text("Complexity")) {<br/>Text("Low").tag(Complexity.low)<br/>Text("Medium").tag(Complexity.medium)<br/>Text("High").tag(Complexity.high)<br/>}<br/>DatePicker(selection: $dateField, displayedComponents: .date) {<br/>Text("Date")<br/>}<br/>}<br/>.navigationBarTitle("Workout Details", displayMode: .inline)<br/>.navigationBarItems(<br/>leading: Button(action: { self.isAddingMode = false }) {<br/>Text("Cancel")<br/>},<br/>trailing: Button(action: {<br/>let workout = Workout(<br/>name: self.nameText,<br/>distance: self.distanceText,<br/>date: self.dateField,<br/>complexity: self.complexityField<br/>)<br/>self.store.dispatch(action: .addWorkout(workout))<br/>self.isAddingMode = false<br/>}) {<br/>Text("Save")<br/>}<br/>.disabled(nameText.isEmpty)<br/>)<br/>}<br/>}</span></pre><p id="9489" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个相当大的控制器，像其他控制器一样，包含存储变量。它还包含变量nameText、distanceText、complexityField和isAddingMode。前三个变量是链接TextField、Picker、DatePicker所必需的，可以在这个屏幕上看到。导航栏有两个元素。第一个按钮是关闭屏幕而不添加新锻炼的按钮，最后一个按钮是向列表中添加新锻炼，这是通过发送addWorkout动作来实现的。此操作还会关闭新的健身程序屏幕。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/cfa988744f0e5fb49c404a511b35a8f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TYSSzeywhX4-RLexmfmgiQ.png"/></div></div></figure><p id="90f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后但并非最不重要的是TrailingView。</p><pre class="mm mn mo mp gt mr ms mt mu aw mv bi"><span id="728f" class="lo lp iq ms b gy mw mx l my mz">struct TrailingView: View {<br/>@EnvironmentObject var store: Store</span><span id="d00d" class="lo lp iq ms b gy np mx l my mz">var body: some View {<br/>HStack(alignment: .center, spacing: 30) {<br/>Button(action: {<br/>switch self.store.state.sortType {<br/>case .distance:<br/>self.store.dispatch(action: .sort(by: .distance))<br/>default:<br/>self.store.dispatch(action: .sort(by: .complexity))<br/>}<br/>}) {<br/>Image(systemName: "arrow.up.arrow.down")<br/>}<br/>EditButton()<br/>}<br/>}<br/>}</span></pre><p id="a7a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该视图由两个按钮组成，分别负责对健身程序列表进行排序，以及激活或禁用健身程序列表的编辑模式。使用dispatch函数调用排序操作，我们可以通过store属性调用该函数。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/72f10c049b0d967a9fb48dadfab7110e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n1nrA_1pHBclTQQANUhpug.png"/></div></div></figure><h1 id="d6a7" class="ns lp iq bd lq nt nu nv lt nw nx ny lw nz oa ob lz oc od oe mc of og oh mf oi bi translated">结果</h1><p id="f4e9" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">应用程序已经准备好，应该完全按照预期工作。让我们试着编译并运行它。</p><h2 id="6357" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kj lx ly lz kn ma mb mc kr md me mf mg bi translated">结论</h2><p id="0074" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">Redux和SwiftUI配合得非常好。使用这些工具编写的代码易于理解，并且可以很好地组织。这个解决方案的另一个优点是它出色的代码可测试性。然而，这种解决方案并非没有缺点。其中之一是当应用程序的状态非常复杂时，应用程序会使用大量内存，在某些特定场景下，应用程序性能可能不理想，因为SwiftUI中的所有视图都是在创建新状态时更新的。这些缺点可能会对应用程序和用户交互的质量产生很大的影响，但是如果我们记住它们并以合理的方式准备状态，负面影响可以很容易地最小化甚至避免。</p><p id="f235" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们希望你喜欢这篇文章，并学到一些新的东西。回头见。我们将要进一步谈论的主题将会更加有趣；)</p><p id="7c59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">进入专家视图— </strong> <a class="ae oj" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>