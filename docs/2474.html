<html>
<head>
<title>Predicting Crashes in Gold Prices Using Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用机器学习预测黄金价格的崩溃</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/predicting-crashes-in-gold-prices-using-machine-learning-5769f548496?source=collection_archive---------0-----------------------#2020-05-02">https://medium.datadriveninvestor.com/predicting-crashes-in-gold-prices-using-machine-learning-5769f548496?source=collection_archive---------0-----------------------#2020-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="169a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/gold-price-prediction" rel="noopener" target="_blank">黄金预测</a></h2><div class=""/><div class=""><h2 id="27d6" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用PyCaret分类预测黄金价格暴跌的分步指南</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/5ce3c51d9663bde49221767f9dd53cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*etQrkJsMtNUP9EWE.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Gold Price Movement</figcaption></figure><h2 id="551e" class="lh li it bd lj lk ll dn lm ln lo dp lp lq lr ls lt lu lv lw lx ly lz ma mb iz bi translated">方法</h2><p id="cf2e" class="pw-post-body-paragraph mc md it me b mf mg kd mh mi mj kg mk lq ml mm mn lu mo mp mq ly mr ms mt mu im bi translated">在<a class="ae mv" href="https://towardsdatascience.com/machine-learning-to-predict-gold-price-returns-4bdb0506b132" rel="noopener" target="_blank">黄金预测</a>系列的前两部分中，我们讨论了如何从免费的yahoofinancials API导入数据，并构建一个<strong class="me jd"> <em class="mw">回归模型</em> </strong>来预测黄金在两个时间段内的回报。即14天和22天。</p><p id="27c3" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">在这一部分，我们将试图预测在未来22天内，黄金价格是否会出现“大幅下跌”或“崩盘”。我们将在这个实验中使用一个<strong class="me jd"> <em class="mw">分类</em> </strong>技术。我们还将学习如何使用训练好的模型对每天的新数据进行预测。这个练习的步骤是:</p><ol class=""><li id="0b4a" class="nc nd it me b mf mx mi my lq ne lu nf ly ng mu nh ni nj nk bi translated"><strong class="me jd">导入并形成数据</strong>——这类似于本文第一部分中的解释。您也可以从我的git <a class="ae mv" href="https://github.com/Riazone/Gold-Return-Prediction/blob/master/Training%20Data.csv" rel="noopener ugc nofollow" target="_blank"> repo </a>下载最终数据集。</li><li id="7d68" class="nc nd it me b mf nl mi nm lq nn lu no ly np mu nh ni nj nk bi translated"><strong class="me jd">定义<em class="mw">【暴跌】</em> </strong>黄金价格。夏普不是一个绝对的衡量标准。我们将尝试客观地定义<em class="mw">【暴跌】</em></li><li id="edc1" class="nc nd it me b mf nl mi nm lq nn lu no ly np mu nh ni nj nk bi translated"><strong class="me jd">创建标签</strong>——根据<em class="mw">【暴跌】</em>的定义，我们将在历史数据上创建标签</li><li id="5de1" class="nc nd it me b mf nl mi nm lq nn lu no ly np mu nh ni nj nk bi translated">训练模型预测<em class="mw">【暴跌】</em>并使用训练好的模型对新数据进行预测</li></ol><p id="2922" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated"><strong class="me jd">准备数据</strong></p><p id="fc23" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">这一部分与我们在第一部分中所做的完全相同。<a class="ae mv" href="https://github.com/Riazone/Gold-Return-Prediction/blob/master/Classification/Gold%20Prediction%20Experiment%20%20Classification-%20PyCaret.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>包含用于数据导入和操作的完整代码块，或者您可以通过加载数据集直接开始，该数据集可以从这里的链接<a class="ae mv" href="https://github.com/Riazone/Gold-Return-Prediction/blob/master/Training%20Data.csv" rel="noopener ugc nofollow" target="_blank">下载。</a></p><p id="281d" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated"><strong class="me jd">定义‘大幅下跌’</strong></p><p id="64e5" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">任何分类问题都需要标签。这里，我们需要通过定义和量化“大幅下跌”来创建标签。</p><p id="66b3" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">为了定义“夏普”，我定义了一个阈值，使得任何窗口(这里是22天，这里是14天)的回报率低于阈值的概率为15%(基本上是p=0.15的正态分布的左尾)。为此，我需要假设收益的分布是正态的。看看回报的分布，这是一个非常合理的假设。</p><div class="ks kt ku kv gt ab cb"><figure class="nq kw nr ns nt nu nv paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/236fa32c1258136fca65c1d2666da405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*hjdmU6aYxcPQfqQ0QncN5w.png"/></div></figure><figure class="nq kw nw ns nt nu nv paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/4a567022c7839ed088214e65032f82ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*LiI4fq4eFHkKzvdXamWfxA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk nx di ny nz">Histogram of Returns for both 14 and 22 Day window. Very close to Normal Distribution</figcaption></figure></div><p id="16c3" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">为了得到两个窗口(14天和22天)的阈值回报水平，我将首先定义分布左尾的p值，在本例中为15%。使用此p值，我们从标准正态分布中获得-1.0364的z值。下面的代码将为我们做这件事。</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="b899" class="lh li it ob b gy of og l oh oi">import scipy.stats as st<br/>#Select Threshold p (left tail probability)<br/>p= 0.15<br/>#Get z-Value<br/>z = st.norm.ppf(p)<br/>print(z)</span></pre><p id="a46a" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">现在，根据上面的z值和每个窗口回报的均值和标准差，我们将获得阈值回报水平。“数据”中的“黄金-T+14”和“黄金-T+22”列显示了14天和22天的远期收益。</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="35f5" class="lh li it ob b gy of og l oh oi">#Calculating Threshold (t) for each Y<br/>t_14 = round((z*np.std(data[“Gold-T+14”]))+np.mean(data[“Gold-T+14”]),5)<br/>t_22 = round((z*np.std(data[“Gold-T+22”]))+np.mean(data[“Gold-T+22”]),5)</span><span id="bafe" class="lh li it ob b gy oj og l oh oi">print(“t_14=”,t_14)<br/>print(“t_22=”,t_22)</span><span id="187e" class="lh li it ob b gy oj og l oh oi">t_14= -0.03733<br/>t_22= -0.04636</span></pre><p id="7a93" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">因此，14天窗口的阈值回报水平为-0.0373或-3.73%，22天窗口的阈值回报水平为-0.0463或-4.63%。这意味着，14天回报率低于-3.73%和22天回报率低于-4.63%的概率只有15%。这是一个类似于计算风险价值(VAR)的概念。</p><p id="a691" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated"><strong class="me jd">创建标签</strong></p><p id="c8bd" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">我们将使用上述阈值水平来创建标签。两个窗口中低于各自阈值的任何回报将被标记为1，否则标记为0。</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="2805" class="lh li it ob b gy of og l oh oi">#Creating Labels<br/>data[‘Y-14’] = (data[‘Gold-T+14’]&lt; t_14)*1<br/>data[‘Y-22’]= (data[‘Gold-T+22’]&lt; t_22)*1<br/>print(“Y-14”, sum(data[‘Y-14’]))<br/>print(“Y-22”, sum(data[‘Y-22’]))</span><span id="420d" class="lh li it ob b gy oj og l oh oi">Y-14 338<br/>Y-22 356</span></pre><p id="0ae1" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">在总共2，379个实例中，有338个实例的14天回报率低于阈值-3.73%，有356个实例的22天回报率低于阈值-4.63%。</p><p id="6d64" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">一旦我们有了这些标签，我们实际上并不需要returns列，因此我们删除了实际returns列。</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="9ca5" class="lh li it ob b gy of og l oh oi">data = data.drop([’Gold-T+14',’Gold-T+22'],axis=1)<br/>data.head()</span></pre><h2 id="615d" class="lh li it bd lj lk ll dn lm ln lo dp lp lq lr ls lt lu lv lw lx ly lz ma mb iz bi translated">用PyCaret建模</h2><p id="b59c" class="pw-post-body-paragraph mc md it me b mf mg kd mh mi mj kg mk lq ml mm mn lu mo mp mq ly mr ms mt mu im bi translated"><strong class="me jd"> 22天窗口</strong></p><p id="ff2d" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">我们将从这里的22天窗口开始。我将在这里使用PyCaret的分类模块进行实验。</p><p id="fd44" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">我们从PyCaret导入上面的模块，然后删除14天的标签，因为我们在这里使用的是22天的窗口。就像在回归中一样，要开始分类练习，我们需要运行<em class="mw"> setup() </em>命令来指出数据和目标列。记住所有基本的预处理都是由PyCaret在后台处理的。</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="9138" class="lh li it ob b gy of og l oh oi">from pycaret.classification import *</span><span id="672d" class="lh li it ob b gy oj og l oh oi">data_22 = data.drop([’Y-14'],axis=1)<br/>s22 = setup(data=data_22, target=’Y-22', session_id=11, silent=True);</span></pre><p id="8ca0" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">为了评估所有模型的集合，我们将运行<em class="mw"> compare_models() </em>命令，并将<em class="mw"> turbo </em>设置为<strong class="me jd"> <em class="mw"> False </em> </strong>，因为我想要评估库中当前可用的所有模型。</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="d3c4" class="lh li it ob b gy of og l oh oi">compare_models(turbo=False)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ok"><img src="../Images/ba78c6caf82ae32b7bd7e2d34d24df0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wmvq7DeuVtmcMdkpz4B94w.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Compare Models Output</figcaption></figure><p id="7447" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">在继续选择模型之前，我们需要了解哪个指标对我们最有价值。分类实验中度量标准的选择取决于业务问题。在精确度和召回率之间总是有一个权衡。这意味着我们必须在真阳性和假阴性之间进行选择和权衡。</p><p id="e208" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">在这里，最终模型将用于为投资者/分析师创建一个标志，警告他即将发生崩溃的可能性。然后，投资者将决定对冲他的头寸以应对可能的下跌。因此，模型能够预测所有/大部分的剧烈下跌是非常重要的。换句话说，我们希望选择一个具有更好的真阳性能力(更好的召回率)的模型，即使它会带来一些假阳性的代价(更低的精度)。换句话说，我们不希望模型错过“急剧下跌”的可能性。我们可以承受一些假阳性，因为如果模型预测会出现大幅下跌，而投资者对冲了他的头寸，但下跌并没有发生，投资者将失去继续投资的机会成本或至多对冲成本(比如说，如果他买入看跌期权)。这个成本将低于假阴性的成本，在假阴性中，模型预测没有<em class="mw">【大幅下跌】</em>，但大幅下跌确实发生了。然而，我们需要注意<strong class="me jd">精度</strong>和<strong class="me jd"> AUC </strong>的权衡。</p><p id="04f1" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">我们将继续创建四个模型，即MLP分类器(<em class="mw"> mlp) </em>、额外树分类器(<em class="mw"> et) </em>、Cat Boost分类器(<em class="mw"> catb </em>)以及具有最佳<strong class="me jd">召回率</strong>和合理<strong class="me jd"> AUC/Precision的轻梯度提升机(<em class="mw"> lgbm </em>)。</strong></p><div class="ks kt ku kv gt ab cb"><figure class="nq kw ol ns nt nu nv paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/058886254a5f93929e70db372b5ad50a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*OUz2ZUmbZLTYwgFn0m3Hvw.png"/></div></figure><figure class="nq kw om ns nt nu nv paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/1d02ab78c608d807cc93c64312ecbafd.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*AFDkbDD6Mxv7YDz1G_5rbg.png"/></div></figure></div><div class="ab cb"><figure class="nq kw on ns nt nu nv paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/103f872d6f5ec735edbfd4a431b127b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*kJUEp_A989tlTGHiaFsz2g.png"/></div></figure><figure class="nq kw oo ns nt nu nv paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/9fc1c59bbd5e47ea77d54c65529c7221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*LYnj_G6F7yx4x5JmYOdcxA.png"/></div></figure></div><p id="1b6b" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">基于我们得到的结果，MLP分类器似乎是最好的选择，具有最高的召回率和非常好的94.7%<em class="mw">AUC。</em></p><p id="34b1" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated"><strong class="me jd">超参数调谐</strong></p><p id="dc34" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">一旦我们有了想要进一步研究的前四个模型，我们需要找到模型的最佳超参数。PyCaret有一个非常方便的函数<strong class="me jd"> <em class="mw"> tune_model() </em> </strong>，它遍历预定义的超参数网格，通过10重交叉验证找到我们模型的最佳参数。PyCaret使用标准的<strong class="me jd"> <em class="mw">随机网格</em> </strong>搜索来遍历参数。迭代次数(<em class="mw"> n_iter </em>)可以根据计算能力和时间限制指定一个较大的数值。在<strong class="me jd"><em class="mw">tune _ function()</em></strong>中，PyCaret还允许我们指定我们想要优化的指标。默认值是准确性，但是我们也可以选择其他指标。就像我们在这里选择<strong class="me jd">回忆</strong>一样，因为这是我们想要增加/优化的指标。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi op"><img src="../Images/db18ee30091dcf1a2da18f7ac08bf19f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*D8_Opw0chItS8Z1HB8OCVA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">CatBoost Tuned Output</figcaption></figure><p id="3756" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">上面的代码调整Cat-Boost分类器，通过在定义的网格上迭代50次来优化<strong class="me jd">【Recall】</strong>，并显示每个折叠的6个指标。我们看到<strong class="me jd">的意思是召回</strong>从base Cat-Boost中的<strong class="me jd"><em class="mw"/></strong>58.2%提升到这里的<strong class="me jd"><em class="mw"/></strong>62.6%。这是一个巨大的跳跃，在调优阶段并不常见。但是仍然低于我们之前创建的基础<strong class="me jd"><em class="mw">【MLP</em></strong>】的<strong class="me jd"><em class="mw"/></strong>66.6%。对于其他三个模型，我们没有看到通过调整带来的性能提升(例如在<a class="ae mv" href="https://github.com/Riazone/Gold-Return-Prediction/blob/master/Classification/Gold%20Prediction%20Experiment%20%20Classification-%20PyCaret.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>中)。原因是迭代参数的随机性。然而，有一个参数将等于或超过基本模型的性能，但为此，我们需要增加更多的时间，这意味着更多的计算时间。</p><p id="4036" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">因此，目前我们排名前四的车型是:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/f1674e187ebe3f7755b5b23ef2a2b36f.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*ok58GJ9EY2YGkhRrhBdpVg.png"/></div></figure><h2 id="cb33" class="lh li it bd lj lk ll dn lm ln lo dp lp lq lr ls lt lu lv lw lx ly lz ma mb iz bi translated"><strong class="ak">评估模型</strong></h2><p id="26ec" class="pw-post-body-paragraph mc md it me b mf mg kd mh mi mj kg mk lq ml mm mn lu mo mp mq ly mr ms mt mu im bi translated">在继续之前，让我们评估一下模型的性能。我们将利用PyCaret的<strong class="me jd"><em class="mw">evaluate _ model()</em></strong>函数来评估和突出显示获奖模型的重要方面。</p><p id="ebc7" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated"><strong class="me jd">混淆矩阵</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi or"><img src="../Images/6024e885744b218c540cf50df4a7cd83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*W7dfGY1PnVEepgq9Y4LzgA.png"/></div></figure><p id="6590" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated"><strong class="me jd">特征重要性</strong></p><p id="1d89" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">由于<em class="mw"> mlp </em>和<em class="mw"> catb_tuned </em>不提供特性重要性，我们将使用<em class="mw"> lgbm </em>来查看哪些特性在我们的预测中最重要:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/7204dff1ff0137352991176835aaf96c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k9IZNrOlsfgiT4jm27HXOA.png"/></div></div></figure><p id="6650" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">我们可以看到，过去180天的<em class="mw">‘黄金回归’</em>是这里最重要的因素。这也是直观的，因为如果黄金价格在过去上涨了很多，它们下跌/修正的机会就更大，反之亦然。接下来的3个特征是白银在250、60和180天内的收益。同样，白银和黄金是交易和关联最广的两种贵金属，因此这种关系非常直观。</p><h2 id="3829" class="lh li it bd lj lk ll dn lm ln lo dp lp lq lr ls lt lu lv lw lx ly lz ma mb iz bi translated"><strong class="ak">集合模特</strong></h2><p id="ab2f" class="pw-post-body-paragraph mc md it me b mf mg kd mh mi mj kg mk lq ml mm mn lu mo mp mq ly mr ms mt mu im bi translated">在调整了模型的超参数之后，我们可以尝试集成方法来提高性能。我们可以尝试的两种组装方法是<a class="ae mv" href="https://towardsdatascience.com/ensemble-methods-bagging-boosting-and-stacking-c9214a10a205" rel="noopener" target="_blank">“装袋”和“增压”</a>。不提供概率估计的模型不能用于提升。因此，我们只能将Boosting与“lgbm”和“et”一起使用。对于其他人，我们尝试bagging来看看性能是否有任何改进。下面是代码快照和10倍的结果。</p><div class="ks kt ku kv gt ab cb"><figure class="nq kw ot ns nt nu nv paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/8fbcf4335427a0e2fc0e825f4c4858eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*lknUUSTHIjRxQ8s0_BRohQ.png"/></div></figure><figure class="nq kw ou ns nt nu nv paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/47eee902126979026ed6287b0038605f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*aGIg3u79djyiWCE9poQ-BA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk ov di ow nz">Ensembling Results</figcaption></figure></div><p id="938b" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">正如我们在上面看到的，这两个模型的结果并没有改善。对于其他型号，性能也有所下降(查看<a class="ae mv" href="https://github.com/Riazone/Gold-Return-Prediction/blob/master/Classification/Gold%20Prediction%20Experiment%20%20Classification-%20PyCaret.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>)。因此，我们的成功模式保持不变。</p><p id="5403" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated"><strong class="me jd">混合模型</strong></p><p id="317b" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">混合模型基本上是在估计器的基础上构建一个投票分类器。对于提供预测概率的模型，我们可以使用软投票(使用它们的概率)，而对于其他模型，我们将使用硬投票。<strong class="me jd"> <em class="mw"> blend_model() </em> </strong>函数默认使用硬投票，可以手动更改。我构建了两个混合，看看是否有一些额外的性能可以提取。</p><div class="ks kt ku kv gt ab cb"><figure class="nq kw ox ns nt nu nv paragraph-image"><img src="../Images/1f8f28c396d1fee08da11158a8a80d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*UwqjMhfu0JtQJKfCOV1VYw.png"/></figure><figure class="nq kw oy ns nt nu nv paragraph-image"><img src="../Images/fb559b0ae54773c431a60b5f7d17a479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*dokZi-hH-1jL2ifHmyAjow.png"/></figure></div><p id="4ce3" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">虽然没有一款车型能够将<strong class="me jd"><em class="mw">【MLP】</em></strong>从榜首位置上赶下来，但第二款<strong class="me jd"><em class="mw">【blend 2】</em></strong>非常有趣，它是<strong class="me jd"><em class="mw">【lgbm】</em></strong>和<strong class="me jd"><em class="mw">【et】</em></strong>的软组合。<strong class="me jd">62.25%</strong><strong class="me jd">97.43%</strong>在<strong class="me jd">召回</strong>和<strong class="me jd"> AUC </strong>上的表现分别高于<strong class="me jd"><em class="mw">【lgbm】</em></strong>和<strong class="me jd"><em class="mw">【et】</em></strong>两者。这展示了混合模型的好处。现在我们的冠军模特将减少到3个。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/37b87488d0998b876472a11a47148135.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*owcSPrycYFxoW9KrfrJ96g.png"/></div></figure><p id="ab55" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated"><a class="ae mv" href="https://www.coursera.org/lecture/competitive-data-science/stacknet-s8RLi" rel="noopener ugc nofollow" target="_blank"> <strong class="me jd">创建栈网</strong> </a></p><p id="c807" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated"><a class="ae mv" href="https://www.geeksforgeeks.org/stacking-in-machine-learning/" rel="noopener ugc nofollow" target="_blank">堆叠模型</a>是一种方法，其中我们允许一个层中的一个模型(或一组模型)的预测被用作后续层的特征，最后，元模型被允许根据先前层的预测和原始特征进行训练(如果<em class="mw"> restack=True </em>)以做出最终预测。PyCaret有一个非常简单的实现，我们可以使用<strong class="me jd"><em class="mw">stack _ model()</em></strong>构建一个一层一元模型的堆栈，或者使用<strong class="me jd"><em class="mw">create _ stacknet()</em></strong>构建多个层一元模型的堆栈。我使用了不同的组合来构建不同的堆栈并评估性能。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pa"><img src="../Images/cf5b44350e41f470d3fe9fbd5083fd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d6PR6Hj2ZYrBFAifh-KSvw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Results of Stack-1</figcaption></figure><p id="4137" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">在第一个堆栈中，<strong class="me jd"><em class="mw">【stack 1】</em></strong>，我使用了表现不佳的模型，<strong class="me jd"> <em class="mw"> catb_tuned </em> </strong>和<strong class="me jd"> <em class="mw"> blend2 </em> </strong>在第一层将它们的预测传递给领导者模型<strong class="me jd"> <em class="mw"> mlp </em> </strong>，这将帮助它做出预测，<strong class="me jd"> <em class="mw"> mlp </em> </strong>的预测由元模型使用，即<strong class="me jd">由于<strong class="me jd"> <em class="mw"> LR </em> </strong>没有很好地处理完整的数据(参见比较模型结果)，我使用了<em class="mw"> restack=False </em>，这意味着只有来自先前模型的预测被传递给后续的估计器，而不是原始特征。我们在这里看到的简直是魔术。<strong class="me jd">召回</strong>从我们最好的车型<strong class="me jd"><em class="mw">【MLP】</em></strong>的<strong class="me jd"> 66.63% </strong>跃升到大规模的<strong class="me jd">77.8%</strong><strong class="me jd">AUC</strong>和<strong class="me jd"> Precision </strong>也是如此。<strong class="me jd"><em class="mw">【stack 1】</em></strong>绝对远远优于我们之前打造的所有车型。显然，我不得不尝试其他配置，看看是否可以实现更好的性能。我确实找到了一个更好的配置:</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pb"><img src="../Images/3d85fbaf1c6ba87711294bf5da074c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n5ZY0N_c4kBaSVpxn78siw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Results of Stack 3</figcaption></figure><p id="1833" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">上面的堆栈<strong class="me jd"><em class="mw">【stack 3】</em></strong>取得了最大的成功，其<strong class="me jd">召回率</strong>平均为<strong class="me jd"> 80.7% </strong>，即<strong class="me jd">比我们的获胜者<strong class="me jd"><em class="mw">【MLP】</em></strong>模型高14% </strong>，而没有牺牲<strong class="me jd">准确性</strong> ( <em class="mw"> 95%，提高了3% </em>)，</p><p id="d54c" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">我们可以使用这个模型来预测我们在设置阶段分离的测试数据<em class="mw">(总观测值的30)</em>。我们可以通过使用<em class="mw"> predict_model() </em>来实现</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/c3bc5d33e5d2226972518aed2fcc61ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*lJGUuf_sa1xsaaCB58QG0w.png"/></div></figure><p id="1867" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">我们可以看到，该模型在测试数据上的表现更好，召回率为86.9%</p><p id="ffe7" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">由于我们有<strong class="me jd"><em class="mw">【stack 3】</em></strong>作为主导模型，我们将在整个数据(包括测试数据)上拟合该模型，并保存该模型以便对新数据进行预测。</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="253d" class="lh li it ob b gy of og l oh oi">classifier_22 = finalize_model(stack3)</span><span id="961f" class="lh li it ob b gy oj og l oh oi">save_model(classifier_22,”22D Classifier”)</span></pre><p id="d2fe" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">上面的代码拟合了整个数据上的模型，并使用<strong class="me jd"> <em class="mw"> save_model() </em> </strong>函数，我将训练好的模型和预处理管道保存在我的active directory中一个名为<a class="ae mv" href="https://github.com/Riazone/Gold-Return-Prediction/blob/master/Classification/22D%20Classifier.pkl" rel="noopener ugc nofollow" target="_blank"> " <strong class="me jd"> <em class="mw"> 22D分类器</em> </strong> " </a>的<em class="mw"> pkl </em>文件中。这个保存的模型可以并且将会被调用来对新数据进行预测。</p><h2 id="6547" class="lh li it bd lj lk ll dn lm ln lo dp lp lq lr ls lt lu lv lw lx ly lz ma mb iz bi translated">预测新数据</h2><p id="32e9" class="pw-post-body-paragraph mc md it me b mf mg kd mh mi mj kg mk lq ml mm mn lu mo mp mq ly mr ms mt mu im bi translated">为了进行预测，我们需要像在练习开始时那样导入原始价格数据，以提取特征，然后加载模型进行预测。唯一的区别是，我们将导入数据直到最后一个交易日，以便根据最新数据做出预测，就像我们在现实生活中所做的那样。标题为<strong class="me jd"><em class="mw">'</em></strong><a class="ae mv" href="https://github.com/Riazone/Gold-Return-Prediction/blob/master/Classification/Gold%20Prediction%20New%20Data%20-%20Classification.ipynb" rel="noopener ugc nofollow" target="_blank"><strong class="me jd"><em class="mw">黄金预测新数据—分类'</em> </strong> </a>的笔记本在回购中展示了数据导入、准备和预测代码。</p><p id="d793" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">我们将跳过数据导入和准备部分(查看笔记本了解详情)，看看预测过程。</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="657d" class="lh li it ob b gy of og l oh oi">from pycaret.classification import *<br/><strong class="ob jd"><em class="mw">#Loading the stored model</em></strong><br/>classifier_22 = load_model(“22D Classifier”);<br/><strong class="ob jd"><em class="mw">#Making Predictions</em></strong><br/>prediction = predict_model(classifier_22,data=prediction_data)</span></pre><p id="5559" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">使用<strong class="me jd"><em class="mw">predict _ model()</em></strong>我们可以将加载的模型应用于新的数据集，以生成预测(1或0)和得分(预测附带的概率)。<em class="mw">‘预测’</em>数据帧也将包含我们提取的所有特征。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/9820bab9400ee41073b39e5bd03bbbbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*MW9Qm_DdhnQFonTPD-meeg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Prediction Tail</figcaption></figure><p id="1db2" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">查看预测的“标签”和“分数”列，该模型没有预测到任何一天会有明显的下跌。例如，考虑到截至4月29日的历史回报，该模型预测未来22天黄金价格的显著下跌是<strong class="me jd"> <em class="mw">不太可能</em> </strong>，因此<strong class="me jd"> Label = 0 </strong>，概率为9.19%。</p><h1 id="f078" class="pe li it bd lj pf pg ph lm pi pj pk lp ki pl kj lt kl pm km lx ko pn kp mb po bi translated">结论</h1><p id="575f" class="pw-post-body-paragraph mc md it me b mf mg kd mh mi mj kg mk lq ml mm mn lu mo mp mq ly mr ms mt mu im bi translated">因此，在这里，我逐步创建了一个分类器来预测未来22天黄金价格的大幅下跌。笔记本也包含了14天模型的代码。您可以尝试创建标签，并尝试以类似的方式预测不同时间窗口内的类似下跌。到目前为止，我们已经创建了一个<a class="ae mv" href="https://towardsdatascience.com/machine-learning-to-predict-gold-price-returns-4bdb0506b132" rel="noopener" target="_blank">回归</a>和一个分类模型。在未来，我们将尝试使用分类模型的预测作为回归问题的特征，看看它是否能提高回归的性能。</p><h1 id="94bb" class="pe li it bd lj pf pg ph lm pi pj pk lp ki pl kj lt kl pm km lx ko pn kp mb po bi translated">重要链接</h1><p id="c10a" class="pw-post-body-paragraph mc md it me b mf mg kd mh mi mj kg mk lq ml mm mn lu mo mp mq ly mr ms mt mu im bi translated"><a class="ae mv" href="https://github.com/Riazone/Gold-Return-Prediction/tree/master/Classification" rel="noopener ugc nofollow" target="_blank"> <strong class="me jd"> <em class="mw"> Git-hub仓库</em></strong>T5】</a></p><p id="2931" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated"><a class="ae mv" href="https://towardsdatascience.com/machine-learning-to-predict-gold-price-returns-4bdb0506b132" rel="noopener" target="_blank"> <strong class="me jd"> <em class="mw">第一部分和第二部分—回归</em> </strong> </a></p><p id="919e" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated"><a class="ae mv" href="https://pycaret.org/" rel="noopener ugc nofollow" target="_blank"><strong class="me jd"><em class="mw">py caret</em></strong></a></p><p id="e004" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated"><a class="ae mv" href="https://www.linkedin.com/in/riazuddin-mohammad/" rel="noopener ugc nofollow" target="_blank"> <strong class="me jd"> <em class="mw">我的领英简介</em> </strong> </a></p></div><div class="ab cl pp pq hx pr" role="separator"><span class="ps bw bk pt pu pv"/><span class="ps bw bk pt pu pv"/><span class="ps bw bk pt pu"/></div><div class="im in io ip iq"><p id="dd57" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">点击订阅DIntel <a class="ae mv" href="https://ddintel.datadriveninvestor.com/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="de15" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">请访问我们的网站:<a class="ae mv" href="https://www.datadriveninvestor.com/" rel="noopener ugc nofollow" target="_blank">https://www.datadriveninvestor.com</a></p><p id="8c9d" class="pw-post-body-paragraph mc md it me b mf mx kd mh mi my kg mk lq mz mm mn lu na mp mq ly nb ms mt mu im bi translated">在这里加入我们的网络:<a class="ae mv" href="https://datadriveninvestor.com/collaborate" rel="noopener ugc nofollow" target="_blank">https://datadriveninvestor.com/collaborate</a></p></div></div>    
</body>
</html>