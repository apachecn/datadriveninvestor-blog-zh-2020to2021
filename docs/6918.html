<html>
<head>
<title>Learn Object-Oriented Programming(OOP) In Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">几分钟内学会面向对象编程(OOP)</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/learn-object-oriented-programming-oop-in-minutes-18d9f957b387?source=collection_archive---------3-----------------------#2020-11-16">https://medium.datadriveninvestor.com/learn-object-oriented-programming-oop-in-minutes-18d9f957b387?source=collection_archive---------3-----------------------#2020-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn"><p id="be9a" class="jo jp iq bd jq jr js jt ju jv jw jx dk translated">理解最自然和实用的方法。一旦掌握了窍门，就可以通过深入钻研Python编程来实现现实世界的问题。</p></blockquote><figure class="jz ka kb kc kd ke gh gi paragraph-image"><div class="gh gi jy"><img src="../Images/a539a3f84196d3d4af8de5cf4a1687a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*SZ6G_TgwL29klHmWWBZvJA.png"/></div></figure><p id="b251" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">大多数时候，你的编码步骤都是围绕着数据分析、预处理、可视化、建模，所有这些都是日常思考的一部分。</p><p id="3b42" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">为了理解这背后的直觉，让我们以尼日利亚的教育系统为例。我们有一个顺序<em class="le">学前&gt; &gt;小学&gt; &gt;中学&gt; &gt;中学。</em>如果我们单独将尼日利亚作为一个国家来讨论，这种顺序观点是可行的。然而，如果这是关于各大洲和地区的，你就不得不考虑全世界成千上万个国家的教育系统。为每个国家制定一系列行动可能会变得不可持续，不管怎样，你必须开始考虑所有大陆的模式。</p><p id="39d9" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">这种思想与代码密切相关，更多的数据保证了更多的步骤和更多的功能。</p><p id="670f" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">简而言之，面向对象编程(OOP)是对象(数据)及其交互模式的集合。OOP关注于思考过程，实现开发者想要操作的东西，而不是操作它们所需的逻辑。代码可伸缩性、效率、可重用性、信息保护、易于调试都是OOP的好处。</p><h2 id="c635" class="lf lg iq bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">面向对象的编程语言包括:</h2><ul class=""><li id="e621" class="ly lz iq kj b kk ma ko mb ks mc kw md la me jx mf mg mh mi bi translated">Java 语言(一种计算机语言，尤用于创建网站)</li><li id="2ec6" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">C++</li><li id="8817" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">计算机编程语言</li><li id="2a82" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">C#</li><li id="665b" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">Java Script语言</li><li id="4cb5" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">r，PHP，Ruby，Swift，Dart，Scala，Kotlin，Matlab，e.t.c</li></ul><p id="21e3" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">在本文中，我们将精力集中在Python中的OOP上。</p><h2 id="5c3f" class="lf lg iq bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">Python中的对象</h2><p id="28b8" class="pw-post-body-paragraph kh ki iq kj b kk ma km kn ko mb kq kr ks mo ku kv kw mp ky kz la mq lc ld jx ij bi translated">Python中的几乎所有东西都是对象，它的属性和方法构成了类。</p><figure class="ms mt mu mv gt ke gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/823c219b48eb2f649e2dd1a2c165d030.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*5-5vEM9oCMD2tgfJEFKGcQ.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">class in python</figcaption></figure><p id="4740" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">您可以在任何Python对象上调用<strong class="kj ir"> type() </strong>来获取它的类。<strong class="kj ir"> dir </strong>函数帮助我们了解附加到<strong class="kj ir"> str </strong>类的方法和属性。</p><figure class="ms mt mu mv gt ke gh gi paragraph-image"><div class="gh gi na"><img src="../Images/dea121ff5cc0b2dd5457132d33f1fe79.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*OcSkOU7qaDCSD30L3KjE1A.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">methods and attributes in python</figcaption></figure><p id="58df" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">其他一些类的例子可以在下面看到。</p><figure class="ms mt mu mv gt ke gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/095836f95a0f5d6271ba49aa24bfbb3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*8tJPFUFP3-F37ovLnYhAkw.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">object with classes</figcaption></figure><h2 id="a8c8" class="lf lg iq bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">OOP的优势</h2><ul class=""><li id="4638" class="ly lz iq kj b kk ma ko mb ks mc kw md la me jx mf mg mh mi bi translated">班级</li><li id="19db" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">目标</li><li id="cb57" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">属性</li><li id="ebd6" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">方法</li></ul><h2 id="78e2" class="lf lg iq bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">班级</h2><p id="cd1c" class="pw-post-body-paragraph kh ki iq kj b kk ma km kn ko mb kq kr ks mo ku kv kw mp ky kz la mq lc ld jx ij bi translated">类是利用被称为用户定义数据类型的OOP的真正优势。它是对象的蓝图，描述了某种类型的每个对象可能具有的状态和行为。如果我告诉一个朋友，说，</p><blockquote class="jn"><p id="6e29" class="jo jp iq bd jq jr nc nd ne nf ng jx dk translated">“我的每一个用户都将拥有一个名字，一个电子邮件，并将能够登录到该网站”，哟！我刚刚创建了一个类！</p></blockquote><figure class="jz ka kb kc kd ke gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nh"><img src="../Images/825b8688f08b0e44e04d187fcf05e63d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*6VaxtyaOgoa52b5wcArfsQ.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">creating your first class</figcaption></figure><p id="b331" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">这是我们的第一节课。这个类的主体现在是空的。</p><figure class="ms mt mu mv gt ke gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/22f804a04c8c48f88c1f187f58921ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*-V2U6zsOwHx325nujG1Zlw.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">new instance</figcaption></figure><p id="16f3" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">这里，我们创建了一个<strong class="kj ir">用户</strong>类的新实例。换句话说，我们实例化了<strong class="kj ir">用户</strong>类。<strong class="kj ir">美元</strong>是对我们新对象的引用。意思是，<em class="le"> usd </em>是我们的<em class="le">用户</em>类的一个实例对象。</p><h2 id="e0b3" class="lf lg iq bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">对象作为数据结构</h2><p id="41d0" class="pw-post-body-paragraph kh ki iq kj b kk ma km kn ko mb kq kr ks mo ku kv kw mp ky kz la mq lc ld jx ij bi translated">对象是具有唯一状态和行为的数据字段。它可以是变量、函数、数据结构的组合。</p><blockquote class="jn"><p id="dfff" class="jo jp iq bd jq jr nc nd ne nf ng jx dk translated">对象=状态+行为</p></blockquote><p id="411c" class="pw-post-body-paragraph kh ki iq kj b kk nn km kn ko no kq kr ks np ku kv kw nq ky kz la nr lc ld jx ij bi translated">陈述，在某种意义上，姓名和电子邮件。行为，如单击页面的登录选项。</p><h2 id="ce98" class="lf lg iq bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">属性</h2><p id="7e35" class="pw-post-body-paragraph kh ki iq kj b kk ma km kn ko mb kq kr ks mo ku kv kw mp ky kz la mq lc ld jx ij bi translated">通俗地说，属性是附加在类型上的性质或特征。类似地，在Python中，它们是通过赋值创建的，并在类模板中定义为存储的信息。单个对象包含存储在属性字段中的数据。例如，网站的每个用户可以根据在进行<em class="le">登录</em>之前提供的<em class="le">姓名</em>和<em class="le">电子邮件地址</em>进行不同的识别。</p><blockquote class="jn"><p id="3fe8" class="jo jp iq bd jq jr nc nd ne nf ng jx dk translated">属性=变量&gt; &gt; &gt; Obj.my_attributes</p></blockquote><p id="6fdb" class="pw-post-body-paragraph kh ki iq kj b kk nn km kn ko no kq kr ks np ku kv kw nq ky kz la nr lc ld jx ij bi translated">Python中的属性通常表示为变量，如数字、字符串、列表、元组、字典。</p><figure class="ms mt mu mv gt ke gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ns"><img src="../Images/12088b9bccfb5d2c2b795d2056a35d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*_1drsNTj922MlnpMS8E5iA.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">class with attributes</figcaption></figure><h2 id="1ec2" class="lf lg iq bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">方法</h2><p id="a2f6" class="pw-post-body-paragraph kh ki iq kj b kk ma km kn ko mb kq kr ks mo ku kv kw mp ky kz la mq lc ld jx ij bi translated">方法执行操作；方法返回关于对象的信息或更新对象的数据。方法的代码总是在类定义中定义为由函数表示的行为。在<em class="le">用户</em>示例中，在<em class="le">用户</em>类中定义了<em class="le">登录</em>方法，并在对象<strong class="kj ir"> usd </strong>上调用了<em class="le">登录()</em> <strong class="kj ir"> <em class="le"> </em> </strong>以获得输出。</p><figure class="ms mt mu mv gt ke gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nt"><img src="../Images/76fee43764e4e3cf31b59d1048774c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0zLxrH1ipMxTb-gjHvJizA.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">example of method</figcaption></figure><p id="0eff" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">按照上面的代码片段，你应该注意到<strong class="kj ir"> self </strong>这个词被分别调用。别搞混了，解释一下！</p><h2 id="091a" class="lf lg iq bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">什么是自我？</h2><blockquote class="jn"><p id="9e31" class="jo jp iq bd jq jr nc nd ne nf ng jx dk translated">Self代表未来物体。</p></blockquote><p id="465e" class="pw-post-body-paragraph kh ki iq kj b kk nn km kn ko no kq kr ks np ku kv kw nq ky kz la nr lc ld jx ij bi translated">定义类时，类的对象还不存在。但是我们经常需要一种方法来引用类定义中特定对象的数据。它是类定义中特定对象的替身，也是对该类当前实例的引用，它用于访问属于该类的变量。</p><p id="3b0a" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">尽管如此，它既不是<strong class="kj ir">关键字</strong>也不是<strong class="kj ir">特殊</strong>名称，而是<strong class="kj ir">常规</strong>名称，可以根据程序员的意图用任何其他词替换，如“<strong class="kj ir"> kitty </strong>”、“<strong class="kj ir"> iris </strong>”等，只要它们被一致地使用而不被替换。</p><p id="8590" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated"><strong class="kj ir">注意</strong>:自身<em class="le">参数</em>应该是常规<strong class="kj ir">实例</strong>方法的第一个参数。尽管如此，始终保持<em class="le">自身</em>为<em class="le">自身</em>。</p><p id="78cc" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">下面的片段是一个参考，以防你仍然不熟悉如何区分OOP的所有四个优点。这里有一张指向它们的草图。</p><figure class="ms mt mu mv gt ke gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/c1f2d57cca70b0495515504c10ff8859.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*XiSS0Kk0ZYdWfFk1jo54YA.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">check each directed arrows</figcaption></figure><h2 id="8ced" class="lf lg iq bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">Python对象初始化器</h2><p id="361f" class="pw-post-body-paragraph kh ki iq kj b kk ma km kn ko mb kq kr ks mo ku kv kw mp ky kz la mq lc ld jx ij bi translated">在查看其他开发人员的代码或库文档时，您一定遇到过<strong class="kj ir"> __init__ </strong>构造函数，其中许多初学者对它的用途和使用方式感到困惑。<strong class="kj ir"> __init__() </strong>被称为<strong class="kj ir">一个类</strong>的 <strong class="kj ir">构造器。在创建对象后，它会被自动调用。</strong></p><p id="9631" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">如果您的类包含大量数据，这是一种非常可持续的方法。它允许您在创建对象时向其添加数据。</p><p id="71a5" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">在<em class="le">属性</em>副标题的代码片段中，我们在类<strong class="kj ir"> User </strong>的<strong class="kj ir"> set_name </strong>方法中定义了<strong class="kj ir"> my_name </strong>属性，然后调用set_name方法会将<strong class="kj ir"> Kolawole Precious </strong>属性添加到<strong class="kj ir"> usd </strong>对象中，与<strong class="kj ir"> set_email </strong>方法相同。或者，一切都可以在构造函数下定义。</p><figure class="ms mt mu mv gt ke gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/85400887a498dcf0f96e901cc565a834.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*mGuhSwy90rgC0z6Cp0h2kg.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">init constructor</figcaption></figure><p id="6ce0" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">使用<strong class="kj ir"> __init__ </strong>构造函数，我们在此确定我们的代码更易维护、可读性更好、组织更好。</p><h2 id="8728" class="lf lg iq bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">面向对象的四个基本原则</h2><figure class="ms mt mu mv gt ke gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/c121a626cd07840b96db17aef7faba63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*khTqScHxkClKMcsXzP-BLQ.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">principles of OOP</figcaption></figure><ul class=""><li id="55b0" class="ly lz iq kj b kk kl ko kp ks nx kw ny la nz jx mf mg mh mi bi translated">遗产</li><li id="7e31" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">包装</li><li id="f2a4" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">多态性</li><li id="169c" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">抽象</li></ul><h2 id="dbbf" class="lf lg iq bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">遗产</h2><figure class="ms mt mu mv gt ke gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/bd3a346e32d654174dfe83560ab7fccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*Lj0wjtGivXV4qorsnonmoA.jpeg"/></div></figure><p id="afa0" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">它指的是定义一个新的类，对现有的类做很少的修改或不做修改。继承从另一个类继承所有方法和属性。它允许代码重用，允许类继承其他类的特性。</p><blockquote class="jn"><p id="59f1" class="jo jp iq bd jq jr nc nd ne nf ng jx dk translated">新类别功能=旧类别功能+额外功能</p></blockquote><p id="fb2e" class="pw-post-body-paragraph kh ki iq kj b kk nn km kn ko no kq kr ks np ku kv kw nq ky kz la nr lc ld jx ij bi translated">例如，<em class="le">癌症</em>分别将属性和功能扩展到<em class="le">乳腺癌、宫颈癌、肺癌、皮肤癌</em>癌症。也就是说，所有的<em class="le">乳腺癌</em>都是<em class="le">癌</em>但所有的<em class="le">癌</em>都不是<em class="le">乳腺癌</em>。继承代表“是”的关系。</p><figure class="ms mt mu mv gt ke gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/04b8934a336eb8be343e7b2140d614dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*d2s4cZmb7-dT4tv2InQZ9w.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">example code of inheritance</figcaption></figure><p id="0215" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">这里我们把<strong class="kj ir">癌(父)</strong>类放在<strong class="kj ir">乳腺癌(子)</strong>类名称后面的圆括号里。定义了<em class="le">癌症类</em>，然后从它继承了一个看似空的<em class="le">乳腺癌</em>类。<em class="le">乳腺癌</em>被视为具有一般<em class="le">癌症类别</em>的所有属性和功能。</p><p id="6cd3" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">我们创建了一个对象<strong class="kj ir"> b_can </strong>，尽管我们没有定义构造函数。令人惊讶的是，我们可以从<em class="le">乳腺癌</em>类中访问<strong class="kj ir"><em class="le"/>_ _颜色</strong>和<strong class="kj ir">_核子</strong>属性，尽管这些特性在新类中没有定义。</p><figure class="ms mt mu mv gt ke gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/a317891e3a70d567624cda14b5b68f4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*U-mtw_ISU9juOkALzj9UHw.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">parent and child differentiation</figcaption></figure><blockquote class="jn"><p id="f0fc" class="jo jp iq bd jq jr js jt ju jv jw jx dk translated">父类也称为超类、祖先类或基类。子类也可以称为派生类、后代类或扩展类。</p></blockquote><h2 id="1a1b" class="lf lg iq bd lh li od dn lk ll oe dp ln ks of lp lq kw og ls lt la oh lv lw lx bi translated">封装_ _向继承中添加功能</h2><p id="3caf" class="pw-post-body-paragraph kh ki iq kj b kk ma km kn ko mb kq kr ks mo ku kv kw mp ky kz la mq lc ld jx ij bi translated">现在，我们可以看到我们创建的类和子类拥有相同的功能。下面是如何给我们的子类添加更多的功能，通过添加一个专门针对<em class="le">乳腺癌</em>的构造函数，使它不同于<em class="le">癌症类</em>。</p><figure class="ms mt mu mv gt ke"><div class="bz fp l di"><div class="oi oj l"/></div></figure><figure class="ms mt mu mv gt ke gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/1e4a4c2c423835769e7d8248eb837a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*f6M9TrmSQhEyNhq022C86w.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">outputs after adding more functionalities</figcaption></figure><p id="66ff" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">从上面的代码中，我们得到了OOP中的封装。我们已经创建了具有一些属性和方法的<em class="le">癌症类</em>，以及具有其属性和方法的<em class="le">乳腺癌</em>子类。然而，如果我们仅仅通过对象的引用就可以简单地改变<em class="le"> Cancer类</em>的属性，那么这些属性就失去了最初初始化它的信息。</p><p id="76c3" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">假设我们已经初步创建了一个<em class="le">癌症类</em>，其属性为<em class="le">黑色</em>。任何拥有<em class="le">乳腺癌</em>对象实例的用户都可以通过简单地引用属性将该颜色更改为橙色或蓝色。为了避免这种情况，我们在<strong class="kj ir"> getters </strong>，<strong class="kj ir"> setters </strong>方法中包含了这些属性。我们可以从<strong class="kj ir">输出</strong>片段中看到，每个类都保留了自己的属性。</p><p id="ea04" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">子类函数下的super有助于从子类中专门调用已经在子类中被覆盖的父类方法。如果您需要从特定的父类调用方法或属性，请使用<em class="le"> super() </em>。</p><p id="6cca" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">我们还应该注意到，在每个属性前面都有双下划线(__) 。它们用于私有变量。根据Python文档——如果您的类打算有子类，并且有您不希望子类使用的属性，考虑用双前导和不超过一个尾随下划线来命名它们。</p><p id="4527" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">Python解释器重写了属性名以避免子类中的命名冲突，并更改了变量的名称，使得以后扩展类时更难产生冲突。</p><h2 id="af75" class="lf lg iq bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">封装的好处</h2><ul class=""><li id="9248" class="ly lz iq kj b kk ma ko mb ks mc kw md la me jx mf mg mh mi bi translated">它帮助我们将属性的初始化和检索包含在方法中。</li><li id="7a3f" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">它有助于抑制不必要的变化。</li><li id="4816" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">getters和setters让我们可以完全控制属性值的获取和设置。</li></ul><h2 id="dc73" class="lf lg iq bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated"><strong class="ak"> <em class="ol">多态性</em> </strong></h2><p id="e7dc" class="pw-post-body-paragraph kh ki iq kj b kk ma km kn ko mb kq kr ks mo ku kv kw mp ky kz la mq lc ld jx ij bi translated">从字面意义上来说，多态性是假设不同形状和形式的能力。在Python中，这意味着变量、函数或对象可以采用多种形式。而在OOP中，多态性允许我们在子类和父类中定义同名的方法。多态的工作可以用两种不同的方式来处理；</p><ul class=""><li id="96f9" class="ly lz iq kj b kk kl ko kp ks nx kw ny la nz jx mf mg mh mi bi translated">方法覆盖</li><li id="20eb" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">方法重载</li></ul><h2 id="0764" class="lf lg iq bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">方法覆盖</h2><p id="d43e" class="pw-post-body-paragraph kh ki iq kj b kk ma km kn ko mb kq kr ks mo ku kv kw mp ky kz la mq lc ld jx ij bi translated">这在子类从父类继承的方法不适合子类的情况下使用。也就是说，我们必须在子类中重新实现这个方法。</p><figure class="ms mt mu mv gt ke gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi om"><img src="../Images/d50be43e5af161408c8e32ef93d32619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MQFIcoGUkCShmn4N4swRQw.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">method overriding example</figcaption></figure><p id="b2c9" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">在这里，父类<strong class="kj ir">狗</strong>拥有独特的能力<strong class="kj ir">用更大的声音吠叫</strong>。儿童类<strong class="kj ir">小狗</strong>也能发出声音，但是声音小一些。值得注意的是，从父类继承的方法不适合子类，所以为子类提供了不同的实现。</p><p id="6698" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">同时，每个方法都是基于调用它时使用的对象类型来调用的。当<em class="le"> Puppy </em>类对象<strong class="kj ir"> py </strong>被用来调用一个被覆盖的方法<em class="le"> bark() </em>时，那么<em class="le"> Puppy </em>类版本的方法<strong class="kj ir"> HOWL </strong>就会被打印出来。但是如果用方法<em class="le"> bark() </em>调用<em class="le"> Dog </em>类对象<strong class="kj ir"> dg </strong>，则<strong class="kj ir"> WOOF </strong>被打印出来。</p><h2 id="29cd" class="lf lg iq bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">方法重载</h2><p id="1800" class="pw-post-body-paragraph kh ki iq kj b kk ma km kn ko mb kq kr ks mo ku kv kw mp ky kz la mq lc ld jx ij bi translated">在编程中，重载指的是一个方法根据传递给它的参数以不同方式运行的能力。在这里，我们将看到如何在Python中执行方法重载。</p><p id="b59b" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">方法或函数可能具有相同的名称，但传递给方法的参数数量不同。根据传入的参数数量，将得到不同的输出。</p><figure class="ms mt mu mv gt ke gh gi paragraph-image"><div class="gh gi on"><img src="../Images/de8a060130e693dd9ac5df83d31b11c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*VKcrtGq7JYSbOgDdsOcPHA.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">method with parameters</figcaption></figure><p id="3561" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">上面我们看到了<em class="le"> bark() </em>是如何设置给对象带参数或者不带参数来得到不同的输出的。</p><p id="d6d4" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">不管怎样，真正的方法重载是在其他编程语言中使用的，而不是在Python中。</p><h2 id="b353" class="lf lg iq bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">抽象</h2><p id="e98b" class="pw-post-body-paragraph kh ki iq kj b kk ma km kn ko mb kq kr ks mo ku kv kw mp ky kz la mq lc ld jx ij bi translated">抽象意味着对用户隐藏复杂性或内部实现。</p><ul class=""><li id="50ac" class="ly lz iq kj b kk kl ko kp ks nx kw ny la nz jx mf mg mh mi bi translated">简单的代码用来表示复杂性。</li><li id="8fb3" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">对用户隐藏复杂的细节。</li></ul><p id="50ae" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">一个真实的例子是一辆<em class="le">汽车</em>的发动机传动和制动系统如何工作的细节，其执行和自动化对于驾驶汽车的人来说是未知的。一辆<em class="le">汽车</em>并不被视为不同的独立部件，而是一个定义明确的物体，具有其独特的行为。OOP中的抽象是通过使用抽象类和方法来实现的。</p><p id="d6d1" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">抽象类提供不完整的功能，并且包含一个或多个抽象方法。抽象方法没有任何实现，但是子类为抽象方法提供实现。</p><p id="9ccf" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">要声明一个抽象类，我们首先需要从<strong class="kj ir"> ABC </strong>模块导入<strong class="kj ir"> abc </strong>类。</p><figure class="ms mt mu mv gt ke gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/c9462eae5b6ee1cffe402a71b348c184.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*UmYU5uwbyXVmFHhsqMN5Sg.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">import ABC</figcaption></figure><figure class="ms mt mu mv gt ke"><div class="bz fp l di"><div class="oi oj l"/></div></figure><figure class="ms mt mu mv gt ke gh gi paragraph-image"><div class="gh gi op"><img src="../Images/da280053e6447be716ea775d07569324.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*ARqSacmipJPa2YPyAX6nkA.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">abstraction.py output</figcaption></figure><p id="0713" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated"><strong class="kj ir"> User </strong>是一个抽象类，继承自<em class="le"> abc </em>模块的<em class="le"> ABC </em>类，<strong class="kj ir"> Cash </strong>和<strong class="kj ir"> Transfer </strong>子类继承自<em class="le"> User </em>类，它们都有自己的<strong class="kj ir"> clearance() </strong>加上<strong class="kj ir">receive()</strong>方法，这些方法是用户唯一可见的东西。但是，当在每个子类的对象中调用<em class="le"> clearance() </em>并传入<strong class="kj ir"> amount </strong>参数时，将显示子类的打印语句。这些定义对用户是隐藏的。</p><blockquote class="jn"><p id="982c" class="jo jp iq bd jq jr nc nd ne nf ng jx dk translated">在我们告别之前，让我们快速浏览一下。</p></blockquote><h2 id="0647" class="lf lg iq bd lh li od dn lk ll oe dp ln ks of lp lq kw og ls lt la oh lv lw lx bi translated">为OOP代码推荐的设计技术</h2><ul class=""><li id="cc99" class="ly lz iq kj b kk ma ko mb ks mc kw md la me jx mf mg mh mi bi translated">类名以大写字母开头。如果一个类名包含多个单词，每个单词都应该以大写字母开头，例如<strong class="kj ir"> ClassName </strong>。它们被视为名词。</li><li id="5eb6" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">函数和循环的模式是预期的。在类后面的代码行中适当缩进。</li><li id="0ef9" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">方法的定义必须以关键字<strong class="kj ir"> def </strong>开始。</li><li id="1ef1" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">方法名必须以小写字母开头。如果不止一个单词，那么单词之间应该有一个<strong class="kj ir">连字符(_) </strong>，例如<strong class="kj ir"> method_name </strong>，或者第一个单词之后的每个单词都以大写字母开头，例如<strong class="kj ir"> methodName() </strong>。</li><li id="41c1" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">参数应该尽可能清楚地表明其目的和存在。</li><li id="431c" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">名称不得以特殊字符开头，如<strong class="kj ir">、&amp;、%、_、等。</strong></li><li id="be6a" class="ly lz iq kj b kk mj ko mk ks ml kw mm la mn jx mf mg mh mi bi translated">一个字符串文字<strong class="kj ir">(“”)</strong>而不是其他类型的表达式出现在任何其他语句之前的类或函数之后。这有助于用户理解类、方法和属性背后的直觉。通过调用特定类或方法上的python内置<strong class="kj ir"> help </strong>函数，可以将其视为输出。在许多开发人员参与某个项目的场景中，这是传递有关类和方法的信息的一种方式，创建这些类和方法是为了帮助其他人理解他们编写的每个代码，并确保代码的可重用性。</li></ul><figure class="ms mt mu mv gt ke gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/85fae7dd31ab79572c9755434fe84e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*_xI5OpBJKNJFA9OabFyK3A.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">docstrings and help function</figcaption></figure><ul class=""><li id="0a04" class="ly lz iq kj b kk kl ko kp ks nx kw ny la nz jx mf mg mh mi bi translated">最后，写好代码。可移植性、可维护性、可读性很重要！！！</li></ul></div><div class="ab cl oq or hu os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="ij ik il im in"><p id="d3d7" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">作为一名开发人员，采用广泛的面向对象编程来构建非刚性的软件，编写每一个逻辑，将复杂的问题作为对象分成小的工作单元。本教程一定已经让你对OOP的风格、执行和实现有了一个简明的概念。但是我们通过实践学习得最好。</p><p id="1258" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld jx ij bi translated">胡拉拉。！！你刚刚看了一篇很长的，内容丰富的文章。感谢沉迷阅读到最后的后劲。点击下面的拍手图标，与朋友、编码伙伴、导师以及尽可能多的需要它的人分享。更重要的是，如果有问题和更多想法，你可以在Twitter和T2 LinkedIn上与我联系。快乐阅读！</p><h2 id="f0f2" class="lf lg iq bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">参考</h2><div class="oy oz gp gr pa pb"><a href="https://learn.datacamp.com/courses/object-oriented-programming-in-python" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd ir gy z fp pg fr fs ph fu fw ip bi translated">签到</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">登录DataCamp帐户</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">learn.datacamp.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp kf pb"/></div></div></a></div><div class="oy oz gp gr pa pb"><a href="https://searchapparchitecture.techtarget.com/definition/object-oriented-programming-OOP" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd ir gy z fp pg fr fs ph fu fw ip bi translated">什么是面向对象编程(OOP)？</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">面向对象编程(OOP)是一种围绕数据组织软件设计的计算机编程模型</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">searchapparchitecture.techtarget.com</p></div></div><div class="pk l"><div class="pq l pm pn po pk pp kf pb"/></div></div></a></div></div></div>    
</body>
</html>