<html>
<head>
<title>Why Big O? Why not Big Omega or Big Theta with algorithm runtime?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么是大O？为什么算法运行时不是大ω或者大θ？</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/why-big-o-why-not-big-omega-or-big-theta-with-algorithm-runtime-112792e3283e?source=collection_archive---------5-----------------------#2020-07-12">https://medium.datadriveninvestor.com/why-big-o-why-not-big-omega-or-big-theta-with-algorithm-runtime-112792e3283e?source=collection_archive---------5-----------------------#2020-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/66aa4426234f74afa9e5bc5d143fe0f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VlCjerf99LtNg8XYx8RM6w.png"/></div></div></figure><p id="4c98" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们用任何语言编写程序或算法时，我们经常发现自己在问两个最重要的问题。</p><ol class=""><li id="2326" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">运行这个程序需要多长时间？</li><li id="0ab8" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">它需要多少<strong class="kd iu">空间</strong>，这是一个优化的空间吗？</li></ol><p id="c682" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">是啊！这个讨论的是大O &amp;算法的时间复杂度！！</p><p id="5d73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基本上，程序的时间概念取决于各种因素，如</p><p id="4c93" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你的机器有多快？你同时在运行其他程序吗？你用的是哪种编程语言？</p><p id="10dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们不再分析这些因素，而是直接考虑算法的运行时间是如何随着输入大小的增长而增长的？</p><p id="7642" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以用渐近符号来描述算法的效率，如大O，大θ(theta)，大ω(Omega)</p><p id="e80e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">大O(oh)</strong><a class="ae ln" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank">Bachmann–Landau符号</a> <strong class="kd iu"> : </strong>它描述了运行时间的渐近上界，我们可以说<strong class="kd iu">最坏情况</strong>或算法完成运算所需的最大运行时间。各种类型的大O符号也是可用的</p><ul class=""><li id="179b" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky lo lf lg lh bi translated"><strong class="kd iu"> O(1) </strong> —常数时间算法。不管n的大小，时间是一个常数，这是最快的。</li><li id="12e7" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky lo lf lg lh bi translated"><strong class="kd iu">O(log n)</strong>-对数时间算法-它与输入大小的对数成比例增长。</li><li id="9c2a" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky lo lf lg lh bi translated"><strong class="kd iu"> O(n) </strong> —线性时间算法—它随输入大小线性增长。</li><li id="303c" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky lo lf lg lh bi translated"><strong class="kd iu"> O(n log n) </strong> — n log n时间算法—它与输入大小的N Log N成比例增长。</li><li id="cccf" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky lo lf lg lh bi translated"><strong class="kd iu"> O(n^p) </strong> —多项式时间算法——这些算法比<strong class="kd iu"> O(n log n </strong>)算法慢。</li><li id="c989" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky lo lf lg lh bi translated"><strong class="kd iu"> O(k^n) </strong> —指数时间算法—它与输入大小的某些因子指数成比例增长。</li><li id="cde8" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky lo lf lg lh bi translated"><strong class="kd iu"> O(n！)</strong> —阶乘时间算法—它增长到输入大小的阶乘。这是最慢的。</li></ul><p id="f9a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">大ω:</strong>它描述了运行时的渐近下限，并给出了<strong class="kd iu">最佳情况</strong>的复杂度，即算法花费的时间最少。我们很少讨论算法的下界，因为任何算法，特殊情况下一些输入得到ω(1)将是下界。</p><p id="6d39" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">大θ: </strong>它描述了运行时的严格限制(即O和ω),并将向您显示算法完成所需的<strong class="kd iu">平均</strong>时间。因此，有一个上限和一个下限，算法执行时间将落在这个范围内。</p><p id="6092" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，用大O来解释算法的时间复杂度或效率将是比其他算法更好的选择，因为它给出了任何输入所消耗的最大时间。消耗较少代码、时间和空间的程序或代码也将是优化的。</p><p id="e1fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们以具有大小为4的整数的数组为例，</p><p id="1fb1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">int arr[] = {5，6，8，15 }；</p><p id="f8f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您想要访问数组中的特定元素，那么下限将是<strong class="kd iu">ω(1)</strong>【在数组的第一个索引中查找元素】<strong class="kd iu">，</strong>平均或严格情况将是<strong class="kd iu"> θ(1) </strong>【在数组的中间索引中查找元素】，最坏情况或上限是<strong class="kd iu"> O(n) </strong>，即遍历整个数组来访问特定元素。</p><p id="83b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章有助于DS&amp;Algo初学者理解时间复杂性，并分享你的意见和建议！</p><p id="219f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lp">参考文献:</em> </strong></p><p id="9313" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">[1]Gayle Laakmann McDowell所著的《破解编码采访》一书。</p><p id="1b8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">[2]<a class="ae ln" href="https://www.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-o-notation" rel="noopener ugc nofollow" target="_blank">https://www . khanacademy . org/computing/computer-science/algorithms/渐近符号/a/big-o-notation </a></p><p id="6842" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">[3]<a class="ae ln" href="https://dev.to/sherryummen/asymptotic-notations-b-oot-big-o-big-omega-big-theta-49e7" rel="noopener ugc nofollow" target="_blank">https://dev . to/sherryummen/渐近符号-b-oot-big-o-big-omega-big-theta-49e 7</a></p></div></div>    
</body>
</html>