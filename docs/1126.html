<html>
<head>
<title>Getting Started with Service Mesh</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务网格入门</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/getting-started-with-service-mesh-4c33760fc6e8?source=collection_archive---------9-----------------------#2020-03-03">https://medium.datadriveninvestor.com/getting-started-with-service-mesh-4c33760fc6e8?source=collection_archive---------9-----------------------#2020-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/98090e78194e127e4717d72d4de4e1af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*5kPIebaXIWdDNk0b.jpeg"/></div></figure><p id="42c4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">本文由彭家豪撰写，他在阿里巴巴的昵称是易信。彭是阿里巴巴淘宝技术部的一名开发工程师，也是云计算的狂热爱好者。</em></p><p id="f73e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">随着计算机软件技术的快速发展，整个软件体系结构世界正在以许多新的方式发展，这使得开发者能够容易且快速地构建大规模且复杂的应用。最初开发容器技术是为了解决运行时环境中的不一致性问题。然而，在容器技术不断发展的过程中，容器技术开辟了越来越多的新的可能性。</p><p id="3a35" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">近年来，这种发展导致云计算领域出现了许多新的软件架构模型，包括云本机、函数计算、无服务器和服务网格。这篇文章可以作为服务网格的简明易懂的指南。</p><h1 id="adac" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是微服务和服务治理</h1><p id="81aa" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">在微服务存在之前的软件开发过程中，所有模块往往都包含在一个应用程序中，并一起编译、打包、部署和维护。因此，一个应用程序通常会包含太多的模块。而且，如果该应用程序中的某个模块出现故障或需要更新，整个应用程序都必须重新部署。所以，你可能已经猜到了，这种方法让开发人员非常头疼，特别是负责的<a class="ae lw" href="https://www.atlassian.com/devops?spm=a2c41.14065545.0.0" rel="noopener ugc nofollow" target="_blank"> DevOps </a>人员。当然，随着应用程序变得越来越复杂，它们涉及越来越多的对象。</p><div class="lx ly gp gr lz ma"><a href="https://www.datadriveninvestor.com/2018/09/22/infographic-journey-to-the-clouds/" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd ir gy z fp mf fr fs mg fu fw ip bi translated">信息图:云之旅|数据驱动的投资者</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">聪明的企业领导者了解利用云的价值。随着数据存储需求的增长，他们已经…</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo js ma"/></div></div></a></div><p id="b423" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">开发人员在这个过程中发现了许多缺点。为了解决这些问题，开发人员开始对服务进行分组，并将大型应用程序分成许多具有应用程序间调用关系的小型应用程序。不同的开发人员管理、部署和维护不同的小型应用程序。微服务的概念本质上就是这样产生的。</p><p id="4da3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">微服务中的应用程序部署在不同的主机上，这意味着您需要为服务找到一种相互通信和协调的方式。这种情况比单个应用程序复杂得多。同一应用程序中不同方法之间的调用是可寻址和快速的，因为它们在代码编译和打包期间链接在同一个内存中。但是，一个微服务中不同服务之间的调用涉及到不同进程或主机之间的通信，一般需要通过第三方中间件进行调解和协调。</p><p id="c6f7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">出于这些原因，开发了大量面向微服务的中间件，包括服务治理框架。这些服务治理工具可以管理与它们集成的所有应用程序，从而简化和加速服务之间的通信和协调。</p><h1 id="5ad1" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是容器和容器编排</h1><p id="6631" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">开发容器技术是为了解决应用程序运行时环境中的不一致性问题，避免应用程序可以在本地或测试环境中正常运行，但在生产环境中崩溃的情况。程序及其依赖项通过容器打包成映像，在安装和执行容器服务的任何主机上启动几个容器。</p><p id="0163" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">每个容器都是一个应用程序运行时实例。这些实例通常具有相同的运行时环境和参数。因此，应用程序可以在不同的主机上获得一致的性能。这个事实方便了开发、测试和O&amp;M，不需要为不同的主机构建相同的运行时环境。</p><p id="112a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">可以将图像推送到图像存储库，方便应用程序迁移和部署。在其他技术中，<a class="ae lw" href="https://www.docker.com/?spm=a2c41.14065545.0.0" rel="noopener ugc nofollow" target="_blank"> Docker </a>是使用最广泛的容器技术之一。目前，许多应用程序是通过使用容器作为微服务来部署的，并且这些开发的数量只会随着时间的推移而增加。所有这些都极大地激励了软件开发。</p><p id="01cb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">随着越来越多的应用程序通过使用容器来部署，单个集群中使用的容器数量也随着时间的推移而显著增加。但是，这使得手动管理和维护这些容器变得困难，因此开发了许多编排工具来管理容器之间的关系。这些工具可以管理容器的整个生命周期。比如Docker发布的<a class="ae lw" href="https://docs.docker.com/compose/?spm=a2c41.14065545.0.0" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>和<a class="ae lw" href="https://docs.docker.com/engine/swarm/?spm=a2c41.14065545.0.0" rel="noopener ugc nofollow" target="_blank"> Docker Swarm </a>可以批量启动和编排容器。但是，它们只提供简单的功能，不能支持大型容器集群。</p><p id="dafc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了解决这个问题，谷歌基于其在容器管理方面的丰富经验，开发了Kubernetes项目。Kubernetes专为每周拥有数亿个容器的Google集群设计，具有强大的容器编排能力和各种功能。Kubernetes定义了很多资源。这些资源是以声明方式创建的。资源可以用JSON或YAML文件来表示。Kubernetes支持多种容器，其中Docker容器是最常见的。Kubernetes提供了容器访问的相关标准，并可以编排任何符合这些标准的容器。Kubernetes有很多功能。</p><p id="7a4b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在将公司的所有应用程序转换为微服务并使用容器进行部署后，您可以在集群中部署Kubernetes，使用Kubernetes提供的功能管理应用程序容器，并在Kubernetes上执行O&amp;M操作。作为使用最广泛的容器编排工具，Kubernetes已经成为容器编排的标准。然而，阿里巴巴集团也开发了自己的容器和容器编排工具。此外，在整个行业中，以Kubernetes为代表的集装箱管理方法衍生出了一些新技术。</p><h1 id="f8f3" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是云原生</h1><p id="efff" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">在过去的两年中，原生云已经成为云计算和IT领域的热门话题。<a class="ae lw" href="https://www.cncf.io/?spm=a2c41.14065545.0.0" rel="noopener ugc nofollow" target="_blank">云原生计算基金会</a> (CNCF)给出了云原生的如下定义:</p><p id="c58b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">云原生技术使组织能够在现代动态环境中构建和运行可扩展的应用，如公共云、私有云以及混合云。容器、服务网格、微服务、不可变基础设施和声明式API就是这种方法的例子。</em></p><p id="714e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这些技术可以构建具有良好容错性、易于管理和易于观察的松散耦合系统。与强大的自动化相结合，它们允许工程师以最少的努力频繁地、可预测地做出影响深远的改变。</p><p id="73a8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">更简单地说，cloud native本质上是指以下动作:将应用开发为微服务，通过使用容器进行部署，通过使用类似Kubernetes的容器编排工具管理容器集群，将开发和O&amp;M导向Kubernetes。Cloud native很有用，因为它允许您轻松地构建应用程序，全面地监控它们，并根据流量快速扩展和缩减它们。</p><p id="ef7e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如下图所示。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mp"><img src="../Images/dc0ad2a127f41df18c908f2bcf04a05b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SOuLcEOgVw5AcTTz.png"/></div></div></figure><p id="373e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Cloud native或多或少由四部分组成:微服务、容器、持续集成和交付以及DevOps。</p><h1 id="2fb8" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是服务网格？</h1><p id="74ea" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">到目前为止，在本文中，我们已经讨论了微服务、容器、容器编排和原生云。所有这些都为本文的主题提供了背景，即服务网格。简而言之，您可以将服务网格广义地定义为云原生微服务治理解决方案。</p><p id="5232" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦我们通过使用容器在Kubernetes上将应用程序部署为微服务，Service Mesh就可以为我们和我们的应用程序提供一个新的、透明的服务间调用和治理解决方案。该解决方案可以让我们摆脱对传统微服务治理框架的依赖。</p><p id="d272" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">服务网格的工作方式是，它为pod中的每个应用程序启动一个Sidecar，作为应用程序的透明代理。然后，应用程序的所有入站和出站流量都通过它的Sidecar。服务之间的调用变成了边车之间的调用，服务治理变成了边车治理。</p><p id="be70" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在服务网格中，Sidecar是透明的，开发人员察觉不到。在过去，我们总是需要引入库和注册服务，这样才能发现和调用应用程序。然而，服务网格中的应用程序对开发人员来说是完全透明的。</p><p id="89f4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这种实现依赖于容器编排工具。在Kubernetes上持续集成和交付应用程序的过程中，在应用程序的pod启动后，其服务已经在YAML文件中向Kubernetes注册，并声明了服务之间的关系。Service Mesh通过与Kubernetes通信获取集群中的所有服务信息，并通过Kubernetes实现对开发者的透明性。</p><p id="a8d0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下图显示了服务网格的基本结构，包括数据平面和控制平面。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi my"><img src="../Images/8c47c1458e143ce252fe3487925e0596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jOMZx4ODqVTygN8-.png"/></div></div></figure><p id="5e5f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这种模式有很多优点。这种模式中使用的语言不影响服务治理过程。服务网格只关心pod或pod中的容器实例，而不关心容器中应用程序的实现语言。边车与它管理的集装箱位于同一个箱内。</p><p id="7d0e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">服务网格可以实现跨语言支持，这是许多传统服务治理框架的一个主要缺点。此外，使用传统的服务治理会引入大量的应用程序依赖性，这会导致依赖性冲突。阿里巴巴集团利用潘多拉隔离应用的依赖性。此外，传统的服务治理很困难，需要开发人员对整个架构有所了解。</p><p id="ef2a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在传统的服务治理框架中，很难解决问题。这也导致开发和运营维护之间的界限不清。然而，使用Service Mesh，开发人员只需交付代码，O&amp;M人员就可以维护基于Kubernetes的整个容器集群。</p><h1 id="f4b0" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">服务网格是如何发展的</h1><p id="ae9e" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">服务网格这个术语最早出现在2016年，在过去两年里变得非常流行。蚂蚁金服有一套完整的服务网状服务框架，名为SOFAMesh，阿里巴巴其他很多团队也纷纷效仿。</p><p id="8300" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">尽管在过去的几年里发生了很多变化，程序开发正变得越来越简单。例如，在阿里巴巴，由于我们完整的技术系统和强大的技术能力，我们现在可以轻松地建立一个支持每秒大量查询的服务。</p><p id="d0c0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么，让我们来看看应用程序的开发过程。</p><h1 id="49ae" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">第1阶段:主机之间的直接连接</h1><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mz"><img src="../Images/efa6244e942d86186bc4b0d7fd12b5bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aL6glTofh1S7G1NS.png"/></div></div></figure><p id="1331" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上图显示的是最古老的阶段。在此阶段，两台主机通过网络电缆直接连接，一个应用程序包含所有可能的功能，包括两台主机的连接管理。当时，网络的概念还没有形成。毕竟，只有通过网络电缆直接连接的主机才能相互通信。</p><h1 id="40ed" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">阶段2:网络层的出现</h1><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi na"><img src="../Images/7f582cb451f4a551257d6a427ef0e988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jTpxP4Bap1FpXKnK.png"/></div></div></figure><p id="57e9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个阶段，网络层随着一些新技术的发展而出现。主机可以通过网络与连接到它的所有其它主机通信。</p><h1 id="6d8e" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">阶段3:应用程序中集成的节流</h1><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nb"><img src="../Images/8bfb9bfab9186e1b2f802e619d1fc19a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fSd5YnIkmkHETVKO.png"/></div></div></figure><p id="8abe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在此阶段，接收流量的能力会因每个应用程序的环境和主机配置而异。例如，当应用程序A发送的流量超过应用程序B允许的流量时，无法接收的数据包将被丢弃。由于这个问题，需要控制流量。在这个阶段，节流是由应用程序实现的，网络层只接收和传输来自应用程序的数据包。</p><h1 id="39ef" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">第4阶段:由网络层实施节流</h1><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nc"><img src="../Images/2f0e18e57ea19feb78e3b8a656d36bca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eflIBPEmPoO2kEdM.png"/></div></div></figure><p id="6e81" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">渐渐地，到了这个阶段，我们发现应用中的网络节流可以通过网络层来实现，如上图所示。当然，我们所说的网络层节流是指TCP节流，这样做是为了确保可靠的网络通信。</p><h1 id="feaa" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">阶段5:服务发现和断路器集成到应用程序中</h1><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nd"><img src="../Images/133ead538a422456f257047914174df0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jlNUTkr1M59UmT2s.png"/></div></div></figure><p id="6b24" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">开发人员在这个阶段开始在他们自己的代码模块中实现服务发现和断路器。</p><h1 id="245d" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">阶段6:用于服务发现和断路器的专用软件包和库</h1><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ne"><img src="../Images/46b5f4754cf212c4b7ba41ff623f5e93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2lUIW5B7IeIl1A1O.png"/></div></div></figure><p id="b566" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">开发人员在这个阶段开始能够通过引用第三方依赖来实现服务发现和断路器。</p><h1 id="e6fd" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">阶段7:用于服务发现和断路器的专用开源软件</h1><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nf"><img src="../Images/65391a94895f09e83af54d1251558337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/0*SPhyW7IxSIbo8dNm.png"/></div></div></figure><p id="f444" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个阶段，服务发现和断路器是基于各种中间件实现的。</p><h1 id="06a2" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">阶段8:服务网格的出现</h1><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ng"><img src="../Images/7050f3e3dc7b32325f3c3628330a916c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gLojWotyOlTqcvHc.png"/></div></div></figure><p id="ebb4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">服务网格的出现进一步提高了整个软件生命周期的生产率和效率。</p><h1 id="3f6f" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">市场竞争</h1><p id="f1bf" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">直到2017年底，服务网格才成为一种流行的解决方案。随着这种流行，微服务市场的竞争开始加剧。但事实是，服务网格早在2016年初就出现了。</p><p id="21a5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">2016年1月，基础设施工程师威廉·摩根和奥利弗·古尔德在离开Twitter后在GitHub上发布了<a class="ae lw" href="https://linkerd.io/?spm=a2c41.14065545.0.0" rel="noopener ugc nofollow" target="_blank"> Linkerd </a> 0.0.7。这标志着业内首个服务网格项目的诞生。基于Twitter的<a class="ae lw" href="https://twitter.github.io/finagle/?spm=a2c41.14065545.0.0" rel="noopener ugc nofollow" target="_blank"> Finagle </a>开源项目，Linkerd重用了Finagle类库，但实现了通用功能，成为业内第一个服务网格项目。</p><p id="6d6f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae lw" href="https://www.envoyproxy.io/?spm=a2c41.14065545.0.0" rel="noopener ugc nofollow" target="_blank">特使</a>是第二个出现的服务网格项目。它与Linkerd几乎同时开发，两者都在2017年成为CNCF项目。</p><p id="6f75" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">2017年5月24日，<a class="ae lw" href="https://istio.io/?spm=a2c41.14065545.0.0" rel="noopener ugc nofollow" target="_blank"> Istio </a> 0.1发布。Google和IBM高调宣布，社区反响热烈，许多公司表示支持该项目。</p><p id="2a27" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Istio发行后，Linkerd很快就被Istio盖过了。作为业内仅有的两个生产级服务网格实现之一，Linkerd仍然能够在市场上保持一定的竞争力，当然，直到Istio完全成熟。</p><p id="9683" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但随着Istio的稳步推进和成熟，Istio取代Linkerd只是时间问题。</p><p id="d57d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">与Linkerd相反，Envoy决定从2016年开始担任Istio的边车。Envoy不需要很多功能，因为它在数据平面上工作，大部分工作可以在Istio的控制平面上完成。这使得支持Envoy的团队能够专注于数据平面的详细改进。凭借与Linkerd完全不同的性质，Envoy为自己做了一个利基，使其不再成为主要服务网状市场激烈竞争的对象。</p><p id="1a9e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由Google和IBM联合推出的Istio自此一直备受瞩目，并得到了服务网格爱好者的广泛好评。作为下一代服务Mesh，Istio相比Linkerd优势明显。此外，其项目路线图要求在未来发布各种新功能。我们期待着它。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nh"><img src="../Images/b3be0cb7d83b801164c5d0a31e41b561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HcSKBKZbduyCYsPZ.png"/></div></div></figure><h1 id="d960" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是Istio</h1><p id="777c" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">因此，为了提供更详细的描述，Istio是最受欢迎的开源服务网格项目。它分为数据平面和控制平面。Istio实现了云原生微服务治理，还可以实现服务发现、节流和安全监控。Istio通过在pod中启动一个应用程序和一个Sidecar来提供透明代理服务。Istio是一个高度可伸缩的框架，支持Kubernetes和其他资源调度器，如<a class="ae lw" href="http://mesos.apache.org/?spm=a2c41.14065545.0.0" rel="noopener ugc nofollow" target="_blank"> Mesos </a>。下图显示了Istio的架构。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ni"><img src="../Images/e562300b7b19a68d0012b3c2b148f77a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lJFce6xLAPbz96Rs.png"/></div></div></figure><ul class=""><li id="424e" class="nj nk iq jw b jx jy kb kc kf nl kj nm kn nn kr no np nq nr bi translated">Istio在逻辑上分为数据平面和控制平面，数据平面是图的上半部分，控制平面是图的下半部分。</li><li id="23df" class="nj nk iq jw b jx ns kb nt kf nu kj nv kn nw kr no np nq nr bi translated">数据平面由一组部署在边车模式下的智能代理(特使)组成。这些代理可以调整和控制微服务和Mixer之间的所有网络通信。</li><li id="13a4" class="nj nk iq jw b jx ns kb nt kf nu kj nv kn nw kr no np nq nr bi translated">控制平面管理和配置代理来路由流量。此外，Mixer配置在控制平面上，用于执行策略和收集遥测数据。</li><li id="3cba" class="nj nk iq jw b jx ns kb nt kf nu kj nv kn nw kr no np nq nr bi translated">Pilot是架构中的抽象层，它抽象了Kubernetes等资源调度器的连接过程，将它们呈现为适配器，并与用户和Sidecars进行交互。</li><li id="6343" class="nj nk iq jw b jx ns kb nt kf nu kj nv kn nw kr no np nq nr bi translated">Galley验证资源配置。</li><li id="d74a" class="nj nk iq jw b jx ns kb nt kf nu kj nv kn nw kr no np nq nr bi translated">Citadel生成身份并管理密钥和证书。</li><li id="b694" class="nj nk iq jw b jx ns kb nt kf nu kj nv kn nw kr no np nq nr bi translated">核心功能包括节流、安全控制、可观察性、多平台支持和定制。</li></ul><h1 id="02c0" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是混音器</h1><p id="b2ec" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">混音器也是Istio中的一个可扩展模块。它收集遥感数据，并集成了一些后端即服务(BaaS)模块。Sidecar不断向Mixer报告其流量，然后Mixer汇总流量信息并显示出来。Sidecars可以调用Mixer提供的一些BaaS功能，例如身份验证、登录和日志记录。Mixer通过适配器连接到各种BaaS模块。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nx"><img src="../Images/218cd41053145053fb7b21a14ae0631a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SZ_VbxltJrsrC3Qk.png"/></div></div></figure><h1 id="2058" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是进程内适配器</h1><p id="8207" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">在Istio的早期版本中，BaaS适配器被集成到Mixer中。在这种模式下，方法调用在同一个进程中是快速的，但是一个BaaS适配器的失败将影响整个混合器。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ny"><img src="../Images/0c082ee7246d3bd444af64fb1cddbebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YJu8S0Hv7fBuT5hH.png"/></div></div></figure><h1 id="79be" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是进程外适配器</h1><p id="b6e5" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">在Istio的最新版本中，适配器被移到了Mixer之外，这意味着Mixer与适配器是分离的。这反过来也意味着任何适配器的故障都不会影响混频器。但是，这样做的一个缺点是适配器和Mixer之间的调用是通过远程过程调用(RPC)实现的，这比同一进程中的方法调用要慢得多。因此，性能受到影响。</p><h1 id="b3af" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是飞行员</h1><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nz"><img src="../Images/61639b0a831522dc47914bff041b3bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Mza3K-PrvXupxZZH.png"/></div></div></figure><ul class=""><li id="af31" class="nj nk iq jw b jx jy kb kc kf nl kj nm kn nn kr no np nq nr bi translated">特使API向特使发送服务发现信息和节流规则。</li><li id="f32b" class="nj nk iq jw b jx ns kb nt kf nu kj nv kn nw kr no np nq nr bi translated">抽象模型由飞行员定义，以分离特定平台细节并提供跨平台支持。</li><li id="61a2" class="nj nk iq jw b jx ns kb nt kf nu kj nv kn nw kr no np nq nr bi translated">平台适配器是这个抽象模型的实现版本，它连接到不同的外部平台，比如Kubernetes和Mesos。</li><li id="a58b" class="nj nk iq jw b jx ns kb nt kf nu kj nv kn nw kr no np nq nr bi translated">提供规则API是为了允许外部系统管理Pilot，包括Istio CLI (istioctl)和将来可能出现的第三方管理界面。</li></ul><h1 id="817f" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是厨房</h1><p id="7c8e" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">厨房是Istio控制面板的一部分。最初，厨房只验证配置。但是，从Istio版本1.1开始，Galley可以作为整个控制平面的配置管理中心，还可以管理和分发配置。Galley使用网格配置协议与其他组件交换配置。</p><p id="975b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Istio有50多个自定义资源定义(CRD)。许多人说面向Kubernetes的编程类似于面向YAML的编程。在早期，Galley只在运行时验证配置，Istio控制平面的每个组件都列出或观察相应的配置。然而，不断增加的配置数量和复杂性给Istio用户带来了诸多不便:</p><ul class=""><li id="2e98" class="nj nk iq jw b jx jy kb kc kf nl kj nm kn nn kr no np nq nr bi translated">配置不是一起管理的，组件分别进行订阅，并且没有统一的回滚机制。这使得定位配置问题变得困难。</li><li id="efc2" class="nj nk iq jw b jx ns kb nt kf nu kj nv kn nw kr no np nq nr bi translated">此外，配置的可重用性相对较低。例如，在1.1版本之前，需要为每个混音器适配器定义一个新的CRD。</li><li id="32fb" class="nj nk iq jw b jx ns kb nt kf nu kj nv kn nw kr no np nq nr bi translated">配置隔离、访问控制列表(ACL)、一致性、抽象和序列化的性能仍然不能令人满意。</li></ul><p id="c2c6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">随着Istio的进一步发展，Istio CRDs的数量将继续增加。社区计划加强Galley，使其成为Istio的配置控制层。除了验证配置，Galley还将提供一个配置管理管道，包括输入、转换、分发和适用于Istio控制平面的网格配置协议(MCP)。</p><h1 id="5c08" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是城堡</h1><p id="e6ee" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">现在让我们讨论一下Istio，Citadel的安全方面。将服务拆分为微服务带来了各种好处，但也提出了更多的安全要求。毕竟不同功能模块之间的方法调用都改成了微服务之间的远程调用。</p><ul class=""><li id="b9f1" class="nj nk iq jw b jx jy kb kc kf nl kj nm kn nn kr no np nq nr bi translated">加密:为了防止信息泄露和防止中间人攻击，服务间的通信需要加密。</li><li id="2391" class="nj nk iq jw b jx ns kb nt kf nu kj nv kn nw kr no np nq nr bi translated">访问控制:并非所有服务都可以访问。因此，我们需要灵活的访问控制，例如双向传输层安全性(TLS)和细粒度的访问策略。</li><li id="2125" class="nj nk iq jw b jx ns kb nt kf nu kj nv kn nw kr no np nq nr bi translated">审计:需要审计功能来审计系统中的用户操作。</li></ul><p id="eb9c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Citadel是Istio中的安全组件。然而，Citadel必须与多个其他组件一起工作。</p><ul class=""><li id="2b65" class="nj nk iq jw b jx jy kb kc kf nl kj nm kn nn kr no np nq nr bi translated">Citadel管理密钥和证书，并将它们交付给负责通信和转发的组件，如Envoy。</li><li id="2a4a" class="nj nk iq jw b jx ns kb nt kf nu kj nv kn nw kr no np nq nr bi translated">Envoy使用Citadel提供的密钥和证书来确保服务间通信的安全性。Localhost用于应用程序和特使之间，因此不需要加密。</li><li id="56ec" class="nj nk iq jw b jx ns kb nt kf nu kj nv kn nw kr no np nq nr bi translated">Pilot向Envoy发送授权策略和安全命名信息。</li><li id="bd59" class="nj nk iq jw b jx ns kb nt kf nu kj nv kn nw kr no np nq nr bi translated">Mixer管理授权并执行审计。</li></ul><p id="71b4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Istio支持以下安全功能:</p><ul class=""><li id="5671" class="nj nk iq jw b jx jy kb kc kf nl kj nm kn nn kr no np nq nr bi translated">流量加密:Istio加密服务之间的通信流量。</li><li id="5776" class="nj nk iq jw b jx ns kb nt kf nu kj nv kn nw kr no np nq nr bi translated">身份认证:Istio通过内置的身份和凭证管理，包括传输认证和源认证，提供强大的服务间和最终用户身份认证功能。它还支持双向TLS。</li><li id="b6da" class="nj nk iq jw b jx ns kb nt kf nu kj nv kn nw kr no np nq nr bi translated">授权和认证:Istio提供基于角色的访问控制(RBAC)以及名称空间、服务和方法级别的访问控制。</li></ul><h1 id="0fc8" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">原始来源:</h1><div class="lx ly gp gr lz ma"><a href="https://www.alibabacloud.com/blog/getting-started-with-service-mesh_595829?spm=a2c41.14065545.0.0" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd ir gy z fp mf fr fs mg fu fw ip bi translated">服务网格入门</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">阿里巴巴Clouder年2月14日147本文由彭家豪撰写，他在阿里巴巴的昵称是易信。彭是一个…</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">www.alibabacloud.com</p></div></div><div class="mj l"><div class="oa l ml mm mn mj mo js ma"/></div></div></a></div><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ob oc l"/></div></figure></div></div>    
</body>
</html>