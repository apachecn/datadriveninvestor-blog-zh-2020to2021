<html>
<head>
<title>Digging into Numpy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入调查Numpy</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/digging-into-a919dda9d3f?source=collection_archive---------35-----------------------#2021-01-05">https://medium.datadriveninvestor.com/digging-into-a919dda9d3f?source=collection_archive---------35-----------------------#2021-01-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/763740be822cdbb093d588c4c9f0ec38.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*4q9Orh4nPd4i9sP54F4FPA.png"/></div></figure><p id="1515" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Numpy是一个用于处理数学计算的python包。它就像C语言的一层薄薄的包装。</p><p id="a42a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这使得numpy计算执行得非常快。它比python列表更接近C数组。</p><h2 id="1759" class="ks kt iq bd ku kv kw dn kx ky kz dp la kf lb lc ld kj le lf lg kn lh li lj lk bi translated">数量和安装的先决条件</h2><p id="cc04" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">要开始使用numpy，唯一的先决条件是您应该安装python</p><p id="50b3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Python可以从<a class="ae lq" href="https://www.python.org/ftp/python/3.9.1/python-3.9.1-amd64.exe" rel="noopener ugc nofollow" target="_blank">这里</a>下载。</p><p id="e5e1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下载python的同时也安装了pip包管理器，可以用来下载numpy包。</p><blockquote class="lr ls lt"><p id="8cf8" class="ju jv lu jw b jx jy jz ka kb kc kd ke lv kg kh ki lw kk kl km lx ko kp kq kr ij bi translated">pip安装数量</p></blockquote><h1 id="2654" class="ly kt iq bd ku lz ma mb kx mc md me la mf mg mh ld mi mj mk lg ml mm mn lj mo bi translated">Numpy及其优势</h1><ul class=""><li id="3c3f" class="mp mq iq jw b jx ll kb lm kf mr kj ms kn mt kr mu mv mw mx bi translated">Numpy数组本质上是同质的。这意味着每个数组只包含一次数据。相反，这些清单在本质上是不同的。</li><li id="b2b7" class="mp mq iq jw b jx my kb mz kf na kj nb kn nc kr mu mv mw mx bi translated">numpy数组存储在连续的内存位置，就像在c中一样。另一方面，c中的列表存储就像一个链表实现。这使得访问numpy数组更快。</li><li id="4494" class="mp mq iq jw b jx my kb mz kf na kj nb kn nc kr mu mv mw mx bi translated">与列表相比，Numpy数组占用的空间也更少。这是因为列表需要一个指针来引用下一个节点或元素。这需要额外的内存。</li><li id="6c0a" class="mp mq iq jw b jx my kb mz kf na kj nb kn nc kr mu mv mw mx bi translated">Numpy数组有助于对大量数据进行数学和其他类型的运算。通常，与使用pythons内置序列相比，这种操作的执行效率更高，代码更少</li></ul><p id="a37f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">也许你对100万个单元不太在意，但对10亿个单元你肯定会在意——这两种方法都不适合32位架构，但对于64位版本，NumPy可以用4 GB左右，Python本身至少需要大约12 GB，这是一种昂贵得多的硬件。</p><p id="b6ac" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，这不应该作为numpy数组比列表更好的论据。两者都有不同的用例，我多次引用列表来说明阵列的优势。</p><p id="d45c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">numpy的强大和受欢迎程度可以通过几乎每个机器学习或数据科学库(如scikit-learn、tensorflow等)都只接受numpy数组的输入来了解</p><h1 id="cb2a" class="ly kt iq bd ku lz ma mb kx mc md me la mf mg mh ld mi mj mk lg ml mm mn lj mo bi translated">Numpy的局限性</h1><p id="d8be" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">就像我前面提到的，numpy数组处理同源数据。因此，如果我们想存储异构数据，我们将不得不使用列表。</p><p id="fe2a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">除此之外，numpy没有太多的限制。这是因为大部分的限制是缺乏其他补充模块如pandas、matplotlib等所解决的特性。</p><p id="37d6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，如果我们想要可视化，我们可以使用seaborn或matplotlib，如果我们想要更多的数据库类型来查看我们正在查看的数据，我们可以使用构建在numpy本身之上的pandas。</p><h1 id="fda2" class="ly kt iq bd ku lz ma mb kx mc md me la mf mg mh ld mi mj mk lg ml mm mn lj mo bi translated">让我们来看看Numpy中的一些常见操作</h1><p id="8fd3" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">现在我将重点介绍一些可以使用numpy执行的操作。</p><h2 id="3c64" class="ks kt iq bd ku kv kw dn kx ky kz dp la kf lb lc ld kj le lf lg kn lh li lj lk bi translated">初始化</h2><ul class=""><li id="731a" class="mp mq iq jw b jx ll kb lm kf mr kj ms kn mt kr mu mv mw mx bi translated"><strong class="jw ir">创建全零数组</strong></li></ul><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/f86d5d89de4ed4251a4680ea4b5e0a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*w8O_3w5A3tZhZKJdSBzUXA.png"/></div></figure><p id="9c5c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">np.zeros( <specify_size>)用于创建一个用零初始化的numpy数组。</specify_size></p><ul class=""><li id="c519" class="mp mq iq jw b jx jy kb kc kf ni kj nj kn nk kr mu mv mw mx bi translated"><strong class="jw ir">创建全1数组</strong></li></ul><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/e6dabcd590f60b849d7bd760b2e6caec.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*Vmc52D6VQ9Jvauij-KfeCg.png"/></div></figure><p id="9b03" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这与用零初始化所有元素的操作相似。</p><ul class=""><li id="87d7" class="mp mq iq jw b jx jy kb kc kf ni kj nj kn nk kr mu mv mw mx bi translated"><strong class="jw ir">创建一个元素间隔相等的数组</strong></li></ul><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/7c0ea8bce596b07491ec01017145f3fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*yEom7e1uxw3nkHnS9OTVBg.png"/></div></figure><p id="e0a2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Linspace帮助创建一个具有等距元素的数组。在给定的示例中，它创建了一个大小为5的数组，其中1到50之间的元素等距分布。</p><blockquote class="lr ls lt"><p id="6bf4" class="ju jv lu jw b jx jy jz ka kb kc kd ke lv kg kh ki lw kk kl km lx ko kp kq kr ij bi translated">np.linspace( <start_range>、<end_range>、<shape_of_array>)</shape_of_array></end_range></start_range></p></blockquote><p id="a185" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要简单地创建自定义数组，我们可以使用以下命令</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/1f6eadd2a09f684c7855865c555efdad.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*OdcQbJ4YhKFKx33gXztFZg.png"/></div></figure><p id="d377" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们传入一个列表，numpy将它转换成一个数组</p><p id="25ec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">还有许多其他的初始化方法，比如从正态分布或以0为中心的正态分布中获取值等等。</p><h2 id="833f" class="ks kt iq bd ku kv kw dn kx ky kz dp la kf lb lc ld kj le lf lg kn lh li lj lk bi translated">访问元素</h2><p id="8ec6" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">我们可以使用索引来访问数组的元素。</p><blockquote class="lr ls lt"><p id="68fc" class="ju jv lu jw b jx jy jz ka kb kc kd ke lv kg kh ki lw kk kl km lx ko kp kq kr ij bi translated">使用列表和数组之间的切片来访问元素的一个关键区别是，数组支持垂直和水平切片，而列表只支持水平切片。</p></blockquote><p id="6bfc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在解释这一点之前，我会解释什么是切片</p><p id="6d54" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">切片:</strong></p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/ab7daf72a805277f11baf10e1857e624.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*2jkgGehGS5vc1U0oq55vMA.png"/></div></figure><p id="0b77" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要访问一组元素，我们可以使用切片。切片的语法:</p><blockquote class="lr ls lt"><p id="5984" class="ju jv lu jw b jx jy jz ka kb kc kd ke lv kg kh ki lw kk kl km lx ko kp kq kr ij bi translated"><array_or_list_name> [ <start_index> : <end_index> ]</end_index></start_index></array_or_list_name></p></blockquote><p id="6a6a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">需要注意的一点是，当我们指定<end_index>时，它被排除在外。例如，当计算y[:3]时，输出是[1，2，3]而不是[1，2，3，4]。</end_index></p><p id="f7ce" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">类似地，当我们想访问最后几个元素，但不知道或者不想知道最后一个索引时，也会出现这种情况。为此我们可以使用负数。负1代表最后一个数字，从这里我们可以访问其他元素。你可以在上面的例子中看到。</p><p id="9f9f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">列表vs数组切片</strong></p><p id="3df5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了解释这个区别，你可以看下面的例子</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi np"><img src="../Images/bedb157ec4c7c6400d3a0194e25d2667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*psD2P-Pfj4jO27-cYvQg5w.png"/></div></div></figure><p id="9ed1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以看到，我们无法使用列表切片来访问同一列不同行的垂直元素。虽然当我们把同样的列表转换成数组时，我们可以很容易地做到这一点。这显示了我前面引用的列表中数组的一个重要属性。</p><h1 id="9503" class="ly kt iq bd ku lz ma mb kx mc md me la mf mg mh ld mi mj mk lg ml mm mn lj mo bi translated">查看与复制</h1><p id="1536" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">每当我们访问这些元素时，我们都能在屏幕上看到输出。然而，这可以代表两件事。当内容被物理地存储在另一个位置时，它被称为<strong class="jw ir">拷贝</strong>。另一方面，如果提供相同存储器内容的不同视图，我们称之为<strong class="jw ir">视图</strong>。</p><p id="8df1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">视图只是原始阵列的视图，视图不拥有数据。当我们对视图进行更改时，它会影响原始阵列，当对原始阵列进行更改时，它会影响视图。</p><h1 id="95ab" class="ly kt iq bd ku lz ma mb kx mc md me la mf mg mh ld mi mj mk lg ml mm mn lj mo bi translated">数字线性代数</h1><p id="d415" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">线性代数是数据科学领域中最重要的课题之一。Numpy提供了高度优化的线性代数函数，因为它们是围绕C函数包装的。</p><h1 id="d5b6" class="ly kt iq bd ku lz ma mb kx mc md me la mf mg mh ld mi mj mk lg ml mm mn lj mo bi translated">矢量化运算</h1><ul class=""><li id="90b4" class="mp mq iq jw b jx ll kb lm kf mr kj ms kn mt kr mu mv mw mx bi translated">当向量与标量相乘时，向量的每个元素都与标量相乘:</li></ul><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/d3eb99fb3884710fb469cf0194eff166.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*TmsNH1MYl7Zg_YoZMxYkGg.png"/></div></figure><ul class=""><li id="b9b6" class="mp mq iq jw b jx jy kb kc kf ni kj nj kn nk kr mu mv mw mx bi translated">另一个常见的操作是<strong class="jw ir">点积</strong>。两个向量的点积是关于位置的元素乘积的和。一个向量的第一个元素乘以第二个向量的第一个元素，依此类推。这些积的和就是点积，可以用<strong class="jw ir"> np.dot() </strong>函数来做。</li></ul><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/60ca8fea85285c01f80ad9ebbd106cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*scarAHNAoSUPh_Ck8x2wbg.png"/></div></figure><ul class=""><li id="9bd1" class="mp mq iq jw b jx jy kb kc kf ni kj nj kn nk kr mu mv mw mx bi translated">向量的元素求和与减法是通过标准的数学运算完成的。</li></ul><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/de4c3f136e8742b009b2523c36bd5339.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*8OV7x7aFIWNZ9TpPYLWLSQ.png"/></div></figure><h1 id="9095" class="ly kt iq bd ku lz ma mb kx mc md me la mf mg mh ld mi mj mk lg ml mm mn lj mo bi translated">广播</h1><p id="3752" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">每个通用函数接受数组输入，并通过对输入逐元素执行核心函数来产生数组输出(其中元素通常是标量，但可以是向量或广义ufuncs的高阶子数组)。应用标准的广播规则，使得不共享完全相同形状的输入仍然可以被有效地操作。广播可以用四个规则来理解:</p><ol class=""><li id="da50" class="mp mq iq jw b jx jy kb kc kf ni kj nj kn nk kr nx mv mw mx bi translated">ndim小于最大ndim的输入数组的所有输入数组的形状前都有1。</li><li id="f3ba" class="mp mq iq jw b jx my kb mz kf na kj nb kn nc kr nx mv mw mx bi translated">输出形状的每个维度中的大小是该维度中所有输入大小的最大值。</li><li id="9df2" class="mp mq iq jw b jx my kb mz kf na kj nb kn nc kr nx mv mw mx bi translated">如果输入在特定维度中的大小与该维度中的输出大小匹配，或者其值正好为1，则可以在计算中使用该输入。</li><li id="1a87" class="mp mq iq jw b jx my kb mz kf na kj nb kn nc kr nx mv mw mx bi translated">如果输入在其形状中的维度大小为1，则该维度中的第一个数据条目将用于该维度上的所有计算。换句话说，<a class="ae lq" href="https://numpy.org/doc/stable/glossary.html#term-ufunc" rel="noopener ugc nofollow" target="_blank"> ufunc </a>的步进机械将不会沿该维度步进(对于该维度，<a class="ae lq" href="https://numpy.org/doc/stable/reference/arrays.ndarray.html#memory-layout" rel="noopener ugc nofollow" target="_blank">步距</a>将为0)。</li></ol><p id="9ce8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果上述规则产生有效结果，<em class="lu">即</em>，则一组数组被称为“可广播”到相同的形状，以下情况之一为真:</p><ol class=""><li id="5aa4" class="mp mq iq jw b jx jy kb kc kf ni kj nj kn nk kr nx mv mw mx bi translated">这些阵列都有完全相同的形状。</li><li id="cb83" class="mp mq iq jw b jx my kb mz kf na kj nb kn nc kr nx mv mw mx bi translated">这些数组都具有相同的维数，并且每个维数的长度要么是共同的长度，要么是1。</li><li id="d579" class="mp mq iq jw b jx my kb mz kf na kj nb kn nc kr nx mv mw mx bi translated">维度太少的数组可以在形状前添加长度为1的维度，以满足属性2。</li></ol><h1 id="598e" class="ly kt iq bd ku lz ma mb kx mc md me la mf mg mh ld mi mj mk lg ml mm mn lj mo bi translated">通用函数</h1><p id="98da" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">在NumPy中，通用函数是numpy.ufunc类的实例。许多内置函数都是用编译后的C代码实现的。基本的ufuncs对标量进行操作，但还有一种通用类型，其基本元素是子数组(向量、矩阵等)。)，而广播是在其他维度之上完成的。</p><p id="987d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">通用函数(或简称为<a class="ae lq" href="https://numpy.org/doc/stable/glossary.html#term-ufunc" rel="noopener ugc nofollow" target="_blank"> ufunc </a>)是一个以逐个元素的方式对数组进行操作的函数，支持<a class="ae lq" href="https://numpy.org/doc/stable/reference/ufuncs.html#ufuncs-broadcasting" rel="noopener ugc nofollow" target="_blank">数组广播</a>、<a class="ae lq" href="https://numpy.org/doc/stable/reference/ufuncs.html#ufuncs-casting" rel="noopener ugc nofollow" target="_blank">类型转换</a>以及其他几个标准特性。也就是说，ufunc是一个函数的“<a class="ae lq" href="https://numpy.org/doc/stable/glossary.html#term-vectorization" rel="noopener ugc nofollow" target="_blank">矢量化</a>”包装器，它接受固定数量的特定输入并产生固定数量的特定输出。</p><h1 id="e5d2" class="ly kt iq bd ku lz ma mb kx mc md me la mf mg mh ld mi mj mk lg ml mm mn lj mo bi translated">以数字表示的日期和时间</h1><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi ny"><img src="../Images/636b85ba0bb807e899d9e899f904b642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bRTFOZdTbyyknOGto8MJ7A.png"/></div></div></figure><p id="750b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有些核心数组数据类型本身支持日期时间功能。数据类型称为“datetime64”，这样命名是因为Python中包含的datetime库已经采用了“datetime”。</p><p id="4fd1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以通过解析datetime64函数中的字符串来创建日期时间。它的语法是</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/bba087465c8b7f52b72b4d15b64b581d.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*a2Y6Iei0txB3G9_MQ7w_OA.png"/></div></figure><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/71164e231e7d7a1bcb5294101bd31d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BH93bwps_TJoC_3MLoaanw.png"/></div></figure><p id="158f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以看到在日期的情况下加减是有意义的，所以我们可以执行这些操作。我们也可以在这些日期执行算术运算。</p><p id="d271" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">datetime类型与许多常见的NumPy函数一起使用，例如，arange可用于生成日期范围。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi ob"><img src="../Images/002d518c29a9f34883f76ded2cb97a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pk53JZlZ05UjHl2qBc5T_w.png"/></div></div></figure><p id="ba97" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们还有处理工作日的功能。默认情况下，工作日被指定为从星期一到星期五。</p><p id="69f4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当输入日期是周末或假日时，busday_offset首先应用规则将日期滚动到有效的工作日，然后应用偏移量。默认规则是“引发”，它只是引发一个异常。最常用的规则是“向前”和“向后”。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/14e6b310d7886e93c70f43028c270847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*dQtBlgDPQjMj1uQEQtL4hg.png"/></div></figure><p id="d94b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因为2021年1月2日是星期六，所以如果我们想要下一个工作日，下一个工作日将是1月4日。然而，我们希望最后一个工作日是1月1日，也就是星期五。</p><p id="e3b6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">访问专家视图— </strong> <a class="ae lq" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">订阅DDI英特尔</strong> </a></p><h1 id="2391" class="ly kt iq bd ku lz ma mb kx mc md me la mf mg mh ld mi mj mk lg ml mm mn lj mo bi translated">参考</h1><ul class=""><li id="3afd" class="mp mq iq jw b jx ll kb lm kf mr kj ms kn mt kr mu mv mw mx bi translated"><a class="ae lq" href="https://webcourses.ucf.edu/courses/1249560/pages/python-lists-vs-numpy-arrays-what-is-the-difference" rel="noopener ugc nofollow" target="_blank">https://web courses . ucf . edu/courses/1249560/pages/python-lists-vs-numpy-arrays-what-is-the-difference</a></li><li id="2a18" class="mp mq iq jw b jx my kb mz kf na kj nb kn nc kr mu mv mw mx bi translated"><a class="ae lq" href="https://www.tutorialspoint.com/numpy/numpy_copies_and_views.htm" rel="noopener ugc nofollow" target="_blank">https://www . tutorialspoint . com/numpy/numpy _ copies _ and _ views . htm</a></li><li id="9a82" class="mp mq iq jw b jx my kb mz kf na kj nb kn nc kr mu mv mw mx bi translated"><a class="ae lq" href="https://scipy-cookbook.readthedocs.io/items/ViewsVsCopies.html" rel="noopener ugc nofollow" target="_blank">https://scipy-cookbook . readthedocs . io/items/viewsvscopies . html</a></li><li id="f4c9" class="mp mq iq jw b jx my kb mz kf na kj nb kn nc kr mu mv mw mx bi translated">https://numpy.org/doc/stable/reference/routines.linalg.html<a class="ae lq" href="https://numpy.org/doc/stable/reference/routines.linalg.html" rel="noopener ugc nofollow" target="_blank"/></li><li id="a2eb" class="mp mq iq jw b jx my kb mz kf na kj nb kn nc kr mu mv mw mx bi translated">【https://numpy.org/doc/stable/reference/ufuncs.html T4】</li><li id="0c7e" class="mp mq iq jw b jx my kb mz kf na kj nb kn nc kr mu mv mw mx bi translated"><a class="ae lq" href="https://stackoverflow.com/questions/13703720/converting-between-datetime-timestamp-and-datetime64" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/13703720/converting-between-datetime-timestamp-and-date time 64</a></li><li id="39b5" class="mp mq iq jw b jx my kb mz kf na kj nb kn nc kr mu mv mw mx bi translated"><a class="ae lq" href="https://numpy.org/doc/stable/reference/arrays.datetime.html" rel="noopener ugc nofollow" target="_blank">https://numpy.org/doc/stable/reference/arrays.datetime.html</a></li><li id="e94e" class="mp mq iq jw b jx my kb mz kf na kj nb kn nc kr mu mv mw mx bi translated"><a class="ae lq" href="https://numpy.org/doc/stable/reference/generated/numpy.busday_offset.html#numpy.busday_offset" rel="noopener ugc nofollow" target="_blank">https://numpy . org/doc/stable/reference/generated/numpy . busday _ offset . html # numpy . busday _ offset</a></li></ul><p id="6d09" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">访问专家视图— </strong> <a class="ae lq" href="https://datadriveninvestor.com/ddi-intel" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">订阅DDI英特尔</strong> </a></p></div></div>    
</body>
</html>