<html>
<head>
<title>The smlar Plug-in for Effective Retrieval of Massive Volumes of SimHash Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于有效检索大量SimHash数据的smlar插件</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/the-smlar-plug-in-for-effective-retrieval-of-massive-volumes-of-simhash-data-e429c19da1a3?source=collection_archive---------8-----------------------#2020-02-11">https://medium.datadriveninvestor.com/the-smlar-plug-in-for-effective-retrieval-of-massive-volumes-of-simhash-data-e429c19da1a3?source=collection_archive---------8-----------------------#2020-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/a573f84f018202a3d3b9fa6348355179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*7USj_6KjeqZDhD6l.jpeg"/></div></figure><h1 id="56a8" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">背景</h1><p id="e938" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">SimHash是一种确定数据集之间相似性的算法。Google Crawler使用SimHash查找相似的页面，避免内容重复。</p><p id="6afc" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">参考上面提到的文章，SimHash算法有助于为每个网页生成向量指纹。因此，如果您想知道我们如何使用SimHash来确定文档之间的相似性，那么让我们快速查看以下步骤，以获得使用汉明距离的应用程序的概述:</p><p id="65a6" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">什么是海明距离？<br/>码字间的汉明距离是不同值的比特数。有效码集中码字之间的最小汉明距离是该码集的汉明距离。例如，10101和00110在第一、第四和第五位具有不同的值，因此汉明距离为3。</p><p id="6d32" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">汉明距离的几何意义<br/>一个n比特的码字可以用n维空间中的一个超立方体顶点来表示。码字之间的汉明距离是超立方体顶点之间最短距离的边。</p><p id="8b5f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">汉明距离应用场景<br/>汉明距离应用于代码错误检查和纠正。</p><p id="d373" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">一旦通过使用SimHash算法提取了指纹，就使用汉明距离来计算相似性。SimHash算法更适合于超过500个单词的长文档。对于短文档，差别可能很大，这取决于应用场景。根据谷歌论文中发表的数据，如果签名是64位，汉明距离是3，则两个文档被认为是相似或重复的。在这个例子中，汉明距离3仅作为参考；在不同的应用场景中可以提供不同的测试值。</p><div class="lv lw gp gr lx ly"><a href="https://www.datadriveninvestor.com/2018/09/22/infographic-journey-to-the-clouds/" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd ir gy z fp md fr fs me fu fw ip bi translated">信息图:云之旅|数据驱动的投资者</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">聪明的企业领导者了解利用云的价值。随着数据存储需求的增长，他们已经…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">www.datadriveninvestor.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm js ly"/></div></div></a></div><p id="8c5a" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">上面解释的技术有助于获得相似性。但是，当有数百亿条数据记录时，就存在一个效率问题。当不断添加数据时，效率会随着每个新数据记录与数据库中所有现有数据的比较而下降。</p><p id="89dc" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">为了提高海量数据的重复数据消除效率，我们可以将64位指纹划分为四个16位数据块。基于抽屉原理，如果当汉明距离为3时两个文档相似，则它们在一个块中一定具有相同的数据。</p><p id="7b5d" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">这里出现的下一个问题是，是否有任何数据库能够有效地支持这种海量数据的检索。</p><p id="58f1" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">多亏了smlar插件，<a class="ae mn" href="https://www.alibabacloud.com/product/apsaradb-for-rds-postgresql?spm=a2c41.13977169.0.0" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>数据库支持如此高效的检索。</p><h1 id="07f0" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">1.要求</h1><p id="63a6" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">首先，从海量SimHash数据池中快速搜索与特定SimHash数据记录相似的SimHash数据记录。</p><h1 id="02ec" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">2.建筑设计</h1><p id="e713" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">PostgreSQL支持多种设计方法在海量数据池中搜索汉明距离小于N的数据。每种设计方法都有不同的能效比(EER)。您可以根据自己的需求选择以下任何一种方法。</p><h1 id="4729" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">a.强力计算</h1><p id="695f" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">暴力扫描的单节点多核并行计算<br/>阿里云ApsaraDB RDS for PostgreSQL 10提供的多核并行计算用于暴力扫描。</p><p id="4efc" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">蛮力扫描多节点多核并行计算<br/>阿里云HybridDB为PostgreSQL提供的多级并发计算用于蛮力扫描。</p><p id="c433" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">用于强力计算加速的GPU和FPGA功能<br/> PostgreSQL提供了扩展接口，允许您使用GPU和FPGA功能进行数据计算。</p><p id="597c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">蛮力计算的CPU向量计算命令<br/> PostgreSQL提供了扩展接口，允许你使用CPU向量计算命令来加速计算。</p><h1 id="25c1" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">b.索引</h1><p id="f10e" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">索引是一种有效的检索方法。比如PostgreSQL smlar插件，利用阿里巴巴导购平台上的索引，及时从海量导购文章池中查询相似的导购文章。</p><p id="cbef" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">为了使smlar插件能够加速基于汉明距离的数据搜索，需要采用更科学的方法，比如切片。</p><p id="c89f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">直接使用位置会产生问题，因为smlar插件的第一个过程是块级收敛。然而，汉明码是64位的。一个数据块包含若干条记录，0和1可能同时出现在任何位置。因为所有数据块都包含0和1，所以在第一个过程中过滤失败。</p><p id="9da4" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">我们可以使用切片来降低过滤失败的可能性。例如，每两个、四个或更多比特被分类为一个片。</p><p id="34a4" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">通常，如果记录之间的汉明距离大于3，则两个记录彼此不相关。</p><h1 id="190f" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">3.演示和性能</h1><h1 id="4651" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">a.强力计算</h1><p id="3a9d" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">为了说明全扫描和并行扫描，首先，创建一个测试表。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e7a7" class="mx jv iq mt b gy my mz l na nb">create table hm (  <br/>  id int,        -- id  <br/>  hmval bit(64)  -- 海明HASH  <br/>);</span></pre><p id="a612" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">现在，向表中写入1000万条测试数据记录。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6d2c" class="mx jv iq mt b gy my mz l na nb">postgres=# insert into hm select id, val::int8::bit(64) from (select id, sqrt(random())::numeric*9223372036854775807*2-9223372036854775807::numeric as val from generate_series(1,10000000) t(id)) t;  <br/>INSERT 0 10000000  <br/>  <br/>postgres=# select * from hm limit 10;  <br/> id |                              hmval                                 <br/>----+------------------------------------------------------------------  <br/>  1 | 0000101001110110110101010111101011100110101010000111100011110111  <br/>  2 | 0110011100110101101000001010101111010001011101100111111011001110  <br/>  3 | 1010110111001011011110110000111111101101101111010111111100101110  <br/>  4 | 0110011110110000001011000010010000101011100101010100111000101001  <br/>  5 | 0101110100101111010110010110000000101110000010001011010110110000  <br/>  6 | 0011010000100000101011011100000101111110010110111101100001100001  <br/>  7 | 1011110011101101101000011101011101010111011001011010110111101000  <br/>  8 | 1110010011000101001101110010001111110100001101010101111101110010  <br/>  9 | 0110111111110011101001001000101101011011111100010010111010001111  <br/> 10 | 0011100011000010101011010001111000000110100011100100111011011001  <br/>(10 rows)</span></pre><p id="b452" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">设置蛮力计算的并行度。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4641" class="mx jv iq mt b gy my mz l na nb">postgres=# set force_parallel_mode = on;  <br/>postgres=# set min_parallel_table_scan_size = 0;  <br/>postgres=# set parallel_setup_cost = 0;  <br/>postgres=# set parallel_tuple_cost = 0;  <br/>postgres=# alter table hm set (parallel_workers = 128);  <br/>postgres=# set max_parallel_workers_per_gather = 64;</span></pre><p id="a5ed" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">并发查询汉明距离小于4的记录。这需要463毫秒才能完成。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="0891" class="mx jv iq mt b gy my mz l na nb">postgres=# select * from hm where length(replace(bitxor(bit'0011110001011010110010001011010101001000111110000111110010010110', hmval)::text,'0','')) &lt; 4;  <br/> id |                              hmval                                 <br/>----+------------------------------------------------------------------  <br/> 16 | 0011110001011010110010001011010101001000111110000111110010010110  <br/>(1 row)  <br/>  <br/>Time: 463.314 ms</span></pre><p id="b4ff" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">非并发查询汉明距离小于4的记录。这需要16秒来完成。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="8b34" class="mx jv iq mt b gy my mz l na nb">postgres=# select * from hm where length(replace(bitxor(bit'0011110001011010110010001011010101001000111110000111110010010110', hmval)::text,'0','')) &lt; 4;  <br/> id |                              hmval                                 <br/>----+------------------------------------------------------------------  <br/> 16 | 0011110001011010110010001011010101001000111110000111110010010110  <br/>(1 row)  <br/>  <br/>Time: 16791.215 ms (00:16.791)</span></pre><p id="2a46" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">有更有效的方法来查询字符串之间不同值的位数。理论上，这需要不到100毫秒来完成。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="eb60" class="mx jv iq mt b gy my mz l na nb"><a class="ae mn" href="https://www.postgresql.org/message-id/flat/ab1ea6540903121110l2a3021d4h6632b206e2419898%40mail.gmail.com#ab1ea6540903121110l2a3021d4h6632b206e2419898@mail.gmail.com" rel="noopener ugc nofollow" target="_blank">https://www.postgresql.org/message-id/flat/ab1ea6540903121110l2a3021d4h6632b206e2419898%40mail.gmail.com#ab1ea6540903121110l2a3021d4h6632b206e2419898@mail.gmail.com</a></span></pre><h1 id="84ba" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">b.索引</h1><p id="e0cd" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">阿里云RDS PostgreSQL提供了一个smlar插件，高效查询数组间的相似度。因此，我们需要将SimHash数据记录转换成数组。</p><p id="28c1" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">根据前面的设计，将八位分类到一个数组中，以搜索汉明距离小于或等于8的值。</p><p id="78ce" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">切片前，在数据切片后验证过滤。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="93c0" class="mx jv iq mt b gy my mz l na nb">postgres=# select relpages from pg_class where relname='hm';  <br/> relpages   <br/>----------  <br/>    63695  <br/>(1 row)  <br/>  <br/>1、单个片为1时，不用说，每个块都包含。  <br/>  <br/>postgres=# select count(*) from (select substring(ctid::text,'(\d+),') from hm where substring(hmval,1,1)='0' group by 1)t;  <br/> count   <br/>-------  <br/> 63695  <br/>(1 row)  <br/>  <br/>2、单个片为8时，有接近一半的块包含。  <br/>  <br/>postgres=# select count(*) from (select substring(ctid::text,'(\d+),') from hm where substring(hmval,1,8)='00000000' group by 1)t;  <br/> count   <br/>-------  <br/> 29100  <br/>(1 row)  <br/>  <br/>3、单个片为16时，只有100多个块包含了。  <br/>  <br/>postgres=# select count(*) from (select substring(ctid::text,'(\d+),') from hm where substring(hmval,1,16)='0000000000000000' group by 1)t;  <br/> count   <br/>-------  <br/>   160  <br/>(1 row)</span></pre><h2 id="4094" class="mx jv iq bd jw nc nd dn ka ne nf dp ke ld ng nh ki lh ni nj km ll nk nl kq nm bi translated">8数组切片方法的性能验证</h2><p id="bb45" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">按照下列步骤测试性能:</p><p id="c93c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">第一步。创建smlar插件。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="dffa" class="mx jv iq mt b gy my mz l na nb">create extension smlar;</span></pre><p id="2b20" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">第二步。创建一个测试表。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="8081" class="mx jv iq mt b gy my mz l na nb">create table hm1 (id int, hmval bit(64), hmarr text[]);</span></pre><p id="7f66" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">第三步。现在，生成1000万条测试数据记录。基于8数组切片方法对这些数据记录进行切片，并将切片后的记录记录为文本数组。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="24bc" class="mx jv iq mt b gy my mz l na nb">insert into hm1   <br/>select   <br/>  id,   <br/>  val::bit(64),   <br/>  regexp_split_to_array('1_'||substring(val,1,8)||',2_'||substring(val,9,8)||',3_'||substring(val,17,8)||',4_'||substring(val,25,8)||',5_'||substring(val,33,8)||',6_'||substring(val,41,8)||',7_'||substring(val,49,8)||',8_'||substring(val,57,8), ',')    <br/>from   <br/>(select id, (sqrt(random())::numeric*9223372036854775807*2-9223372036854775807::numeric)::int8::bit(64)::text as val from generate_series(1,10000000) t(id)) t;  <br/>  <br/>postgres=# select * from hm1 limit 10;  <br/> id |                              hmval                               |                                           hmarr                                             <br/>----+------------------------------------------------------------------+-------------------------------------------------------------------------------------------  <br/>  1 | 0000001110101101100110011000100111100100001100100101101010010011 | {1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}  <br/>  2 | 0001001000010101001100100010101010111001001000000110101101100100 | {1_00010010,2_00010101,3_00110010,4_00101010,5_10111001,6_00100000,7_01101011,8_01100100}  <br/>  3 | 0011111111010100011001001010110110100010101110101001101111010000 | {1_00111111,2_11010100,3_01100100,4_10101101,5_10100010,6_10111010,7_10011011,8_11010000}  <br/>  4 | 1100110010011001001110101110111111111111010000100000010011000010 | {1_11001100,2_10011001,3_00111010,4_11101111,5_11111111,6_01000010,7_00000100,8_11000010}  <br/>  5 | 0011000011010001011111010101010111100110000110000011101100000101 | {1_00110000,2_11010001,3_01111101,4_01010101,5_11100110,6_00011000,7_00111011,8_00000101}  <br/>  6 | 0111101101111110101000010110101101110011011110100100010111011001 | {1_01111011,2_01111110,3_10100001,4_01101011,5_01110011,6_01111010,7_01000101,8_11011001}  <br/>  7 | 0010001011111111100010101011110001001101001011100100011000010000 | {1_00100010,2_11111111,3_10001010,4_10111100,5_01001101,6_00101110,7_01000110,8_00010000}  <br/>  8 | 1110001111100011011110110111101111010101000111000100111111111101 | {1_11100011,2_11100011,3_01111011,4_01111011,5_11010101,6_00011100,7_01001111,8_11111101}  <br/>  9 | 0111110010111000010111001000000101111000000110110110000011101110 | {1_01111100,2_10111000,3_01011100,4_10000001,5_01111000,6_00011011,7_01100000,8_11101110}  <br/> 10 | 0111001101100010001101101111000000100100000000010001010011100101 | {1_01110011,2_01100010,3_00110110,4_11110000,5_00100100,6_00000001,7_00010100,8_11100101}  <br/>(10 rows)</span></pre><p id="0b36" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">第四步。创建smlar索引。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="8692" class="mx jv iq mt b gy my mz l na nb">postgres=# create index idx_hm1 on hm1 using gin(hmarr _text_sml_ops );</span></pre><p id="fe79" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">第五步。现在，使用smlar索引搜索汉明距离小于或等于1的值。使用smlar索引后，完成查询需要63毫秒。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5a08" class="mx jv iq mt b gy my mz l na nb">postgres=# set smlar.type = overlap;  <br/>postgres=# set smlar.threshold = 7;  <br/>  <br/>select    <br/>    *,    <br/>    smlar( hmarr, '{1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}')    <br/>  from    <br/>    hm1    <br/>  where    <br/>    hmarr % '{1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}'      <br/>    and length(replace(bitxor(bit'0000001110101101100110011000100111100100001100100101101010010011', hmval)::text,'0','')) &lt; 2  <br/>  limit 100;  <br/>  <br/>  <br/>postgres=# explain (analyze,verbose,timing,costs,buffers) select    <br/>    *,    <br/>    smlar( hmarr, '{1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}')    <br/>  from    <br/>    hm1    <br/>  where    <br/>    hmarr % '{1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}'      <br/>    and length(replace(bitxor(bit'0000001110101101100110011000100111100100001100100101101010010011', hmval)::text,'0','')) &lt; 2  <br/>  limit 100;  <br/>                                                                            QUERY PLAN                                                                               <br/>-------------------------------------------------------------------------------------------------------------------------------------------------------------------  <br/> Limit  (cost=117.83..420.48 rows=100 width=169) (actual time=62.928..62.929 rows=1 loops=1)  <br/>   Output: id, hmval, hmarr, (smlar(hmarr, '{1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}'::text[]))  <br/>   Buffers: shared hit=166  <br/>   -&gt;  Bitmap Heap Scan on public.hm1  (cost=117.83..10205.17 rows=3333 width=169) (actual time=62.927..62.927 rows=1 loops=1)  <br/>         Output: id, hmval, hmarr, smlar(hmarr, '{1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}'::text[])  <br/>         Recheck Cond: (hm1.hmarr % '{1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}'::text[])  <br/>         Filter: (length(replace((bitxor(B'0000001110101101100110011000100111100100001100100101101010010011'::"bit", hm1.hmval))::text, '0'::text, ''::text)) &lt; 2)  <br/>         Heap Blocks: exact=1  <br/>         Buffers: shared hit=166  <br/>         -&gt;  Bitmap Index Scan on idx_hm1  (cost=0.00..117.00 rows=10000 width=0) (actual time=62.898..62.898 rows=1 loops=1)  <br/>               Index Cond: (hm1.hmarr % '{1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}'::text[])  <br/>               Buffers: shared hit=165  <br/> Planning time: 0.147 ms  <br/> Execution time: 62.975 ms  <br/>(14 rows)  <br/>  <br/>postgres=# select                  <br/>    *,    <br/>    smlar( hmarr, '{1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}')    <br/>  from    <br/>    hm1    <br/>  where    <br/>    hmarr % '{1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011}'      <br/>    and length(replace(bitxor(bit'0000001110101101100110011000100111100100001100100101101010010011', hmval)::text,'0','')) &lt; 2  <br/>  limit 100;  <br/> id |                              hmval                               |                                           hmarr                                           | smlar   <br/>----+------------------------------------------------------------------+-------------------------------------------------------------------------------------------+-------  <br/>  1 | 0000001110101101100110011000100111100100001100100101101010010011 | {1_00000011,2_10101101,3_10011001,4_10001001,5_11100100,6_00110010,7_01011010,8_10010011} |     8  <br/>(1 row)  <br/>Time: 61.227 ms</span></pre><p id="7d1f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">要查询汉明距离小于或等于4的值，我们可以使用16数组切片方法或不同切片方法的组合。</p><h2 id="3b31" class="mx jv iq bd jw nc nd dn ka ne nf dp ke ld ng nh ki lh ni nj km ll nk nl kq nm bi translated">混合6阵列切片方法的性能验证</h2><p id="d235" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">6阵列切片方法的配置为8位、16位、8位、8位、16位和8位。这种切片方法可以查询汉明距离小于或等于6的值。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2908" class="mx jv iq mt b gy my mz l na nb">create table hm2 (id int, hmval bit(64), hmarr text[]);  <br/>  <br/>insert into hm2   <br/>select   <br/>  id,   <br/>  val::bit(64),   <br/>  regexp_split_to_array('1_'||substring(val,1,8)||',2_'||substring(val,9,16)||',3_'||substring(val,25,8)||',4_'||substring(val,33,8)||',5_'||substring(val,41,16)||',6_'||substring(val,57,8), ',')    <br/>from   <br/>(select id, (sqrt(random())::numeric*9223372036854775807*2-9223372036854775807::numeric)::int8::bit(64)::text as val from generate_series(1,10000000) t(id)) t;  <br/>  <br/>postgres=# select * from hm2 limit 10;  <br/> id |                              hmval                               |                                        hmarr                                          <br/>----+------------------------------------------------------------------+-------------------------------------------------------------------------------------  <br/>  1 | 1100111011000001100100100111111110100011100111111101101001101010 | {1_11001110,2_1100000110010010,3_01111111,4_10100011,5_1001111111011010,6_01101010}  <br/>  2 | 0111111000101011000111010011011000000010010001111001000111011101 | {1_01111110,2_0010101100011101,3_00110110,4_00000010,5_0100011110010001,6_11011101}  <br/>  3 | 0111111000101111000101011100100000001111011101101100110100000101 | {1_01111110,2_0010111100010101,3_11001000,4_00001111,5_0111011011001101,6_00000101}  <br/>  4 | 0111010101010010100000110001100011110010111000001011000010010010 | {1_01110101,2_0101001010000011,3_00011000,4_11110010,5_1110000010110000,6_10010010}  <br/>  5 | 1111101100110100101111000011001011111110111000100110101001100001 | {1_11111011,2_0011010010111100,3_00110010,4_11111110,5_1110001001101010,6_01100001}  <br/>  6 | 0011110000100010101001000001100010000010111011100010011001000110 | {1_00111100,2_0010001010100100,3_00011000,4_10000010,5_1110111000100110,6_01000110}  <br/>  7 | 0000111111001110100110011110000110001101110111111111111010111001 | {1_00001111,2_1100111010011001,3_11100001,4_10001101,5_1101111111111110,6_10111001}  <br/>  8 | 0110100010010100111100110110000011101110101001001111010101011111 | {1_01101000,2_1001010011110011,3_01100000,4_11101110,5_1010010011110101,6_01011111}  <br/>  9 | 0111001111001100101011001001100100000000111100000110110001000011 | {1_01110011,2_1100110010101100,3_10011001,4_00000000,5_1111000001101100,6_01000011}  <br/> 10 | 1101111101011000111100101010101000100001101100101110100001111000 | {1_11011111,2_0101100011110010,3_10101010,4_00100001,5_1011001011101000,6_01111000}  <br/>(10 rows)  <br/>  <br/>create index idx_hm2 on hm2 using gin(hmarr _text_sml_ops );</span></pre><p id="8444" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">当查询汉明距离小于或等于1的值时，查询时间减少到2 ms。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3730" class="mx jv iq mt b gy my mz l na nb">postgres=# set smlar.type = overlap;  <br/>postgres=# set smlar.threshold = 5;  <br/>  <br/>postgres=# select    <br/>    *,    <br/>    smlar( hmarr, '{1_11001110,2_1100000110010010,3_01111111,4_10100011,5_1001111111011010,6_01101010}')    <br/>  from    <br/>    hm2   <br/>  where    <br/>    hmarr % '{1_11001110,2_1100000110010010,3_01111111,4_10100011,5_1001111111011010,6_01101010}'      <br/>    and length(replace(bitxor(bit'1100111011000001100100100111111110100011100111111101101001101010', hmval)::text,'0','')) &lt; 2  <br/>  limit 100;  <br/> id |                              hmval                               |                                        hmarr                                        | smlar   <br/>----+------------------------------------------------------------------+-------------------------------------------------------------------------------------+-------  <br/>  1 | 1100111011000001100100100111111110100011100111111101101001101010 | {1_11001110,2_1100000110010010,3_01111111,4_10100011,5_1001111111011010,6_01101010} |     6  <br/>(1 row)  <br/>Time: 1.954 ms  <br/>  <br/>postgres=# explain (analyze,verbose,timing,costs,buffers) select    <br/>    *,    <br/>    smlar( hmarr, '{1_11001110,2_1100000110010010,3_01111111,4_10100011,5_1001111111011010,6_01101010}')    <br/>  from    <br/>    hm2   <br/>  where    <br/>    hmarr % '{1_11001110,2_1100000110010010,3_01111111,4_10100011,5_1001111111011010,6_01101010}'      <br/>    and length(replace(bitxor(bit'1100111011000001100100100111111110100011100111111101101001101010', hmval)::text,'0','')) &lt; 2  <br/>  limit 100;  <br/>                                                                            QUERY PLAN                                                                               <br/>-------------------------------------------------------------------------------------------------------------------------------------------------------------------  <br/> Limit  (cost=103.83..406.06 rows=100 width=153) (actual time=2.414..2.416 rows=1 loops=1)  <br/>   Output: id, hmval, hmarr, (smlar(hmarr, '{1_11001110,2_1100000110010010,3_01111111,4_10100011,5_1001111111011010,6_01101010}'::text[]))  <br/>   Buffers: shared hit=102  <br/>   -&gt;  Bitmap Heap Scan on public.hm2  (cost=103.83..10177.17 rows=3333 width=153) (actual time=2.414..2.415 rows=1 loops=1)  <br/>         Output: id, hmval, hmarr, smlar(hmarr, '{1_11001110,2_1100000110010010,3_01111111,4_10100011,5_1001111111011010,6_01101010}'::text[])  <br/>         Recheck Cond: (hm2.hmarr % '{1_11001110,2_1100000110010010,3_01111111,4_10100011,5_1001111111011010,6_01101010}'::text[])  <br/>         Filter: (length(replace((bitxor(B'1100111011000001100100100111111110100011100111111101101001101010'::"bit", hm2.hmval))::text, '0'::text, ''::text)) &lt; 2)  <br/>         Heap Blocks: exact=1  <br/>         Buffers: shared hit=102  <br/>         -&gt;  Bitmap Index Scan on idx_hm2  (cost=0.00..103.00 rows=10000 width=0) (actual time=2.374..2.374 rows=1 loops=1)  <br/>               Index Cond: (hm2.hmarr % '{1_11001110,2_1100000110010010,3_01111111,4_10100011,5_1001111111011010,6_01101010}'::text[])  <br/>               Buffers: shared hit=101  <br/> Planning time: 0.149 ms  <br/> Execution time: 2.463 ms  <br/>(14 rows)</span></pre><h2 id="1c07" class="mx jv iq bd jw nc nd dn ka ne nf dp ke ld ng nh ki lh ni nj km ll nk nl kq nm bi translated">4阵列切片方法的性能验证</h2><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="9ee5" class="mx jv iq mt b gy my mz l na nb">create table hm3 (id int, hmval bit(64), hmarr text[]);  <br/>  <br/>insert into hm3   <br/>select   <br/>  id,   <br/>  val::bit(64),   <br/>  regexp_split_to_array('1_'||substring(val,1,16)||',2_'||substring(val,17,16)||',3_'||substring(val,33,16)||',4_'||substring(val,41,16), ',')    <br/>from   <br/>(select id, (sqrt(random())::numeric*9223372036854775807*2-9223372036854775807::numeric)::int8::bit(64)::text as val from generate_series(1,10000000) t(id)) t;  <br/>  <br/>postgres=# select * from hm3 limit 10;  <br/> id |                              hmval                               |                                     hmarr                                       <br/>----+------------------------------------------------------------------+-------------------------------------------------------------------------------  <br/>  1 | 0101011111111010000001001011101101100011111101111101101100000011 | {1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}  <br/>  2 | 1101011000010000000000000000111011011111011101110100000010101011 | {1_1101011000010000,2_0000000000001110,3_1101111101110111,4_0111011101000000}  <br/>  3 | 0101000010110110110010001010100010101001001010111111011000110011 | {1_0101000010110110,2_1100100010101000,3_1010100100101011,4_0010101111110110}  <br/>  4 | 0111000111100011111000100111000011101111110000011110101101000100 | {1_0111000111100011,2_1110001001110000,3_1110111111000001,4_1100000111101011}  <br/>  5 | 0010111010101011111010011110110010011110111111110011101110010011 | {1_0010111010101011,2_1110100111101100,3_1001111011111111,4_1111111100111011}  <br/>  6 | 0110111110011100100110010111010000000011100011000011110001010110 | {1_0110111110011100,2_1001100101110100,3_0000001110001100,4_1000110000111100}  <br/>  7 | 0100110100111001110011011110100111101110101001000101010110110110 | {1_0100110100111001,2_1100110111101001,3_1110111010100100,4_1010010001010101}  <br/>  8 | 0110010111001100111000011011011100001100111111101111011010100010 | {1_0110010111001100,2_1110000110110111,3_0000110011111110,4_1111111011110110}  <br/>  9 | 0110111010110000001010101111000101110000010011100011100101000100 | {1_0110111010110000,2_0010101011110001,3_0111000001001110,4_0100111000111001}  <br/> 10 | 0101101000000110100101100011111111000101110001010011100110101011 | {1_0101101000000110,2_1001011000111111,3_1100010111000101,4_1100010100111001}  <br/>(10 rows)  <br/>  <br/>create index idx_hm3 on hm3 using gin(hmarr _text_sml_ops );</span></pre><p id="0ddf" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">当查询汉明距离小于或等于1的值时，查询时间减少到0.2 ms。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="bba0" class="mx jv iq mt b gy my mz l na nb">postgres=# set smlar.type = overlap;  <br/>postgres=# set smlar.threshold = 3;  <br/>  <br/>postgres=# select    <br/>    *,    <br/>    smlar( hmarr, '{1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}')    <br/>  from    <br/>    hm3  <br/>  where    <br/>    hmarr % '{1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}'      <br/>    and length(replace(bitxor(bit'0101011111111010000001001011101101100011111101111101101100000011', hmval)::text,'0','')) &lt; 2  <br/>  limit 100;  <br/> id |                              hmval                               |                                     hmarr                                     | smlar   <br/>----+------------------------------------------------------------------+-------------------------------------------------------------------------------+-------  <br/>  1 | 0101011111111010000001001011101101100011111101111101101100000011 | {1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011} |     4  <br/>(1 row)  <br/>  <br/>  <br/>postgres=# explain (analyze,verbose,timing,costs,buffers) select    <br/>    *,    <br/>    smlar( hmarr, '{1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}')    <br/>  from    <br/>    hm3  <br/>  where    <br/>    hmarr % '{1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}'      <br/>    and length(replace(bitxor(bit'0101011111111010000001001011101101100011111101111101101100000011', hmval)::text,'0','')) &lt; 2  <br/>  limit 100;  <br/>                                                                            QUERY PLAN                                                                               <br/>-------------------------------------------------------------------------------------------------------------------------------------------------------------------  <br/> Limit  (cost=99.83..401.19 rows=100 width=134) (actual time=0.169..0.170 rows=1 loops=1)  <br/>   Output: id, hmval, hmarr, (smlar(hmarr, '{1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}'::text[]))  <br/>   Buffers: shared hit=14  <br/>   -&gt;  Bitmap Heap Scan on public.hm3  (cost=99.83..10144.17 rows=3333 width=134) (actual time=0.168..0.169 rows=1 loops=1)  <br/>         Output: id, hmval, hmarr, smlar(hmarr, '{1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}'::text[])  <br/>         Recheck Cond: (hm3.hmarr % '{1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}'::text[])  <br/>         Filter: (length(replace((bitxor(B'0101011111111010000001001011101101100011111101111101101100000011'::"bit", hm3.hmval))::text, '0'::text, ''::text)) &lt; 2)  <br/>         Heap Blocks: exact=1  <br/>         Buffers: shared hit=14  <br/>         -&gt;  Bitmap Index Scan on idx_hm3  (cost=0.00..99.00 rows=10000 width=0) (actual time=0.145..0.145 rows=1 loops=1)  <br/>               Index Cond: (hm3.hmarr % '{1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}'::text[])  <br/>               Buffers: shared hit=13  <br/> Planning time: 0.101 ms  <br/> Execution time: 0.200 ms  <br/>(14 rows)</span></pre><p id="14f9" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">当查询汉明距离小于或等于4的值时，查询时间保持几毫秒。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5657" class="mx jv iq mt b gy my mz l na nb">postgres=# set smlar.type = overlap;  <br/>postgres=# set smlar.threshold = 0;  <br/>  <br/>postgres=# select    <br/>    *,    <br/>    smlar( hmarr, '{1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}')    <br/>  from    <br/>    hm3  <br/>  where    <br/>    hmarr % '{1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}'      <br/>    and length(replace(bitxor(bit'0101011111111010000001001011101101100011111101111101101100000011', hmval)::text,'0','')) &lt; 5  <br/>  limit 100;  <br/> id |                              hmval                               |                                     hmarr                                     | smlar   <br/>----+------------------------------------------------------------------+-------------------------------------------------------------------------------+-------  <br/>  1 | 0101011111111010000001001011101101100011111101111101101100000011 | {1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011} |     4  <br/>(1 row)  <br/>Time: 6.983 ms</span></pre><p id="23fa" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">如果没有使用索引，查询需要23秒才能完成。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e15c" class="mx jv iq mt b gy my mz l na nb">postgres=# select * from hm3 where length(replace(bitxor(bit'0101011111111010000001001011101101100011111101111101101100000011', hmval)::text,'0','')) &lt; 5;  <br/> id |                              hmval                               |                                     hmarr                                       <br/>----+------------------------------------------------------------------+-------------------------------------------------------------------------------  <br/>  1 | 0101011111111010000001001011101101100011111101111101101100000011 | {1_0101011111111010,2_0000010010111011,3_0110001111110111,4_1111011111011011}  <br/>(1 row)  <br/>  <br/>Time: 22954.686 ms</span></pre><p id="0757" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">与不使用索引的场景相比，性能提高了114，800倍，从23秒提高到0.2毫秒。</p><h1 id="a973" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">自动切片</h1><p id="68c2" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果您想知道如何在对SimHash数据进行切片后生成数组，那么不要担心。PostgreSQL提供了强大的用户定义函数(UDF)来生成数组。</p><p id="5723" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">您可以创建UDF和触发器，一旦写入数据，切片时就会自动生成数组。以下示例说明了自动切片的工作原理:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ac11" class="mx jv iq mt b gy my mz l na nb">create table hm4 (id int, hmval bit(64), hmarr text[]);  </span><span id="f305" class="mx jv iq mt b gy nn mz l na nb">create or replace function sp(val bit(64)) returns text[] as $$<br/>select regexp_split_to_array('1_'||substring(val::text,1,10)||',2_'||substring(val::text,11,10)||',3_'||substring(val::text,21,10)||',4_'||substring(val::text,31,10)||',5_'||substring(val::text,41,10)||',6_'||substring(val::text,51,14), ',') ;            <br/>$$ language sql strict;</span><span id="be68" class="mx jv iq mt b gy nn mz l na nb">postgres=# select sp(123::bit(64));<br/>                                         sp                                          <br/>-------------------------------------------------------------------------------------<br/> {1_0000000000,2_0000000000,3_0000000000,4_0000000000,5_0000000000,6_00000001111011}<br/>(1 row)</span><span id="5281" class="mx jv iq mt b gy nn mz l na nb">-- 写入1亿记录</span><span id="5f99" class="mx jv iq mt b gy nn mz l na nb">insert into hm4  <br/>select   <br/>  id,   <br/>  val::bit(64),   <br/>  sp(val::bit(64))    <br/>from   <br/>(select id, (sqrt(random())::numeric*9223372036854775807*2-9223372036854775807::numeric)::int8::bit(64)::text as val from generate_series(1,100000000) t(id)) t;  </span><span id="8dfe" class="mx jv iq mt b gy nn mz l na nb">-- 索引</span><span id="fcad" class="mx jv iq mt b gy nn mz l na nb">create index idx_hm4 on hm4 using gin(hmarr _text_sml_ops );  </span><span id="eaa0" class="mx jv iq mt b gy nn mz l na nb">-- 查询海明距离小于等于1的记录，性能杠杠的</span><span id="3405" class="mx jv iq mt b gy nn mz l na nb">postgres=# set smlar.type = overlap;  <br/>postgres=# set smlar.threshold = 5; </span><span id="2725" class="mx jv iq mt b gy nn mz l na nb">select    <br/>    *,    <br/>    smlar( hmarr, sp(123::bit(64)))     -- 查询与123::bit(64)海明距离小于2的记录<br/>  from    <br/>    hm3  <br/>  where    <br/>    hmarr % sp(123::bit(64))      -- 查询与123::bit(64)海明距离小于2的记录<br/>    and length(replace(bitxor(123::bit(64), hmval)::text,'0','')) &lt; 2      -- 查询与123::bit(64)海明距离小于2的记录<br/>  limit 100;  <br/>  <br/>postgres=# explain (analyze,verbose,timing,costs,buffers) select<br/>    *,<br/>    smlar( hmarr, sp(123::bit(64)))     -- 查询与123::bit(64)海明距离小于2的记录<br/>  from<br/>    hm3<br/>  where<br/>    hmarr % sp(123::bit(64))      -- 查询与123::bit(64)海明距离小于2的记录<br/>    and length(replace(bitxor(123::bit(64), hmval)::text,'0','')) &lt; 2      -- 查询与123::bit(64)海明距离小于2的记录<br/>  limit 100;<br/>                                                                             QUERY PLAN                                                                              <br/>---------------------------------------------------------------------------------------------------------------------------------------------------------------------<br/> Limit  (cost=109.83..411.19 rows=100 width=134) (actual time=0.078..0.078 rows=0 loops=1)<br/>   Output: id, hmval, hmarr, (smlar(hmarr, '{1_0000000000,2_0000000000,3_0000000000,4_0000000000,5_0000000000,6_00000001111011}'::text[]))<br/>   Buffers: shared hit=19<br/>   -&gt;  Bitmap Heap Scan on public.hm3  (cost=109.83..10154.17 rows=3333 width=134) (actual time=0.076..0.076 rows=0 loops=1)<br/>         Output: id, hmval, hmarr, smlar(hmarr, '{1_0000000000,2_0000000000,3_0000000000,4_0000000000,5_0000000000,6_00000001111011}'::text[])<br/>         Recheck Cond: (hm3.hmarr % '{1_0000000000,2_0000000000,3_0000000000,4_0000000000,5_0000000000,6_00000001111011}'::text[])<br/>         Filter: (length(replace((bitxor(B'0000000000000000000000000000000000000000000000000000000001111011'::bit(64), hm3.hmval))::text, '0'::text, ''::text)) &lt; 2)<br/>         Buffers: shared hit=19<br/>         -&gt;  Bitmap Index Scan on idx_hm3  (cost=0.00..109.00 rows=10000 width=0) (actual time=0.074..0.074 rows=0 loops=1)<br/>               Index Cond: (hm3.hmarr % '{1_0000000000,2_0000000000,3_0000000000,4_0000000000,5_0000000000,6_00000001111011}'::text[])<br/>               Buffers: shared hit=19<br/> Planning time: 0.592 ms<br/> Execution time: 0.117 ms<br/>(13 rows)</span></pre><p id="a3d3" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">接下来，您需要创建一个触发器。当写入SimHash数据时，切片产生的数组被自动写入。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6eed" class="mx jv iq mt b gy my mz l na nb">create or replace function tg() returns trigger as $$<br/>declare<br/>begin<br/>  NEW.hmarr := sp(NEW.hmval);<br/>  return NEW;<br/>end;<br/>$$ language plpgsql strict;</span><span id="e565" class="mx jv iq mt b gy nn mz l na nb">postgres=# create trigger tg before insert or update on hm4 for each row execute procedure tg();<br/>CREATE TRIGGER</span><span id="aa3d" class="mx jv iq mt b gy nn mz l na nb">-- 效果很赞</span><span id="8d67" class="mx jv iq mt b gy nn mz l na nb">postgres=# truncate hm4;<br/>TRUNCATE TABLE<br/>postgres=# insert into hm4 values (1,1::bit(64));<br/>INSERT 0 1<br/>postgres=# select * from hm4;<br/> id |                              hmval                               |                                        hmarr                                        <br/>----+------------------------------------------------------------------+-------------------------------------------------------------------------------------<br/>  1 | 0000000000000000000000000000000000000000000000000000000000000001 | {1_0000000000,2_0000000000,3_0000000000,4_0000000000,5_0000000000,6_00000000000001}<br/>(1 row)</span><span id="7108" class="mx jv iq mt b gy nn mz l na nb">postgres=# update hm4 set hmval=123456::bit(64);<br/>UPDATE 1<br/>postgres=# select * from hm4;<br/> id |                              hmval                               |                                        hmarr                                        <br/>----+------------------------------------------------------------------+-------------------------------------------------------------------------------------<br/>  1 | 0000000000000000000000000000000000000000000000011110001001000000 | {1_0000000000,2_0000000000,3_0000000000,4_0000000000,5_0000000111,6_10001001000000}<br/>(1 row)</span></pre><h1 id="7eb0" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">基于GIN索引的相似性算法简介</h1><p id="46fe" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">让我们来看看各种基于GIN指数的相似性算法:</p><p id="f354" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.余弦</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3045" class="mx jv iq mt b gy my mz l na nb">相似值算法<br/>                case ST_COSINE:<br/>                        {<br/>                                int                             cnt;<br/>                                double                  power;</span><span id="22a4" class="mx jv iq mt b gy nn mz l na nb">                                power = ((double)(sa-&gt;nelems)) * ((double)(sb-&gt;nelems));<br/>                                cnt = numOfIntersect(sa, sb);</span><span id="bbe2" class="mx jv iq mt b gy nn mz l na nb">                                PG_RETURN_FLOAT4(  ((double)cnt) / sqrt( power ) );<br/>                        }<br/>GIN一重过滤算法<br/>                                case ST_COSINE:<br/>                                                {<br/>                                                        double                  power;</span><span id="a549" class="mx jv iq mt b gy nn mz l na nb">                                                        power = sqrt( ((double)(sa-&gt;nelems)) * ((double)(cnt)) );</span><span id="ac23" class="mx jv iq mt b gy nn mz l na nb">                                                        if (  ((double)cnt) / power &gt;= GetSmlarLimit()  )<br/>                                                                res = true;<br/>                                                }</span></pre><p id="f7c1" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.重叠</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="b449" class="mx jv iq mt b gy my mz l na nb">相似值算法<br/>                case ST_OVERLAP:<br/>                        {<br/>                                float4 res = (float4)numOfIntersect(sa, sb);</span><span id="809f" class="mx jv iq mt b gy nn mz l na nb">                                PG_RETURN_FLOAT4(res);<br/>                        }<br/>GIN一重过滤算法<br/>                                case ST_OVERLAP:<br/>                                                if (cnt &gt;= GetSmlarLimit())<br/>                                                        res = true;</span></pre><p id="3cce" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.TF-IDF</p><p id="c11c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">目前，只有当TF值等于IDF值时，才支持基于GIN索引的数据检索。此外，IDF值被写入表中。这意味着指数支持IDF值，但不支持TF值。算法本身同时支持TF和IDF。</p><p id="0cd8" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">要使GIN索引支持TF，您需要修改smlar代码。但是，由于GiST索引已经支持TF，所以您可以使用GiST索引来代替。可以参考博客-<br/><a class="ae mn" href="https://github.com/digoal/blog/blob/master/201701/20170116_03.md?spm=a2c41.13977169.0.0&amp;file=20170116_03.md" rel="noopener ugc nofollow" target="_blank">PostgreSQL结合余弦和线性相关算法在文本、图像、数组相似性领域的应用(2)——smlar插件介绍</a>了解更多信息。</p><p id="4681" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">smlar插件可用于确定短文档之间的相似性。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="65c7" class="mx jv iq mt b gy my mz l na nb">相似值算法<br/>考虑了IDF的权重(一张IDF TABLE来记录权重)。相比cosine算法，更适合短文本相似判断。 但是请注意不考虑TF。<br/>例如一个短文的关键词向量为 (我1, 爱1, 中国5),这里的tf 115全部不计。    </span><span id="8c98" class="mx jv iq mt b gy nn mz l na nb">static double<br/>TFIDFSml(SimpleArray *a, SimpleArray *b)<br/>{<br/>        int                             cmp;<br/>        Datum                   *aptr = a-&gt;elems,<br/>                                        *bptr = b-&gt;elems;<br/>        ProcTypeInfo    info = a-&gt;info;<br/>        double                  res = 0.0;<br/>        double                  suma = 0.0, sumb = 0.0;</span><span id="74c7" class="mx jv iq mt b gy nn mz l na nb">        Assert( a-&gt;info-&gt;typid == b-&gt;info-&gt;typid );<br/>        Assert( a-&gt;df );<br/>        Assert( b-&gt;df );</span><span id="7c6b" class="mx jv iq mt b gy nn mz l na nb">        getFmgrInfoCmp(info);</span><span id="34be" class="mx jv iq mt b gy nn mz l na nb">        while( aptr - a-&gt;elems &lt; a-&gt;nelems &amp;&amp; bptr - b-&gt;elems &lt; b-&gt;nelems )<br/>        {<br/>                cmp = cmpArrayElem(aptr, bptr, info);<br/>                if ( cmp &lt; 0 )<br/>                {<br/>                        suma += a-&gt;df[ aptr - a-&gt;elems ] * a-&gt;df[ aptr - a-&gt;elems ];<br/>                        aptr++;<br/>                }<br/>                else if ( cmp &gt; 0 )<br/>                {<br/>                        sumb += b-&gt;df[ bptr - b-&gt;elems ] * b-&gt;df[ bptr - b-&gt;elems ];<br/>                        bptr++;<br/>                }<br/>                else<br/>                {<br/>                        res += a-&gt;df[ aptr - a-&gt;elems ] * b-&gt;df[ bptr - b-&gt;elems ];<br/>                        suma += a-&gt;df[ aptr - a-&gt;elems ] * a-&gt;df[ aptr - a-&gt;elems ];<br/>                        sumb += b-&gt;df[ bptr - b-&gt;elems ] * b-&gt;df[ bptr - b-&gt;elems ];<br/>                        aptr++;<br/>                        bptr++;<br/>                }<br/>        }</span><span id="a126" class="mx jv iq mt b gy nn mz l na nb">        /*<br/>         * Compute last elements<br/>         */<br/>        while( aptr - a-&gt;elems &lt; a-&gt;nelems )<br/>        {<br/>                suma += a-&gt;df[ aptr - a-&gt;elems ] * a-&gt;df[ aptr - a-&gt;elems ];<br/>                aptr++;<br/>        }</span><span id="efc4" class="mx jv iq mt b gy nn mz l na nb">        while( bptr - b-&gt;elems &lt; b-&gt;nelems )<br/>        {<br/>                sumb += b-&gt;df[ bptr - b-&gt;elems ] * b-&gt;df[ bptr - b-&gt;elems ];<br/>                bptr++;<br/>        }</span><span id="ef05" class="mx jv iq mt b gy nn mz l na nb">        if ( suma &gt; 0.0 &amp;&amp; sumb &gt; 0.0 )<br/>                res = res / sqrt( suma * sumb );<br/>        else<br/>                res = 0.0;</span><span id="1d49" class="mx jv iq mt b gy nn mz l na nb">        return res;<br/>}<br/>GIN一重过滤算法<br/>                                case ST_TFIDF:<br/>                                                {<br/>                                                        double  weight = 0.0, /* exact weight of union */<br/>                                                                        saSum = 0.0,  /* exact length of query */<br/>                                                                        siSum = 0.0;  /* lower limit of length of indexed value */ </span><span id="b168" class="mx jv iq mt b gy nn mz l na nb">                                                        if ( getTFMethod() != TF_CONST )<br/>                                                                elog(ERROR,"GIN supports only smlar.tf_method = \"const\"" );</span><span id="accd" class="mx jv iq mt b gy nn mz l na nb">                                                        Assert(sa-&gt;df);</span><span id="8cef" class="mx jv iq mt b gy nn mz l na nb">                                                        for(i=0; i&lt;sa-&gt;nelems; i++)<br/>                                                        {<br/>                                                                /*<br/>                                                                 * With smlar.tf_method = "const"   sa-&gt;df[i] is <br/>                                                                 * equal to its idf, so lookup of StatElem is not needed<br/>                                                                 */<br/>                                                                if ( check[i] )<br/>                                                                {<br/>                                                                        weight += sa-&gt;df[i] * sa-&gt;df[i];<br/>                                                                        siSum += sa-&gt;df[i] * sa-&gt;df[i];<br/>                                                                }<br/>                                                                saSum += sa-&gt;df[i] * sa-&gt;df[i];<br/>                                                        }</span><span id="3372" class="mx jv iq mt b gy nn mz l na nb">                                                        if ( saSum &gt; 0.0 &amp;&amp; siSum &gt; 0.0 &amp;&amp; weight / sqrt(saSum * siSum ) &gt; GetSmlarLimit() )<br/>                                                                res = true;<br/>                                                }</span></pre><p id="9f62" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">基于TF-IDF查询相似文档。</p><h1 id="82da" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">4.技术要点</h1><ol class=""><li id="d893" class="no np iq ku b kv kw kz la ld nq lh nr ll ns lp nt nu nv nw bi translated">阿里云ApsaraDB RDS for PostgreSQL的smlar插件使用了GIN索引、块级收敛和双重过滤。从1000万条数据记录中检索汉明距离小于或等于2的记录只需不到0.2 ms。</li><li id="34f5" class="no np iq ku b kv nx kz ny ld nz lh oa ll ob lp nt nu nv nw bi translated">阿里云ApsaraDB RDS for PostgreSQL 10采用多核并行计算和蛮力扫描。从1000万条数据记录中检索汉明距离小于或等于N的记录需要不到450 ms。</li><li id="dc49" class="no np iq ku b kv nx kz ny ld nz lh oa ll ob lp nt nu nv nw bi translated">阿里云HybridDB for PostgreSQL采用多主机并行计算，横向扩展计算能力，进行蛮力扫描。查询效率取决于节点的数量。</li></ol><h1 id="f3c0" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">5.结论</h1><p id="2c39" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">可以将smlar插件与阿里云ApsaraDB RDS for PostgreSQL配合使用，从数千万条SimHash数据记录中检索相似数据。稍后将提供关于更大数据量的测试的信息，响应速度应该是几毫秒。与不使用索引的场景相比，性能提高了114，800倍，从23秒提高到0.2毫秒。</p><p id="6dd4" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><em class="oc">在阿里云上用</em><a class="ae mn" href="https://www.alibabacloud.com/product/apsaradb-for-rds-postgresql?spm=a2c41.13977169.0.0" rel="noopener ugc nofollow" target="_blank"><em class="oc">ApsaraDB for RDS PostgreSQL</em></a><em class="oc">构建自己的PostgreSQL解决方案。</em></p><h1 id="ad47" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">原始来源:</h1><div class="lv lw gp gr lx ly"><a href="https://www.alibabacloud.com/blog/the-smlar-plug-in-for-effective-retrieval-of-massive-volumes-of-simhash-data_595786?spm=a2c41.13977169.0.0" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd ir gy z fp md fr fs me fu fw ip bi translated">用于有效检索大量SimHash数据的smlar插件</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">本文解释了PostgreSQL数据库和smlar插件如何帮助高效地检索大量的…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">www.alibabacloud.com</p></div></div><div class="mh l"><div class="od l mj mk ml mh mm js ly"/></div></div></a></div><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="oe of l"/></div></figure></div></div>    
</body>
</html>