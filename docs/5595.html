<html>
<head>
<title>How To Merge Stock Data in Python With reduce()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用reduce()合并Python中的股票数据</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/how-to-efficiently-merge-stocks-data-in-python-with-reduce-5ea9e233a5f7?source=collection_archive---------4-----------------------#2020-09-25">https://medium.datadriveninvestor.com/how-to-efficiently-merge-stocks-data-in-python-with-reduce-5ea9e233a5f7?source=collection_archive---------4-----------------------#2020-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6d4c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">下载历史股票价格，并使用强大的reduce()函数将它们合并成一个数据集。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/812b84018c31099822fe8e8125cc6a1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R-kL11wOSLWbPF4z3HETog.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://www.pexels.com/@artempodrez?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Artem Podrez</a> from <a class="ae ky" href="https://www.pexels.com/photo/light-marketing-businessman-man-5716052/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="86ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">如果您刚刚开始使用Python分析历史股票价格，目的是可视化趋势并构建投资策略，或者如果您是一名经验丰富的程序员，厌倦了使用循环，您应该继续学习如何使用<code class="fe me mf mg mh b">reduce()</code>函数来改进您的脚本。</span></p><p id="09f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设您选择了许多股票报价机，您的任务是下载每家公司的历史<em class="mi">调整收盘价</em>，并将它们合并到一个独特的干净数据集中，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/ee79795974171a79da8802e1eba9e791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*597OgqKRWSgF_m3Bm8qWrA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">The Adj. Close Prices of ten stocks merged in a single DataFrame</figcaption></figure><p id="be2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，在将股票价格附加到一个列表(或另一个<em class="mi"> iterable对象</em>)后，您可以使用下面的代码合并它们:</p><pre class="kj kk kl km gt mk mh ml mm aw mn bi"><span id="527d" class="mo mp it mh b gy mq mr l ms mt">#The historical stock prices saved in adj_prices are passed to <br/>#reduce()to apply the merge function recursively from left to right</span><span id="361f" class="mo mp it mh b gy mu mr l ms mt">reduce(lambda x, y: pd.merge(x, y, left_index = True, right_index = True, how=’outer’), adj_prices)</span></pre><p id="4641" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的函数遵循以下语法:</p><pre class="kj kk kl km gt mk mh ml mm aw mn bi"><span id="90f3" class="mo mp it mh b gy mq mr l ms mt">reduce(function, iterable [, initializer])</span></pre><p id="e7af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当可迭代对象是列表<code class="fe me mf mg mh b">adj_pricest</code>时，(<em class="mi">λ</em>)函数是<code class="fe me mf mg mh b">lambda x,y: pd.merge(x,y,left_index = True, right_index = True, how='outer')</code>，初始化器被省略了。</p><p id="28c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用于生成上述数据集的完整脚本将在本文稍后分享，但在对此进行评论之前，让我们通过回顾一些理论来理解<code class="fe me mf mg mh b">reduce()</code>函数的作用。</p><div class="mv mw gp gr mx my"><a href="https://towardsdatascience.com/airflow-how-to-refresh-stocks-data-while-you-sleep-part-1-a464514e45b7" rel="noopener follow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">气流:如何在睡觉时刷新股票数据——第1部分</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">在这个关于Apache Airflow的第一个教程中，学习如何构建一个数据管道来自动提取、转换和…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">towardsdatascience.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm ks my"/></div></div></a></div><h2 id="bab5" class="mo mp it bd nn no np dn nq nr ns dp nt li nu nv nw lm nx ny nz lq oa ob oc od bi translated">一点理论</h2><p id="5bcf" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">在Python 3中，<code class="fe me mf mg mh b">reduce()</code>函数属于<code class="fe me mf mg mh b">functools</code>模块，这意味着它可以通过以下两种方式之一导入:</p><pre class="kj kk kl km gt mk mh ml mm aw mn bi"><span id="f0b5" class="mo mp it mh b gy mq mr l ms mt"><strong class="mh iu">import functools<br/></strong># Imports the full module and then use <!-- -->functools.reduce()</span><span id="1b3a" class="mo mp it mh b gy mu mr l ms mt"><strong class="mh iu">from functools import reduce<br/></strong># Only imports reduce() from functools to use it directly</span></pre><p id="1fa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">reduce()</code>函数被认为是<strong class="lb iu">高阶函数</strong>，因为它将其他函数作为参数并对其进行操作。更详细地说，<code class="fe me mf mg mh b">reduce()</code>功能实现了一种称为<strong class="lb iu">缩减</strong>(或<em class="mi">折叠</em>)的技术，包括:</p><ul class=""><li id="4e16" class="oj ok it lb b lc ld lf lg li ol lm om lq on lu oo op oq or bi translated"><strong class="lb iu">对可迭代对象的前两项应用</strong>双自变量函数(<em class="mi">从左到右</em>)以生成部分结果，</li><li id="fd9c" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu oo op oq or bi translated"><strong class="lb iu">使用</strong>iterable中带有下一项的部分结果获得另一部分结果，</li><li id="5e69" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu oo op oq or bi translated">通过重复该过程将iterable减少到单个累积值，直到没有剩余的项目。</li></ul><p id="fbba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们使用<code class="fe me mf mg mh b">reduce()</code>来计算一系列数字的乘积:</p><pre class="kj kk kl km gt mk mh ml mm aw mn bi"><span id="a1a8" class="mo mp it mh b gy mq mr l ms mt">from functools import reduce</span><span id="13df" class="mo mp it mh b gy mu mr l ms mt">numbers = [7,2,5,9]</span><span id="9606" class="mo mp it mh b gy mu mr l ms mt">def simple_prod(x,y):<br/> return x * y</span><span id="2560" class="mo mp it mh b gy mu mr l ms mt">reduce(simple_prod, numbers)</span><span id="9b7d" class="mo mp it mh b gy mu mr l ms mt">Output:<br/>630</span></pre><p id="b69e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，可以使用lambda函数执行相同的计算:</p><pre class="kj kk kl km gt mk mh ml mm aw mn bi"><span id="244a" class="mo mp it mh b gy mq mr l ms mt">from functools import reduce</span><span id="2997" class="mo mp it mh b gy mu mr l ms mt">numbers = [7,2,5,9]</span><span id="5b97" class="mo mp it mh b gy mu mr l ms mt">reduce(lambda x,y: x * y, numbers)</span><span id="dcda" class="mo mp it mh b gy mu mr l ms mt">Output:<br/>630</span></pre><p id="982f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mi">注意:</em>因为<code class="fe me mf mg mh b">reduce()</code>通过多次应用函数来工作，所以在某些情况下可能会导致性能不佳，并且<em class="mi">自定义函数</em>的使用会影响代码的可读性。出于这个原因，评估是否存在一种更Pythonic化的方法来解决每个特定的用例总是明智的。正如您将在下面看到的，依赖于<code class="fe me mf mg mh b">reduce()</code>对于本文中执行的任务是有意义的，因为它避免了循环的产生，使代码更加紧凑。</p><h2 id="e90a" class="mo mp it bd nn no np dn nq nr ns dp nt li nu nv nw lm nx ny nz lq oa ob oc od bi translated">将理论付诸实践</h2><p id="8b34" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">下载历史调整价格并将其合并到唯一的<em class="mi">数据框架</em>中的完整脚本如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="32a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是对我所采取的每一步的简短评论:</p><ol class=""><li id="6bea" class="oj ok it lb b lc ld lf lg li ol lm om lq on lu oz op oq or bi translated"><strong class="lb iu">导入模块:</strong>首先，我导入了<strong class="lb iu"> <em class="mi">熊猫</em> </strong>、<strong class="lb iu"> <em class="mi"> yfinance </em> </strong>和<em class="mi"/><strong class="lb iu"><em class="mi">functools</em></strong>模块(或者只是上面所示的<em class="mi"> reduce </em>函数)。特别是，<a class="ae ky" href="https://pypi.org/project/yfinance/" rel="noopener ugc nofollow" target="_blank"> yfinance </a>模块在这里起着关键作用，因为它提供了许多获取历史价格和公司基本面的方法。</li><li id="a634" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu oz op oq or bi translated"><strong class="lb iu">将ticker保存到Iterable: </strong>我的原始代码包括200多个通过csv导入的ticker，并保存到一个列表中。实际上，在实践中你可能会用到几十个报价器，但是为了简单起见，我只选择了10个。</li><li id="752c" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu oz op oq or bi translated"><strong class="lb iu">从雅虎财经下载调整收盘价格:</strong>然后我使用<code class="fe me mf mg mh b">yf.download()</code>功能轻松下载了<code class="fe me mf mg mh b">tickers</code>列表中每家公司的历史股价。在可用的列中，我特别选择了Adj. Close列:</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/c5a61dfd3ab6c5a4fa63f172ef699158.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*pYb4Ivj3MZ0tbmogdYK1RA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Example of yf.download() function applied on AAPL.</figcaption></figure><p id="b050" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.<strong class="lb iu">删除缺失值和重复值:</strong>缺失行值已使用<code class="fe me mf mg mh b">dropna()</code>全部删除，重复日期被过滤掉，以获得每个日期的唯一<em class="mi">调整收盘价</em>。最终，每组价格都被添加到(最初为空的)<em class="mi"> adj_prices </em>列表中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/bc766765ece3774f77f46e02ba14d160.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*E-H_YF5UZiBYF8MW6VJhHg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Single groups of prices appended to the adj_prices list</figcaption></figure><p id="b1d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 5。用Reduce()合并历史价格:</strong>然后，我将<em class="mi"> adj_prices </em>列表传递给<code class="fe me mf mg mh b">reduce()</code>函数，将合并函数从左到右成对地应用于每组价格，使用公共的<code class="fe me mf mg mh b">Date</code>索引将它们连接起来。请注意，我使用了一个<code class="fe me mf mg mh b">outer</code>连接，因为不同的股票在不同的时间报价，目标是保持可用价格的完整性。最后一个操作是按降序对日期进行排序(最近的排在最前面)。</p><p id="7058" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您运行这段代码，您将获得一个与我在文章开头分享的数据帧相同的<em class="mi">数据帧。正如您所看到的，只需要几行代码就可以下载股票价格历史，并生成一个干净的数据集，然后为您的投资策略提供信息。</em></p><h1 id="e4a0" class="pc mp it bd nn pd pe pf nq pg ph pi nt jz pj ka nw kc pk kd nz kf pl kg oc pm bi translated">结论</h1><p id="3026" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated"><code class="fe me mf mg mh b">reduce()</code>函数只是Python中众多强大的函数式编程特性之一。尽管递归通常不是最有效的方法，但在本文中，我已经展示了如何有效地在merge上应用reduction技术来生成一个干净的数据帧，包括针对多个分笔成交点的<em class="mi"> adj、close prices </em>。如果你知道一个更优雅的方法来达到同样的效果，请随时留下评论。</p><h1 id="64f4" class="pc mp it bd nn pd pe pf nq pg ph pi nt jz pj ka nw kc pk kd nz kf pl kg oc pm bi translated">您可能还喜欢:</h1><div class="mv mw gp gr mx my"><a href="https://levelup.gitconnected.com/15-git-commands-you-should-learn-before-your-very-first-project-f8eebb8dc6e9" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">在你开始第一个项目之前，要掌握15个Git命令</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">您需要掌握的最后一个Git教程是命令行版本控制。</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nh l"><div class="pn l nj nk nl nh nm ks my"/></div></div></a></div><div class="mv mw gp gr mx my"><a href="https://towardsdatascience.com/8-popular-sql-window-functions-replicated-in-python-e17e6b34d5d7" rel="noopener follow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">Python中复制的8个流行的SQL窗口函数</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">关于如何利用业务分析中的Pandas高效复制最常用的SQL窗口的教程…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">towardsdatascience.com</p></div></div><div class="nh l"><div class="po l nj nk nl nh nm ks my"/></div></div></a></div><div class="mv mw gp gr mx my"><a href="https://medium.com/swlh/5-pythons-sets-problems-to-solve-before-your-coding-interview-41bb1d14ac25" rel="noopener follow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">5套算法解决之前，你的Python编码屏幕</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">你对Python中的集合了解多少？用这些“简单”和“中等”的LeetCode问题挑战自己。</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">medium.co</p></div></div><div class="nh l"><div class="pp l nj nk nl nh nm ks my"/></div></div></a></div></div></div>    
</body>
</html>