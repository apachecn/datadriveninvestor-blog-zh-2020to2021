<html>
<head>
<title>Tensorflow 2.0 — from preprocessing to serving (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tensorflow 2.0 —从预处理到服务(第3部分)</h1>
<blockquote>原文：<a href="https://medium.datadriveninvestor.com/tensorflow-2-0-from-preprocessing-to-serving-part-3-7fa5d1b6b142?source=collection_archive---------19-----------------------#2020-05-18">https://medium.datadriveninvestor.com/tensorflow-2-0-from-preprocessing-to-serving-part-3-7fa5d1b6b142?source=collection_archive---------19-----------------------#2020-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1017875a1f63aafb34dd8521fa3cd945.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NQ9M9WwJipNwV2lx.png"/></div></div></figure><p id="fcf4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">欢迎来到tensorflow及其keras API教程的第三部分。我们将讨论深度学习的一切——从如何预处理输入数据开始，然后建模你的神经网络来编码你的数据和处理输出，优化训练，并将模型作为REST API。</p><p id="bc08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您继续阅读本系列的前两篇文章也是明智的，因为我们已经讨论了预处理和模型设计，我们将从那里继续。</p><p id="7178" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在你开始阅读这篇文章及其后继者之前，你应该了解以下主题的基础知识，以便在阅读时不会感到慌张:<br/> 1。微积分<br/> 2。线性代数<br/> 3。神经网络<br/> 4。熊猫，熊猫</p><p id="08ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您可能已经从主题中推断出的那样，这是一篇编程文章，因此它可能有助于了解一些python方面的经验。</p><p id="0d80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">建议您使用Spyder(Anaconda的代码编辑器)进行编码，因为它具有选择性执行功能，这对于理解变量转换非常有帮助。</p><p id="017b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你没有GPU，最好在Google Colab上完成这项工作——Colaboratory是一个免费的Jupyter笔记本环境，不需要设置，完全在云中运行。</p><p id="749b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">借助Colaboratory，您可以编写和执行代码、保存和共享您的分析，以及访问强大的计算资源，所有这些都可以从浏览器中免费获得。</p><p id="9b19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在这里使用的数据集是<code class="fe kw kx ky kz b">Fashion-MNIST</code>。<code class="fe kw kx ky kz b">Fashion-MNIST</code>是一个由<a class="ae la" href="https://jobs.zalando.com/tech/" rel="noopener ugc nofollow" target="_blank"> Zalando </a>的文章图像组成的数据集——由60，000个样本的训练集和10，000个样本的测试集组成。每个示例都是28x28灰度图像，与10个类别的标签相关联。我们打算<code class="fe kw kx ky kz b">Fashion-MNIST</code>作为原始<a class="ae la" href="http://yann.lecun.com/exdb/mnist/" rel="noopener ugc nofollow" target="_blank"> MNIST数据集</a>的直接替代，用于机器学习算法的基准测试。它共享训练和测试分割的相同图像大小和结构。</p><p id="7deb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">数据集的一个范例是:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/f104cb4c9c9c7401c44dd9e158fdc94c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lEXOzibvoiYa8F61.png"/></div></div></figure><p id="d110" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来自时尚MNIST数据集的样本(每个类占三行)</p><p id="1973" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你们可能对MNIST的手写数字数据集有过经验，但我们不会在这里使用它，因为有两个非常好的理由。MNIST的网络设计太简单了，即使你使用密集的网络，你也可以达到98%的准确率。<br/> 2。它被过度使用了，我们想要学习新的东西，而不是重复旧的内容。</p><p id="2e0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上次我们已经完成了模型设计，现在我们已经准备好进行优化和指标回调。</p><p id="4446" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们前进之前，让我们看看我们的模型设计</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/15bc44df2be47ec72d9c46d2d52093e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*AY_wXEaS41Rcf-Oj3drwSw.png"/></div></figure><p id="5d3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们继续定义分布策略，分布策略提供了一个抽象概念，用于将您的培训分布到多个处理单元。目标是允许用户使用现有的模型和培训代码进行分布式培训，并进行最小的更改。</p><p id="07d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在这里使用the tf.distribute.MirrorStrategy策略，它在一台机器上的许多GPU上通过同步训练进行图内复制。本质上，它将模型的所有变量复制到每个处理器。然后，它使用<a class="ae la" href="http://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/" rel="noopener ugc nofollow" target="_blank"> all-reduce </a>来组合来自所有处理器的梯度，并将组合值应用于模型的所有副本。</p><p id="c6a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更多策略可在<a class="ae la" href="https://www.tensorflow.org/guide/distributed_training" rel="noopener ugc nofollow" target="_blank">分销策略指南</a>中找到。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lh"><img src="../Images/5796c672555a8a8a208fc4338ccaea15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*szl7TzcXHsuEPd219HspbQ.png"/></div></div></figure><p id="7050" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在声明了策略之后，我们可以获得设备的数量和它们的id，以便访问它们。</p><p id="e3cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在必须在<code class="fe kw kx ky kz b">strategy.scope</code>的上下文中创建和编译Keras模型</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/5a4c7b086f6e343a8ee4f5c5c7d0c7ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JbvOEdtXfTKrVGx_XlZyPg.png"/></div></div></figure><p id="d56c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们训练，就像我们习惯的那样:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lj"><img src="../Images/7e03754c53a1295e11bc924d3a1313b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FoGqKa5N0u6MKV7BzcLMyQ.png"/></div></div></figure><p id="b454" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要查看完整的代码，请查看:</p><p id="99a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae la" href="https://github.com/lordtt13/Medium-Articles" rel="noopener ugc nofollow" target="_blank">https://github.com/lordtt13/Medium-Articles</a></p><p id="d553" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经完成了培训，现在剩下的就是开始为模型服务，我们很快就会讨论这个问题，所以请密切关注。</p><p id="da59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在那之前，再见！</p></div></div>    
</body>
</html>